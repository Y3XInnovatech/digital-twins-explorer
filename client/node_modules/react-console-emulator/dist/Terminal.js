"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _defaults = _interopRequireDefault(require("defaults"));

var _reactFastCompare = _interopRequireDefault(require("react-fast-compare"));

var _TerminalMessage = _interopRequireDefault(require("./TerminalMessage"));

var _validateCommands = _interopRequireDefault(require("./handlers/validateCommands"));

var _scrollHistory = _interopRequireDefault(require("./handlers/scrollHistory"));

var _parseEOL = _interopRequireDefault(require("./handlers/parseEOL"));

var _Terminal = _interopRequireDefault(require("./defs/styles/Terminal"));

var _Terminal2 = _interopRequireDefault(require("./defs/types/Terminal"));

var _commandExists2 = _interopRequireDefault(require("./utils/commandExists"));

(function () {
  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;
  enterModule && enterModule(module);
})();

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal["default"].signature : function (a) {
  return a;
};

var Terminal = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(Terminal, _Component);

  var _super = _createSuper(Terminal);

  function Terminal(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, Terminal);
    _this = _super.call(this, props);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "focusTerminal", function () {
      // Only focus the terminal if text isn't being copied
      var isTextSelected = window.getSelection().type === 'Range';
      if (!isTextSelected) _this.terminalInput.current.focus();
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "scrollToBottom", function () {
      var rootNode = _this.terminalRoot.current; // This may look ridiculous, but it is necessary to decouple execution for just a millisecond in order to scroll all the way

      setTimeout(function () {
        rootNode.scrollTop = rootNode.scrollHeight;
      }, 1);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "validateCommands", function () {
      var _this$props = _this.props,
          commands = _this$props.commands,
          noDefaults = _this$props.noDefaults,
          ignoreCommandCase = _this$props.ignoreCommandCase;
      var validCommands = (0, _validateCommands["default"])(commands, _this.showHelp, _this.clearStdout, {
        noDefaults: noDefaults,
        ignoreCommandCase: ignoreCommandCase
      });

      _this.setState({
        commands: validCommands
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "showWelcomeMessage", function () {
      var msg = _this.props.welcomeMessage;
      if (typeof msg === 'boolean') _this.pushToStdout('Welcome to the React terminal! Type \'help\' to get a list of commands.');else if (Array.isArray(msg)) msg.map(function (item) {
        return _this.pushToStdout(item);
      });else _this.pushToStdout(msg);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "showHelp", function () {
      var commands = _this.state.commands;

      for (var c in commands) {
        var cmdObj = commands[c];
        var usage = cmdObj.usage ? " - ".concat(cmdObj.usage) : '';

        _this.pushToStdout("".concat(c, " - ").concat(cmdObj.description).concat(usage));
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "pushToStdout", function (message, options) {
      var stdout = _this.state.stdout;
      stdout.push({
        message: message,
        isEcho: (options === null || options === void 0 ? void 0 : options.isEcho) || false
      });
      /* istanbul ignore next: Covered by interactivity tests */

      if (options === null || options === void 0 ? void 0 : options.rawInput) _this.pushToHistory(options.rawInput);

      _this.setState({
        stdout: stdout
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "pushToHistory", function (rawInput) {
      var history = _this.state.history;
      history.push(rawInput);

      _this.setState({
        history: history,
        historyPosition: null
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getStdout", function () {
      // Parse EOL if it isn't disabled
      var stdout = !_this.props.noNewlineParsing ? (0, _parseEOL["default"])(_this.state.stdout) : _this.state.stdout;
      return stdout.map(function (line, i) {
        return /*#__PURE__*/_react["default"].createElement(_TerminalMessage["default"], {
          key: i,
          content: line.message,
          dangerMode: _this.props.dangerMode,
          className: !line.isEcho ? _this.props.messageClassName :
          /* istanbul ignore next: Covered by interactivity tests */
          undefined,
          style: !line.isEcho ? _this.props.messageStyle :
          /* istanbul ignore next: Covered by interactivity tests */
          undefined
        });
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "clearStdout", function () {
      _this.setState({
        stdout: []
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "clearInput", function () {
      _this.setState({
        historyPosition: null
      });

      _this.terminalInput.current.value = '';
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "processCommand", function () {
      _this.setState({
        processing: true
      }, function () {
        // Initialise command result object
        var commandResult = {
          command: null,
          args: [],
          rawInput: null,
          result: null
        };
        var rawInput = _this.terminalInput.current.value;
        if (!_this.props.noHistory) _this.pushToHistory(rawInput);

        if (!_this.props.noEchoBack) {
          // Mimic native terminal by echoing command back
          // Also exempt it from message since it should not really be a message despite behaving like one
          // Containing it in a span to allow JSX values in the prompt label
          var echo = /*#__PURE__*/_react["default"].createElement("span", null, _this.props.promptLabel || '$', " ", rawInput);

          _this.pushToStdout(echo, {
            isEcho: true
          });
        }

        if (rawInput) {
          var input = rawInput.split(' ');
          var rawCommand = input.splice(0, 1)[0]; // Removed portion is returned...

          var args = input; // ...and the rest can be used

          commandResult.rawInput = rawInput;
          commandResult.command = rawCommand;
          commandResult.args = args;

          var _commandExists = (0, _commandExists2["default"])(_this.state.commands, rawCommand, _this.props.ignoreCommandCase),
              exists = _commandExists.exists,
              command = _commandExists.command;

          if (!exists) {
            _this.pushToStdout(_this.props.errorText ? _this.props.errorText.replace(/\[command\]/gi, command) : "Command '".concat(rawCommand, "' not found!"));
          } else {
            var cmd = _this.state.commands[command];
            var res = cmd.fn.apply(cmd, (0, _toConsumableArray2["default"])(args));

            _this.pushToStdout(res);

            commandResult.result = res;
            if (cmd.explicitExec) cmd.fn.apply(cmd, (0, _toConsumableArray2["default"])(args));
          }
        }

        _this.setState({
          processing: false
        }, function () {
          _this.clearInput();

          if (!_this.props.noAutoScroll) _this.scrollToBottom();
          if (_this.props.commandCallback) _this.props.commandCallback(commandResult);
        });
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "scrollHistory", function (direction) {
      var _this$state = _this.state,
          history = _this$state.history,
          historyPosition = _this$state.historyPosition,
          previousHistoryPosition = _this$state.previousHistoryPosition;
      var toUpdate = (0, _scrollHistory["default"])(direction, {
        history: history,
        historyPosition: historyPosition,
        previousHistoryPosition: previousHistoryPosition,
        terminalInput: _this.terminalInput
      }); // Only update if there is something to update

      if (toUpdate) _this.setState(toUpdate);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "handleInput", function (event) {
      switch (event.key) {
        case 'Enter':
          _this.processCommand();

          break;

        case 'ArrowUp':
          _this.scrollHistory('up');

          break;

        case 'ArrowDown':
          _this.scrollHistory('down');

          break;
      }
    });
    _this.state = {
      commands: {},
      stdout: [],
      history: [],
      historyPosition: null,
      previousHistoryPosition: null,
      // TODO: Add prop-controlled enable/disable on the input
      processing: false
    };
    _this.terminalRoot = /*#__PURE__*/_react["default"].createRef();
    _this.terminalInput = /*#__PURE__*/_react["default"].createRef();
    return _this;
  }

  (0, _createClass2["default"])(Terminal, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      // If there was a change in commands, re-validate
      if (!(0, _reactFastCompare["default"])(prevProps.commands, this.props.commands)) this.validateCommands();
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.validateCommands();
      if (this.props.welcomeMessage) this.showWelcomeMessage();
      /* istanbul ignore next: Covered by interactivity tests */

      if (this.props.autoFocus) this.focusTerminal();
    }
  }, {
    key: "render",
    value: function render() {
      var styles = {
        container: (0, _defaults["default"])(this.props.style, _Terminal["default"].container),
        content: (0, _defaults["default"])(this.props.contentStyle, _Terminal["default"].content),
        inputArea: (0, _defaults["default"])(this.props.inputAreaStyle, _Terminal["default"].inputArea),
        promptLabel: (0, _defaults["default"])(this.props.promptLabelStyle, _Terminal["default"].promptLabel),
        input: (0, _defaults["default"])(this.props.inputStyle, _Terminal["default"].input)
      };
      return /*#__PURE__*/_react["default"].createElement("div", {
        ref: this.terminalRoot,
        name: "react-console-emulator",
        className: this.props.className,
        style: styles.container,
        onClick: this.focusTerminal
      }, /*#__PURE__*/_react["default"].createElement("div", {
        name: "react-console-emulator__content",
        className: this.props.contentClassName,
        style: styles.content
      }, this.getStdout(), /*#__PURE__*/_react["default"].createElement("div", {
        name: "react-console-emulator__inputArea",
        className: this.props.inputAreaClassName,
        style: styles.inputArea
      }, /*#__PURE__*/_react["default"].createElement("span", {
        name: "react-console-emulator__promptLabel",
        className: this.props.promptLabelClassName,
        style: styles.promptLabel
      }, this.props.promptLabel || '$'), /*#__PURE__*/_react["default"].createElement("input", {
        ref: this.terminalInput,
        name: "react-console-emulator__input",
        className: this.props.inputClassName,
        style: styles.input,
        onKeyDown: this.handleInput,
        type: "text",
        autoComplete: "off",
        disabled: this.props.disabled || this.props.disableOnProcess &&
        /* istanbul ignore next: Covered by interactivity tests */
        this.state.processing
      }))));
    }
  }, {
    key: "__reactstandin__regenerateByEval",
    // @ts-ignore
    value: function __reactstandin__regenerateByEval(key, code) {
      // @ts-ignore
      this[key] = eval(code);
    }
  }]);
  return Terminal;
}(_react.Component);

exports["default"] = Terminal;
(0, _defineProperty2["default"])(Terminal, "propTypes", _Terminal2["default"]);
;

(function () {
  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(Terminal, "Terminal", "C:\\Users\\LWTech Gaming\\Code Projects\\react-console-emulator\\src\\Terminal.jsx");
})();

;

(function () {
  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;
  leaveModule && leaveModule(module);
})();