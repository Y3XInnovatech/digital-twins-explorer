"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Util_1 = require("./Util");
/* eslint-disable no-dupe-class-members */
const numberComparator = (a, b) => a - b;
const bigIntComparator = (a, b) => Number(a - b);
const stringComparator = (a, b) => a.localeCompare(b);
const dateComparator = (a, b) => a.getTime() - b.getTime();
const comparators = {
    number: numberComparator,
    string: stringComparator,
    Date: dateComparator,
    bigInt: bigIntComparator,
    none: () => 0
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const decideCompareFn = (value) => {
    if (typeof value === 'number') {
        return comparators.number;
    }
    if (typeof value === 'string') {
        return comparators.string;
    }
    if (typeof value === 'bigint') {
        return comparators.bigInt;
    }
    if (Util_1.isDate(value)) {
        return comparators.Date;
    }
    if (Util_1.isComparable(value)) {
        return (o1, o2) => {
            return o1.compare(o2);
        };
    }
    throw new Error('Cannot sort keys in this map. You have to specify compareFn if the type of key in this map is not number, string, or Date.');
};
class TreeMap extends Map {
    constructor(iterableOrCompareFn, compareFn) {
        super();
        this.specifiedCompareFn = false;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/explicit-module-boundary-types
        this.isCompareFn = (value) => {
            return typeof value === 'function';
        };
        this.compareFn = comparators.none;
        this.sortedKeys = [];
        if (Util_1.isIterable(iterableOrCompareFn)) {
            this._constructor(iterableOrCompareFn, compareFn);
        }
        if (this.isCompareFn(iterableOrCompareFn)) {
            this._constructor(null, iterableOrCompareFn);
        }
        if (iterableOrCompareFn == null) {
            this._constructor(null, compareFn);
        }
        // if (reverse) {
        //   this.reverseOrder = reverse
        // }
    }
    // private reverseOrder: boolean = false
    get comparator() {
        return this.compareFn;
    }
    compare(a, b) {
        const val = Math.sign(this.compareFn(a, b));
        // return this.reverseOrder ? -val : val
        return val;
    }
    _constructor(iterable, compareFn) {
        this.compareFn = compareFn == null ? comparators.none : compareFn;
        this.specifiedCompareFn = compareFn != null;
        if (iterable == null) {
            return;
        }
        for (const entry of iterable) {
            this.set(...entry);
        }
    }
    /**
     * Creates and returns a new `TreeMap` object from the given map.
     * @param map Map object
     * @param compareFn Specifies a function that defines the sort order of the keys
     */
    static fromMap(map, compareFn) {
        const treeMap = new TreeMap(compareFn);
        treeMap.setAll(map);
        return treeMap;
    }
    /**
     * Duplicates this map and returns it as a new `TreeMap` object.
     */
    duplicate() {
        return TreeMap.fromMap(this, this.compareFn);
    }
    /**
     * Returns this map as a new `Map` object.
     */
    toMap() {
        const normalMap = new Map();
        const entries = Array.from(super.entries());
        entries.sort((a, b) => {
            return this.compareFn(a[0], b[0]);
        });
        entries.forEach(([k, v]) => {
            normalMap.set(k, v);
        });
        return normalMap;
    }
    reverseKeys() {
        const keys = [...this.sortedKeys].reverse();
        return keys.values();
    }
    get(key) {
        const resultKey = this.sortedKeys.find((key0) => this.comparator(key0, key) === 0);
        if (resultKey == null) {
            return undefined;
        }
        return super.get(resultKey);
    }
    /**
     * Adds or updates entry with the specified value with the specified key in this map.
     * @param key
     * @param value
     */
    set(key, value) {
        if (this.sortedKeys.length === 0 && !this.specifiedCompareFn) {
            this.compareFn = decideCompareFn(key);
            this.specifiedCompareFn = true;
        }
        const actualKey = this.sortedKeys.find((k) => this.compareFn(k, key) === 0);
        if (actualKey == null) {
            this.sortedKeys.push(key);
            super.set(key, value);
        }
        else {
            super.set(actualKey, value);
        }
        this.sortedKeys.sort(this.compareFn);
        return this;
    }
    /**
     * Copies all of the entries from the given map to this map.
     * @param map
     */
    setAll(map) {
        map.forEach((value, key) => {
            this.set(key, value);
        });
        return this;
    }
    /**
     * Removes the entry for given key from this map and returns `true` if present.
     * @param key
     */
    delete(key) {
        if (super.delete(key)) {
            this.sortedKeys = this.sortedKeys.filter((existKey) => this.compare(existKey, key) !== 0);
            return true;
        }
        return false;
    }
    /**
     * Removes all of the entry from this map.
     */
    clear() {
        super.clear();
        this.sortedKeys = [];
    }
    /**
     * Returns an iterable of sorted keys in this map.
     */
    keys() {
        return this.sortedKeys.values();
    }
    /**
     * Returns an iterable of sorted values in this map.
     */
    values() {
        return this.sortedKeys.map((k) => super.get(k)).values();
    }
    /**
     * Returns an iterable of sorted entries in this map.
     */
    entries() {
        return this.toMap().entries();
    }
    /**
     * Returns the first entry currently in this map, or `undefined` if the map is empty.
     */
    firstEntry() {
        const key = this.firstKey();
        if (key == null) {
            return undefined;
        }
        const value = this.get(key);
        return value === undefined ? undefined : [key, value];
    }
    /**
     * Returns the first key currently in this map, or `undefined` if the map is empty.
     */
    firstKey() {
        return this.sortedKeys[0];
    }
    /**
     * Returns the last entry currently in this map, or `undefined` if the map is empty.
     */
    lastEntry() {
        const key = this.lastKey();
        if (key == null) {
            return undefined;
        }
        const value = this.get(key);
        return value === undefined ? undefined : [key, value];
    }
    /**
     * Returns the last key currently in this map, or `undefined` if the map is empty.
     */
    lastKey() {
        return [...this.sortedKeys].reverse()[0];
    }
    /**
     * Removes the first element of this map and returns that removed entry,
     * or `undefined` if the map is empty.
     */
    shiftEntry() {
        const entry = this.firstEntry();
        if (entry == null) {
            return undefined;
        }
        this.delete(entry[0]);
        return entry;
    }
    /**
     * Removes the last element of this map and returns that removed entry,
     * or `undefined` if the map is empty.
     */
    popEntry() {
        const entry = this.lastEntry();
        if (entry == null) {
            return undefined;
        }
        this.delete(entry[0]);
        return entry;
    }
    /**
     * Returns entry associated with the greatest key from the keys less than or equal to the specified key,
     * or `undefined` if there is no such key.
     * @param key
     */
    floorEntry(key) {
        const resultKey = this.floorKey(key);
        if (resultKey != null) {
            const value = this.get(resultKey);
            return value === undefined ? undefined : [resultKey, value];
        }
        return undefined;
    }
    /**
     * Returns the greatest key from the keys less than or equal to the specified key,
     * or `undefined` if there is no such key.
     * @param key
     */
    floorKey(key) {
        const filtered = this.sortedKeys.filter((existKey) => this.compare(existKey, key) <= 0);
        return filtered.reverse()[0];
    }
    /**
     * Returns entry associated with the least key from the keys greater than or equal to the specified key,
     * or `undefined` if there is no such key.
     * @param key
     */
    ceilingEntry(key) {
        const resultKey = this.ceilingKey(key);
        if (resultKey != null) {
            const value = this.get(resultKey);
            return value === undefined ? undefined : [resultKey, value];
        }
        return undefined;
    }
    /**
     * Returns the least key from the keys greater than or equal to the specified key,
     * or `undefined` if there is no such key.
     * @param key
     */
    ceilingKey(key) {
        const filtered = this.sortedKeys.filter((existKey) => this.compare(existKey, key) >= 0);
        return filtered[0];
    }
    /**
     * Returns entry associated with the greatest key from the keys less than the specified key,
     * or `undefined` if there is no such key.
     * @param key
     */
    lowerEntry(key) {
        const resultKey = this.lowerKey(key);
        if (resultKey != null) {
            const value = this.get(resultKey);
            return value === undefined ? undefined : [resultKey, value];
        }
        return undefined;
    }
    /**
     * Returns the greatest key from the keys less than the specified key,
     * or `undefined` if there is no such key.
     * @param key
     */
    lowerKey(key) {
        const filtered = this.sortedKeys.filter((existKey) => this.compare(existKey, key) < 0);
        return filtered.reverse()[0];
    }
    /**
     * Returns entry associated with the least key from the keys greater than the specified key,
     * or `undefined` if there is no such key.
     * @param key
     */
    higherEntry(key) {
        const resultKey = this.higherKey(key);
        if (resultKey != null) {
            const value = this.get(resultKey);
            return value === undefined ? undefined : [resultKey, value];
        }
        return undefined;
    }
    /**
     * Returns the least key from the keys greater than the specified key,
     * or `undefined` if there is no such key.
     * @param key
     */
    higherKey(key) {
        const filtered = this.sortedKeys.filter((existKey) => this.compare(existKey, key) > 0);
        return filtered[0];
    }
    /**
     * Returns a new TreeMap with entries containing keys less than (or equal to) `key` in this map.
     * @param key
     * @param include If `true`, split this map including an entry associated with `key`. Default is `true`.
     */
    splitLower(key, include = true) {
        const entries = Array.from(this.entries()).filter((e) => {
            const range = this.compare(e[0], key) < 0;
            return include ? range || this.compare(e[0], key) === 0 : range;
        });
        return new TreeMap(entries, this.compareFn);
    }
    /**
     * Returns a new TreeMap with entries containing keys greater than (or equal to) `key` in this map.
     * @param key
     * @param include If `true`, split this map including an entry associated with `key`. Default is `true`.
     */
    splitHigher(key, include = true) {
        const entries = Array.from(this.entries()).filter((e) => {
            const range = this.compare(e[0], key) > 0;
            return include ? range || this.compare(e[0], key) === 0 : range;
        });
        return new TreeMap(entries, this.compareFn);
    }
    forEach(callbackfn, thisArg) {
        Array.from(this.entries()).forEach(([k, v]) => {
            callbackfn(v, k, this);
        }, thisArg);
    }
}
exports.default = TreeMap;
tslib_1.__exportStar(require("./Types"), exports);
