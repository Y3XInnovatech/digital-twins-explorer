"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const jsiterable_1 = __importDefault(require("jsiterable"));
const edge_1 = __importDefault(require("./edge"));
const graphIndex_1 = __importDefault(require("./graphIndex"));
const vertex_1 = __importStar(require("./vertex"));
class JsonldGraph extends events_1.EventEmitter {
    /**
     * Creates an instance of JsonLdGraph.
     * @memberof JsonLdGraph
     */
    constructor(contexts) {
        super();
        this._index = new graphIndex_1.default();
        this._index.on('edgeCreated', indexEdge => this.emit('edgeAdded', new edge_1.default(indexEdge, this._index)));
        this._index.on('edgeDeleted', indexEdge => this.emit('edgeRemoved', new edge_1.default(indexEdge, this._index)));
        this._index.on('nodeCreated', indexNode => this.emit('vertexAdded', new vertex_1.default(indexNode, this._index)));
        this._index.on('nodeDeleted', indexNode => this.emit('vertexRemoved', new vertex_1.default(indexNode, this._index)));
        this._index.on('nodeIdChanged', (indexNode, previousId) => this.emit('vertexIdChanged', new vertex_1.default(indexNode, this._index), previousId));
        if (contexts && contexts.length > 0) {
            for (const { uri, context } of contexts) {
                this._index.addContext(uri, context);
            }
        }
    }
    /**
     * @description Gets the contexts registered with the graph.
     * @readonly
     * @type {Iterable<[string, any]>}
     * @memberof JsonldGraph
     */
    get contexts() {
        return this._index.contexts;
    }
    /**
     * @description Gets the count of edges in the graph.
     * @readonly
     * @type {number}
     * @memberof JsonLdGraph
     */
    get edgeCount() {
        return this._index.edgeCount;
    }
    /**
     * @description Gets the count of vertices in the graph.
     * @readonly
     * @type {number}
     * @memberof JsonLdGraph
     */
    get vertexCount() {
        return this._index.nodeCount;
    }
    /**
     * @description Adds a context.
     * @param {string} uri The uri of the context to add.
     * @param {*} context The context object.
     * @memberof JsonLdGraph
     */
    addContext(uri, context) {
        this._index.addContext(uri, context);
    }
    /**
     * @description Adds a prefix to the graph that allows accessing and creating edges & vertices using short ids containing the prefix.
     * @param {string} prefix The prefix to add.
     * @param {string} uri A valid URI that the prefix maps to.
     * @memberof JsonldGraph
     */
    addPrefix(prefix, uri) {
        this._index.addPrefix(prefix, uri);
    }
    /**
     * @description Creates a new vertex.
     * @param {string} id Id of the vertex to create.
     * @returns {Vertex}
     * @memberof JsonLdGraph
     */
    createVertex(id) {
        if (!id) {
            throw new ReferenceError(`Invalid id. id is ${id}`);
        }
        const existing = this._index.getNode(id);
        if (existing) {
            return new vertex_1.default(existing, this._index);
        }
        else {
            const node = this._index.createNode(id);
            return new vertex_1.default(node, this._index);
        }
    }
    /**
     * @description Gets edges in the graph.
     * @param {string} [label] Optional label to filter only edges with the specified label.
     * @returns {Iterable<Edge>}
     * @memberof JsonLdGraph
     */
    getEdges(label) {
        return new jsiterable_1.default(this._index.getEdges(label)).map(x => new edge_1.default(x, this._index));
    }
    /**
     * @description Gets all vertices with the specified incoming edge.
     * @param {string} edgeLabel The label of the incoming edge.
     * @param {(string | VertexSelector)} [vertexSelector] Optional vertex selector that is used to filter only matching vertices.
     * @returns {Iterable<Vertex>}
     * @memberof JsonLdGraph
     */
    getIncoming(edgeLabel, vertexSelector) {
        if (!edgeLabel) {
            throw new ReferenceError(`Invalid edgeLabel. edgeLabel is ${edgeLabel}`);
        }
        const filter = new vertex_1.VertexFilter(vertexSelector);
        return new jsiterable_1.default(this._index.getEdgeIncoming(edgeLabel))
            .map(node => new vertex_1.default(node, this._index))
            .filter(vertex => filter.match(vertex));
    }
    /**
     * @description Gets all vertices with the specified outgoing edge.
     * @param {string} edgeLabel The label of the outgoing edge.
     * @param {(string | VertexSelector)} [vertexSelector] Optional vertex selector that is used to filter only matching vertices.
     * @returns {Iterable<Vertex}
     * @memberof JsonLdGraph
     */
    getOutgoing(edgeLabel, vertexSelector) {
        if (!edgeLabel) {
            throw new ReferenceError(`Invalid edgeLabel. edgeLabel is ${edgeLabel}`);
        }
        const filter = new vertex_1.VertexFilter(vertexSelector);
        return new jsiterable_1.default(this._index.getEdgeOutgoing(edgeLabel))
            .map(node => new vertex_1.default(node, this._index))
            .filter(vertex => filter.match(vertex));
    }
    /**
     * @description Gets all vertices in the graph.
     * @param {VertexSelector} [vertexSelector] Optional vertex selector that is used to filter only matching vertices.
     * @returns {Iterable<Vertex>}
     * @memberof JsonLdGraph
     */
    getVertices(vertexSelector) {
        const filter = new vertex_1.VertexFilter(vertexSelector);
        return new jsiterable_1.default(this._index.getNodes())
            .map(node => new vertex_1.default(node, this._index))
            .filter(vertex => filter.match(vertex));
    }
    /**
     * @description Gets a specific vertex in the graph.
     * @param {string} id Id of the vertex to get.
     * @returns {Vertex}
     * @memberof JsonLdGraph
     */
    getVertex(id) {
        if (!id) {
            throw new ReferenceError(`Invalid id. id is ${id}`);
        }
        const node = this._index.getNode(id);
        if (!node) {
            return null;
        }
        else {
            return new vertex_1.default(node, this._index);
        }
    }
    /**
     * @description Checks if a edge exists.
     * @param {string} label The label of the edge.
     * @param {string} fromVertexId The outgoing vertex id.
     * @param {string} toVertexId The incoming vertex id.
     * @returns {boolean}
     * @memberof JsonLdGraph
     */
    hasEdge(label, fromVertexId, toVertexId) {
        return this._index.hasEdge(label, fromVertexId, toVertexId);
    }
    /**
     * @description Checks if a vertex exists.
     * @param {string} id The id of the vertex to check.
     * @returns {boolean}
     * @memberof JsonLdGraph
     */
    hasVertex(id) {
        return this._index.hasNode(id);
    }
    /**
     * @description Loads one or more documents into the graph.
     * @param {(any | any[])} inputs Input documents to load into the graph.
     * @param {string|string[]|object|object[]} [contexts] Optional contexts to use for importing the documents.
     * @param {string} [base] Optional base IRI of the inputs.
     * @returns {Promise<Set<string>>} A set containing all vertices that were created / added as part of the load.
     * @memberof JsonLdGraph
     */
    load(inputs, contexts, base) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._index.load(inputs, contexts, base);
        });
    }
    /**
     * @description Merges a set of JSON-LD documents into the graph.
     * @param {(any | any[])} inputs The inputs to merge.
     * @param {string[]} [contexts] The contexts to merge.
     * @param {string} [base] The base IRI of the document.
     * @returns {Promise<Set<string>>} A set containing all vertices that were created / added as part of the load.
     * @memberof JsonLdGraph
     */
    merge(inputs, contexts, base) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._index.merge(inputs, contexts, base);
        });
    }
    /**
     * @description Removes a context.
     * @param {string} uri The uri of the context to remove.
     * @returns {void}
     * @memberof JsonLdGraph
     */
    removeContext(uri) {
        return this._index.removeContext(uri);
    }
    /**
     * @description Removes a prefix previously added to the graph.
     * @param {string} prefix The prefix to remove from the graph.
     * @returns {void}
     * @memberof JsonldGraph
     */
    removePrefix(prefix) {
        return this._index.removePrefix(prefix);
    }
    /**
     * @description Removes a vertex from the graph.
     * @param {(string | Vertex)} vertex The vertex id or vertex instance to remove from the graph.
     * @memberof JsonLdGraph
     */
    removeVertex(vertex) {
        if (!vertex) {
            throw new ReferenceError(`Invalid vertex. vertex is ${vertex}`);
        }
        const nodeId = typeof vertex === 'string' ? vertex : vertex.id;
        this._index.removeNode(nodeId);
    }
    /**
     * @description Gets a JSON representation of the graph.
     * @param {string[]} contexts Contexts to use for compaction.
     * @param {*} [frame] Optional frame to use for formatting the JSON output.
     * @returns {Promise<any>}
     * @memberof JsonLdGraph
     */
    /* tslint:disable:promise-function-async*/
    toJson(options) {
        return this._index.toJson(options);
    }
}
exports.JsonldGraph = JsonldGraph;
exports.default = JsonldGraph;
//# sourceMappingURL=graph.js.map