"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const events_1 = require("events");
const jsiterable_1 = __importDefault(require("jsiterable"));
const constants_1 = require("./constants");
const errors_1 = __importDefault(require("./errors"));
const identityMap_1 = __importDefault(require("./identityMap"));
const iri_1 = __importDefault(require("./iri"));
const jsonldProcessor_1 = __importDefault(require("./jsonldProcessor"));
/**
 * @description Node in an index.
 * @export
 * @class IndexNode
 */
class IndexNode {
    /**
     * @description Creates an instance of IndexNode.
     * @param {string} id The id of the node.
     * @param {GraphIndex} The index the node belongs to.
     * @param {GraphIndex} index The index containing this node.
     * @memberof IndexNode
     */
    constructor(id, index) {
        this._attributes = new Map();
        /**
         * @description Metadata object for tracking.
         * @memberof IndexNode
         */
        this.metadata = {};
        if (!id) {
            throw new ReferenceError(`Invalid id. id is ${id}`);
        }
        if (!index) {
            throw new ReferenceError(`Invalid index. index is ${index}`);
        }
        this._nodeId = id;
        this._index = index;
    }
    /**
     * @description Gets the id of the node.
     * @readonly
     * @memberof IndexNode
     */
    get id() {
        return this._index.iri.compact(this._nodeId);
    }
    /**
     * @description Sets the id of the node.
     * @memberof IndexNode
     */
    set id(id) {
        if (!id) {
            throw new ReferenceError(`Invalid newId. newId is ${id}`);
        }
        const expandedId = this._index.iri.expand(id);
        if (this._index.iri.equal(this._nodeId, expandedId)) {
            return;
        }
        if (this._index.hasNode(expandedId)) {
            throw new errors_1.default.IndexNodeDuplicateError(id);
        }
        // Change the id of the node and re-add it to the index with the new id.
        const previousId = this._nodeId;
        const outgoingEdges = [...this._index.getNodeOutgoing(this._nodeId)];
        const incomingEdges = [...this._index.getNodeIncoming(this._nodeId)];
        this._index.removeNode(this);
        this._nodeId = expandedId;
        this._index.addNode(this);
        // Recreate the outgoing edges from the new node.
        for (const { edge } of outgoingEdges) {
            this._index.createEdge(edge.label, this._nodeId, edge.toNodeId);
        }
        // Recreate incoming edges to the new node.
        for (const { edge } of incomingEdges) {
            this._index.createEdge(edge.label, edge.fromNodeId, this._nodeId);
        }
        this._index.emit('nodeIdChanged', this, previousId);
    }
    /**
     * @description Gets the @index attribute of this node.
     * @memberof IndexNode
     */
    get index() {
        return this._nodeIndex;
    }
    /**
     * @description Sets the @index attribute of this node.
     * @memberof IndexNode
     */
    set index(value) {
        this._nodeIndex = value;
    }
    /**
     * @description Gets all the attributes defined on the node.
     * @readonly
     * @type {Iterable<[string, any]>}
     * @memberof IndexNode
     */
    get attributes() {
        return new jsiterable_1.default(this._attributes.entries()).map(([key, val]) => {
            return [
                this._index.iri.compact(key),
                val.map(x => {
                    return {
                        value: x['@value'],
                        language: x['@language']
                    };
                })
            ];
        });
    }
    /**
     * @description Adds an attribute value.
     * @param {string} name The name of the attribute.
     * @param {*} value The value to add
     * @returns {this}
     * @memberof IndexNode
     */
    addAttributeValue(name, value, language) {
        if (!name) {
            throw new ReferenceError(`Invalid name. name is ${name}`);
        }
        if (value === null || value === undefined) {
            throw new ReferenceError(`Invalid value. value is ${value}`);
        }
        if (language && typeof value !== 'string') {
            throw new TypeError(`Invalid argument type. Language attribute values must be strings, but instead found ${typeof value}`);
        }
        const normalizedName = this._index.iri.expand(name);
        if (this._attributes.has(normalizedName)) {
            const values = this._attributes.get(normalizedName);
            if (language) {
                // If an existing value for the specified language is already set, then replace the value, else add a new one.
                const existing = values.find(x => x['@language'] === language);
                if (existing) {
                    existing['@value'] = value;
                }
                else {
                    values.push({ '@language': language, '@value': value });
                }
            }
            else {
                values.push({ '@value': value });
            }
        }
        else {
            if (language) {
                this._attributes.set(normalizedName, [
                    {
                        '@language': language,
                        '@value': value
                    }
                ]);
            }
            else {
                this._attributes.set(normalizedName, [
                    {
                        '@value': value
                    }
                ]);
            }
        }
        return this;
    }
    /**
     * @description Deletes a attribute and its value.
     * @param {string} name The name of the attribute to delete.
     * @param {string} [language] The optional language whose value should be deleted.
     * @returns {this}
     * @memberof IndexNode
     */
    deleteAttribute(name, language) {
        if (!name) {
            throw new ReferenceError(`Invalid name. name is ${name}`);
        }
        const normalizedName = this._index.iri.expand(name);
        if (language) {
            const currentValues = this._attributes.get(normalizedName);
            if (currentValues) {
                const valueIndex = currentValues.findIndex(x => x['@language'] === language);
                if (valueIndex >= 0) {
                    currentValues.splice(valueIndex, 1);
                }
            }
        }
        else {
            this._attributes.delete(this._index.iri.expand(name));
        }
        return this;
    }
    /**
     * @description Gets an attribute value.
     * @template T
     * @param {string} name The name of the attribute value to get.
     * @returns {T}
     * @memberof IndexNode
     */
    getAttributeValues(name) {
        if (!name) {
            throw new ReferenceError(`Invalid name. name is ${name}`);
        }
        const normalizedName = this._index.iri.expand(name);
        const values = this._attributes.get(normalizedName);
        if (!values) {
            return [];
        }
        return values.map(x => {
            return {
                value: x['@value'],
                language: x['@language']
            };
        });
    }
    /**
     * @description Checks if an attribute has been defined on the node.
     * @param {string} name The name of the attribute to check.
     * @returns {boolean} True if the attribute has been defined, else false.
     * @memberof IndexNode
     */
    hasAttribute(name) {
        if (!name) {
            throw new ReferenceError(`Invalid name. name is ${name}`);
        }
        return this._attributes.has(this._index.iri.expand(name));
    }
    /**
     * @description Checks if an attribute has been defined and has the specified value.
     * @param {string} name The name of the attribute to check.
     * @param {*} value The value of the attribute to check.
     * @param {string} [language] Optional language.
     * @returns {boolean} True if the attribute has been defined and has the specified value.
     * @memberof IndexNode
     */
    hasAttributeValue(name, value, language) {
        if (!name) {
            throw new ReferenceError(`Invalid name. name is '${name}'`);
        }
        if (!value) {
            throw new ReferenceError(`Invalid value. value is '${value}'`);
        }
        if (language && typeof value !== 'string') {
            throw new TypeError(`Invalid argument type. Language attribute values must be strings, but instead found ${typeof value}`);
        }
        const normalizedName = this._index.iri.expand(name);
        const values = this._attributes.get(normalizedName);
        if (values) {
            return language
                ? values.some(x => x['@language'] === language && x['@value'] === value)
                : values.some(x => x['@value'] === value);
        }
        else {
            return false;
        }
    }
    /**
     * @description Removes an attribute value.
     * @param {string} name The name of the attribute whose value should be removed.
     * @param {string} value The value to remove.
     * @param {string} [language] Optional language to remove the value from.
     * @returns {this}
     * @memberof IndexNode
     */
    removeAttributeValue(name, value) {
        if (!name) {
            throw new ReferenceError(`Invalid name. name is '${name}'`);
        }
        if (!value) {
            throw new ReferenceError(`Invalid value. value is '${value}'`);
        }
        const normalizedName = this._index.iri.expand(name);
        if (!this._attributes.has(normalizedName)) {
            return;
        }
        const currentValues = this._attributes.get(normalizedName);
        if (!currentValues) {
            return this;
        }
        let valueIndex = currentValues.findIndex(x => x['@value'] === value);
        while (valueIndex >= 0) {
            currentValues.splice(valueIndex, 1);
            valueIndex = currentValues.findIndex(x => x['@value'] === value);
        }
        if (currentValues.length === 0) {
            // Removal of all values of an attribute equals deletion of the attribute.
            this._attributes.delete(normalizedName);
        }
        return this;
    }
    /**
     * @description Sets an attribute value, replacing any existing value.
     * @param {string} name The name of the attribute to set.
     * @param {*} value The value to set.
     * @param {string} [language] Optional language to set the value for.
     * @returns {this}
     * @memberof IndexNode
     */
    setAttributeValue(name, value, language) {
        if (!name) {
            throw new ReferenceError(`Invalid label. label is ${name}`);
        }
        if (value === null || value === undefined) {
            throw new ReferenceError(`Invalid value. value is ${value}`);
        }
        if (language && typeof value !== 'string') {
            throw new TypeError(`Invalid argument type. Language attribute values must be strings, but instead found ${typeof value}`);
        }
        const normalizedName = this._index.iri.expand(name);
        if (language) {
            // If an existing value for the specified language is already set, then replace the value, else add a new one.
            const values = this._attributes.get(normalizedName) || [];
            const existing = values.find(x => x['@language'] === language);
            if (existing) {
                existing['@value'] = value;
            }
            else {
                values.push({ '@language': language, '@value': value });
            }
        }
        else {
            this._attributes.set(normalizedName, [{ '@value': value }]);
        }
        return this;
    }
    /**
     * @description Returns a JSON representation of the node.
     * @param {JsonFormatOptions} [options={}] Formatting options for the node.
     * @returns {Promise<any>}
     * @memberof IndexNode
     */
    toJson(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            options.frame = Object.assign(options.frame || {}, {
                [constants_1.JsonldKeywords.id]: this._nodeId
            });
            const json = yield this._index.toJson(options);
            return json['@graph'][0];
        });
    }
    /**
     * @description Converts the vertex into a triple form.
     * @returns {*} JSON object containing the triple
     * @memberof IndexNode
     */
    toTriple() {
        const triple = {
            [constants_1.JsonldKeywords.id]: this._nodeId
        };
        for (const [attributeName, values] of this._attributes) {
            triple[this._index.iri.expand(attributeName)] = values;
        }
        for (const { edge, node } of this._index.getNodeOutgoing(this._nodeId)) {
            const edgeLabelId = this._index.iri.expand(edge.label);
            const edgeNodeId = node._nodeId;
            if (!triple[edgeLabelId]) {
                triple[edgeLabelId] = [];
            }
            if (edgeLabelId === constants_1.JsonldKeywords.type) {
                triple[edgeLabelId].push(edgeNodeId);
            }
            else {
                triple[edgeLabelId].push({
                    [constants_1.JsonldKeywords.id]: edgeNodeId
                });
            }
        }
        return triple;
    }
}
exports.IndexNode = IndexNode;
/**
 * @description Edge in an index.
 * @export
 * @class IndexEdge
 */
class IndexEdge {
    /**
     *Creates an instance of IndexEdge.
     * @param {string} label The edge label.
     * @param {string} fromNodeId The outgoing node id.
     * @param {string} toNodeId The incoming node id.
     * @param {GraphIndex} index The index containing this edge.
     * @memberof IndexEdge
     */
    constructor(label, fromNodeId, toNodeId, index) {
        if (!label) {
            throw new ReferenceError(`Invalid label. label is ${label}`);
        }
        if (!fromNodeId) {
            throw new ReferenceError(`Invalid fromNodeId. fromNodeId is ${fromNodeId}`);
        }
        if (!toNodeId) {
            throw new ReferenceError(`Invalid toNodeId. toNodeId is ${toNodeId}`);
        }
        if (!index) {
            throw new ReferenceError(`Invalid index. index is ${index}`);
        }
        this._label = label;
        this._fromNodeId = fromNodeId;
        this._toNodeId = toNodeId;
        this._index = index;
    }
    /**
     * @description Gets the id of the index.
     * @readonly
     * @type {string}
     * @memberof IndexEdge
     */
    get id() {
        return IndexEdge.toId(this._label, this._fromNodeId, this._toNodeId);
    }
    /**
     * @description Gets the label of the edge.
     * @readonly
     * @type {string}
     * @memberof IndexEdge
     */
    get label() {
        return this._index.iri.compact(this._label);
    }
    /**
     * @description Gets the outgoing node id of the edge.
     * @readonly
     * @type {string}
     * @memberof IndexEdge
     */
    get fromNodeId() {
        return this._index.iri.compact(this._fromNodeId);
    }
    /**
     * @description Gets the incoming node id of the edge.
     * @readonly
     * @type {string}
     * @memberof IndexEdge
     */
    get toNodeId() {
        return this._index.iri.compact(this._toNodeId);
    }
    /**
     * @description Generates a deterministic id for an edge.
     * @static
     * @param {string} label The label of the edge.
     * @param {string} fromNodeId The outgoing node id of the edge.
     * @param {string} toNodeId The incoming node id of the edge.
     * @returns
     * @memberof IndexEdge
     */
    static toId(label, fromNodeId, toNodeId) {
        if (!label) {
            throw new ReferenceError(`Invalid label. label is ${label}`);
        }
        if (!fromNodeId) {
            throw new ReferenceError(`Invalid fromNodeId. fromNodeId is ${fromNodeId}`);
        }
        if (!toNodeId) {
            throw new ReferenceError(`Invalid toNodeId. toNodeId is ${toNodeId}`);
        }
        return `${fromNodeId}->${label}->${toNodeId}`;
    }
}
exports.IndexEdge = IndexEdge;
/**
 * @description Index store for graph nodes and edges.
 * @export
 * @class GraphIndex
 */
class GraphIndex extends events_1.EventEmitter {
    constructor() {
        super();
        this.iri = new iri_1.default();
        this._edges = new Map();
        this._index = new Map();
        this._nodes = new Map();
        this._processor = new jsonldProcessor_1.default({ remoteContexts: false });
    }
    /**
     * @description Gets the contexts registered with the index.
     * @readonly
     * @type {Iterable<[string, any]>}
     * @memberof GraphIndex
     */
    get contexts() {
        return this._processor.contexts;
    }
    /**
     * @description Gets the count of nodes in the index.
     * @readonly
     * @type {number}
     * @memberof GraphIndex
     */
    get nodeCount() {
        return this._nodes.size;
    }
    /**
     * @description Gets the count of edges in the index.
     * @readonly
     * @type {number}
     * @memberof GraphIndex
     */
    get edgeCount() {
        return this._index.size;
    }
    /**
     * @description Adds a context to the index.
     * @param {string} id The id of the context to add.
     * @param {value} context The context to add.
     * @memberof GraphIndex
     */
    addContext(id, context) {
        this._processor.addContext(id, context);
    }
    /**
     * @description Adds a prefix for a canonical URI
     * @param {string} prefix The prefix to add.
     * @param {string} uri The uri the prefix maps to.
     * @memberof GraphIndex
     */
    addPrefix(prefix, uri) {
        this.iri.addPrefix(prefix, uri);
    }
    /**
     * @description Adds a new node to the index.
     * @param {IndexNode} node The node instance to add.
     * @memberof GraphIndex
     */
    addNode(node) {
        if (!node) {
            throw new ReferenceError(`Invalid node. node is ${node}`);
        }
        if (this._nodes.has(node.id)) {
            throw new errors_1.default.IndexNodeDuplicateError(node.id);
        }
        this._nodes.set(node.id, node);
    }
    /**
     * @description Creates a new edge in the index.
     * @param {string} label The label of the edge to create.
     * @param {string} fromNodeId The edge outgoing node id.
     * @param {string} toNodeId The edge incoming node id.
     * @memberof GraphIndex
     */
    createEdge(label, fromNodeId, toNodeId) {
        if (!label) {
            throw new ReferenceError(`Invalid label. label is ${label}`);
        }
        if (!fromNodeId) {
            throw new ReferenceError(`Invalid fromNodeId. fromNodeId is ${fromNodeId}`);
        }
        if (!toNodeId) {
            throw new ReferenceError(`Invalid toNodeId. toNodeId is ${toNodeId}`);
        }
        const expandedLabel = this.iri.expand(label);
        const expandedFromId = this.iri.expand(fromNodeId);
        const expandedToId = this.iri.expand(toNodeId);
        if (!this._nodes.has(expandedFromId)) {
            throw new errors_1.default.IndexEdgeNodeNotFoundError(label, fromNodeId, 'outgoing');
        }
        if (!this._nodes.has(expandedToId)) {
            throw new errors_1.default.IndexEdgeNodeNotFoundError(label, toNodeId, 'incoming');
        }
        if (expandedFromId === expandedToId) {
            throw new errors_1.default.IndexEdgeCyclicalError(label, toNodeId);
        }
        const edgeId = IndexEdge.toId(expandedLabel, expandedFromId, expandedToId);
        if (this._edges.has(edgeId)) {
            return this._edges.get(edgeId);
        }
        const edge = new IndexEdge(expandedLabel, expandedFromId, expandedToId, this);
        this._edges.set(edge.id, edge);
        this._indexEdge(expandedLabel, expandedFromId, expandedToId);
        this.emit('edgeCreated', edge);
        return edge;
    }
    /**
     * @description Creates a new node in the index.
     * @param {string} id The id of the node to create.
     * @returns {IndexNode}
     * @memberof GraphIndex
     */
    createNode(id) {
        if (!id) {
            throw new ReferenceError(`Invalid id. id is ${id}`);
        }
        const expandedId = this.iri.expand(id);
        if (this._nodes.has(expandedId)) {
            throw new errors_1.default.IndexNodeDuplicateError(id);
        }
        const node = new IndexNode(expandedId, this);
        this._nodes.set(expandedId, node);
        this.emit('nodeCreated', node);
        return node;
    }
    /**
     * @description Gets an edge in the index.
     * @param {string} label The label of the edge ot get.
     * @param {string} fromNodeId The edge outgoing node id.
     * @param {string} toNodeId The edge incoming node id.
     * @returns {IndexEdge}
     * @memberof GraphIndex
     */
    getEdge(label, fromNodeId, toNodeId) {
        if (!label) {
            throw new ReferenceError(`Invalid label. label is ${label}`);
        }
        if (!fromNodeId) {
            throw new ReferenceError(`Invalid fromNodeId. fromNodeId is ${fromNodeId}`);
        }
        if (!toNodeId) {
            throw new ReferenceError(`Invalid toNodeId. toNodeId is ${toNodeId}`);
        }
        return this._edges.get(IndexEdge.toId(this.iri.expand(label), this.iri.expand(fromNodeId), this.iri.expand(toNodeId)));
    }
    /**
     * @description Gets edges in the index.
     * @param {string} [label] Optional label filter used to only return edges with the matching label.
     * @returns {IterableIterator<IndexEdge>}
     * @memberof GraphIndex
     */
    *getEdges(label) {
        if (!label) {
            for (const [, edge] of this._edges) {
                yield edge;
            }
        }
        else {
            const indexKey = GraphIndex.IX_EDGES_KEY(this.iri.expand(label));
            if (!this._index.has(indexKey)) {
                return;
            }
            for (const edgeId of this._index.get(indexKey)) {
                yield this._edges.get(edgeId);
            }
        }
    }
    /**
     * @description Gets all nodes that have an incoming edge with the specified label.
     * @param {string} label The incoming edge label.
     * @returns {IterableIterator<IndexNode>}
     * @memberof GraphIndex
     */
    *getEdgeIncoming(label) {
        if (!label) {
            throw new ReferenceError(`Invalid label. label is ${label}`);
        }
        const indexKey = GraphIndex.IX_EDGE_INCOMING_KEY(this.iri.expand(label));
        if (!this._index.has(indexKey)) {
            return;
        }
        const visited = new Set();
        for (const edgeId of this._index.get(indexKey)) {
            const edge = this._edges.get(edgeId);
            if (!visited.has(edge.toNodeId)) {
                visited.add(edge.toNodeId);
                yield this._nodes.get(edge.toNodeId);
            }
        }
    }
    /**
     * @description Gets all nodes that haven an outgoing edge with the specified label.
     * @param {string} label The outgoing edge label.
     * @returns {IterableIterator<IndexNode>}
     * @memberof GraphIndex
     */
    *getEdgeOutgoing(label) {
        if (!label) {
            throw new ReferenceError(`Invalid label. label is ${label}`);
        }
        const indexKey = GraphIndex.IX_EDGE_OUTGOING_KEY(this.iri.expand(label));
        if (!this._index.has(indexKey)) {
            return;
        }
        const visited = new Set();
        for (const edgeId of this._index.get(indexKey)) {
            const edge = this._edges.get(edgeId);
            if (!visited.has(edge.fromNodeId)) {
                visited.add(edge.fromNodeId);
                yield this._nodes.get(edge.fromNodeId);
            }
        }
    }
    /**
     * @description Gets a specific node in the index.
     * @param {string} id The id of the node to get.
     * @returns {IndexNode}
     * @memberof GraphIndex
     */
    getNode(id) {
        if (!id) {
            throw new ReferenceError(`Invalid id. id is ${id}`);
        }
        return this._nodes.get(this.iri.expand(id));
    }
    /**
     * @description Gets all nodes in the index.
     * @returns {IterableIterator<IndexNode>}
     * @memberof GraphIndex
     */
    *getNodes() {
        for (const [, node] of this._nodes) {
            yield node;
        }
    }
    /**
     * @description Gets a node's incoming edges, along with the incoming node.
     * @param {string} id The node whose incoming edges and nodes are to be retrieved.
     * @param {string} [label] Optional label to filter only those incoming edges that match the specified label.
     * @returns {IterableIterator<{ edge: IndexEdge, node: IndexNode }>}
     * @memberof GraphIndex
     */
    *getNodeIncoming(id, label) {
        if (!id) {
            throw new ReferenceError(`id is invalid. id is ${id}`);
        }
        let indexKey;
        if (!label) {
            indexKey = GraphIndex.IX_NODE_INCOMING_ALL_KEY(this.iri.expand(id));
        }
        else {
            indexKey = GraphIndex.IX_NODE_INCOMING_EDGES(this.iri.expand(id), this.iri.expand(label));
        }
        if (!this._index.has(indexKey)) {
            return;
        }
        for (const edgeId of this._index.get(indexKey)) {
            const edge = this._edges.get(edgeId);
            const node = this._nodes.get(this.iri.expand(edge.fromNodeId));
            yield { edge, node };
        }
    }
    /**
     * @description Gets a node's outgoing edges, along with the outgoing node.
     * @param {string} id The node whose outgoing edges and nodes are to be retrieved.
     * @param {string} [label] Optional label to filter only those outgoing edges that match the specified label.
     * @returns {IterableIterator<{ edge: IndexEdge, node: IndexNode }>}
     * @memberof GraphIndex
     */
    *getNodeOutgoing(id, label) {
        let indexKey;
        if (!label) {
            indexKey = GraphIndex.IX_NODE_OUTGOING_ALL(this.iri.expand(id));
        }
        else {
            indexKey = GraphIndex.IX_NODE_OUTGOING_EDGES(this.iri.expand(id), this.iri.expand(label));
        }
        if (!this._index.has(indexKey)) {
            return;
        }
        for (const edgeId of this._index.get(indexKey)) {
            const edge = this._edges.get(edgeId);
            const node = this._nodes.get(this.iri.expand(edge.toNodeId));
            yield { edge, node };
        }
    }
    /**
     * @description Checks if a specific edge exists.
     * @param {string} label The label of the edge.
     * @param {string} fromNodeId The edge outgoing node id.
     * @param {string} toNodeId The edge incoming node id.
     * @returns {boolean} True if the edge exists, else false.
     * @memberof GraphIndex
     */
    hasEdge(label, fromNodeId, toNodeId) {
        if (!label) {
            throw new ReferenceError(`Invalid label. label is ${label}`);
        }
        if (!fromNodeId) {
            throw new ReferenceError(`Invalid fromNodeId. fromNodeId is ${fromNodeId}`);
        }
        if (!toNodeId) {
            throw new ReferenceError(`Invalid toNodeId. toNodeId is ${toNodeId}`);
        }
        return this._edges.has(IndexEdge.toId(this.iri.expand(label), this.iri.expand(fromNodeId), this.iri.expand(toNodeId)));
    }
    /**
     * @description Checks if a specific node exists.
     * @param {string} id The id of the node to check for.
     * @returns {boolean} True if the node exists, else false.
     * @memberof GraphIndex
     */
    hasNode(id) {
        if (!id) {
            throw new ReferenceError(`Invalid nodeId. nodeId is ${id}`);
        }
        return this._nodes.has(this.iri.expand(id));
    }
    /**
     * @description Loads a set of input JSON-LD documents into the index.
     * @param {(any | any[])} inputs The inputs to load.
     * @param {string|string[]|object|object[]} [contexts] The contexts to load.
     * @param {string} [base] The base IRI of the context.
     * @returns {Promise<Set<string>>}
     * @memberof GraphIndex
     */
    load(inputs, contexts, base) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!inputs) {
                throw new ReferenceError(`Invalid inputs. inputs is ${inputs}`);
            }
            const vertexTracker = new Set();
            const documents = inputs instanceof Array ? inputs : [inputs];
            for (const document of documents) {
                try {
                    const triples = yield this._processor.flatten(document, contexts, base);
                    this._loadTriples(triples, vertexTracker, false);
                }
                catch (err) {
                    throw new errors_1.default.DocumentParseError(err);
                }
            }
            return vertexTracker;
        });
    }
    /**
     * @description Loads and merges a set of input JSON-LD documents into the index.
     * @param {(any | any[])} inputs The inputs to merge.
     * @param {string|string[]|object|object[]} [contexts] The contexts to merge.
     * @param {string} [base] The base IRI of inputs.
     * @returns {Promise<Set<string>>}
     * @memberof GraphIndex
     */
    merge(inputs, contexts, base) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!inputs) {
                throw new ReferenceError(`Invalid inputs. inputs is ${inputs}`);
            }
            const vertexTracker = new Set();
            const documents = inputs instanceof Array ? inputs : [inputs];
            for (const document of documents) {
                try {
                    const triples = yield this._processor.flatten(document, contexts, base);
                    this._loadTriples(triples, vertexTracker, true);
                }
                catch (err) {
                    throw new errors_1.default.DocumentParseError(err);
                }
            }
            return vertexTracker;
        });
    }
    /**
     * @description Removes a context.
     * @param {string} uri The uri of the context to remove.
     * @memberof GraphIndex
     */
    removeContext(uri) {
        this._processor.removeContext(uri);
    }
    /**
     * @description Removes an edge from the index.
     * @param {(string | IndexEdge)} edge The id or edge instance to remove from the index.
     * @returns {void}
     * @memberof GraphIndex
     */
    removeEdge(edge) {
        if (!edge) {
            throw new ReferenceError(`Invalid edge. edge is ${edge}`);
        }
        let indexEdge = edge;
        if (typeof edge === 'string') {
            indexEdge = this._edges.get(this.iri.expand(edge));
            if (!indexEdge) {
                return;
            }
        }
        this._deleteEdgeIndex(this.iri.expand(indexEdge.label), this.iri.expand(indexEdge.fromNodeId), this.iri.expand(indexEdge.toNodeId));
        if (this._edges.delete(indexEdge.id)) {
            this.emit('edgeDeleted', indexEdge);
        }
    }
    /**
     * @description Removes a node from the index.
     * @param {(string | IndexNode)} node The id or node instance to remove from the index.
     * @returns {void}
     * @memberof GraphIndex
     */
    removeNode(node) {
        if (!node) {
            throw new ReferenceError(`Invalid node. node is ${node}`);
        }
        let indexNode = node;
        if (typeof node === 'string') {
            indexNode = this._nodes.get(this.iri.expand(node));
            if (!indexNode) {
                return;
            }
        }
        const incomingEdgesKey = GraphIndex.IX_NODE_INCOMING_ALL_KEY(this.iri.expand(indexNode.id));
        const outgoingEdgesKey = GraphIndex.IX_NODE_OUTGOING_ALL(this.iri.expand(indexNode.id));
        if (this._index.has(incomingEdgesKey)) {
            for (const edgeId of this._index.get(incomingEdgesKey)) {
                this.removeEdge(edgeId);
            }
            this._index.delete(incomingEdgesKey);
        }
        if (this._index.has(outgoingEdgesKey)) {
            for (const edgeId of this._index.get(outgoingEdgesKey)) {
                this.removeEdge(edgeId);
            }
            this._index.delete(outgoingEdgesKey);
        }
        this._nodes.delete(this.iri.expand(indexNode.id));
        this.emit('nodeDeleted', indexNode);
    }
    /**
     * @description Removes a prefix from the index.
     * @param {string} prefix The prefix string to remove.
     * @memberof GraphIndex
     */
    removePrefix(prefix) {
        this.iri.removePrefix(prefix);
    }
    /**
     * @description Gets a JSON representation of the index.
     * @param {frame} [any] Optional frame instruction.
     * @returns {Promise<any>}
     * @memberof GraphIndex
     */
    toJson(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const document = { [constants_1.JsonldKeywords.graph]: [] };
            for (const node of this.getNodes()) {
                document[constants_1.JsonldKeywords.graph].push(node.toTriple());
            }
            const formatOptions = lodash_clonedeep_1.default(options);
            if (formatOptions.frame) {
                this._expandIdReferences(formatOptions.frame);
                if (formatOptions.context && !formatOptions.frame[constants_1.JsonldKeywords.container]) {
                    formatOptions.frame[constants_1.JsonldKeywords.context] = options.context;
                }
                return this._processor.frame(document, formatOptions.frame, [], options.base);
            }
            else if (options.context) {
                const expanded = yield this._processor.expand(document, formatOptions.context, options.base);
                return this._processor.compact(expanded, formatOptions.context);
            }
            else {
                return document;
            }
        });
    }
    _createEdgeIndexKeys(label, fromNodeId, toNodeId) {
        return [
            GraphIndex.IX_EDGES_KEY(label),
            GraphIndex.IX_EDGE_INCOMING_KEY(label),
            GraphIndex.IX_EDGE_OUTGOING_KEY(label),
            GraphIndex.IX_NODE_INCOMING_ALL_KEY(toNodeId),
            GraphIndex.IX_NODE_INCOMING_EDGES(toNodeId, label),
            GraphIndex.IX_NODE_OUTGOING_ALL(fromNodeId),
            GraphIndex.IX_NODE_OUTGOING_EDGES(fromNodeId, label)
        ];
    }
    _deleteEdgeIndex(label, fromNodeId, toNodeId) {
        const edgeId = IndexEdge.toId(label, fromNodeId, toNodeId);
        const indexKeys = this._createEdgeIndexKeys(label, fromNodeId, toNodeId);
        for (const key of indexKeys) {
            if (this._index.has(key)) {
                this._index.get(key).delete(edgeId);
                if (this._index.get(key).size === 0) {
                    this._index.delete(key);
                }
            }
        }
    }
    _expandIdReferences(source) {
        // This function is primarily looking for objects with @id keys and processing the identity references.
        // 1. Start by only accepting Array or object types.
        // 2. If source is an array, loop over elements in the array and recursively call self.
        // 3. If source is an object
        // 4. Get all own property keys. Loop through each key.
        // 4.a.Key is @id, process the value
        // 4.a @id value can either b a string or an array. If string replace the id with expanded id value. If an array then go through and expand each element.
        if (source instanceof Array) {
            for (const element of source) {
                this._expandIdReferences(element);
            }
        }
        else if (typeof source === 'object') {
            const keys = Object.getOwnPropertyNames(source);
            for (const key of keys) {
                if (key === constants_1.JsonldKeywords.id) {
                    if (source[key] instanceof Array) {
                        const elements = [...source[key]];
                        for (const element of elements) {
                            if (typeof element === 'string') {
                                source[key].splice(source[key].indexOf(element), 1, this.iri.expand(element));
                            }
                        }
                    }
                    else if (typeof source[key] === 'string') {
                        source[key] = this.iri.expand(source[key]);
                    }
                }
                else if (source[key] instanceof Array || typeof source[key] === 'object') {
                    this._expandIdReferences(source[key]);
                }
            }
        }
    }
    _indexEdge(label, fromNodeId, toNodeId) {
        const edgeId = IndexEdge.toId(label, fromNodeId, toNodeId);
        for (const key of this._createEdgeIndexKeys(label, fromNodeId, toNodeId)) {
            if (!this._index.has(key)) {
                this._index.set(key, new Set());
            }
            this._index.get(key).add(edgeId);
        }
    }
    _loadTriples(triples, vertexTracker, mergeAttributes = false) {
        const identityMap = new identityMap_1.default();
        for (const triple of triples) {
            const id = identityMap.get(triple);
            const types = triple[constants_1.JsonldKeywords.type] || [];
            let subjectNode;
            if (this.hasNode(id)) {
                subjectNode = this.getNode(id);
            }
            else {
                subjectNode = this.createNode(id);
                vertexTracker.add(this.iri.compact(id));
            }
            // Add outgoing edges to type nodes.
            for (const typeId of types) {
                if (!this.hasNode(typeId)) {
                    this.createNode(typeId);
                }
                this.createEdge(constants_1.JsonldKeywords.type, subjectNode.id, typeId);
            }
            // Process each predicate for the object.
            for (const predicate of Object.keys(triple)) {
                this._loadPredicate(identityMap, subjectNode, predicate, triple[predicate], vertexTracker, mergeAttributes);
            }
        }
    }
    _loadPredicate(identityMap, subjectNode, predicate, objects, vertexTracker, mergeAttributes) {
        for (const obj of objects) {
            if (obj[constants_1.JsonldKeywords.list]) {
                // Predicate object is a @list container, Load individual items in the @list array.
                return this._loadPredicate(identityMap, subjectNode, predicate, obj[constants_1.JsonldKeywords.list], vertexTracker, mergeAttributes);
            }
            if (obj[constants_1.JsonldKeywords.id]) {
                // Predicate object is a reference to another entity, create an edge to model the relationship.
                const objectId = identityMap.get(obj);
                if (!this.hasNode(objectId)) {
                    this.createNode(objectId);
                }
                vertexTracker.add(this.iri.compact(objectId));
                this.createEdge(predicate, subjectNode.id, objectId);
            }
            if (obj[constants_1.JsonldKeywords.value] !== null && obj[constants_1.JsonldKeywords.value] !== undefined) {
                // Predicate object is a value. Inline the value as a attribute of the subject vertex.
                if (mergeAttributes) {
                    subjectNode.setAttributeValue(predicate, obj[constants_1.JsonldKeywords.value], obj[constants_1.JsonldKeywords.language]);
                }
                else {
                    subjectNode.addAttributeValue(predicate, obj[constants_1.JsonldKeywords.value], obj[constants_1.JsonldKeywords.language]);
                }
            }
        }
    }
}
exports.GraphIndex = GraphIndex;
GraphIndex.IX_EDGES_KEY = (label) => `[e]::${label}`;
GraphIndex.IX_EDGE_INCOMING_KEY = (label) => `[e]::${label}_[in]`;
GraphIndex.IX_EDGE_OUTGOING_KEY = (label) => `[e]::${label}_[out]`;
GraphIndex.IX_NODE_INCOMING_ALL_KEY = (id) => `[v]::${id}_[in]`;
GraphIndex.IX_NODE_INCOMING_EDGES = (id, label) => `[v]::${id}_[in]_[e]::${label}`;
GraphIndex.IX_NODE_OUTGOING_ALL = (id) => `[v]::${id}_[out]`;
GraphIndex.IX_NODE_OUTGOING_EDGES = (id, label) => `[v]::${id}_[out]_[e]::${label}`;
exports.default = GraphIndex;
//# sourceMappingURL=graphIndex.js.map