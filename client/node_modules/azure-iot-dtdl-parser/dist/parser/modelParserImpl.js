"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/* eslint-disable valid-jsdoc */
/* eslint-disable guard-for-in */
/* eslint-disable no-empty */
/* eslint-disable no-empty-function */
/* eslint-disable no-unused-vars */
/* eslint-disable sort-imports */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModelParserImpl = void 0;
const enum_1 = require("./enum");
const parsingErrorImpl_1 = require("./parsingErrorImpl");
const resolutionError_1 = require("./resolutionError");
const jsonSyntaxError_1 = require("./jsonSyntaxError");
const parsingException_1 = require("./parsingException");
const aggregateContext_1 = require("./aggregateContext");
const model_1 = require("./model");
const partitionTypeCollection_1 = require("./partitionTypeCollection");
const standardElements_1 = require("./standardElements");
const rootableTypeCollection_1 = require("./rootableTypeCollection");
const modelParserStatic_1 = require("./modelParserStatic");
/**
 * Class for parsing the DTDL langauge.
 **/
class ModelParserImpl {
    constructor() {
        // codegen-outline-begin constructor
        this.options = enum_1.ModelParsingOption.None;
        // codegen-outline-end
    }
    async parse(jsonTexts) {
        if ((this.options & enum_1.ModelParsingOption.MandateTopLevelPartition) !== 0 &&
            (this.options & enum_1.ModelParsingOption.PermitAnyTopLevelElement) !== 0) {
            throw new Error("Options MandateTopLevelPartition and PermitAnyTopLevelElement are both specfied but are incompatible.");
        }
        const model = new model_1.Model();
        const objectPropertyInfoList = [];
        const elementPropertyConstraints = [];
        const parsingErrors = [];
        await this._parseAndResolveAsNeeded(jsonTexts, model, objectPropertyInfoList, elementPropertyConstraints, parsingErrors);
        model.setObjectProperties(objectPropertyInfoList, parsingErrors);
        for (const elementPropertyConstraint of elementPropertyConstraints) {
            const typeChecker = model.dict[elementPropertyConstraint.elementId];
            if (elementPropertyConstraint.valueConstraint.requiredTypes !== undefined &&
                !elementPropertyConstraint.valueConstraint.requiredTypes.some((t) => typeChecker === null || typeChecker === void 0 ? void 0 : typeChecker.doesHaveType(t))) {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                    cause: `{primaryId:p} property '{property}' has value {secondaryId} that does not have @type of {value}.`,
                    action: `Provide a value for property '{ property }' that has an @type of {value} or a subtype thereof.`,
                    primaryId: elementPropertyConstraint.parentId,
                    property: elementPropertyConstraint.propertyName,
                    secondaryId: elementPropertyConstraint.elementId,
                    value: elementPropertyConstraint.valueConstraint.requiredTypesString,
                }));
            }
            if (elementPropertyConstraint.valueConstraint.requiredValues !== undefined &&
                !elementPropertyConstraint.valueConstraint.requiredValues.includes(elementPropertyConstraint.elementId)) {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badValue", {
                    cause: `{primaryId:p} property '{property}' has value {secondaryId} that is not {value}.`,
                    action: `Change the value of property '{property}' to {value}.`,
                    primaryId: elementPropertyConstraint.parentId,
                    property: elementPropertyConstraint.propertyName,
                    secondaryId: elementPropertyConstraint.elementId,
                    value: elementPropertyConstraint.valueConstraint.requiredValuesString,
                }));
            }
        }
        for (const element of Object.values(model.dict)) {
            element.applyTransformations(model, parsingErrors);
        }
        for (const element of Object.values(model.dict)) {
            element.checkRestrictions(parsingErrors);
        }
        if (parsingErrors.length > 0) {
            throw new parsingException_1.ParsingException(parsingErrors);
        }
        return model.dict;
    }
    async _parseAndResolveAsNeeded(jsonTexts, model, objectPropertyInfoList, elementPropertyConstraints, parsingErrors) {
        this._parseTextsIntoModel(jsonTexts, model, objectPropertyInfoList, elementPropertyConstraints, parsingErrors);
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const undefinedIdentifierSet = new Set();
            for (const objectPropertyInfo of objectPropertyInfoList) {
                if (!model.hasElementWithId(objectPropertyInfo.referencedElementId)) {
                    if (!standardElements_1.StandardElements.tryAddElementToModel(model, objectPropertyInfo.referencedElementId)) {
                        undefinedIdentifierSet.add(objectPropertyInfo.referencedElementId);
                    }
                }
            }
            const undefinedIdentifiers = Array.from(undefinedIdentifierSet.values());
            if (undefinedIdentifiers.length === 0) {
                return;
            }
            if (this.getModels === undefined) {
                throw new resolutionError_1.ResolutionError("No getModels provided to resolve requisite reference(s): " + undefinedIdentifiers.join(" "), undefinedIdentifiers);
            }
            const dependencyMapping = await this.getModels(undefinedIdentifiers, {
                dependencyResolution: "enabled",
            });
            const additionalJsonTexts = dependencyMapping && Object.values(dependencyMapping).map((value) => JSON.stringify(value));
            if (additionalJsonTexts === null) {
                throw new resolutionError_1.ResolutionError("getModels refused to resolve requisite references to element(s): " +
                    undefinedIdentifiers.join(" "), undefinedIdentifiers);
            }
            this._parseTextsIntoModel(additionalJsonTexts, model, objectPropertyInfoList, elementPropertyConstraints, parsingErrors);
            const stillUnresolvedIdentifierSet = new Set();
            for (const undefinedId of undefinedIdentifiers) {
                if (!model.hasElementWithId(undefinedId)) {
                    stillUnresolvedIdentifierSet.add(undefinedId);
                }
            }
            const stillUnresolvedIdentifiers = Array.from(stillUnresolvedIdentifierSet.values());
            if (stillUnresolvedIdentifiers.length > 0) {
                throw new resolutionError_1.ResolutionError("getModels failed to resolve requisite references to element(s): " +
                    stillUnresolvedIdentifiers.join(" "), stillUnresolvedIdentifiers);
            }
        }
    }
    _parseTextsIntoModel(jsonTexts, model, objectPropertyInfoList, elementPropertyConstraints, parsingErrors) {
        jsonTexts.forEach((jsonText, index) => {
            let documentToken;
            try {
                documentToken = JSON.parse(jsonText);
            }
            catch (error) {
                throw new jsonSyntaxError_1.JsonSyntaxError(error, index);
            }
            this._parseToken(model, objectPropertyInfoList, elementPropertyConstraints, parsingErrors, documentToken, 0);
            if (parsingErrors.length > 0) {
                throw new parsingException_1.ParsingException(parsingErrors);
            }
        });
    }
    _parseToken(model, objectPropertyInfoList, elementPropertyConstraints, parsingErrors, token, dtdlVersion) {
        if (Array.isArray(token)) {
            for (const subToken of token) {
                this._parseToken(model, objectPropertyInfoList, elementPropertyConstraints, parsingErrors, subToken, dtdlVersion);
            }
            return;
        }
        if (typeof token !== "object") {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:notJsonObject", {
                cause: `Top-level JSON element is neither a JSON object nor a JSON array of JSON objects.`,
                action: `Update your model to follow the examples in https://github.com/Azure/opendigitaltwins-dtdl/tree/master/DTDL.`,
            }));
            throw new parsingException_1.ParsingException(parsingErrors);
        }
        const obj = token;
        const aggregateContext = new aggregateContext_1.AggregateContext((this.options & enum_1.ModelParsingOption.RejectUndefinedExtensions) !== 0, (this.options & enum_1.ModelParsingOption.RejectNonDtmiContexts) !== 0, this.maxDtdlVersion).getChildContext(obj, parsingErrors);
        if (Object.prototype.hasOwnProperty.call(obj, ModelParserImpl.graphKeyword)) {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:graphDisallowed", {
                cause: `Top-level JSON object contains '@graph' property, which is not allowed.`,
                action: `Remove the'@graph' property, and elevate the value of this property to the top level of the JSON document.`,
            }));
            throw new parsingException_1.ParsingException(parsingErrors);
        }
        if (!Object.prototype.hasOwnProperty.call(obj, ModelParserImpl.idKeyword)) {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:missingTopLevelId", {
                cause: `Top-level element requires an identifer but none provided.`,
                action: `Add an '@id' property whose value is a string that conforms to the DTMI syntax -- see https://github.com/Azure/digital-twin-model-identifier.`,
            }));
            throw new parsingException_1.ParsingException(parsingErrors);
        }
        if ((this.options & enum_1.ModelParsingOption.MandateTopLevelPartition) !== 0) {
            if (!partitionTypeCollection_1.PartitionTypeCollection.hasPartitionType(obj)) {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                    cause: `Top-level element ${JSON.stringify(obj[ModelParserImpl.idKeyword])} does not have @type of ${partitionTypeCollection_1.PartitionTypeCollection.partitionTypeDescription}.`,
                    action: `Provide a @type in the set of allowable types.`,
                }));
                throw new parsingException_1.ParsingException(parsingErrors);
            }
        }
        else if ((this.options & enum_1.ModelParsingOption.PermitAnyTopLevelElement) === 0) {
            if (!rootableTypeCollection_1.RootableTypeCollection.hasRootableType(obj, aggregateContext.dtdlVersion)) {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                    cause: `Top-level element ${JSON.stringify(obj[ModelParserImpl.idKeyword])} does not have @type of ${rootableTypeCollection_1.RootableTypeCollection.rootableTypeDescriptions[aggregateContext.dtdlVersion]}.`,
                    action: `Provide a @type in the set of allowable types.`,
                }));
                throw new parsingException_1.ParsingException(parsingErrors);
            }
        }
        modelParserStatic_1.ModelParserStatic.parseObject(model, objectPropertyInfoList, elementPropertyConstraints, aggregateContext, parsingErrors, obj);
    }
}
exports.ModelParserImpl = ModelParserImpl;
// codegen-outline-begin fields
ModelParserImpl.graphKeyword = "@graph";
ModelParserImpl.idKeyword = "@id";
//# sourceMappingURL=modelParserImpl.js.map