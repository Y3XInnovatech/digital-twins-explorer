"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/* eslint-disable valid-jsdoc */
/* eslint-disable guard-for-in */
/* eslint-disable no-empty */
/* eslint-disable no-empty-function */
/* eslint-disable no-unused-vars */
/* eslint-disable sort-imports */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReferenceInfoParser = void 0;
const idValidator_1 = require("./idValidator");
const parsingErrorImpl_1 = require("./parsingErrorImpl");
const aggregateContext_1 = require("./aggregateContext");
const internalDtmi_1 = require("./internalDtmi");
const reference_1 = require("../common/reference");
const supplementalTypeInfoStatic_1 = require("./supplementalTypeInfoStatic");
class ReferenceInfoParser {
    static initialize() {
        this._concreteKinds = {};
        this._badTypeActionFormat = {};
        this._badTypeCauseFormat = {};
    }
    static tryParseSupplementalProperty(model, elementInfo, objectPropertyInfoList, elementPropertyConstraints, aggregateContext, parsingErrors, propName, 
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    propToken) {
        const propDtmi = aggregateContext.createDtmi(propName);
        if (propDtmi === undefined) {
            return false;
        }
        for (const supplementalType of elementInfo.supplementalTypes) {
            if (supplementalType.tryParseProperty(model, objectPropertyInfoList, elementPropertyConstraints, aggregateContext, parsingErrors, elementInfo.id, propDtmi.value, propToken, elementInfo.supplementalProperties)) {
                return true;
            }
        }
        return false;
    }
    static parseObject(model, objectPropertyInfoList, elementPropertyConstraints, valueConstraints, aggregateContext, parsingErrors, object, parentId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    definedIn, propName, dtmiSeg, keyProp, idRequired, typeRequired, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    allowIdReferenceSyntax, allowedVersions) {
        // This is a method to parse the object read from DTDL into a type of ReferenceInfo
        const childAggregateContext = aggregateContext.getChildContext(object, parsingErrors);
        if (Object.keys(object).length === 1 &&
            Object.prototype.hasOwnProperty.call(object, "@id") &&
            typeof object["@id"] === "string") {
            if (allowIdReferenceSyntax && parentId !== undefined) {
                this.parseIdString(objectPropertyInfoList, elementPropertyConstraints, valueConstraints, childAggregateContext, parsingErrors, object["@id"], parentId, propName, keyProp, allowedVersions);
                return;
            }
            else {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:idReference", {
                    cause: `{primaryId:p} property '{property}' has an inline definition containing nothing but an '@id' property.`,
                    action: `Replace the inline definition with a string value of '{secondaryId}', or provide a complete inline definition for property '{property}'.`,
                    primaryId: parentId,
                    property: propName,
                    secondaryId: object["@id"],
                }));
                return;
            }
        }
        if (allowedVersions !== undefined &&
            allowedVersions.size !== 0 &&
            !allowedVersions.has(childAggregateContext.dtdlVersion)) {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:disallowedVersionDefinition", {
                cause: `{primaryId:p} property '{property}' has a value that specifies DTDL context version ${childAggregateContext.dtdlVersion}, which is not allowed for this property.`,
                action: `Change the DTDL context version of property '{property}' to one of the following: ${Array.from(allowedVersions.values()).join(" ,")}.`,
                primaryId: parentId,
                property: propName,
            }));
        }
        const typeToken = object["@type"];
        let typeTokenArr = [];
        const elementId = idValidator_1.IdValidator.parseIdProperty(object, parentId !== undefined ? parentId : "", propName, dtmiSeg, idRequired, parsingErrors, childAggregateContext.dtdlVersion);
        if (elementId === undefined || elementId === null) {
            return;
        }
        if (Object.prototype.hasOwnProperty.call(model.dict, elementId)) {
            const elementDtmi = internalDtmi_1.InDTMI.createDtmi(elementId);
            if (!(elementDtmi === null || elementDtmi === void 0 ? void 0 : elementDtmi.isReserved)) {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:duplicateDefinition", {
                    cause: `{primaryId:p} has more than one definition.`,
                    action: `Remove all but one JSON object containing '@id' property with value {primaryId}, or change the '@id' values so there are no duplicates.`,
                    primaryId: elementId,
                }));
            }
            else if (dtmiSeg !== undefined) {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:nonUniquePropertyValue", {
                    cause: `{primaryId:p} property ${propName} contains more than one element whose property '{dtmiSeg}' has value ${dtmiSeg}`,
                    action: `Change the value of property ${dtmiSeg} to a string value that is unique across all values of ${propName}.`,
                    primaryId: parentId,
                    property: propName,
                    value: dtmiSeg,
                }));
            }
            return;
        }
        if (typeRequired && typeToken === undefined) {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                cause: this._badTypeCauseFormat[childAggregateContext.dtdlVersion],
                action: this._badTypeActionFormat[childAggregateContext.dtdlVersion],
                primaryId: parentId,
                property: propName,
                secondaryId: elementId,
            }));
            return;
        }
        if (typeToken === undefined) {
            typeTokenArr = ["Reference"];
        }
        else if (!Array.isArray(typeToken)) {
            typeTokenArr = [typeToken];
        }
        else {
            typeTokenArr = typeToken;
        }
        const elementInfo = this.parseTypeArray(typeTokenArr, elementId, parentId, definedIn, propName, childAggregateContext, parsingErrors);
        if (elementInfo === undefined) {
            return;
        }
        elementInfo.sourceObject = object;
        switch (childAggregateContext.dtdlVersion) {
        }
        model.dict[elementId] = elementInfo;
        if (parentId !== undefined) {
            const objectPropertyInfo = {
                elementId: parentId,
                propertyName: propName || "",
                referencedElementId: elementId,
                keyProperty: keyProp,
                expectedKinds: [],
                allowedVersions: new Set(),
                badTypeCauseFormat: undefined,
                badTypeActionFormat: undefined,
            };
            objectPropertyInfoList.push(objectPropertyInfo);
            if (valueConstraints !== undefined && elementPropertyConstraints !== undefined) {
                for (const vc of valueConstraints) {
                    const elementPropertyConstraint = {
                        parentId: parentId,
                        propertyName: propName,
                        elementId: elementId,
                        valueConstraint: vc,
                    };
                    elementPropertyConstraints.push(elementPropertyConstraint);
                }
            }
        }
    }
    static parseTypeArray(tokenArr, elementId, parentId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    definedIn, propName, aggregateContext, parsingErrors) {
        const materialKinds = [];
        const elementInfo = (0, reference_1.referenceInit)();
        // eslint-disable-next-line prefer-const
        let anyFailures = false;
        const supplementalTypeIds = [];
        const undefinedTypes = [];
        for (const element of tokenArr) {
            if (typeof element !== "string") {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                    cause: this._badTypeCauseFormat[aggregateContext.dtdlVersion],
                    action: this._badTypeActionFormat[aggregateContext.dtdlVersion],
                    primaryId: parentId,
                    property: propName,
                    secondaryId: elementId,
                    value: element,
                }));
                return undefined;
            }
        }
        if (anyFailures) {
            return undefined;
        }
        if (elementInfo.ref === undefined) {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                cause: this._badTypeCauseFormat[aggregateContext.dtdlVersion],
                action: this._badTypeActionFormat[aggregateContext.dtdlVersion],
                primaryId: parentId,
                property: propName,
                secondaryId: elementId,
            }));
            return undefined;
        }
        if (materialKinds.length > 1) {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:multipleMaterialTypes", {
                cause: `{primaryId:p} has @type that specifies multiple material types: ${materialKinds.join(" ,")}`,
                action: `Remove excess @type values so that only one material type remains.`,
                primaryId: elementId,
            }));
            return undefined;
        }
        elementInfo.ref.undefinedTypes = undefinedTypes;
        for (const supplementalTypeId of supplementalTypeIds) {
            const supplementalTypeInfo = supplementalTypeInfoStatic_1.SupplementalTypeInfoStatic.retrieveSupplementalTypeCollection().supplementalTypes.get(supplementalTypeId);
            if (elementInfo.ref !== undefined && elementInfo.ref.entityKind !== undefined) {
                if (!(supplementalTypeInfo === null || supplementalTypeInfo === void 0 ? void 0 : supplementalTypeInfo.allowedCotypeKinds.includes(elementInfo.ref.entityKind))) {
                    parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:invalidCotype", {
                        cause: `{primaryId:p} has @type {value} that can only be applied to elements of @type ${supplementalTypeInfo === null || supplementalTypeInfo === void 0 ? void 0 : supplementalTypeInfo.allowedCotypeKinds.join(" or ")} + '.'`,
                        action: `Remove @type '{value}' from element.`,
                        primaryId: elementId,
                        value: aggregateContext_1.AggregateContext.getTermOrUri(supplementalTypeId),
                    }));
                }
                else if (!(supplementalTypeInfo === null || supplementalTypeInfo === void 0 ? void 0 : supplementalTypeInfo.allowedCotypeVersions.includes(elementInfo.ref.dtdlVersion))) {
                    parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:invalidCotypeVersion", {
                        cause: `{primaryId:p} has @type {value} that can only be applied to elements defined in DTDL version ${supplementalTypeInfo === null || supplementalTypeInfo === void 0 ? void 0 : supplementalTypeInfo.allowedCotypeVersions.join(" or ")} + '.'`,
                        action: `Remove @type '{value}' from element.`,
                        primaryId: elementId,
                        value: aggregateContext_1.AggregateContext.getTermOrUri(supplementalTypeId),
                    }));
                }
                else {
                    elementInfo.ref.addType(supplementalTypeId, supplementalTypeInfo);
                }
            }
        }
        return elementInfo.ref;
        // this ends the method.
    }
    static parseToken(model, objectPropertyInfoList, elementPropertyConstraints, valueConstraints, aggregateContext, parsingErrors, 
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    token, parentId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    definedIn, propName, dtmiSeg, keyProp, idRequired, typeRequired, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    allowIdReferenceSyntax, allowedVersions) {
        let valueCount = 0;
        if (typeof token === "string") {
            if (parentId !== undefined) {
                this.parseIdString(objectPropertyInfoList, elementPropertyConstraints, valueConstraints, aggregateContext, parsingErrors, token.toString(), parentId, propName, keyProp, allowedVersions);
                valueCount++;
            }
        }
        else if (Array.isArray(token)) {
            for (const elementToken of token) {
                valueCount += this.parseToken(model, objectPropertyInfoList, elementPropertyConstraints, valueConstraints, aggregateContext, parsingErrors, elementToken, parentId, definedIn, propName, dtmiSeg, keyProp, idRequired, typeRequired, allowIdReferenceSyntax, allowedVersions);
            }
        }
        else if (typeof token === "object") {
            this.parseObject(model, objectPropertyInfoList, elementPropertyConstraints, valueConstraints, aggregateContext, parsingErrors, token, parentId, definedIn, propName, dtmiSeg, keyProp, idRequired, typeRequired, allowIdReferenceSyntax, allowedVersions);
            valueCount++;
        }
        else {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badDtmiOrTerm", {
                cause: `{primaryId:p} property '{property}' has value '{value}' that is not a DTMI or a DTDL term.`,
                action: `Replace the value of property '{property}, with a valid DTMI or a term defined by DTDL -- see https://github.com/Azure/opendigitaltwins-dtdl/tree/master/DTDL.`,
                primaryId: parentId,
                property: propName,
                value: token.toString(),
            }));
        }
        return valueCount;
    }
    static parseIdString(objectPropertyInfoList, elementPropertyConstraints, valueConstraints, aggregateContext, parsingErrors, idString, parentId, propName, keyProp, allowedVersions) {
        const elementId = aggregateContext.createDtmi(idString);
        if (elementId !== undefined) {
            const objectPropertyInfo = {
                elementId: parentId,
                propertyName: propName !== null && propName !== void 0 ? propName : "",
                referencedElementId: elementId.value,
                keyProperty: keyProp,
                expectedKinds: this._concreteKinds[aggregateContext.dtdlVersion],
                allowedVersions: allowedVersions,
                badTypeCauseFormat: this._badTypeCauseFormat[aggregateContext.dtdlVersion],
                badTypeActionFormat: this._badTypeActionFormat[aggregateContext.dtdlVersion],
            };
            objectPropertyInfoList.push(objectPropertyInfo);
            if (valueConstraints !== null && elementPropertyConstraints !== null) {
                for (const vc of valueConstraints) {
                    const elementPropertyConstraint = {
                        parentId: parentId,
                        propertyName: propName !== null && propName !== void 0 ? propName : "",
                        elementId: elementId.value,
                        valueConstraint: vc,
                    };
                    elementPropertyConstraints.push(elementPropertyConstraint);
                }
            }
        }
        else {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badDtmiOrTerm", {
                cause: `{primaryId:p} property '{property}' has value '{value}' that is not a DTMI or a DTDL term.`,
                action: `Replace the value of property '{property}, with a valid DTMI or a term defined by DTDL -- see https://github.com/Azure/opendigitaltwins-dtdl/tree/master/DTDL.`,
                primaryId: parentId,
                property: propName,
                value: idString,
            }));
        }
    }
}
exports.ReferenceInfoParser = ReferenceInfoParser;
//# sourceMappingURL=referenceInfoParser.js.map