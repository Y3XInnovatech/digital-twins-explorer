"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/* eslint-disable valid-jsdoc */
/* eslint-disable guard-for-in */
/* eslint-disable no-empty */
/* eslint-disable no-empty-function */
/* eslint-disable no-unused-vars */
/* eslint-disable sort-imports */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Model = void 0;
const parsingErrorImpl_1 = require("./parsingErrorImpl");
const referenceInfoImpl_1 = require("./referenceInfoImpl");
/**
 * A DTDL model.
 **/
class Model {
    constructor() {
        // codegen-outline-begin constructor
        this.dict = {};
        // codegen-outline-end
    }
    isPartition(elementId) {
        var _a;
        return ((_a = this.dict[elementId]) === null || _a === void 0 ? void 0 : _a.isPartition) || false;
    }
    addType(elementId, supplementalTypeId, supplementalType) {
        var _a;
        (_a = this.dict[elementId]) === null || _a === void 0 ? void 0 : _a.addType(supplementalTypeId, supplementalType);
    }
    doesPropertyDictContainKey(elementId, propertyName, key) {
        var _a;
        return ((_a = this.dict[elementId]) === null || _a === void 0 ? void 0 : _a.doesPropertyDictContainKey(propertyName, key)) || false;
    }
    trySetObjectProperty(elementId, propertyName, referencedElementId, key) {
        var _a;
        const obj = Object.keys(this.dict).includes(referencedElementId)
            ? this.dict[referencedElementId]
            : new referenceInfoImpl_1.ReferenceInfoImpl(0, referencedElementId, undefined, undefined, "reference");
        return ((_a = this.dict[elementId]) === null || _a === void 0 ? void 0 : _a.trySetObjectProperty(propertyName, obj, key)) || false;
    }
    isKindInSet(elementId, kindSet) {
        var _a, _b;
        if (((_a = this.dict[elementId]) === null || _a === void 0 ? void 0 : _a.entityKind) !== undefined) {
            return kindSet.includes((_b = this.dict[elementId]) === null || _b === void 0 ? void 0 : _b.entityKind);
        }
        return false;
    }
    getKindString(elementId) {
        const element = this.dict[elementId];
        return element !== undefined
            ? element.entityKind.substring(0, 1).toUpperCase() + element.entityKind.substring(1)
            : "";
    }
    checkRestrictions(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    parsingErrors) { }
    applyTransformations(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    parsingErrors) { }
    // codegen-outline-begin method-block
    hasElementWithId(elementId) {
        return Object.prototype.hasOwnProperty.call(this.dict, elementId);
    }
    /**
     * Set the object properties from objectPropertyInfoList on elements in this Model.
     * @param objectPropertyInfoList - Object property information for the this.
     * @param parsingErrors - A list of ParsingErrors to which any parsing error is added.
     */
    setObjectProperties(objectPropertyInfoList, parsingErrors) {
        var _a, _b, _c, _d, _e;
        for (const objectPropertyInfo of objectPropertyInfoList) {
            if (!((_a = this.dict[objectPropertyInfo.referencedElementId]) === null || _a === void 0 ? void 0 : _a.isPartition)) {
                // TODO: will this ever be undefined?
                const elementIdValue = this.dict[objectPropertyInfo.elementId];
                // TODO: isPartition will be a boolean value... So is this OR operation correct?
                const sourcePartition = (elementIdValue === null || elementIdValue === void 0 ? void 0 : elementIdValue.isPartition) || (elementIdValue === null || elementIdValue === void 0 ? void 0 : elementIdValue.definedIn) === undefined
                    ? objectPropertyInfo.elementId
                    : elementIdValue === null || elementIdValue === void 0 ? void 0 : elementIdValue.definedIn;
                const targetPartition = (_b = this.dict[objectPropertyInfo.referencedElementId]) === null || _b === void 0 ? void 0 : _b.definedIn;
                if (targetPartition !== undefined && targetPartition !== sourcePartition) {
                    parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:crossPartitionReference", {
                        cause: `{primaryId:p} property '${objectPropertyInfo.propertyName}' refers to \${secondaryId}, which is defined under ${targetPartition}.`,
                        action: `Create a copy of \${secondaryId} under ${sourcePartition}, give it a unique @id value, and refer to it instead of \${secondaryId}.`,
                        primaryId: objectPropertyInfo.elementId,
                        secondaryId: objectPropertyInfo.referencedElementId,
                        property: objectPropertyInfo.propertyName,
                    }));
                }
            }
            // TODO: this is replacing this.IsKindInSet, which is generated. What do we do here?
            if (objectPropertyInfo.expectedKinds !== undefined &&
                objectPropertyInfo.expectedKinds.length !== 0 &&
                !this.isKindInSet(objectPropertyInfo.referencedElementId, objectPropertyInfo.expectedKinds)) {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                    cause: objectPropertyInfo.badTypeCauseFormat || "",
                    action: objectPropertyInfo.badTypeActionFormat || "",
                    primaryId: objectPropertyInfo.elementId,
                    secondaryId: objectPropertyInfo.referencedElementId,
                    property: objectPropertyInfo.propertyName,
                    value: this.getKindString(objectPropertyInfo.referencedElementId),
                }));
            }
            if (objectPropertyInfo.allowedVersions !== undefined &&
                objectPropertyInfo.allowedVersions.size !== 0 &&
                typeof ((_c = this.dict[objectPropertyInfo.referencedElementId]) === null || _c === void 0 ? void 0 : _c.dtdlVersion) === "number" &&
                !objectPropertyInfo.allowedVersions.has((_d = this.dict[objectPropertyInfo.referencedElementId]) === null || _d === void 0 ? void 0 : _d.dtdlVersion)) {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)(`dtmi:dtdl:parsingError:disallowedVersionReference`, {
                    cause: `{primaryId:p} property '${objectPropertyInfo.propertyName}' refers to {secondaryId}, which is defined in DTDL version {this.dict[objectPropertyInfo.referencedElementId.value]?.dtdlVersion}, which is not allowed for this property.`,
                    action: `Change the value of property '{property}' to an element defined in one of the following DTDL versions: {string.Join(" ,", objectPropertyInfo.AllowedVersions)}.`,
                    primaryId: objectPropertyInfo.elementId,
                    secondaryId: objectPropertyInfo.referencedElementId,
                    property: objectPropertyInfo.propertyName,
                }));
            }
            let dictKey = "";
            if (objectPropertyInfo.keyProperty !== undefined) {
                const keyToken = (_e = this.dict[objectPropertyInfo.referencedElementId]) === null || _e === void 0 ? void 0 : _e.sourceObject[objectPropertyInfo.keyProperty];
                if (keyToken === undefined || typeof keyToken !== "string") {
                    parsingErrors.push((0, parsingErrorImpl_1.createParsingError)(`dtmi:dtdl:parsingError:missingRequiredProperty`, {
                        cause: `{primaryId:p} property '${objectPropertyInfo.propertyName}' requires property '${objectPropertyInfo.keyProperty}' to be specified but it is not.`,
                        action: `Add a '${objectPropertyInfo.keyProperty}' property with a string value that is unique across all values of '${objectPropertyInfo.propertyName}'.`,
                        primaryId: objectPropertyInfo.elementId,
                        property: objectPropertyInfo.propertyName,
                        value: objectPropertyInfo.keyProperty,
                    }));
                }
                // TODO: Is this equivalent to ((JValue)keyToken).Value<string>();
                dictKey = keyToken.toString();
            }
            // TODO: Rather than undefined I have defined dictKey as ''. Should that change? We should be aware to avoid bugs.
            if (this.doesPropertyDictContainKey(objectPropertyInfo.elementId, objectPropertyInfo.propertyName, dictKey)) {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:nonUniquePropertyValue", {
                    cause: `{primaryId:p} property '${objectPropertyInfo.propertyName}' contains more than one element whose property '${objectPropertyInfo.keyProperty}' has value '${dictKey}'.`,
                    action: `Change the value of property '${objectPropertyInfo.keyProperty}' to a string value that is unique across all values of '${objectPropertyInfo.propertyName}'.`,
                    primaryId: objectPropertyInfo.elementId,
                    property: objectPropertyInfo.propertyName,
                    value: objectPropertyInfo.keyProperty,
                }));
            }
            else {
                this.trySetObjectProperty(objectPropertyInfo.elementId, objectPropertyInfo.propertyName, objectPropertyInfo.referencedElementId, dictKey);
            }
        }
    }
}
exports.Model = Model;
//# sourceMappingURL=model.js.map