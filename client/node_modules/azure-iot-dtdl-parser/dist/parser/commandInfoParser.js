"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/* eslint-disable valid-jsdoc */
/* eslint-disable guard-for-in */
/* eslint-disable no-empty */
/* eslint-disable no-empty-function */
/* eslint-disable no-unused-vars */
/* eslint-disable sort-imports */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandInfoParser = void 0;
const commandInfoImpl_1 = require("./commandInfoImpl");
const idValidator_1 = require("./idValidator");
const parsingErrorImpl_1 = require("./parsingErrorImpl");
const aggregateContext_1 = require("./aggregateContext");
const internalDtmi_1 = require("./internalDtmi");
const reference_1 = require("../common/reference");
const supplementalTypeInfoStatic_1 = require("./supplementalTypeInfoStatic");
const materialTypeNameCollection_1 = require("./materialTypeNameCollection");
const extensionKind_1 = require("./extensionKind");
const parserCollection_1 = require("./parserCollection");
const valueParser_1 = require("./valueParser");
class CommandInfoParser {
    static initialize() {
        this._concreteKinds = {};
        this._concreteKinds[2] = [];
        this._concreteKinds[2].push("command");
        this._concreteKinds[3] = [];
        this._concreteKinds[3].push("command");
        this._badTypeActionFormat = {};
        this._badTypeCauseFormat = {};
        this._badTypeActionFormat[2] = `Provide a value for property '{property}' with @type Command.`;
        this._badTypeActionFormat[3] = `Provide a value for property '{property}' with @type Command.`;
        this._badTypeCauseFormat[2] = `{primaryId:p} property '{property}' has value{secondaryId:e} that does not have @type of Command.`;
        this._badTypeCauseFormat[3] = `{primaryId:p} property '{property}' has value{secondaryId:e} that does not have @type of Command.`;
    }
    static tryParseSupplementalProperty(model, elementInfo, objectPropertyInfoList, elementPropertyConstraints, aggregateContext, parsingErrors, propName, 
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    propToken) {
        const propDtmi = aggregateContext.createDtmi(propName);
        if (propDtmi === undefined) {
            return false;
        }
        for (const supplementalType of elementInfo.supplementalTypes) {
            if (supplementalType.tryParseProperty(model, objectPropertyInfoList, elementPropertyConstraints, aggregateContext, parsingErrors, elementInfo.id, propDtmi.value, propToken, elementInfo.supplementalProperties)) {
                return true;
            }
        }
        return false;
    }
    static parseObject(model, objectPropertyInfoList, elementPropertyConstraints, valueConstraints, aggregateContext, parsingErrors, object, parentId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    definedIn, propName, dtmiSeg, keyProp, idRequired, typeRequired, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    allowIdReferenceSyntax, allowedVersions) {
        var _a, _b, _c, _d;
        // This is a method to parse the object read from DTDL into a type of CommandInfo
        const childAggregateContext = aggregateContext.getChildContext(object, parsingErrors);
        if (Object.keys(object).length === 1 &&
            Object.prototype.hasOwnProperty.call(object, "@id") &&
            typeof object["@id"] === "string") {
            if (allowIdReferenceSyntax && parentId !== undefined) {
                this.parseIdString(objectPropertyInfoList, elementPropertyConstraints, valueConstraints, childAggregateContext, parsingErrors, object["@id"], parentId, propName, keyProp, allowedVersions);
                return;
            }
            else {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:idReference", {
                    cause: `{primaryId:p} property '{property}' has an inline definition containing nothing but an '@id' property.`,
                    action: `Replace the inline definition with a string value of '{secondaryId}', or provide a complete inline definition for property '{property}'.`,
                    primaryId: parentId,
                    property: propName,
                    secondaryId: object["@id"],
                }));
                return;
            }
        }
        if (allowedVersions !== undefined &&
            allowedVersions.size !== 0 &&
            !allowedVersions.has(childAggregateContext.dtdlVersion)) {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:disallowedVersionDefinition", {
                cause: `{primaryId:p} property '{property}' has a value that specifies DTDL context version ${childAggregateContext.dtdlVersion}, which is not allowed for this property.`,
                action: `Change the DTDL context version of property '{property}' to one of the following: ${Array.from(allowedVersions.values()).join(" ,")}.`,
                primaryId: parentId,
                property: propName,
            }));
        }
        const typeToken = object["@type"];
        let typeTokenArr = [];
        const elementId = idValidator_1.IdValidator.parseIdProperty(object, parentId !== undefined ? parentId : "", propName, dtmiSeg, idRequired, parsingErrors, childAggregateContext.dtdlVersion);
        if (elementId === undefined || elementId === null) {
            return;
        }
        if (Object.prototype.hasOwnProperty.call(model.dict, elementId)) {
            const elementDtmi = internalDtmi_1.InDTMI.createDtmi(elementId);
            if (!(elementDtmi === null || elementDtmi === void 0 ? void 0 : elementDtmi.isReserved)) {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:duplicateDefinition", {
                    cause: `{primaryId:p} has more than one definition.`,
                    action: `Remove all but one JSON object containing '@id' property with value {primaryId}, or change the '@id' values so there are no duplicates.`,
                    primaryId: elementId,
                }));
            }
            else if (dtmiSeg !== undefined) {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:nonUniquePropertyValue", {
                    cause: `{primaryId:p} property ${propName} contains more than one element whose property '{dtmiSeg}' has value ${dtmiSeg}`,
                    action: `Change the value of property ${dtmiSeg} to a string value that is unique across all values of ${propName}.`,
                    primaryId: parentId,
                    property: propName,
                    value: dtmiSeg,
                }));
            }
            return;
        }
        if (typeRequired && typeToken === undefined) {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                cause: this._badTypeCauseFormat[childAggregateContext.dtdlVersion],
                action: this._badTypeActionFormat[childAggregateContext.dtdlVersion],
                primaryId: parentId,
                property: propName,
                secondaryId: elementId,
            }));
            return;
        }
        if (typeToken === undefined) {
            typeTokenArr = ["Command"];
        }
        else if (!Array.isArray(typeToken)) {
            typeTokenArr = [typeToken];
        }
        else {
            typeTokenArr = typeToken;
        }
        const elementInfo = this.parseTypeArray(typeTokenArr, elementId, parentId, definedIn, propName, childAggregateContext, parsingErrors);
        if (elementInfo === undefined) {
            return;
        }
        elementInfo.sourceObject = object;
        switch (childAggregateContext.dtdlVersion) {
            case 2: {
                if (((_a = elementInfo.parserClass) === null || _a === void 0 ? void 0 : _a.parsePropertiesV2) !== undefined) {
                    (_b = elementInfo.parserClass) === null || _b === void 0 ? void 0 : _b.parsePropertiesV2(model, elementInfo, objectPropertyInfoList, elementPropertyConstraints, childAggregateContext, parsingErrors, object, definedIn, allowIdReferenceSyntax);
                }
                break;
            }
            case 3: {
                if (((_c = elementInfo.parserClass) === null || _c === void 0 ? void 0 : _c.parsePropertiesV3) !== undefined) {
                    (_d = elementInfo.parserClass) === null || _d === void 0 ? void 0 : _d.parsePropertiesV3(model, elementInfo, objectPropertyInfoList, elementPropertyConstraints, childAggregateContext, parsingErrors, object, definedIn, allowIdReferenceSyntax);
                }
                break;
            }
        }
        model.dict[elementId] = elementInfo;
        if (parentId !== undefined) {
            const objectPropertyInfo = {
                elementId: parentId,
                propertyName: propName || "",
                referencedElementId: elementId,
                keyProperty: keyProp,
                expectedKinds: [],
                allowedVersions: new Set(),
                badTypeCauseFormat: undefined,
                badTypeActionFormat: undefined,
            };
            objectPropertyInfoList.push(objectPropertyInfo);
            if (valueConstraints !== undefined && elementPropertyConstraints !== undefined) {
                for (const vc of valueConstraints) {
                    const elementPropertyConstraint = {
                        parentId: parentId,
                        propertyName: propName,
                        elementId: elementId,
                        valueConstraint: vc,
                    };
                    elementPropertyConstraints.push(elementPropertyConstraint);
                }
            }
        }
    }
    static parseTypeArray(tokenArr, elementId, parentId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    definedIn, propName, aggregateContext, parsingErrors) {
        const materialKinds = [];
        const elementInfo = (0, reference_1.referenceInit)();
        // eslint-disable-next-line prefer-const
        let anyFailures = false;
        const supplementalTypeIds = [];
        const undefinedTypes = [];
        for (const element of tokenArr) {
            if (typeof element !== "string") {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                    cause: this._badTypeCauseFormat[aggregateContext.dtdlVersion],
                    action: this._badTypeActionFormat[aggregateContext.dtdlVersion],
                    primaryId: parentId,
                    property: propName,
                    secondaryId: elementId,
                    value: element,
                }));
                return undefined;
            }
            switch (aggregateContext.dtdlVersion) {
                case 2: {
                    if (!this.tryParseTypeStringV2(element.toString(), elementId, parentId, definedIn, propName, materialKinds, supplementalTypeIds, elementInfo, undefinedTypes, aggregateContext, parsingErrors)) {
                        anyFailures = true;
                    }
                    break;
                }
                case 3: {
                    if (!this.tryParseTypeStringV3(element.toString(), elementId, parentId, definedIn, propName, materialKinds, supplementalTypeIds, elementInfo, undefinedTypes, aggregateContext, parsingErrors)) {
                        anyFailures = true;
                    }
                    break;
                }
            }
        }
        if (anyFailures) {
            return undefined;
        }
        if (elementInfo.ref === undefined) {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                cause: this._badTypeCauseFormat[aggregateContext.dtdlVersion],
                action: this._badTypeActionFormat[aggregateContext.dtdlVersion],
                primaryId: parentId,
                property: propName,
                secondaryId: elementId,
            }));
            return undefined;
        }
        if (materialKinds.length > 1) {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:multipleMaterialTypes", {
                cause: `{primaryId:p} has @type that specifies multiple material types: ${materialKinds.join(" ,")}`,
                action: `Remove excess @type values so that only one material type remains.`,
                primaryId: elementId,
            }));
            return undefined;
        }
        elementInfo.ref.undefinedTypes = undefinedTypes;
        for (const supplementalTypeId of supplementalTypeIds) {
            const supplementalTypeInfo = supplementalTypeInfoStatic_1.SupplementalTypeInfoStatic.retrieveSupplementalTypeCollection().supplementalTypes.get(supplementalTypeId);
            if (elementInfo.ref !== undefined && elementInfo.ref.entityKind !== undefined) {
                if (!(supplementalTypeInfo === null || supplementalTypeInfo === void 0 ? void 0 : supplementalTypeInfo.allowedCotypeKinds.includes(elementInfo.ref.entityKind))) {
                    parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:invalidCotype", {
                        cause: `{primaryId:p} has @type {value} that can only be applied to elements of @type ${supplementalTypeInfo === null || supplementalTypeInfo === void 0 ? void 0 : supplementalTypeInfo.allowedCotypeKinds.join(" or ")} + '.'`,
                        action: `Remove @type '{value}' from element.`,
                        primaryId: elementId,
                        value: aggregateContext_1.AggregateContext.getTermOrUri(supplementalTypeId),
                    }));
                }
                else if (!(supplementalTypeInfo === null || supplementalTypeInfo === void 0 ? void 0 : supplementalTypeInfo.allowedCotypeVersions.includes(elementInfo.ref.dtdlVersion))) {
                    parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:invalidCotypeVersion", {
                        cause: `{primaryId:p} has @type {value} that can only be applied to elements defined in DTDL version ${supplementalTypeInfo === null || supplementalTypeInfo === void 0 ? void 0 : supplementalTypeInfo.allowedCotypeVersions.join(" or ")} + '.'`,
                        action: `Remove @type '{value}' from element.`,
                        primaryId: elementId,
                        value: aggregateContext_1.AggregateContext.getTermOrUri(supplementalTypeId),
                    }));
                }
                else {
                    elementInfo.ref.addType(supplementalTypeId, supplementalTypeInfo);
                }
            }
        }
        return elementInfo.ref;
        // this ends the method.
    }
    static tryParseTypeStringV2(typestring, elementId, parentId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    definedIn, propName, materialKinds, supplementalTypeIds, elementInfo, undefinedTypes, aggregateContext, parsingErrors) {
        switch (typestring) {
            case "Command":
            case "dtmi:dtdl:class:Command;2":
                elementInfo.ref = new commandInfoImpl_1.CommandInfoImpl(2, elementId, parentId, definedIn, "command");
                materialKinds.push("command");
                return true;
        }
        if (materialTypeNameCollection_1.MaterialTypeNameCollection.isMaterialType(typestring)) {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                cause: this._badTypeCauseFormat[2],
                action: this._badTypeActionFormat[2],
                primaryId: parentId,
                property: propName,
                secondaryId: elementId,
                value: typestring,
            }));
        }
        const supplementalTypeId = aggregateContext.createDtmi(typestring);
        if (supplementalTypeId === undefined) {
            if (undefinedTypes === undefined) {
                undefinedTypes = [];
            }
            undefinedTypes.push(typestring);
            return true;
        }
        const mapOfInDTMIToSupplementalTypeInfo = supplementalTypeInfoStatic_1.SupplementalTypeInfoStatic.retrieveSupplementalTypeCollection().supplementalTypes;
        if (supplementalTypeId !== undefined &&
            !mapOfInDTMIToSupplementalTypeInfo.has(supplementalTypeId.value)) {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                cause: this._badTypeCauseFormat[2],
                action: this._badTypeActionFormat[2],
                primaryId: parentId,
                property: propName,
                secondaryId: elementId,
                value: typestring,
            }));
            return false;
        }
        if (supplementalTypeId !== undefined) {
            const supplementalTypeInfo = mapOfInDTMIToSupplementalTypeInfo.get(supplementalTypeId.value);
            if (supplementalTypeInfo === null || supplementalTypeInfo === void 0 ? void 0 : supplementalTypeInfo.isAbstract) {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:abstractSupplementalType", {
                    cause: `{primaryId:p} has @type that specifies supplemental type {value} that is abstract.`,
                    action: `Remove @type {value} or replace with a concrete subtype of {value}.`,
                    primaryId: elementId,
                    property: "@type",
                    value: aggregateContext_1.AggregateContext.getTermOrUri(supplementalTypeId.value),
                }));
            }
            switch (supplementalTypeInfo === null || supplementalTypeInfo === void 0 ? void 0 : supplementalTypeInfo.extensionKind) {
                case extensionKind_1.ExtensionKind.UNIT:
                    parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                        cause: this._badTypeCauseFormat[2],
                        action: this._badTypeActionFormat[2],
                        primaryId: parentId,
                        property: propName,
                        secondaryId: elementId,
                        value: typestring,
                    }));
                    break;
                case extensionKind_1.ExtensionKind.UNITATTRIBUTE:
                    parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                        cause: this._badTypeCauseFormat[2],
                        action: this._badTypeActionFormat[2],
                        primaryId: parentId,
                        property: propName,
                        secondaryId: elementId,
                        value: typestring,
                    }));
                    break;
            }
            supplementalTypeIds.push(supplementalTypeId.value);
            return true;
        }
        return true;
    }
    static parsePropertiesV2(model, 
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    elementInfoAsAny, objectPropertyInfoList, elementPropertyConstraints, aggregateContext, parsingErrors, object, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    definedIn, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    allowIdReferenceSyntax) {
        const elementInfo = elementInfoAsAny;
        elementInfo.languageVersion = 2;
        let namePropertyMissing = true;
        for (const propKey in object) {
            let valueCount;
            const propValue = object[propKey];
            if (propValue === undefined || propValue === null) {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:propertyValueNull", {
                    cause: `{primaryId:p} property '{property}' has value null, which is not allowed in DTDL models.`,
                    action: `Change the value of '{property}' to a value that is legal for this property.`,
                    primaryId: elementInfo.id,
                    property: propKey,
                }));
                continue;
            }
            if (propKey[0] === "@") {
                continue;
            }
            switch (propKey) {
                case "commandType":
                case "dtmi:dtdl:property:commandType;2":
                    valueCount = parserCollection_1.ParserCollection.CommandTypeInfoParser.parseToken(model, objectPropertyInfoList, elementPropertyConstraints, elementInfo._commandTypeValueConstraints, aggregateContext, parsingErrors, propValue, elementInfo.id, definedIn !== null && definedIn !== void 0 ? definedIn : elementInfo.id, "commandType", undefined, undefined, true, true, allowIdReferenceSyntax, elementInfo._commandTypeAllowedVersionsV2);
                    if (valueCount > 1) {
                        parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:propertyCountAboveMax", {
                            cause: `{primaryId:p} property 'commandType' has value valueCount values, but the allowed maximum count is 1`,
                            action: `Remove one or more 'commandType' to the object until the maximum count is satisfied.`,
                            primaryId: elementInfo.id,
                            property: "commandType",
                        }));
                    }
                    continue;
                case "comment":
                case "dtmi:dtdl:property:comment;2":
                    elementInfo.comment = valueParser_1.ValueParser.parseSingularStringToken(elementInfo.id, "comment", propValue, 512, undefined, parsingErrors);
                    continue;
                case "description":
                case "dtmi:dtdl:property:description;2":
                    elementInfo.description = valueParser_1.ValueParser.parseLangStringToken(elementInfo.id, "description", propValue, "en", 512, undefined, parsingErrors);
                    continue;
                case "displayName":
                case "dtmi:dtdl:property:displayName;2":
                    elementInfo.displayName = valueParser_1.ValueParser.parseLangStringToken(elementInfo.id, "displayName", propValue, "en", 64, undefined, parsingErrors);
                    continue;
                case "name":
                case "dtmi:dtdl:property:name;2":
                    namePropertyMissing = false;
                    elementInfo.name = valueParser_1.ValueParser.parseSingularStringToken(elementInfo.id, "name", propValue, 64, elementInfo.namePropertyRegexPatternV2, parsingErrors);
                    continue;
                case "request":
                case "dtmi:dtdl:property:request;2":
                    valueCount = parserCollection_1.ParserCollection.CommandPayloadInfoParser.parseToken(model, objectPropertyInfoList, elementPropertyConstraints, elementInfo._requestValueConstraints, aggregateContext, parsingErrors, propValue, elementInfo.id, definedIn !== null && definedIn !== void 0 ? definedIn : elementInfo.id, "request", undefined, undefined, false, false, allowIdReferenceSyntax, elementInfo._requestAllowedVersionsV2);
                    if (valueCount > 1) {
                        parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:propertyCountAboveMax", {
                            cause: `{primaryId:p} property 'request' has value valueCount values, but the allowed maximum count is 1`,
                            action: `Remove one or more 'request' to the object until the maximum count is satisfied.`,
                            primaryId: elementInfo.id,
                            property: "request",
                        }));
                    }
                    continue;
                case "response":
                case "dtmi:dtdl:property:response;2":
                    valueCount = parserCollection_1.ParserCollection.CommandPayloadInfoParser.parseToken(model, objectPropertyInfoList, elementPropertyConstraints, elementInfo._responseValueConstraints, aggregateContext, parsingErrors, propValue, elementInfo.id, definedIn !== null && definedIn !== void 0 ? definedIn : elementInfo.id, "response", undefined, undefined, false, false, allowIdReferenceSyntax, elementInfo._responseAllowedVersionsV2);
                    if (valueCount > 1) {
                        parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:propertyCountAboveMax", {
                            cause: `{primaryId:p} property 'response' has value valueCount values, but the allowed maximum count is 1`,
                            action: `Remove one or more 'response' to the object until the maximum count is satisfied.`,
                            primaryId: elementInfo.id,
                            property: "response",
                        }));
                    }
                    continue;
            }
            if (CommandInfoParser.tryParseSupplementalProperty(model, elementInfo, objectPropertyInfoList, elementPropertyConstraints, aggregateContext, parsingErrors, propKey, propValue)) {
                continue;
            }
            if (elementInfo.undefinedTypes !== undefined && elementInfo.undefinedTypes.length > 0) {
                elementInfo.undefinedProperties[propKey] = propValue;
            }
            else {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:noTypeThatAllows", {
                    cause: `{primaryId:p} does not have a @type that allows property ${propKey}.`,
                    action: `Remove property ${propKey} or correct if misspelled.`,
                    primaryId: elementInfo.id,
                    property: propKey,
                }));
            }
        }
        if (namePropertyMissing) {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:missingRequiredProperty", {
                cause: "{primaryId:p} property name is required but missing.",
                action: "Add a name property to the object.",
                primaryId: elementInfo.id,
                property: "name",
            }));
        }
        for (const supplementalType of elementInfo.supplementalTypes) {
            supplementalType.checkForRequiredProperties(parsingErrors, elementInfo.id, elementInfo.supplementalProperties);
        }
    }
    static tryParseTypeStringV3(typestring, elementId, parentId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    definedIn, propName, materialKinds, supplementalTypeIds, elementInfo, undefinedTypes, aggregateContext, parsingErrors) {
        switch (typestring) {
            case "Command":
            case "dtmi:dtdl:class:Command;3":
                elementInfo.ref = new commandInfoImpl_1.CommandInfoImpl(3, elementId, parentId, definedIn, "command");
                materialKinds.push("command");
                return true;
        }
        if (materialTypeNameCollection_1.MaterialTypeNameCollection.isMaterialType(typestring)) {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                cause: this._badTypeCauseFormat[3],
                action: this._badTypeActionFormat[3],
                primaryId: parentId,
                property: propName,
                secondaryId: elementId,
                value: typestring,
            }));
        }
        const supplementalTypeId = aggregateContext.createDtmi(typestring);
        if (supplementalTypeId === undefined) {
            if (undefinedTypes === undefined) {
                undefinedTypes = [];
            }
            undefinedTypes.push(typestring);
            return true;
        }
        const mapOfInDTMIToSupplementalTypeInfo = supplementalTypeInfoStatic_1.SupplementalTypeInfoStatic.retrieveSupplementalTypeCollection().supplementalTypes;
        if (supplementalTypeId !== undefined &&
            !mapOfInDTMIToSupplementalTypeInfo.has(supplementalTypeId.value)) {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                cause: this._badTypeCauseFormat[3],
                action: this._badTypeActionFormat[3],
                primaryId: parentId,
                property: propName,
                secondaryId: elementId,
                value: typestring,
            }));
            return false;
        }
        if (supplementalTypeId !== undefined) {
            const supplementalTypeInfo = mapOfInDTMIToSupplementalTypeInfo.get(supplementalTypeId.value);
            if (supplementalTypeInfo === null || supplementalTypeInfo === void 0 ? void 0 : supplementalTypeInfo.isAbstract) {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:abstractSupplementalType", {
                    cause: `{primaryId:p} has @type that specifies supplemental type {value} that is abstract.`,
                    action: `Remove @type {value} or replace with a concrete subtype of {value}.`,
                    primaryId: elementId,
                    property: "@type",
                    value: aggregateContext_1.AggregateContext.getTermOrUri(supplementalTypeId.value),
                }));
            }
            switch (supplementalTypeInfo === null || supplementalTypeInfo === void 0 ? void 0 : supplementalTypeInfo.extensionKind) {
                case extensionKind_1.ExtensionKind.LATENTTYPE:
                    parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                        cause: this._badTypeCauseFormat[3],
                        action: this._badTypeActionFormat[3],
                        primaryId: parentId,
                        property: propName,
                        secondaryId: elementId,
                        value: typestring,
                    }));
                    break;
                case extensionKind_1.ExtensionKind.NAMEDLATENTTYPE:
                    parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                        cause: this._badTypeCauseFormat[3],
                        action: this._badTypeActionFormat[3],
                        primaryId: parentId,
                        property: propName,
                        secondaryId: elementId,
                        value: typestring,
                    }));
                    break;
                case extensionKind_1.ExtensionKind.UNIT:
                    parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                        cause: this._badTypeCauseFormat[3],
                        action: this._badTypeActionFormat[3],
                        primaryId: parentId,
                        property: propName,
                        secondaryId: elementId,
                        value: typestring,
                    }));
                    break;
                case extensionKind_1.ExtensionKind.UNITATTRIBUTE:
                    parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badType", {
                        cause: this._badTypeCauseFormat[3],
                        action: this._badTypeActionFormat[3],
                        primaryId: parentId,
                        property: propName,
                        secondaryId: elementId,
                        value: typestring,
                    }));
                    break;
            }
            supplementalTypeIds.push(supplementalTypeId.value);
            return true;
        }
        return true;
    }
    static parsePropertiesV3(model, 
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    elementInfoAsAny, objectPropertyInfoList, elementPropertyConstraints, aggregateContext, parsingErrors, object, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    definedIn, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    allowIdReferenceSyntax) {
        const elementInfo = elementInfoAsAny;
        elementInfo.languageVersion = 3;
        let namePropertyMissing = true;
        for (const propKey in object) {
            let valueCount;
            const propValue = object[propKey];
            if (propValue === undefined || propValue === null) {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:propertyValueNull", {
                    cause: `{primaryId:p} property '{property}' has value null, which is not allowed in DTDL models.`,
                    action: `Change the value of '{property}' to a value that is legal for this property.`,
                    primaryId: elementInfo.id,
                    property: propKey,
                }));
                continue;
            }
            if (propKey[0] === "@") {
                continue;
            }
            switch (propKey) {
                case "commandType":
                case "dtmi:dtdl:property:commandType;3":
                    valueCount = parserCollection_1.ParserCollection.CommandTypeInfoParser.parseToken(model, objectPropertyInfoList, elementPropertyConstraints, elementInfo._commandTypeValueConstraints, aggregateContext, parsingErrors, propValue, elementInfo.id, definedIn !== null && definedIn !== void 0 ? definedIn : elementInfo.id, "commandType", undefined, undefined, true, true, allowIdReferenceSyntax, elementInfo._commandTypeAllowedVersionsV3);
                    if (valueCount > 1) {
                        parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:propertyCountAboveMax", {
                            cause: `{primaryId:p} property 'commandType' has value valueCount values, but the allowed maximum count is 1`,
                            action: `Remove one or more 'commandType' to the object until the maximum count is satisfied.`,
                            primaryId: elementInfo.id,
                            property: "commandType",
                        }));
                    }
                    continue;
                case "comment":
                case "dtmi:dtdl:property:comment;3":
                    elementInfo.comment = valueParser_1.ValueParser.parseSingularStringToken(elementInfo.id, "comment", propValue, 512, undefined, parsingErrors);
                    continue;
                case "description":
                case "dtmi:dtdl:property:description;3":
                    elementInfo.description = valueParser_1.ValueParser.parseLangStringToken(elementInfo.id, "description", propValue, "en", 512, undefined, parsingErrors);
                    continue;
                case "displayName":
                case "dtmi:dtdl:property:displayName;3":
                    elementInfo.displayName = valueParser_1.ValueParser.parseLangStringToken(elementInfo.id, "displayName", propValue, "en", 64, undefined, parsingErrors);
                    continue;
                case "name":
                case "dtmi:dtdl:property:name;3":
                    namePropertyMissing = false;
                    elementInfo.name = valueParser_1.ValueParser.parseSingularStringToken(elementInfo.id, "name", propValue, 64, elementInfo.namePropertyRegexPatternV3, parsingErrors);
                    continue;
                case "request":
                case "dtmi:dtdl:property:request;3":
                    valueCount = parserCollection_1.ParserCollection.CommandRequestInfoParser.parseToken(model, objectPropertyInfoList, elementPropertyConstraints, elementInfo._requestValueConstraints, aggregateContext, parsingErrors, propValue, elementInfo.id, definedIn !== null && definedIn !== void 0 ? definedIn : elementInfo.id, "request", undefined, undefined, false, false, allowIdReferenceSyntax, elementInfo._requestAllowedVersionsV3);
                    if (valueCount > 1) {
                        parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:propertyCountAboveMax", {
                            cause: `{primaryId:p} property 'request' has value valueCount values, but the allowed maximum count is 1`,
                            action: `Remove one or more 'request' to the object until the maximum count is satisfied.`,
                            primaryId: elementInfo.id,
                            property: "request",
                        }));
                    }
                    continue;
                case "response":
                case "dtmi:dtdl:property:response;3":
                    valueCount = parserCollection_1.ParserCollection.CommandResponseInfoParser.parseToken(model, objectPropertyInfoList, elementPropertyConstraints, elementInfo._responseValueConstraints, aggregateContext, parsingErrors, propValue, elementInfo.id, definedIn !== null && definedIn !== void 0 ? definedIn : elementInfo.id, "response", undefined, undefined, false, false, allowIdReferenceSyntax, elementInfo._responseAllowedVersionsV3);
                    if (valueCount > 1) {
                        parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:propertyCountAboveMax", {
                            cause: `{primaryId:p} property 'response' has value valueCount values, but the allowed maximum count is 1`,
                            action: `Remove one or more 'response' to the object until the maximum count is satisfied.`,
                            primaryId: elementInfo.id,
                            property: "response",
                        }));
                    }
                    continue;
            }
            if (CommandInfoParser.tryParseSupplementalProperty(model, elementInfo, objectPropertyInfoList, elementPropertyConstraints, aggregateContext, parsingErrors, propKey, propValue)) {
                continue;
            }
            if (elementInfo.undefinedTypes !== undefined && elementInfo.undefinedTypes.length > 0) {
                elementInfo.undefinedProperties[propKey] = propValue;
            }
            else {
                parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:noTypeThatAllows", {
                    cause: `{primaryId:p} does not have a @type that allows property ${propKey}.`,
                    action: `Remove property ${propKey} or correct if misspelled.`,
                    primaryId: elementInfo.id,
                    property: propKey,
                }));
            }
        }
        if (namePropertyMissing) {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:missingRequiredProperty", {
                cause: "{primaryId:p} property name is required but missing.",
                action: "Add a name property to the object.",
                primaryId: elementInfo.id,
                property: "name",
            }));
        }
        for (const supplementalType of elementInfo.supplementalTypes) {
            supplementalType.checkForRequiredProperties(parsingErrors, elementInfo.id, elementInfo.supplementalProperties);
        }
    }
    static parseToken(model, objectPropertyInfoList, elementPropertyConstraints, valueConstraints, aggregateContext, parsingErrors, 
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    token, parentId, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    definedIn, propName, dtmiSeg, keyProp, idRequired, typeRequired, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    allowIdReferenceSyntax, allowedVersions) {
        let valueCount = 0;
        if (typeof token === "string") {
            if (parentId !== undefined) {
                this.parseIdString(objectPropertyInfoList, elementPropertyConstraints, valueConstraints, aggregateContext, parsingErrors, token.toString(), parentId, propName, keyProp, allowedVersions);
                valueCount++;
            }
        }
        else if (Array.isArray(token)) {
            for (const elementToken of token) {
                valueCount += this.parseToken(model, objectPropertyInfoList, elementPropertyConstraints, valueConstraints, aggregateContext, parsingErrors, elementToken, parentId, definedIn, propName, dtmiSeg, keyProp, idRequired, typeRequired, allowIdReferenceSyntax, allowedVersions);
            }
        }
        else if (typeof token === "object") {
            this.parseObject(model, objectPropertyInfoList, elementPropertyConstraints, valueConstraints, aggregateContext, parsingErrors, token, parentId, definedIn, propName, dtmiSeg, keyProp, idRequired, typeRequired, allowIdReferenceSyntax, allowedVersions);
            valueCount++;
        }
        else {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badDtmiOrTerm", {
                cause: `{primaryId:p} property '{property}' has value '{value}' that is not a DTMI or a DTDL term.`,
                action: `Replace the value of property '{property}, with a valid DTMI or a term defined by DTDL -- see https://github.com/Azure/opendigitaltwins-dtdl/tree/master/DTDL.`,
                primaryId: parentId,
                property: propName,
                value: token.toString(),
            }));
        }
        return valueCount;
    }
    static parseIdString(objectPropertyInfoList, elementPropertyConstraints, valueConstraints, aggregateContext, parsingErrors, idString, parentId, propName, keyProp, allowedVersions) {
        const elementId = aggregateContext.createDtmi(idString);
        if (elementId !== undefined) {
            const objectPropertyInfo = {
                elementId: parentId,
                propertyName: propName !== null && propName !== void 0 ? propName : "",
                referencedElementId: elementId.value,
                keyProperty: keyProp,
                expectedKinds: this._concreteKinds[aggregateContext.dtdlVersion],
                allowedVersions: allowedVersions,
                badTypeCauseFormat: this._badTypeCauseFormat[aggregateContext.dtdlVersion],
                badTypeActionFormat: this._badTypeActionFormat[aggregateContext.dtdlVersion],
            };
            objectPropertyInfoList.push(objectPropertyInfo);
            if (valueConstraints !== null && elementPropertyConstraints !== null) {
                for (const vc of valueConstraints) {
                    const elementPropertyConstraint = {
                        parentId: parentId,
                        propertyName: propName !== null && propName !== void 0 ? propName : "",
                        elementId: elementId.value,
                        valueConstraint: vc,
                    };
                    elementPropertyConstraints.push(elementPropertyConstraint);
                }
            }
        }
        else {
            parsingErrors.push((0, parsingErrorImpl_1.createParsingError)("dtmi:dtdl:parsingError:badDtmiOrTerm", {
                cause: `{primaryId:p} property '{property}' has value '{value}' that is not a DTMI or a DTDL term.`,
                action: `Replace the value of property '{property}, with a valid DTMI or a term defined by DTDL -- see https://github.com/Azure/opendigitaltwins-dtdl/tree/master/DTDL.`,
                primaryId: parentId,
                property: propName,
                value: idString,
            }));
        }
    }
}
exports.CommandInfoParser = CommandInfoParser;
//# sourceMappingURL=commandInfoParser.js.map