{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, KeyCodes, divProperties, doesElementContainFocus, getDocument, getNativeProps, on, getWindow, elementContains } from '../../Utilities';\n/**\n * This adds accessibility to Dialog and Panel controls\n */\nvar Popup = /** @class */function (_super) {\n  __extends(Popup, _super);\n  function Popup(props) {\n    var _this = _super.call(this, props) || this;\n    _this._root = React.createRef();\n    _this._disposables = [];\n    _this._onKeyDown = function (ev) {\n      switch (ev.which) {\n        case KeyCodes.escape:\n          if (_this.props.onDismiss) {\n            _this.props.onDismiss(ev);\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n          break;\n      }\n    };\n    _this._onFocus = function () {\n      _this._containsFocus = true;\n    };\n    _this._onBlur = function (ev) {\n      /** The popup should update this._containsFocus when:\n       * relatedTarget exists AND\n       * the relatedTarget is not contained within the popup.\n       * If the relatedTarget is within the popup, that means the popup still has focus\n       * and focused moved from one element to another within the popup.\n       * If relatedTarget is undefined or null that usually means that a\n       * keyboard event occured and focus didn't change\n       */\n      if (_this._root.current && ev.relatedTarget && !elementContains(_this._root.current, ev.relatedTarget)) {\n        _this._containsFocus = false;\n      }\n    };\n    _this._async = new Async(_this);\n    _this.state = {\n      needsVerticalScrollBar: false\n    };\n    return _this;\n  }\n  Popup.prototype.UNSAFE_componentWillMount = function () {\n    this._originalFocusedElement = getDocument().activeElement;\n  };\n  Popup.prototype.componentDidMount = function () {\n    if (this._root.current) {\n      this._disposables.push(on(this._root.current, 'focus', this._onFocus, true), on(this._root.current, 'blur', this._onBlur, true));\n      var currentWindow = getWindow(this._root.current);\n      if (currentWindow) {\n        this._disposables.push(on(currentWindow, 'keydown', this._onKeyDown));\n      }\n      if (doesElementContainFocus(this._root.current)) {\n        this._containsFocus = true;\n      }\n    }\n    this._updateScrollBarAsync();\n  };\n  Popup.prototype.componentDidUpdate = function () {\n    this._updateScrollBarAsync();\n    this._async.dispose();\n  };\n  Popup.prototype.componentWillUnmount = function () {\n    var _a;\n    this._disposables.forEach(function (dispose) {\n      return dispose();\n    });\n    // eslint-disable-next-line deprecation/deprecation\n    if (this.props.shouldRestoreFocus) {\n      var _b = this.props.onRestoreFocus,\n        onRestoreFocus = _b === void 0 ? defaultFocusRestorer : _b;\n      onRestoreFocus({\n        originalElement: this._originalFocusedElement,\n        containsFocus: this._containsFocus,\n        documentContainsFocus: ((_a = getDocument()) === null || _a === void 0 ? void 0 : _a.hasFocus()) || false\n      });\n    }\n    // De-reference DOM Node to avoid retainment via transpiled closure of _onKeyDown\n    delete this._originalFocusedElement;\n  };\n  Popup.prototype.render = function () {\n    var _a = this.props,\n      role = _a.role,\n      className = _a.className,\n      ariaLabel = _a.ariaLabel,\n      ariaLabelledBy = _a.ariaLabelledBy,\n      ariaDescribedBy = _a.ariaDescribedBy,\n      style = _a.style;\n    return React.createElement(\"div\", __assign({\n      ref: this._root\n    }, getNativeProps(this.props, divProperties), {\n      className: className,\n      role: role,\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabelledBy,\n      \"aria-describedby\": ariaDescribedBy,\n      onKeyDown: this._onKeyDown,\n      style: __assign({\n        overflowY: this.state.needsVerticalScrollBar ? 'scroll' : undefined,\n        outline: 'none'\n      }, style)\n    }), this.props.children);\n  };\n  Popup.prototype._updateScrollBarAsync = function () {\n    var _this = this;\n    this._async.requestAnimationFrame(function () {\n      _this._getScrollBar();\n    });\n  };\n  Popup.prototype._getScrollBar = function () {\n    // If overflowY is overriden, don't waste time calculating whether the scrollbar is necessary.\n    if (this.props.style && this.props.style.overflowY) {\n      return;\n    }\n    var needsVerticalScrollBar = false;\n    if (this._root && this._root.current && this._root.current.firstElementChild) {\n      // ClientHeight returns the client height of an element rounded to an\n      // integer. On some browsers at different zoom levels this rounding\n      // can generate different results for the root container and child even\n      // though they are the same height. This causes us to show a scroll bar\n      // when not needed. Ideally we would use BoundingClientRect().height\n      // instead however seems that the API is 90% slower than using ClientHeight.\n      // Therefore instead we will calculate the difference between heights and\n      // allow for a 1px difference to still be considered ok and not show the\n      // scroll bar.\n      var rootHeight = this._root.current.clientHeight;\n      var firstChildHeight = this._root.current.firstElementChild.clientHeight;\n      if (rootHeight > 0 && firstChildHeight > rootHeight) {\n        needsVerticalScrollBar = firstChildHeight - rootHeight > 1;\n      }\n    }\n    if (this.state.needsVerticalScrollBar !== needsVerticalScrollBar) {\n      this.setState({\n        needsVerticalScrollBar: needsVerticalScrollBar\n      });\n    }\n  };\n  Popup.defaultProps = {\n    shouldRestoreFocus: true\n  };\n  return Popup;\n}(React.Component);\nexport { Popup };\nfunction defaultFocusRestorer(options) {\n  var originalElement = options.originalElement,\n    containsFocus = options.containsFocus;\n  if (originalElement && containsFocus && originalElement !== window) {\n    // Make sure that the focus method actually exists\n    // In some cases the object might exist but not be a real element.\n    // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n    if (originalElement.focus) {\n      originalElement.focus();\n    }\n  }\n}","map":{"version":3,"sources":["components/Popup/Popup.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  KeyCodes,\n  divProperties,\n  doesElementContainFocus,\n  getDocument,\n  getNativeProps,\n  on,\n  getWindow,\n  elementContains,\n} from '../../Utilities';\nimport { IPopupProps } from './Popup.types';\n\nexport interface IPopupState {\n  needsVerticalScrollBar?: boolean;\n}\n\n/**\n * This adds accessibility to Dialog and Panel controls\n */\nexport class Popup extends React.Component<IPopupProps, IPopupState> {\n  public static defaultProps: IPopupProps = {\n    shouldRestoreFocus: true,\n  };\n\n  public _root = React.createRef<HTMLDivElement>();\n  private _disposables: (() => void)[] = [];\n  private _originalFocusedElement: HTMLElement;\n  private _containsFocus: boolean;\n  private _async: Async;\n\n  public constructor(props: IPopupProps) {\n    super(props);\n    this._async = new Async(this);\n    this.state = { needsVerticalScrollBar: false };\n  }\n\n  public UNSAFE_componentWillMount(): void {\n    this._originalFocusedElement = getDocument()!.activeElement as HTMLElement;\n  }\n\n  public componentDidMount(): void {\n    if (this._root.current) {\n      this._disposables.push(\n        on(this._root.current, 'focus', this._onFocus, true),\n        on(this._root.current, 'blur', this._onBlur, true),\n      );\n      const currentWindow = getWindow(this._root.current);\n      if (currentWindow) {\n        this._disposables.push(on(currentWindow, 'keydown', this._onKeyDown as any));\n      }\n      if (doesElementContainFocus(this._root.current)) {\n        this._containsFocus = true;\n      }\n    }\n\n    this._updateScrollBarAsync();\n  }\n\n  public componentDidUpdate() {\n    this._updateScrollBarAsync();\n    this._async.dispose();\n  }\n\n  public componentWillUnmount(): void {\n    this._disposables.forEach((dispose: () => void) => dispose());\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (this.props.shouldRestoreFocus) {\n      const { onRestoreFocus = defaultFocusRestorer } = this.props;\n      onRestoreFocus({\n        originalElement: this._originalFocusedElement,\n        containsFocus: this._containsFocus,\n        documentContainsFocus: getDocument()?.hasFocus() || false,\n      });\n    }\n    // De-reference DOM Node to avoid retainment via transpiled closure of _onKeyDown\n    delete this._originalFocusedElement;\n  }\n\n  public render(): JSX.Element {\n    const { role, className, ariaLabel, ariaLabelledBy, ariaDescribedBy, style } = this.props;\n\n    return (\n      <div\n        ref={this._root}\n        {...getNativeProps(this.props, divProperties)}\n        className={className}\n        role={role}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        aria-describedby={ariaDescribedBy}\n        onKeyDown={this._onKeyDown}\n        style={{ overflowY: this.state.needsVerticalScrollBar ? 'scroll' : undefined, outline: 'none', ...style }}\n      >\n        {this.props.children}\n      </div>\n    );\n  }\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    switch (ev.which) {\n      case KeyCodes.escape:\n        if (this.props.onDismiss) {\n          this.props.onDismiss(ev);\n\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n\n        break;\n    }\n  };\n\n  private _updateScrollBarAsync(): void {\n    this._async.requestAnimationFrame(() => {\n      this._getScrollBar();\n    });\n  }\n\n  private _getScrollBar(): void {\n    // If overflowY is overriden, don't waste time calculating whether the scrollbar is necessary.\n    if (this.props.style && this.props.style.overflowY) {\n      return;\n    }\n\n    let needsVerticalScrollBar = false;\n    if (this._root && this._root.current && this._root.current.firstElementChild) {\n      // ClientHeight returns the client height of an element rounded to an\n      // integer. On some browsers at different zoom levels this rounding\n      // can generate different results for the root container and child even\n      // though they are the same height. This causes us to show a scroll bar\n      // when not needed. Ideally we would use BoundingClientRect().height\n      // instead however seems that the API is 90% slower than using ClientHeight.\n      // Therefore instead we will calculate the difference between heights and\n      // allow for a 1px difference to still be considered ok and not show the\n      // scroll bar.\n      const rootHeight = this._root.current.clientHeight;\n      const firstChildHeight = this._root.current.firstElementChild.clientHeight;\n      if (rootHeight > 0 && firstChildHeight > rootHeight) {\n        needsVerticalScrollBar = firstChildHeight - rootHeight > 1;\n      }\n    }\n    if (this.state.needsVerticalScrollBar !== needsVerticalScrollBar) {\n      this.setState({\n        needsVerticalScrollBar: needsVerticalScrollBar,\n      });\n    }\n  }\n\n  private _onFocus = (): void => {\n    this._containsFocus = true;\n  };\n\n  private _onBlur = (ev: FocusEvent): void => {\n    /** The popup should update this._containsFocus when:\n     * relatedTarget exists AND\n     * the relatedTarget is not contained within the popup.\n     * If the relatedTarget is within the popup, that means the popup still has focus\n     * and focused moved from one element to another within the popup.\n     * If relatedTarget is undefined or null that usually means that a\n     * keyboard event occured and focus didn't change\n     */\n    if (\n      this._root.current &&\n      ev.relatedTarget &&\n      !elementContains(this._root.current, ev.relatedTarget as HTMLElement)\n    ) {\n      this._containsFocus = false;\n    }\n  };\n}\n\nfunction defaultFocusRestorer(options: {\n  originalElement?: HTMLElement | Window;\n  containsFocus: boolean;\n  documentContainsFocus: boolean;\n}) {\n  const { originalElement, containsFocus } = options;\n\n  if (originalElement && containsFocus && originalElement !== window) {\n    // Make sure that the focus method actually exists\n    // In some cases the object might exist but not be a real element.\n    // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n    if (originalElement.focus) {\n      originalElement.focus();\n    }\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}