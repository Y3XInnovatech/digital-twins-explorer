{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { KeyCodes, classNamesFunction, getId, getNativeProps, divProperties, css, initializeComponentRef } from '../../Utilities';\nimport { Calendar, DayOfWeek } from '../../Calendar';\nimport { FirstWeekOfYear } from '../../utilities/dateValues/DateValues';\nimport { Callout } from '../../Callout';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { TextField } from '../../TextField';\nimport { compareDates, compareDatePart } from '../../utilities/dateMath/DateMath';\nimport { FocusTrapZone } from '../../FocusTrapZone';\nvar getClassNames = classNamesFunction();\nvar DEFAULT_STRINGS = {\n  months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n  shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n  days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n  shortDays: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],\n  goToToday: 'Go to today',\n  prevMonthAriaLabel: 'Go to previous month',\n  nextMonthAriaLabel: 'Go to next month',\n  prevYearAriaLabel: 'Go to previous year',\n  nextYearAriaLabel: 'Go to next year',\n  prevYearRangeAriaLabel: 'Previous year range',\n  nextYearRangeAriaLabel: 'Next year range',\n  closeButtonAriaLabel: 'Close date picker',\n  weekNumberFormatString: 'Week number {0}'\n};\nvar DatePickerBase = /** @class */function (_super) {\n  __extends(DatePickerBase, _super);\n  function DatePickerBase(props) {\n    var _this = _super.call(this, props) || this;\n    _this._calendar = React.createRef();\n    _this._datePickerDiv = React.createRef();\n    _this._textField = React.createRef();\n    _this._onSelectDate = function (date) {\n      var _a = _this.props,\n        formatDate = _a.formatDate,\n        onSelectDate = _a.onSelectDate;\n      if (_this.props.calendarProps && _this.props.calendarProps.onSelectDate) {\n        _this.props.calendarProps.onSelectDate(date);\n      }\n      _this.setState({\n        selectedDate: date,\n        formattedDate: formatDate && date ? formatDate(date) : ''\n      });\n      if (onSelectDate) {\n        onSelectDate(date);\n      }\n      _this._calendarDismissed();\n    };\n    _this._onCalloutPositioned = function () {\n      var shouldFocus = true;\n      // If the user has specified that the callout shouldn't use initial focus, then respect\n      // that and don't attempt to set focus. That will default to true within the callout\n      // so we need to check if it's undefined here.\n      if (_this.props.calloutProps && _this.props.calloutProps.setInitialFocus !== undefined) {\n        shouldFocus = _this.props.calloutProps.setInitialFocus;\n      }\n      if (_this._calendar.current && shouldFocus) {\n        _this._calendar.current.focus();\n      }\n    };\n    _this._onTextFieldFocus = function (ev) {\n      if (_this.props.disableAutoFocus) {\n        return;\n      }\n      if (!_this.props.allowTextInput) {\n        if (!_this._preventFocusOpeningPicker) {\n          _this._showDatePickerPopup();\n        } else {\n          _this._preventFocusOpeningPicker = false;\n        }\n      }\n    };\n    _this._onTextFieldBlur = function (ev) {\n      _this._validateTextInput();\n    };\n    _this._onTextFieldChanged = function (ev, newValue) {\n      var _a = _this.props,\n        allowTextInput = _a.allowTextInput,\n        textField = _a.textField;\n      if (allowTextInput) {\n        if (_this.state.isDatePickerShown) {\n          _this._dismissDatePickerPopup();\n        }\n        var _b = _this.props,\n          isRequired = _b.isRequired,\n          strings = _b.strings;\n        _this.setState({\n          errorMessage: isRequired && !newValue ? strings.isRequiredErrorMessage || ' ' : undefined,\n          formattedDate: newValue\n        });\n      }\n      if (textField && textField.onChange) {\n        textField.onChange(ev, newValue);\n      }\n    };\n    _this._onTextFieldKeyDown = function (ev) {\n      switch (ev.which) {\n        case KeyCodes.enter:\n          ev.preventDefault();\n          ev.stopPropagation();\n          if (!_this.state.isDatePickerShown) {\n            _this._validateTextInput();\n            _this._showDatePickerPopup();\n          } else {\n            // When DatePicker allows input date string directly,\n            // it is expected to hit another enter to close the popup\n            if (_this.props.allowTextInput) {\n              _this._dismissDatePickerPopup();\n            }\n          }\n          break;\n        case KeyCodes.escape:\n          _this._handleEscKey(ev);\n          break;\n        default:\n          break;\n      }\n    };\n    _this._onTextFieldClick = function (ev) {\n      if (!_this.props.disableAutoFocus && !_this.state.isDatePickerShown && !_this.props.disabled) {\n        _this._showDatePickerPopup();\n        return;\n      }\n      if (_this.props.allowTextInput) {\n        _this._dismissDatePickerPopup();\n      }\n    };\n    _this._onIconClick = function (ev) {\n      ev.stopPropagation();\n      if (!_this.state.isDatePickerShown && !_this.props.disabled) {\n        _this._showDatePickerPopup();\n      } else if (_this.props.allowTextInput) {\n        _this._dismissDatePickerPopup();\n      }\n    };\n    _this._dismissDatePickerPopup = function () {\n      if (_this.state.isDatePickerShown) {\n        _this.setState({\n          isDatePickerShown: false\n        }, function () {\n          // setState is async, so we must call validate in a callback\n          _this._validateTextInput();\n        });\n      }\n    };\n    /**\n     * Callback for closing the calendar callout\n     */\n    _this._calendarDismissed = function () {\n      _this._preventFocusOpeningPicker = true;\n      _this._dismissDatePickerPopup();\n      // don't need to focus the text box, if necessary the focusTrapZone will do it\n    };\n    _this._handleEscKey = function (ev) {\n      if (_this.state.isDatePickerShown) {\n        ev.stopPropagation();\n      }\n      _this._calendarDismissed();\n    };\n    _this._validateTextInput = function () {\n      var _a = _this.props,\n        isRequired = _a.isRequired,\n        allowTextInput = _a.allowTextInput,\n        strings = _a.strings,\n        parseDateFromString = _a.parseDateFromString,\n        onSelectDate = _a.onSelectDate,\n        formatDate = _a.formatDate,\n        minDate = _a.minDate,\n        maxDate = _a.maxDate;\n      var inputValue = _this.state.formattedDate;\n      // Do validation only if DatePicker's popup is dismissed\n      if (_this.state.isDatePickerShown) {\n        return;\n      }\n      if (allowTextInput) {\n        var date = null;\n        if (inputValue) {\n          // Don't parse if the selected date has the same formatted string as what we're about to parse.\n          // The formatted string might be ambiguous (ex: \"1/2/3\" or \"New Year Eve\") and the parser might\n          // not be able to come up with the exact same date.\n          if (_this.state.selectedDate && !_this.state.errorMessage && formatDate && formatDate(_this.state.selectedDate) === inputValue) {\n            return;\n          }\n          date = parseDateFromString(inputValue);\n          // Check if date is null, or date is Invalid Date\n          if (!date || isNaN(date.getTime())) {\n            // Reset invalid input field, if formatting is available\n            if (formatDate) {\n              date = _this.state.selectedDate;\n              _this.setState({\n                formattedDate: formatDate(date).toString()\n              });\n            }\n            _this.setState({\n              errorMessage: strings.invalidInputErrorMessage || ' '\n            });\n          } else {\n            // Check against optional date boundaries\n            if (_this._isDateOutOfBounds(date, minDate, maxDate)) {\n              _this.setState({\n                errorMessage: strings.isOutOfBoundsErrorMessage || ' '\n              });\n            } else {\n              _this.setState({\n                selectedDate: date,\n                errorMessage: ''\n              });\n              // When formatting is available:\n              // If formatted date is valid, but is different from input, update with formatted date.\n              // This occurs when an invalid date is entered twice.\n              if (formatDate && formatDate(date) !== inputValue) {\n                _this.setState({\n                  formattedDate: formatDate(date).toString()\n                });\n              }\n            }\n          }\n        } else {\n          // Only show error for empty inputValue if it is a required field\n          _this.setState({\n            errorMessage: isRequired ? strings.isRequiredErrorMessage || ' ' : ''\n          });\n        }\n        // Execute onSelectDate callback\n        if (onSelectDate) {\n          // If no input date string or input date string is invalid\n          // date variable will be null, callback should expect null value for this case\n          onSelectDate(date);\n        }\n      } else if (isRequired && !inputValue) {\n        // Check when DatePicker is a required field but has NO input value\n        _this.setState({\n          errorMessage: strings.isRequiredErrorMessage || ' '\n        });\n      } else {\n        // Cleanup the error message\n        _this.setState({\n          errorMessage: ''\n        });\n      }\n    };\n    initializeComponentRef(_this);\n    _this.state = _this._getDefaultState();\n    _this._id = props.id || getId('DatePicker');\n    _this._preventFocusOpeningPicker = false;\n    return _this;\n  }\n  DatePickerBase.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    var formatDate = nextProps.formatDate,\n      value = nextProps.value;\n    if (compareDates(this.props.minDate, nextProps.minDate) && compareDates(this.props.maxDate, nextProps.maxDate) && this.props.isRequired === nextProps.isRequired && compareDates(this.state.selectedDate, value) && this.props.formatDate === formatDate) {\n      // if the props we care about haven't changed, don't run validation or updates\n      return;\n    }\n    this._setErrorMessage(true, nextProps);\n    this._id = nextProps.id || this._id;\n    // Issue# 1274: Check if the date value changed from old value, i.e., if indeed a new date is being\n    // passed in or if the formatting function was modified. We only update the selected date if either of these\n    // had a legit change. Note tha the bug will still repro when only the formatDate was passed in props and this\n    // is the result of the onSelectDate callback, but this should be a rare scenario.\n    var oldValue = this.state.selectedDate;\n    if (!compareDates(oldValue, value) || this.props.formatDate !== formatDate) {\n      this.setState({\n        selectedDate: value || undefined,\n        formattedDate: formatDate && value ? formatDate(value) : ''\n      });\n    }\n  };\n  DatePickerBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    if (prevState.isDatePickerShown && !this.state.isDatePickerShown) {\n      // If DatePicker's menu (Calendar) is closed, run onAfterMenuDismiss\n      if (this.props.onAfterMenuDismiss) {\n        this.props.onAfterMenuDismiss();\n      }\n    }\n  };\n  DatePickerBase.prototype.render = function () {\n    var _a = this.props,\n      firstDayOfWeek = _a.firstDayOfWeek,\n      strings = _a.strings,\n      label = _a.label,\n      theme = _a.theme,\n      className = _a.className,\n      styles = _a.styles,\n      initialPickerDate = _a.initialPickerDate,\n      isRequired = _a.isRequired,\n      disabled = _a.disabled,\n      ariaLabel = _a.ariaLabel,\n      pickerAriaLabel = _a.pickerAriaLabel,\n      placeholder = _a.placeholder,\n      allowTextInput = _a.allowTextInput,\n      borderless = _a.borderless,\n      minDate = _a.minDate,\n      maxDate = _a.maxDate,\n      showCloseButton = _a.showCloseButton,\n      calendarProps = _a.calendarProps,\n      calloutProps = _a.calloutProps,\n      textFieldProps = _a.textField,\n      underlined = _a.underlined,\n      allFocusable = _a.allFocusable,\n      _b = _a.calendarAs,\n      CalendarType = _b === void 0 ? Calendar : _b,\n      tabIndex = _a.tabIndex;\n    var _c = this.state,\n      isDatePickerShown = _c.isDatePickerShown,\n      formattedDate = _c.formattedDate,\n      selectedDate = _c.selectedDate;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      disabled: disabled,\n      label: !!label,\n      isDatePickerShown: isDatePickerShown\n    });\n    var calloutId = getId('DatePicker-Callout');\n    var nativeProps = getNativeProps(this.props, divProperties, ['value']);\n    var iconProps = textFieldProps && textFieldProps.iconProps;\n    return React.createElement(\"div\", __assign({}, nativeProps, {\n      className: classNames.root\n    }), React.createElement(\"div\", {\n      ref: this._datePickerDiv,\n      \"aria-haspopup\": \"true\",\n      \"aria-owns\": isDatePickerShown ? calloutId : undefined,\n      className: classNames.wrapper\n    }, React.createElement(TextField, __assign({\n      role: \"combobox\",\n      label: label,\n      \"aria-expanded\": isDatePickerShown,\n      ariaLabel: ariaLabel,\n      \"aria-controls\": isDatePickerShown ? calloutId : undefined,\n      required: isRequired,\n      disabled: disabled,\n      errorMessage: this._getErrorMessage(),\n      placeholder: placeholder,\n      borderless: borderless,\n      value: formattedDate,\n      componentRef: this._textField,\n      underlined: underlined,\n      tabIndex: tabIndex,\n      readOnly: !allowTextInput\n    }, textFieldProps, {\n      id: this._id + '-label',\n      className: css(classNames.textField, textFieldProps && textFieldProps.className),\n      iconProps: __assign(__assign({\n        iconName: 'Calendar'\n      }, iconProps), {\n        className: css(classNames.icon, iconProps && iconProps.className),\n        onClick: this._onIconClick\n      }),\n      onKeyDown: this._onTextFieldKeyDown,\n      onFocus: this._onTextFieldFocus,\n      onBlur: this._onTextFieldBlur,\n      onClick: this._onTextFieldClick,\n      onChange: this._onTextFieldChanged\n    }))), isDatePickerShown && React.createElement(Callout, __assign({\n      id: calloutId,\n      role: \"dialog\",\n      ariaLabel: pickerAriaLabel,\n      isBeakVisible: false,\n      gapSpace: 0,\n      doNotLayer: false,\n      target: this._datePickerDiv.current,\n      directionalHint: DirectionalHint.bottomLeftEdge\n    }, calloutProps, {\n      className: css(classNames.callout, calloutProps && calloutProps.className),\n      onDismiss: this._calendarDismissed,\n      onPositioned: this._onCalloutPositioned\n    }), React.createElement(FocusTrapZone, {\n      isClickableOutsideFocusTrap: true,\n      disableFirstFocus: this.props.disableAutoFocus,\n      forceFocusInsideTrap: false\n    }, React.createElement(CalendarType, __assign({}, calendarProps, {\n      onSelectDate: this._onSelectDate,\n      onDismiss: this._calendarDismissed,\n      isMonthPickerVisible: this.props.isMonthPickerVisible,\n      showMonthPickerAsOverlay: this.props.showMonthPickerAsOverlay,\n      today: this.props.today,\n      value: selectedDate || initialPickerDate,\n      firstDayOfWeek: firstDayOfWeek,\n      strings: strings,\n      highlightCurrentMonth: this.props.highlightCurrentMonth,\n      highlightSelectedMonth: this.props.highlightSelectedMonth,\n      showWeekNumbers: this.props.showWeekNumbers,\n      firstWeekOfYear: this.props.firstWeekOfYear,\n      showGoToToday: this.props.showGoToToday,\n      dateTimeFormatter: this.props.dateTimeFormatter,\n      minDate: minDate,\n      maxDate: maxDate,\n      componentRef: this._calendar,\n      showCloseButton: showCloseButton,\n      allFocusable: allFocusable\n    })))));\n  };\n  DatePickerBase.prototype.focus = function () {\n    if (this._textField.current) {\n      this._textField.current.focus();\n    }\n  };\n  DatePickerBase.prototype.reset = function () {\n    this.setState(this._getDefaultState());\n  };\n  DatePickerBase.prototype._setErrorMessage = function (setState, nextProps) {\n    var _a = nextProps || this.props,\n      isRequired = _a.isRequired,\n      strings = _a.strings,\n      value = _a.value,\n      minDate = _a.minDate,\n      maxDate = _a.maxDate,\n      initialPickerDate = _a.initialPickerDate;\n    var errorMessage = !initialPickerDate && isRequired && !value ? strings.isRequiredErrorMessage || ' ' : undefined;\n    if (!errorMessage && value) {\n      errorMessage = this._isDateOutOfBounds(value, minDate, maxDate) ? strings.isOutOfBoundsErrorMessage || ' ' : undefined;\n    }\n    if (setState) {\n      this.setState({\n        errorMessage: errorMessage\n      });\n    }\n    return errorMessage;\n  };\n  DatePickerBase.prototype._showDatePickerPopup = function () {\n    if (!this.state.isDatePickerShown) {\n      this._preventFocusOpeningPicker = true;\n      this.setState({\n        isDatePickerShown: true\n      });\n    }\n  };\n  DatePickerBase.prototype._getDefaultState = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n    return {\n      selectedDate: props.value || undefined,\n      formattedDate: props.formatDate && props.value ? props.formatDate(props.value) : '',\n      isDatePickerShown: false,\n      errorMessage: this._setErrorMessage(false)\n    };\n  };\n  DatePickerBase.prototype._isDateOutOfBounds = function (date, minDate, maxDate) {\n    return !!minDate && compareDatePart(minDate, date) > 0 || !!maxDate && compareDatePart(maxDate, date) < 0;\n  };\n  DatePickerBase.prototype._getErrorMessage = function () {\n    if (this.state.isDatePickerShown) {\n      return undefined;\n    }\n    return this.state.errorMessage;\n  };\n  DatePickerBase.defaultProps = {\n    allowTextInput: false,\n    formatDate: function (date) {\n      if (date) {\n        return date.toDateString();\n      }\n      return '';\n    },\n    parseDateFromString: function (dateStr) {\n      var date = Date.parse(dateStr);\n      if (date) {\n        return new Date(date);\n      }\n      return null;\n    },\n    firstDayOfWeek: DayOfWeek.Sunday,\n    initialPickerDate: new Date(),\n    isRequired: false,\n    isMonthPickerVisible: true,\n    showMonthPickerAsOverlay: false,\n    strings: DEFAULT_STRINGS,\n    highlightCurrentMonth: false,\n    highlightSelectedMonth: false,\n    borderless: false,\n    pickerAriaLabel: 'Calendar',\n    showWeekNumbers: false,\n    firstWeekOfYear: FirstWeekOfYear.FirstDay,\n    showGoToToday: true,\n    dateTimeFormatter: undefined,\n    showCloseButton: false,\n    underlined: false,\n    allFocusable: false\n  };\n  return DatePickerBase;\n}(React.Component);\nexport { DatePickerBase };","map":{"version":3,"sources":["components/DatePicker/DatePicker.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  IDatePicker,\n  IDatePickerProps,\n  IDatePickerStrings,\n  IDatePickerStyleProps,\n  IDatePickerStyles,\n} from './DatePicker.types';\nimport {\n  KeyCodes,\n  classNamesFunction,\n  getId,\n  getNativeProps,\n  divProperties,\n  css,\n  initializeComponentRef,\n} from '../../Utilities';\nimport { Calendar, ICalendar, DayOfWeek } from '../../Calendar';\nimport { FirstWeekOfYear } from '../../utilities/dateValues/DateValues';\nimport { Callout } from '../../Callout';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { TextField, ITextField } from '../../TextField';\nimport { compareDates, compareDatePart } from '../../utilities/dateMath/DateMath';\nimport { FocusTrapZone } from '../../FocusTrapZone';\n\nconst getClassNames = classNamesFunction<IDatePickerStyleProps, IDatePickerStyles>();\n\nexport interface IDatePickerState {\n  selectedDate?: Date;\n  formattedDate?: string;\n  isDatePickerShown?: boolean;\n  errorMessage?: string;\n}\n\nconst DEFAULT_STRINGS: IDatePickerStrings = {\n  months: [\n    'January',\n    'February',\n    'March',\n    'April',\n    'May',\n    'June',\n    'July',\n    'August',\n    'September',\n    'October',\n    'November',\n    'December',\n  ],\n  shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n  days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n  shortDays: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],\n  goToToday: 'Go to today',\n  prevMonthAriaLabel: 'Go to previous month',\n  nextMonthAriaLabel: 'Go to next month',\n  prevYearAriaLabel: 'Go to previous year',\n  nextYearAriaLabel: 'Go to next year',\n  prevYearRangeAriaLabel: 'Previous year range',\n  nextYearRangeAriaLabel: 'Next year range',\n  closeButtonAriaLabel: 'Close date picker',\n  weekNumberFormatString: 'Week number {0}',\n};\n\nexport class DatePickerBase extends React.Component<IDatePickerProps, IDatePickerState> implements IDatePicker {\n  public static defaultProps: IDatePickerProps = {\n    allowTextInput: false,\n    formatDate: (date: Date) => {\n      if (date) {\n        return date.toDateString();\n      }\n\n      return '';\n    },\n    parseDateFromString: (dateStr: string) => {\n      const date = Date.parse(dateStr);\n      if (date) {\n        return new Date(date);\n      }\n\n      return null;\n    },\n    firstDayOfWeek: DayOfWeek.Sunday,\n    initialPickerDate: new Date(),\n    isRequired: false,\n    isMonthPickerVisible: true,\n    showMonthPickerAsOverlay: false,\n    strings: DEFAULT_STRINGS,\n    highlightCurrentMonth: false,\n    highlightSelectedMonth: false,\n    borderless: false,\n    pickerAriaLabel: 'Calendar',\n    showWeekNumbers: false,\n    firstWeekOfYear: FirstWeekOfYear.FirstDay,\n    showGoToToday: true,\n    dateTimeFormatter: undefined,\n    showCloseButton: false,\n    underlined: false,\n    allFocusable: false,\n  };\n\n  private _calendar = React.createRef<ICalendar>();\n  private _datePickerDiv = React.createRef<HTMLDivElement>();\n  private _textField = React.createRef<ITextField>();\n  private _preventFocusOpeningPicker: boolean;\n  private _id: string;\n\n  constructor(props: IDatePickerProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this.state = this._getDefaultState();\n\n    this._id = props.id || getId('DatePicker');\n\n    this._preventFocusOpeningPicker = false;\n  }\n\n  public UNSAFE_componentWillReceiveProps(nextProps: IDatePickerProps): void {\n    const { formatDate, value } = nextProps;\n\n    if (\n      compareDates(this.props.minDate!, nextProps.minDate!) &&\n      compareDates(this.props.maxDate!, nextProps.maxDate!) &&\n      this.props.isRequired === nextProps.isRequired &&\n      compareDates(this.state.selectedDate!, value!) &&\n      this.props.formatDate === formatDate\n    ) {\n      // if the props we care about haven't changed, don't run validation or updates\n      return;\n    }\n\n    this._setErrorMessage(true, nextProps);\n\n    this._id = nextProps.id || this._id;\n\n    // Issue# 1274: Check if the date value changed from old value, i.e., if indeed a new date is being\n    // passed in or if the formatting function was modified. We only update the selected date if either of these\n    // had a legit change. Note tha the bug will still repro when only the formatDate was passed in props and this\n    // is the result of the onSelectDate callback, but this should be a rare scenario.\n    const oldValue = this.state.selectedDate;\n    if (!compareDates(oldValue!, value!) || this.props.formatDate !== formatDate) {\n      this.setState({\n        selectedDate: value || undefined,\n        formattedDate: formatDate && value ? formatDate(value) : '',\n      });\n    }\n  }\n\n  public componentDidUpdate(prevProps: IDatePickerProps, prevState: IDatePickerState) {\n    if (prevState.isDatePickerShown && !this.state.isDatePickerShown) {\n      // If DatePicker's menu (Calendar) is closed, run onAfterMenuDismiss\n      if (this.props.onAfterMenuDismiss) {\n        this.props.onAfterMenuDismiss();\n      }\n    }\n  }\n\n  public render(): JSX.Element {\n    const {\n      firstDayOfWeek,\n      strings,\n      label,\n      theme,\n      className,\n      styles,\n      initialPickerDate,\n      isRequired,\n      disabled,\n      ariaLabel,\n      pickerAriaLabel,\n      placeholder,\n      allowTextInput,\n      borderless,\n      minDate,\n      maxDate,\n      showCloseButton,\n      calendarProps,\n      calloutProps,\n      textField: textFieldProps,\n      underlined,\n      allFocusable,\n      calendarAs: CalendarType = Calendar,\n      tabIndex,\n    } = this.props;\n    const { isDatePickerShown, formattedDate, selectedDate } = this.state;\n\n    const classNames = getClassNames(styles, {\n      theme: theme!,\n      className,\n      disabled,\n      label: !!label,\n      isDatePickerShown,\n    });\n\n    const calloutId = getId('DatePicker-Callout');\n    const nativeProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties, ['value']);\n    const iconProps = textFieldProps && textFieldProps.iconProps;\n\n    return (\n      <div {...nativeProps} className={classNames.root}>\n        <div\n          ref={this._datePickerDiv}\n          aria-haspopup=\"true\"\n          aria-owns={isDatePickerShown ? calloutId : undefined}\n          className={classNames.wrapper}\n        >\n          <TextField\n            role=\"combobox\"\n            label={label}\n            aria-expanded={isDatePickerShown}\n            ariaLabel={ariaLabel}\n            aria-controls={isDatePickerShown ? calloutId : undefined}\n            required={isRequired}\n            disabled={disabled}\n            errorMessage={this._getErrorMessage()}\n            placeholder={placeholder}\n            borderless={borderless}\n            value={formattedDate}\n            componentRef={this._textField}\n            underlined={underlined}\n            tabIndex={tabIndex}\n            readOnly={!allowTextInput}\n            {...textFieldProps}\n            id={this._id + '-label'}\n            className={css(classNames.textField, textFieldProps && textFieldProps.className)}\n            iconProps={{\n              iconName: 'Calendar',\n              ...iconProps,\n              className: css(classNames.icon, iconProps && iconProps.className),\n              onClick: this._onIconClick,\n            }}\n            onKeyDown={this._onTextFieldKeyDown}\n            onFocus={this._onTextFieldFocus}\n            onBlur={this._onTextFieldBlur}\n            onClick={this._onTextFieldClick}\n            onChange={this._onTextFieldChanged}\n          />\n        </div>\n        {isDatePickerShown && (\n          <Callout\n            id={calloutId}\n            role=\"dialog\"\n            ariaLabel={pickerAriaLabel}\n            isBeakVisible={false}\n            gapSpace={0}\n            doNotLayer={false}\n            target={this._datePickerDiv.current}\n            directionalHint={DirectionalHint.bottomLeftEdge}\n            {...calloutProps}\n            className={css(classNames.callout, calloutProps && calloutProps.className)}\n            onDismiss={this._calendarDismissed}\n            onPositioned={this._onCalloutPositioned}\n          >\n            <FocusTrapZone\n              isClickableOutsideFocusTrap={true}\n              disableFirstFocus={this.props.disableAutoFocus}\n              forceFocusInsideTrap={false}\n            >\n              <CalendarType\n                {...calendarProps}\n                onSelectDate={this._onSelectDate}\n                onDismiss={this._calendarDismissed}\n                isMonthPickerVisible={this.props.isMonthPickerVisible}\n                showMonthPickerAsOverlay={this.props.showMonthPickerAsOverlay}\n                today={this.props.today}\n                value={selectedDate || initialPickerDate}\n                firstDayOfWeek={firstDayOfWeek}\n                strings={strings!}\n                highlightCurrentMonth={this.props.highlightCurrentMonth}\n                highlightSelectedMonth={this.props.highlightSelectedMonth}\n                showWeekNumbers={this.props.showWeekNumbers}\n                firstWeekOfYear={this.props.firstWeekOfYear}\n                showGoToToday={this.props.showGoToToday}\n                dateTimeFormatter={this.props.dateTimeFormatter}\n                minDate={minDate}\n                maxDate={maxDate}\n                componentRef={this._calendar}\n                showCloseButton={showCloseButton}\n                allFocusable={allFocusable}\n              />\n            </FocusTrapZone>\n          </Callout>\n        )}\n      </div>\n    );\n  }\n\n  public focus(): void {\n    if (this._textField.current) {\n      this._textField.current.focus();\n    }\n  }\n\n  public reset(): void {\n    this.setState(this._getDefaultState());\n  }\n\n  private _setErrorMessage(setState: boolean, nextProps?: IDatePickerProps): string | undefined {\n    const { isRequired, strings, value, minDate, maxDate, initialPickerDate } = nextProps || this.props;\n    let errorMessage = !initialPickerDate && isRequired && !value ? strings!.isRequiredErrorMessage || ' ' : undefined;\n\n    if (!errorMessage && value) {\n      errorMessage = this._isDateOutOfBounds(value!, minDate, maxDate)\n        ? strings!.isOutOfBoundsErrorMessage || ' '\n        : undefined;\n    }\n\n    if (setState) {\n      this.setState({\n        errorMessage: errorMessage,\n      });\n    }\n\n    return errorMessage;\n  }\n\n  private _onSelectDate = (date: Date): void => {\n    const { formatDate, onSelectDate } = this.props;\n\n    if (this.props.calendarProps && this.props.calendarProps.onSelectDate) {\n      this.props.calendarProps.onSelectDate(date);\n    }\n\n    this.setState({\n      selectedDate: date,\n      formattedDate: formatDate && date ? formatDate(date) : '',\n    });\n\n    if (onSelectDate) {\n      onSelectDate(date);\n    }\n\n    this._calendarDismissed();\n  };\n\n  private _onCalloutPositioned = (): void => {\n    let shouldFocus = true;\n    // If the user has specified that the callout shouldn't use initial focus, then respect\n    // that and don't attempt to set focus. That will default to true within the callout\n    // so we need to check if it's undefined here.\n    if (this.props.calloutProps && this.props.calloutProps.setInitialFocus !== undefined) {\n      shouldFocus = this.props.calloutProps.setInitialFocus;\n    }\n    if (this._calendar.current && shouldFocus) {\n      this._calendar.current.focus();\n    }\n  };\n\n  private _onTextFieldFocus = (ev: React.FocusEvent<HTMLElement>): void => {\n    if (this.props.disableAutoFocus) {\n      return;\n    }\n\n    if (!this.props.allowTextInput) {\n      if (!this._preventFocusOpeningPicker) {\n        this._showDatePickerPopup();\n      } else {\n        this._preventFocusOpeningPicker = false;\n      }\n    }\n  };\n\n  private _onTextFieldBlur = (ev: React.FocusEvent<HTMLElement>): void => {\n    this._validateTextInput();\n  };\n\n  private _onTextFieldChanged = (\n    ev: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>,\n    newValue: string,\n  ): void => {\n    const { allowTextInput, textField } = this.props;\n\n    if (allowTextInput) {\n      if (this.state.isDatePickerShown) {\n        this._dismissDatePickerPopup();\n      }\n\n      const { isRequired, strings } = this.props;\n\n      this.setState({\n        errorMessage: isRequired && !newValue ? strings!.isRequiredErrorMessage || ' ' : undefined,\n        formattedDate: newValue,\n      });\n    }\n\n    if (textField && textField.onChange) {\n      textField.onChange(ev, newValue);\n    }\n  };\n\n  private _onTextFieldKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    switch (ev.which) {\n      case KeyCodes.enter:\n        ev.preventDefault();\n        ev.stopPropagation();\n        if (!this.state.isDatePickerShown) {\n          this._validateTextInput();\n          this._showDatePickerPopup();\n        } else {\n          // When DatePicker allows input date string directly,\n          // it is expected to hit another enter to close the popup\n          if (this.props.allowTextInput) {\n            this._dismissDatePickerPopup();\n          }\n        }\n        break;\n\n      case KeyCodes.escape:\n        this._handleEscKey(ev);\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  private _onTextFieldClick = (ev: React.MouseEvent<HTMLElement>): void => {\n    if (!this.props.disableAutoFocus && !this.state.isDatePickerShown && !this.props.disabled) {\n      this._showDatePickerPopup();\n      return;\n    }\n    if (this.props.allowTextInput) {\n      this._dismissDatePickerPopup();\n    }\n  };\n\n  private _onIconClick = (ev: React.MouseEvent<HTMLElement>): void => {\n    ev.stopPropagation();\n    if (!this.state.isDatePickerShown && !this.props.disabled) {\n      this._showDatePickerPopup();\n    } else if (this.props.allowTextInput) {\n      this._dismissDatePickerPopup();\n    }\n  };\n\n  private _showDatePickerPopup(): void {\n    if (!this.state.isDatePickerShown) {\n      this._preventFocusOpeningPicker = true;\n      this.setState({\n        isDatePickerShown: true,\n      });\n    }\n  }\n\n  private _dismissDatePickerPopup = (): void => {\n    if (this.state.isDatePickerShown) {\n      this.setState(\n        {\n          isDatePickerShown: false,\n        },\n        () => {\n          // setState is async, so we must call validate in a callback\n          this._validateTextInput();\n        },\n      );\n    }\n  };\n\n  /**\n   * Callback for closing the calendar callout\n   */\n  private _calendarDismissed = (): void => {\n    this._preventFocusOpeningPicker = true;\n    this._dismissDatePickerPopup();\n    // don't need to focus the text box, if necessary the focusTrapZone will do it\n  };\n\n  private _handleEscKey = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    if (this.state.isDatePickerShown) {\n      ev.stopPropagation();\n    }\n    this._calendarDismissed();\n  };\n\n  private _validateTextInput = (): void => {\n    const {\n      isRequired,\n      allowTextInput,\n      strings,\n      parseDateFromString,\n      onSelectDate,\n      formatDate,\n      minDate,\n      maxDate,\n    } = this.props;\n    const inputValue = this.state.formattedDate;\n\n    // Do validation only if DatePicker's popup is dismissed\n    if (this.state.isDatePickerShown) {\n      return;\n    }\n\n    if (allowTextInput) {\n      let date = null;\n\n      if (inputValue) {\n        // Don't parse if the selected date has the same formatted string as what we're about to parse.\n        // The formatted string might be ambiguous (ex: \"1/2/3\" or \"New Year Eve\") and the parser might\n        // not be able to come up with the exact same date.\n        if (\n          this.state.selectedDate &&\n          !this.state.errorMessage &&\n          formatDate &&\n          formatDate(this.state.selectedDate) === inputValue\n        ) {\n          return;\n        }\n        date = parseDateFromString!(inputValue);\n\n        // Check if date is null, or date is Invalid Date\n        if (!date || isNaN(date.getTime())) {\n          // Reset invalid input field, if formatting is available\n          if (formatDate) {\n            date = this.state.selectedDate;\n            this.setState({\n              formattedDate: formatDate(date!).toString(),\n            });\n          }\n\n          this.setState({\n            errorMessage: strings!.invalidInputErrorMessage || ' ',\n          });\n        } else {\n          // Check against optional date boundaries\n          if (this._isDateOutOfBounds(date, minDate, maxDate)) {\n            this.setState({\n              errorMessage: strings!.isOutOfBoundsErrorMessage || ' ',\n            });\n          } else {\n            this.setState({\n              selectedDate: date,\n              errorMessage: '',\n            });\n\n            // When formatting is available:\n            // If formatted date is valid, but is different from input, update with formatted date.\n            // This occurs when an invalid date is entered twice.\n            if (formatDate && formatDate(date) !== inputValue) {\n              this.setState({\n                formattedDate: formatDate(date).toString(),\n              });\n            }\n          }\n        }\n      } else {\n        // Only show error for empty inputValue if it is a required field\n        this.setState({\n          errorMessage: isRequired ? strings!.isRequiredErrorMessage || ' ' : '',\n        });\n      }\n\n      // Execute onSelectDate callback\n      if (onSelectDate) {\n        // If no input date string or input date string is invalid\n        // date variable will be null, callback should expect null value for this case\n        onSelectDate(date);\n      }\n    } else if (isRequired && !inputValue) {\n      // Check when DatePicker is a required field but has NO input value\n      this.setState({\n        errorMessage: strings!.isRequiredErrorMessage || ' ',\n      });\n    } else {\n      // Cleanup the error message\n      this.setState({\n        errorMessage: '',\n      });\n    }\n  };\n\n  private _getDefaultState(props: IDatePickerProps = this.props): IDatePickerState {\n    return {\n      selectedDate: props.value || undefined,\n      formattedDate: props.formatDate && props.value ? props.formatDate(props.value) : '',\n      isDatePickerShown: false,\n      errorMessage: this._setErrorMessage(false),\n    };\n  }\n\n  private _isDateOutOfBounds(date: Date, minDate?: Date, maxDate?: Date): boolean {\n    return (!!minDate && compareDatePart(minDate!, date) > 0) || (!!maxDate && compareDatePart(maxDate!, date) < 0);\n  }\n\n  private _getErrorMessage(): string | undefined {\n    if (this.state.isDatePickerShown) {\n      return undefined;\n    }\n    return this.state.errorMessage;\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}