{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortError } from \"@azure/abort-controller\";\nimport { HttpHeaders } from \"./httpHeaders\";\nimport { RestError } from \"./restError\";\n/**\n * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.\n */\nvar XhrHttpClient = /** @class */function () {\n  function XhrHttpClient() {}\n  XhrHttpClient.prototype.sendRequest = function (request) {\n    var _a;\n    var xhr = new XMLHttpRequest();\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n    var abortSignal = request.abortSignal;\n    if (abortSignal) {\n      if (abortSignal.aborted) {\n        return Promise.reject(new AbortError(\"The operation was aborted.\"));\n      }\n      var listener_1 = function () {\n        xhr.abort();\n      };\n      abortSignal.addEventListener(\"abort\", listener_1);\n      xhr.addEventListener(\"readystatechange\", function () {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          abortSignal.removeEventListener(\"abort\", listener_1);\n        }\n      });\n    }\n    addProgressListener(xhr.upload, request.onUploadProgress);\n    addProgressListener(xhr, request.onDownloadProgress);\n    if (request.formData) {\n      var formData = request.formData;\n      var requestForm_1 = new FormData();\n      var appendFormValue = function (key, value) {\n        if (value && Object.prototype.hasOwnProperty.call(value, \"value\") && Object.prototype.hasOwnProperty.call(value, \"options\")) {\n          requestForm_1.append(key, value.value, value.options);\n        } else {\n          requestForm_1.append(key, value);\n        }\n      };\n      for (var _i = 0, _b = Object.keys(formData); _i < _b.length; _i++) {\n        var formKey = _b[_i];\n        var formValue = formData[formKey];\n        if (Array.isArray(formValue)) {\n          for (var j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j]);\n          }\n        } else {\n          appendFormValue(formKey, formValue);\n        }\n      }\n      request.body = requestForm_1;\n      request.formData = undefined;\n      var contentType = request.headers.get(\"Content-Type\");\n      if (contentType && contentType.indexOf(\"multipart/form-data\") !== -1) {\n        // browser will automatically apply a suitable content-type header\n        request.headers.remove(\"Content-Type\");\n      }\n    }\n    xhr.open(request.method, request.url);\n    xhr.timeout = request.timeout;\n    xhr.withCredentials = request.withCredentials;\n    for (var _c = 0, _d = request.headers.headersArray(); _c < _d.length; _c++) {\n      var header = _d[_c];\n      xhr.setRequestHeader(header.name, header.value);\n    }\n    xhr.responseType = ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.size) || request.streamResponseBody ? \"blob\" : \"text\";\n    // tslint:disable-next-line:no-null-keyword\n    xhr.send(request.body === undefined ? null : request.body);\n    if (xhr.responseType === \"blob\") {\n      return new Promise(function (resolve, reject) {\n        handleBlobResponse(xhr, request, resolve, reject);\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    } else {\n      return new Promise(function (resolve, reject) {\n        xhr.addEventListener(\"load\", function () {\n          return resolve({\n            request: request,\n            status: xhr.status,\n            headers: parseHeaders(xhr),\n            bodyAsText: xhr.responseText\n          });\n        });\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    }\n  };\n  return XhrHttpClient;\n}();\nexport { XhrHttpClient };\nfunction handleBlobResponse(xhr, request, res, rej) {\n  xhr.addEventListener(\"readystatechange\", function () {\n    var _a;\n    // Resolve as soon as headers are loaded\n    if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n      if (request.streamResponseBody || ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(xhr.status))) {\n        var blobBody = new Promise(function (resolve, reject) {\n          xhr.addEventListener(\"load\", function () {\n            resolve(xhr.response);\n          });\n          rejectOnTerminalEvent(request, xhr, reject);\n        });\n        res({\n          request: request,\n          status: xhr.status,\n          headers: parseHeaders(xhr),\n          blobBody: blobBody\n        });\n      } else {\n        xhr.addEventListener(\"load\", function () {\n          // xhr.response is of Blob type if the request is sent with xhr.responseType === \"blob\"\n          // but the status code is not one of the stream response status codes,\n          // so treat it as text and convert from Blob to text\n          if (xhr.response) {\n            // Blob.text() is not supported in IE so using FileReader instead\n            var reader_1 = new FileReader();\n            reader_1.onload = function (e) {\n              var _a;\n              var text = (_a = e.target) === null || _a === void 0 ? void 0 : _a.result;\n              res({\n                request: request,\n                status: xhr.status,\n                headers: parseHeaders(xhr),\n                bodyAsText: text\n              });\n            };\n            reader_1.onerror = function (_e) {\n              rej(reader_1.error);\n            };\n            reader_1.readAsText(xhr.response, \"UTF-8\");\n          } else {\n            res({\n              request: request,\n              status: xhr.status,\n              headers: parseHeaders(xhr)\n            });\n          }\n        });\n      }\n    }\n  });\n}\nfunction addProgressListener(xhr, listener) {\n  if (listener) {\n    xhr.addEventListener(\"progress\", function (rawEvent) {\n      return listener({\n        loadedBytes: rawEvent.loaded\n      });\n    });\n  }\n}\n// exported locally for testing\nexport function parseHeaders(xhr) {\n  var responseHeaders = new HttpHeaders();\n  var headerLines = xhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n  for (var _i = 0, headerLines_1 = headerLines; _i < headerLines_1.length; _i++) {\n    var line = headerLines_1[_i];\n    var index = line.indexOf(\":\");\n    var headerName = line.slice(0, index);\n    var headerValue = line.slice(index + 2);\n    responseHeaders.set(headerName, headerValue);\n  }\n  return responseHeaders;\n}\nfunction rejectOnTerminalEvent(request, xhr, reject) {\n  xhr.addEventListener(\"error\", function () {\n    return reject(new RestError(\"Failed to send request to \" + request.url, RestError.REQUEST_SEND_ERROR, undefined, request));\n  });\n  var abortError = new AbortError(\"The operation was aborted.\");\n  xhr.addEventListener(\"abort\", function () {\n    return reject(abortError);\n  });\n  xhr.addEventListener(\"timeout\", function () {\n    return reject(abortError);\n  });\n}","map":{"version":3,"sources":["../../src/xhrHttpClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortError } from \"@azure/abort-controller\";\nimport { HttpClient } from \"./httpClient\";\nimport { HttpHeaders, HttpHeadersLike } from \"./httpHeaders\";\nimport { WebResourceLike, TransferProgressEvent } from \"./webResource\";\nimport { HttpOperationResponse } from \"./httpOperationResponse\";\nimport { RestError } from \"./restError\";\n\n/**\n * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.\n */\nexport class XhrHttpClient implements HttpClient {\n  public sendRequest(request: WebResourceLike): Promise<HttpOperationResponse> {\n    const xhr = new XMLHttpRequest();\n\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n\n    const abortSignal = request.abortSignal;\n    if (abortSignal) {\n      if (abortSignal.aborted) {\n        return Promise.reject(new AbortError(\"The operation was aborted.\"));\n      }\n\n      const listener = (): void => {\n        xhr.abort();\n      };\n      abortSignal.addEventListener(\"abort\", listener);\n      xhr.addEventListener(\"readystatechange\", () => {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          abortSignal.removeEventListener(\"abort\", listener);\n        }\n      });\n    }\n\n    addProgressListener(xhr.upload, request.onUploadProgress);\n    addProgressListener(xhr, request.onDownloadProgress);\n\n    if (request.formData) {\n      const formData = request.formData;\n      const requestForm = new FormData();\n      const appendFormValue = (key: string, value: any): void => {\n        if (\n          value &&\n          Object.prototype.hasOwnProperty.call(value, \"value\") &&\n          Object.prototype.hasOwnProperty.call(value, \"options\")\n        ) {\n          requestForm.append(key, value.value, value.options);\n        } else {\n          requestForm.append(key, value);\n        }\n      };\n      for (const formKey of Object.keys(formData)) {\n        const formValue = formData[formKey];\n        if (Array.isArray(formValue)) {\n          for (let j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j]);\n          }\n        } else {\n          appendFormValue(formKey, formValue);\n        }\n      }\n\n      request.body = requestForm;\n      request.formData = undefined;\n      const contentType = request.headers.get(\"Content-Type\");\n      if (contentType && contentType.indexOf(\"multipart/form-data\") !== -1) {\n        // browser will automatically apply a suitable content-type header\n        request.headers.remove(\"Content-Type\");\n      }\n    }\n\n    xhr.open(request.method, request.url);\n    xhr.timeout = request.timeout;\n    xhr.withCredentials = request.withCredentials;\n    for (const header of request.headers.headersArray()) {\n      xhr.setRequestHeader(header.name, header.value);\n    }\n\n    xhr.responseType =\n      request.streamResponseStatusCodes?.size || request.streamResponseBody ? \"blob\" : \"text\";\n\n    // tslint:disable-next-line:no-null-keyword\n    xhr.send(request.body === undefined ? null : request.body);\n\n    if (xhr.responseType === \"blob\") {\n      return new Promise((resolve, reject) => {\n        handleBlobResponse(xhr, request, resolve, reject);\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    } else {\n      return new Promise(function(resolve, reject) {\n        xhr.addEventListener(\"load\", () =>\n          resolve({\n            request,\n            status: xhr.status,\n            headers: parseHeaders(xhr),\n            bodyAsText: xhr.responseText\n          })\n        );\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    }\n  }\n}\n\nfunction handleBlobResponse(\n  xhr: XMLHttpRequest,\n  request: WebResourceLike,\n  res: (value: HttpOperationResponse | PromiseLike<HttpOperationResponse>) => void,\n  rej: (reason?: any) => void\n): void {\n  xhr.addEventListener(\"readystatechange\", () => {\n    // Resolve as soon as headers are loaded\n    if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n      if (request.streamResponseBody || request.streamResponseStatusCodes?.has(xhr.status)) {\n        const blobBody = new Promise<Blob>((resolve, reject) => {\n          xhr.addEventListener(\"load\", () => {\n            resolve(xhr.response);\n          });\n          rejectOnTerminalEvent(request, xhr, reject);\n        });\n        res({\n          request,\n          status: xhr.status,\n          headers: parseHeaders(xhr),\n          blobBody\n        });\n      } else {\n        xhr.addEventListener(\"load\", () => {\n          // xhr.response is of Blob type if the request is sent with xhr.responseType === \"blob\"\n          // but the status code is not one of the stream response status codes,\n          // so treat it as text and convert from Blob to text\n          if (xhr.response) {\n            // Blob.text() is not supported in IE so using FileReader instead\n            const reader = new FileReader();\n            reader.onload = function(e) {\n              const text = e.target?.result as string;\n              res({\n                request,\n                status: xhr.status,\n                headers: parseHeaders(xhr),\n                bodyAsText: text\n              });\n            };\n            reader.onerror = function(_e) {\n              rej(reader.error);\n            };\n            reader.readAsText(xhr.response, \"UTF-8\");\n          } else {\n            res({\n              request,\n              status: xhr.status,\n              headers: parseHeaders(xhr)\n            });\n          }\n        });\n      }\n    }\n  });\n}\n\nfunction addProgressListener(\n  xhr: XMLHttpRequestEventTarget,\n  listener?: (progress: TransferProgressEvent) => void\n): void {\n  if (listener) {\n    xhr.addEventListener(\"progress\", (rawEvent) =>\n      listener({\n        loadedBytes: rawEvent.loaded\n      })\n    );\n  }\n}\n\n// exported locally for testing\nexport function parseHeaders(xhr: XMLHttpRequest): HttpHeadersLike {\n  const responseHeaders = new HttpHeaders();\n  const headerLines = xhr\n    .getAllResponseHeaders()\n    .trim()\n    .split(/[\\r\\n]+/);\n  for (const line of headerLines) {\n    const index = line.indexOf(\":\");\n    const headerName = line.slice(0, index);\n    const headerValue = line.slice(index + 2);\n    responseHeaders.set(headerName, headerValue);\n  }\n  return responseHeaders;\n}\n\nfunction rejectOnTerminalEvent(\n  request: WebResourceLike,\n  xhr: XMLHttpRequest,\n  reject: (err: any) => void\n): void {\n  xhr.addEventListener(\"error\", () =>\n    reject(\n      new RestError(\n        `Failed to send request to ${request.url}`,\n        RestError.REQUEST_SEND_ERROR,\n        undefined,\n        request\n      )\n    )\n  );\n  const abortError = new AbortError(\"The operation was aborted.\");\n  xhr.addEventListener(\"abort\", () => reject(abortError));\n  xhr.addEventListener(\"timeout\", () => reject(abortError));\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}