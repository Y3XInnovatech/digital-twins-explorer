{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, KeyCodes, css, elementContains, getId, classNamesFunction, styled, initializeComponentRef } from '../../Utilities';\nimport { FocusZone, FocusZoneDirection } from '../../FocusZone';\nimport { Callout, DirectionalHint } from '../../Callout';\nimport { Selection, SelectionZone, SelectionMode } from '../../utilities/selection/index';\nimport { Suggestions } from './Suggestions/Suggestions';\nimport { getStyles as suggestionsStyles } from './Suggestions/Suggestions.styles';\nimport { SuggestionsController } from './Suggestions/SuggestionsController';\nimport { ValidationState } from './BasePicker.types';\nimport { Autofill } from '../Autofill/index';\nimport * as stylesImport from './BasePicker.scss';\nvar legacyStyles = stylesImport;\nvar getClassNames = classNamesFunction();\n/**\n * Should be removed once new picker without inheritance is created\n */\nfunction getStyledSuggestions(suggestionsType) {\n  return styled(suggestionsType, suggestionsStyles, undefined, {\n    scope: 'Suggestions'\n  });\n}\n/**\n * {@docCategory Pickers}\n */\nvar BasePicker = /** @class */function (_super) {\n  __extends(BasePicker, _super);\n  function BasePicker(basePickerProps) {\n    var _this = _super.call(this, basePickerProps) || this;\n    // Refs\n    _this.root = React.createRef();\n    _this.input = React.createRef();\n    _this.focusZone = React.createRef();\n    _this.suggestionElement = React.createRef();\n    /**\n     * @deprecated this is no longer necessary as typescript now supports generic elements\n     */\n    _this.SuggestionOfProperType = Suggestions;\n    // eslint-disable-next-line deprecation/deprecation\n    _this._styledSuggestions = getStyledSuggestions(_this.SuggestionOfProperType);\n    _this.dismissSuggestions = function (ev) {\n      var selectItemFunction = function () {\n        var addItemOnDismiss = true;\n        if (_this.props.onDismiss) {\n          addItemOnDismiss = _this.props.onDismiss(ev, _this.suggestionStore.currentSuggestion ? _this.suggestionStore.currentSuggestion.item : undefined);\n        }\n        if (!ev || ev && !ev.defaultPrevented) {\n          // Select the first suggestion if one is available and permitted by onDismiss when user leaves.\n          if (addItemOnDismiss !== false && _this.canAddItems() && _this.suggestionStore.hasSelectedSuggestion() && _this.state.suggestedDisplayValue) {\n            _this.addItemByIndex(0);\n          }\n        }\n      };\n      if (_this.currentPromise) {\n        _this.currentPromise.then(function () {\n          return selectItemFunction();\n        });\n      } else {\n        selectItemFunction();\n      }\n      _this.setState({\n        suggestionsVisible: false\n      });\n    };\n    _this.refocusSuggestions = function (keyCode) {\n      _this.resetFocus();\n      if (_this.suggestionStore.suggestions && _this.suggestionStore.suggestions.length > 0) {\n        if (keyCode === KeyCodes.up) {\n          _this.suggestionStore.setSelectedSuggestion(_this.suggestionStore.suggestions.length - 1);\n        } else if (keyCode === KeyCodes.down) {\n          _this.suggestionStore.setSelectedSuggestion(0);\n        }\n      }\n    };\n    _this.onInputChange = function (value) {\n      _this.updateValue(value);\n      _this.setState({\n        moreSuggestionsAvailable: true,\n        isMostRecentlyUsedVisible: false\n      });\n    };\n    _this.onSuggestionClick = function (ev, item, index) {\n      _this.addItemByIndex(index);\n    };\n    _this.onSuggestionRemove = function (ev, item, index) {\n      if (_this.props.onRemoveSuggestion) {\n        _this.props.onRemoveSuggestion(item);\n      }\n      _this.suggestionStore.removeSuggestion(index);\n    };\n    _this.onInputFocus = function (ev) {\n      _this.selection.setAllSelected(false);\n      // Only trigger all of the focus if this component isn't already focused.\n      // For example when an item is selected or removed from the selected list it should be treated\n      // as though the input is still focused.\n      if (!_this.state.isFocused) {\n        _this.setState({\n          isFocused: true\n        });\n        _this._userTriggeredSuggestions();\n        if (_this.props.inputProps && _this.props.inputProps.onFocus) {\n          _this.props.inputProps.onFocus(ev);\n        }\n      }\n    };\n    _this.onInputBlur = function (ev) {\n      if (_this.props.inputProps && _this.props.inputProps.onBlur) {\n        _this.props.inputProps.onBlur(ev);\n      }\n    };\n    _this.onBlur = function (ev) {\n      if (_this.state.isFocused) {\n        // Only blur the entire component if an unrelated element gets focus.\n        // Otherwise treat it as though it still has focus.\n        // Do nothing if the blur is coming from something\n        // inside the comboBox root or the comboBox menu since\n        // it we are not really bluring from the whole comboBox\n        var relatedTarget = ev.relatedTarget;\n        if (ev.relatedTarget === null) {\n          // In IE11, due to lack of support, event.relatedTarget is always\n          // null making every onBlur call to be \"outside\" of the ComboBox\n          // even when it's not. Using document.activeElement is another way\n          // for us to be able to get what the relatedTarget without relying\n          // on the event\n          relatedTarget = document.activeElement;\n        }\n        if (relatedTarget && !elementContains(_this.root.current, relatedTarget)) {\n          _this.setState({\n            isFocused: false\n          });\n          if (_this.props.onBlur) {\n            _this.props.onBlur(ev);\n          }\n        }\n      }\n    };\n    /**\n     * Reveals suggestions any time the user clicks on the input element\n     * without shifting focus.\n     */\n    _this.onClick = function (ev) {\n      if (_this.props.inputProps !== undefined && _this.props.inputProps.onClick !== undefined) {\n        _this.props.inputProps.onClick(ev);\n      }\n      // Only primary (left) clicks show suggestions.\n      if (ev.button === 0) {\n        _this._userTriggeredSuggestions();\n      }\n    };\n    _this.onKeyDown = function (ev) {\n      var keyCode = ev.which;\n      switch (keyCode) {\n        case KeyCodes.escape:\n          if (_this.state.suggestionsVisible) {\n            _this.setState({\n              suggestionsVisible: false\n            });\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n          break;\n        case KeyCodes.tab:\n        case KeyCodes.enter:\n          if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedActionSelected()) {\n            _this.suggestionElement.current.executeSelectedAction();\n          } else if (!ev.shiftKey && _this.suggestionStore.hasSelectedSuggestion() && _this.state.suggestionsVisible) {\n            _this.completeSuggestion();\n            ev.preventDefault();\n            ev.stopPropagation();\n          } else {\n            _this._completeGenericSuggestion();\n          }\n          break;\n        case KeyCodes.backspace:\n          if (!_this.props.disabled) {\n            _this.onBackspace(ev);\n          }\n          ev.stopPropagation();\n          break;\n        case KeyCodes.del:\n          if (!_this.props.disabled) {\n            if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible && _this.suggestionStore.currentIndex !== -1) {\n              if (_this.props.onRemoveSuggestion) {\n                _this.props.onRemoveSuggestion(_this.suggestionStore.currentSuggestion.item);\n              }\n              _this.suggestionStore.removeSuggestion(_this.suggestionStore.currentIndex);\n              _this.forceUpdate();\n            } else {\n              _this.onBackspace(ev);\n            }\n          }\n          ev.stopPropagation();\n          break;\n        case KeyCodes.up:\n          if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible) {\n            if (_this.suggestionElement.current && _this.suggestionElement.current.tryHandleKeyDown(keyCode, _this.suggestionStore.currentIndex)) {\n              ev.preventDefault();\n              ev.stopPropagation();\n              _this.forceUpdate();\n            } else {\n              if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedAction() && _this.suggestionStore.currentIndex === 0) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                _this.suggestionElement.current.focusAboveSuggestions();\n                _this.suggestionStore.deselectAllSuggestions();\n                _this.forceUpdate();\n              } else {\n                if (_this.suggestionStore.previousSuggestion()) {\n                  ev.preventDefault();\n                  ev.stopPropagation();\n                  _this.onSuggestionSelect();\n                }\n              }\n            }\n          }\n          break;\n        case KeyCodes.down:\n          if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible) {\n            if (_this.suggestionElement.current && _this.suggestionElement.current.tryHandleKeyDown(keyCode, _this.suggestionStore.currentIndex)) {\n              ev.preventDefault();\n              ev.stopPropagation();\n              _this.forceUpdate();\n            } else {\n              if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedAction() && _this.suggestionStore.currentIndex + 1 === _this.suggestionStore.suggestions.length) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                _this.suggestionElement.current.focusBelowSuggestions();\n                _this.suggestionStore.deselectAllSuggestions();\n                _this.forceUpdate();\n              } else {\n                if (_this.suggestionStore.nextSuggestion()) {\n                  ev.preventDefault();\n                  ev.stopPropagation();\n                  _this.onSuggestionSelect();\n                }\n              }\n            }\n          }\n          break;\n      }\n    };\n    _this.onItemChange = function (changedItem, index) {\n      var items = _this.state.items;\n      if (index >= 0) {\n        var newItems = items;\n        newItems[index] = changedItem;\n        _this._updateSelectedItems(newItems);\n      }\n    };\n    _this.onGetMoreResults = function () {\n      _this.setState({\n        isSearching: true\n      }, function () {\n        if (_this.props.onGetMoreResults && _this.input.current) {\n          var suggestions = _this.props.onGetMoreResults(_this.input.current.value, _this.state.items);\n          var suggestionsArray = suggestions;\n          var suggestionsPromiseLike = suggestions;\n          if (Array.isArray(suggestionsArray)) {\n            _this.updateSuggestions(suggestionsArray);\n            _this.setState({\n              isSearching: false\n            });\n          } else if (suggestionsPromiseLike.then) {\n            suggestionsPromiseLike.then(function (newSuggestions) {\n              _this.updateSuggestions(newSuggestions);\n              _this.setState({\n                isSearching: false\n              });\n            });\n          }\n        } else {\n          _this.setState({\n            isSearching: false\n          });\n        }\n        if (_this.input.current) {\n          _this.input.current.focus();\n        }\n        _this.setState({\n          moreSuggestionsAvailable: false,\n          isResultsFooterVisible: true\n        });\n      });\n    };\n    _this.completeSelection = function (item) {\n      _this.addItem(item);\n      _this.updateValue('');\n      if (_this.input.current) {\n        _this.input.current.clear();\n      }\n      _this.setState({\n        suggestionsVisible: false\n      });\n    };\n    _this.addItemByIndex = function (index) {\n      _this.completeSelection(_this.suggestionStore.getSuggestionAtIndex(index).item);\n    };\n    _this.addItem = function (item) {\n      var processedItem = _this.props.onItemSelected ? _this.props.onItemSelected(item) : item;\n      if (processedItem === null) {\n        return;\n      }\n      var processedItemObject = processedItem;\n      var processedItemPromiseLike = processedItem;\n      if (processedItemPromiseLike && processedItemPromiseLike.then) {\n        processedItemPromiseLike.then(function (resolvedProcessedItem) {\n          var newItems = _this.state.items.concat([resolvedProcessedItem]);\n          _this._updateSelectedItems(newItems);\n        });\n      } else {\n        var newItems = _this.state.items.concat([processedItemObject]);\n        _this._updateSelectedItems(newItems);\n      }\n      _this.setState({\n        suggestedDisplayValue: ''\n      });\n    };\n    _this.removeItem = function (item, focusNextItem) {\n      var items = _this.state.items;\n      var index = items.indexOf(item);\n      if (index >= 0) {\n        var newItems = items.slice(0, index).concat(items.slice(index + 1));\n        _this._updateSelectedItems(newItems);\n      }\n    };\n    _this.removeItems = function (itemsToRemove) {\n      var items = _this.state.items;\n      var newItems = items.filter(function (item) {\n        return itemsToRemove.indexOf(item) === -1;\n      });\n      _this._updateSelectedItems(newItems);\n    };\n    _this._shouldFocusZoneEnterInnerZone = function (ev) {\n      // If suggestions are shown const up/down keys control them, otherwise allow them through to control the focusZone.\n      if (_this.state.suggestionsVisible) {\n        switch (ev.which) {\n          case KeyCodes.up:\n          case KeyCodes.down:\n            return true;\n        }\n      }\n      if (ev.which === KeyCodes.enter) {\n        return true;\n      }\n      return false;\n    };\n    _this._onResolveSuggestions = function (updatedValue) {\n      var suggestions = _this.props.onResolveSuggestions(updatedValue, _this.state.items);\n      if (suggestions !== null) {\n        _this.updateSuggestionsList(suggestions, updatedValue);\n      }\n    };\n    _this._completeGenericSuggestion = function () {\n      if (_this.props.onValidateInput && _this.input.current && _this.props.onValidateInput(_this.input.current.value) !== ValidationState.invalid && _this.props.createGenericItem) {\n        var itemToConvert = _this.props.createGenericItem(_this.input.current.value, _this.props.onValidateInput(_this.input.current.value));\n        _this.suggestionStore.createGenericSuggestion(itemToConvert);\n        _this.completeSuggestion();\n      }\n    };\n    /**\n     * This should be called when the user does something other than use text entry to trigger suggestions.\n     *\n     */\n    _this._userTriggeredSuggestions = function () {\n      if (!_this.state.suggestionsVisible) {\n        var input = _this.input.current ? _this.input.current.value : '';\n        if (!input) {\n          _this.onEmptyInputFocus();\n        } else {\n          if (_this.suggestionStore.suggestions.length === 0) {\n            _this._onResolveSuggestions(input);\n          } else {\n            _this.setState({\n              isMostRecentlyUsedVisible: false,\n              suggestionsVisible: true\n            });\n          }\n        }\n      }\n    };\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    var items = basePickerProps.selectedItems || basePickerProps.defaultSelectedItems || [];\n    _this._id = getId();\n    _this._ariaMap = {\n      selectedItems: \"selected-items-\" + _this._id,\n      selectedSuggestionAlert: \"selected-suggestion-alert-\" + _this._id,\n      suggestionList: \"suggestion-list-\" + _this._id,\n      combobox: \"combobox-\" + _this._id\n    };\n    _this.suggestionStore = new SuggestionsController();\n    _this.selection = new Selection({\n      onSelectionChanged: function () {\n        return _this.onSelectionChange();\n      }\n    });\n    _this.selection.setItems(items);\n    _this.state = {\n      items: items,\n      suggestedDisplayValue: '',\n      isMostRecentlyUsedVisible: false,\n      moreSuggestionsAvailable: false,\n      isFocused: false,\n      isSearching: false,\n      selectedIndices: []\n    };\n    return _this;\n  }\n  BasePicker.getDerivedStateFromProps = function (newProps) {\n    if (newProps.selectedItems) {\n      return {\n        items: newProps.selectedItems\n      };\n    }\n    return null;\n  };\n  Object.defineProperty(BasePicker.prototype, \"items\", {\n    get: function () {\n      return this.state.items;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  BasePicker.prototype.componentDidMount = function () {\n    this.selection.setItems(this.state.items);\n    this._onResolveSuggestions = this._async.debounce(this._onResolveSuggestions, this.props.resolveDelay);\n  };\n  BasePicker.prototype.componentDidUpdate = function (oldProps, oldState) {\n    if (this.state.items && this.state.items !== oldState.items) {\n      var currentSelectedIndex = this.selection.getSelectedIndices()[0];\n      this.selection.setItems(this.state.items);\n      if (this.state.isFocused) {\n        // Reset focus and selection so that selected item stays in sync if something\n        // has been removed\n        if (this.state.items.length < oldState.items.length) {\n          this.selection.setIndexSelected(currentSelectedIndex, true, true);\n          this.resetFocus(currentSelectedIndex);\n        }\n      }\n    }\n  };\n  BasePicker.prototype.componentWillUnmount = function () {\n    if (this.currentPromise) {\n      this.currentPromise = undefined;\n    }\n    this._async.dispose();\n  };\n  BasePicker.prototype.focus = function () {\n    if (this.focusZone.current) {\n      this.focusZone.current.focus();\n    }\n  };\n  BasePicker.prototype.focusInput = function () {\n    if (this.input.current) {\n      this.input.current.focus();\n    }\n  };\n  BasePicker.prototype.completeSuggestion = function (forceComplete) {\n    if (this.suggestionStore.hasSelectedSuggestion() && this.input.current) {\n      this.completeSelection(this.suggestionStore.currentSuggestion.item);\n    } else if (forceComplete) {\n      this._completeGenericSuggestion();\n    }\n  };\n  BasePicker.prototype.render = function () {\n    var _a, _b;\n    var _c = this.state,\n      suggestedDisplayValue = _c.suggestedDisplayValue,\n      isFocused = _c.isFocused,\n      items = _c.items;\n    var _d = this.props,\n      className = _d.className,\n      inputProps = _d.inputProps,\n      disabled = _d.disabled,\n      theme = _d.theme,\n      styles = _d.styles;\n    var suggestionsAvailable = this.state.suggestionsVisible ? this._ariaMap.suggestionList : '';\n    // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n    var classNames = styles ? getClassNames(styles, {\n      theme: theme,\n      className: className,\n      isFocused: isFocused,\n      disabled: disabled,\n      inputClassName: inputProps && inputProps.className\n    }) : {\n      root: css('ms-BasePicker', className ? className : ''),\n      text: css('ms-BasePicker-text', legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused),\n      itemsWrapper: legacyStyles.pickerItems,\n      input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n      screenReaderText: legacyStyles.screenReaderOnly\n    };\n    return React.createElement(\"div\", {\n      ref: this.root,\n      className: classNames.root,\n      onKeyDown: this.onKeyDown,\n      onBlur: this.onBlur\n    }, React.createElement(FocusZone, {\n      componentRef: this.focusZone,\n      direction: FocusZoneDirection.bidirectional,\n      shouldEnterInnerZone: this._shouldFocusZoneEnterInnerZone\n    }, this.getSuggestionsAlert(classNames.screenReaderText), React.createElement(SelectionZone, {\n      selection: this.selection,\n      selectionMode: SelectionMode.multiple\n    }, React.createElement(\"div\", {\n      className: classNames.text\n    }, items.length > 0 && React.createElement(\"span\", {\n      id: this._ariaMap.selectedItems,\n      className: classNames.itemsWrapper,\n      role: 'list'\n    }, this.renderItems()), this.canAddItems() && React.createElement(Autofill, __assign({\n      spellCheck: false\n    }, inputProps, {\n      className: classNames.input,\n      componentRef: this.input,\n      id: ((_a = inputProps) === null || _a === void 0 ? void 0 : _a.id) ? inputProps.id : this._ariaMap.combobox,\n      onClick: this.onClick,\n      onFocus: this.onInputFocus,\n      onBlur: this.onInputBlur,\n      onInputValueChange: this.onInputChange,\n      suggestedDisplayValue: suggestedDisplayValue,\n      \"aria-activedescendant\": this.getActiveDescendant(),\n      \"aria-controls\": suggestionsAvailable,\n      \"aria-describedby\": items.length > 0 ? this._ariaMap.selectedItems : undefined,\n      \"aria-expanded\": !!this.state.suggestionsVisible,\n      \"aria-haspopup\": \"listbox\",\n      \"aria-label\": this.props['aria-label'] || ((_b = inputProps) === null || _b === void 0 ? void 0 : _b['aria-label']),\n      role: \"combobox\",\n      disabled: disabled,\n      onInputChange: this.props.onInputChange\n    }))))), this.renderSuggestions());\n  };\n  BasePicker.prototype.canAddItems = function () {\n    var items = this.state.items;\n    var itemLimit = this.props.itemLimit;\n    return itemLimit === undefined || items.length < itemLimit;\n  };\n  BasePicker.prototype.renderSuggestions = function () {\n    var StyledTypedSuggestions = this._styledSuggestions;\n    return this.state.suggestionsVisible && this.input ? React.createElement(Callout, __assign({\n      isBeakVisible: false,\n      gapSpace: 5,\n      target: this.input.current ? this.input.current.inputElement : undefined,\n      onDismiss: this.dismissSuggestions,\n      directionalHint: DirectionalHint.bottomLeftEdge,\n      directionalHintForRTL: DirectionalHint.bottomRightEdge\n    }, this.props.pickerCalloutProps), React.createElement(StyledTypedSuggestions\n    // Assumed to set in derived component's defaultProps\n    , __assign({\n      // Assumed to set in derived component's defaultProps\n      onRenderSuggestion: this.props.onRenderSuggestionsItem,\n      onSuggestionClick: this.onSuggestionClick,\n      onSuggestionRemove: this.onSuggestionRemove,\n      suggestions: this.suggestionStore.getSuggestions(),\n      componentRef: this.suggestionElement,\n      onGetMoreResults: this.onGetMoreResults,\n      moreSuggestionsAvailable: this.state.moreSuggestionsAvailable,\n      isLoading: this.state.suggestionsLoading,\n      isSearching: this.state.isSearching,\n      isMostRecentlyUsedVisible: this.state.isMostRecentlyUsedVisible,\n      isResultsFooterVisible: this.state.isResultsFooterVisible,\n      refocusSuggestions: this.refocusSuggestions,\n      removeSuggestionAriaLabel: this.props.removeButtonAriaLabel,\n      suggestionsListId: this._ariaMap.suggestionList,\n      createGenericItem: this._completeGenericSuggestion\n    }, this.props.pickerSuggestionsProps))) : null;\n  };\n  BasePicker.prototype.renderItems = function () {\n    var _this = this;\n    var _a = this.props,\n      disabled = _a.disabled,\n      removeButtonAriaLabel = _a.removeButtonAriaLabel;\n    var onRenderItem = this.props.onRenderItem;\n    var _b = this.state,\n      items = _b.items,\n      selectedIndices = _b.selectedIndices;\n    return items.map(function (item, index) {\n      return onRenderItem({\n        item: item,\n        index: index,\n        key: item.key ? item.key : index,\n        selected: selectedIndices.indexOf(index) !== -1,\n        onRemoveItem: function () {\n          return _this.removeItem(item, true);\n        },\n        disabled: disabled,\n        onItemChange: _this.onItemChange,\n        removeButtonAriaLabel: removeButtonAriaLabel\n      });\n    });\n  };\n  BasePicker.prototype.resetFocus = function (index) {\n    var items = this.state.items;\n    if (items.length && index >= 0) {\n      var newEl = this.root.current && this.root.current.querySelectorAll('[data-selection-index]')[Math.min(index, items.length - 1)];\n      if (newEl && this.focusZone.current) {\n        this.focusZone.current.focusElement(newEl);\n      }\n    } else if (!this.canAddItems()) {\n      this.resetFocus(items.length - 1);\n    } else {\n      if (this.input.current) {\n        this.input.current.focus();\n      }\n    }\n  };\n  BasePicker.prototype.onSuggestionSelect = function () {\n    if (this.suggestionStore.currentSuggestion) {\n      var currentValue = this.input.current ? this.input.current.value : '';\n      var itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, currentValue);\n      this.setState({\n        suggestedDisplayValue: itemValue\n      });\n    }\n  };\n  BasePicker.prototype.onSelectionChange = function () {\n    this.setState({\n      selectedIndices: this.selection.getSelectedIndices()\n    });\n  };\n  BasePicker.prototype.updateSuggestions = function (suggestions) {\n    this.suggestionStore.updateSuggestions(suggestions, 0);\n    this.forceUpdate();\n  };\n  /**\n   * Only to be called when there is nothing in the input. Checks to see if the consumer has\n   * provided a function to resolve suggestions\n   */\n  BasePicker.prototype.onEmptyInputFocus = function () {\n    var emptyResolveSuggestions = this.props.onEmptyResolveSuggestions ? this.props.onEmptyResolveSuggestions :\n    // eslint-disable-next-line deprecation/deprecation\n    this.props.onEmptyInputFocus;\n    // Only attempt to resolve suggestions if it exists\n    if (emptyResolveSuggestions) {\n      var suggestions = emptyResolveSuggestions(this.state.items);\n      this.updateSuggestionsList(suggestions);\n      this.setState({\n        isMostRecentlyUsedVisible: true,\n        suggestionsVisible: true,\n        moreSuggestionsAvailable: false\n      });\n    }\n  };\n  BasePicker.prototype.updateValue = function (updatedValue) {\n    this._onResolveSuggestions(updatedValue);\n  };\n  BasePicker.prototype.updateSuggestionsList = function (suggestions, updatedValue) {\n    var _this = this;\n    var suggestionsArray = suggestions;\n    var suggestionsPromiseLike = suggestions;\n    // Check to see if the returned value is an array, if it is then just pass it into the next function .\n    // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n    // If it is then resolve it asynchronously.\n    if (Array.isArray(suggestionsArray)) {\n      this._updateAndResolveValue(updatedValue, suggestionsArray);\n    } else if (suggestionsPromiseLike && suggestionsPromiseLike.then) {\n      this.setState({\n        suggestionsLoading: true\n      });\n      // Clear suggestions\n      this.suggestionStore.updateSuggestions([]);\n      if (updatedValue !== undefined) {\n        this.setState({\n          suggestionsVisible: this._getShowSuggestions()\n        });\n      } else {\n        this.setState({\n          suggestionsVisible: this.input.current && this.input.current.inputElement === document.activeElement\n        });\n      }\n      // Ensure that the promise will only use the callback if it was the most recent one.\n      var promise_1 = this.currentPromise = suggestionsPromiseLike;\n      promise_1.then(function (newSuggestions) {\n        if (promise_1 === _this.currentPromise) {\n          _this._updateAndResolveValue(updatedValue, newSuggestions);\n        }\n      });\n    }\n  };\n  BasePicker.prototype.resolveNewValue = function (updatedValue, suggestions) {\n    var _this = this;\n    this.updateSuggestions(suggestions);\n    var itemValue = undefined;\n    if (this.suggestionStore.currentSuggestion) {\n      itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, updatedValue);\n    }\n    // Only set suggestionloading to false after there has been time for the new suggestions to flow\n    // to the suggestions list. This is to ensure that the suggestions are available before aria-activedescendant\n    // is set so that screen readers will read out the first selected option.\n    this.setState({\n      suggestedDisplayValue: itemValue,\n      suggestionsVisible: this._getShowSuggestions()\n    }, function () {\n      return _this.setState({\n        suggestionsLoading: false\n      });\n    });\n  };\n  BasePicker.prototype.onChange = function (items) {\n    if (this.props.onChange) {\n      this.props.onChange(items);\n    }\n  };\n  // This is protected because we may expect the backspace key to work differently in a different kind of picker.\n  // This lets the subclass override it and provide it's own onBackspace. For an example see the BasePickerListBelow\n  BasePicker.prototype.onBackspace = function (ev) {\n    if (this.state.items.length && !this.input.current || this.input.current && !this.input.current.isValueSelected && this.input.current.cursorLocation === 0) {\n      if (this.selection.getSelectedCount() > 0) {\n        this.removeItems(this.selection.getSelection());\n      } else {\n        this.removeItem(this.state.items[this.state.items.length - 1]);\n      }\n    }\n  };\n  BasePicker.prototype.getActiveDescendant = function () {\n    if (this.state.suggestionsLoading) {\n      return undefined;\n    }\n    var currentIndex = this.suggestionStore.currentIndex;\n    // if the suggestions element has actions and the currentIndex does not point to a suggestion, return the action id\n    if (currentIndex < 0 && this.suggestionElement.current && this.suggestionElement.current.hasSuggestedAction()) {\n      return 'sug-selectedAction';\n    }\n    return currentIndex > -1 && !this.state.suggestionsLoading ? 'sug-' + currentIndex : undefined;\n  };\n  BasePicker.prototype.getSuggestionsAlert = function (suggestionAlertClassName) {\n    if (suggestionAlertClassName === void 0) {\n      suggestionAlertClassName = legacyStyles.screenReaderOnly;\n    }\n    var currentIndex = this.suggestionStore.currentIndex;\n    if (this.props.enableSelectedSuggestionAlert) {\n      var selectedSuggestion = currentIndex > -1 ? this.suggestionStore.getSuggestionAtIndex(this.suggestionStore.currentIndex) : undefined;\n      var selectedSuggestionAlertText = selectedSuggestion ? selectedSuggestion.ariaLabel : undefined;\n      return React.createElement(\"div\", {\n        className: suggestionAlertClassName,\n        role: \"alert\",\n        id: this._ariaMap.selectedSuggestionAlert,\n        \"aria-live\": \"assertive\"\n      }, selectedSuggestionAlertText, ' ');\n    }\n  };\n  /**\n   * Takes in the current updated value and either resolves it with the new suggestions\n   * or if updated value is undefined then it clears out currently suggested items\n   */\n  BasePicker.prototype._updateAndResolveValue = function (updatedValue, newSuggestions) {\n    if (updatedValue !== undefined) {\n      this.resolveNewValue(updatedValue, newSuggestions);\n    } else {\n      this.suggestionStore.updateSuggestions(newSuggestions, -1);\n      if (this.state.suggestionsLoading) {\n        this.setState({\n          suggestionsLoading: false\n        });\n      }\n    }\n  };\n  /**\n   * Controls what happens whenever there is an action that impacts the selected items.\n   * If `selectedItems` is provided, this will act as a controlled component and it will not update its own state.\n   */\n  BasePicker.prototype._updateSelectedItems = function (items) {\n    var _this = this;\n    if (this.props.selectedItems) {\n      // If the component is a controlled component then the controlling component will need to add or remove the items.\n      this.onChange(items);\n    } else {\n      this.setState({\n        items: items\n      }, function () {\n        _this._onSelectedItemsUpdated(items);\n      });\n    }\n  };\n  BasePicker.prototype._onSelectedItemsUpdated = function (items) {\n    this.onChange(items);\n  };\n  /**\n   * Suggestions are normally shown after the user updates text and the text\n   * is non-empty, but also when the user clicks on the input element.\n   * @returns True if suggestions should be shown.\n   */\n  BasePicker.prototype._getShowSuggestions = function () {\n    var areSuggestionsVisible = this.input.current !== undefined && this.input.current !== null && this.input.current.inputElement === document.activeElement && this.input.current.value !== '';\n    return areSuggestionsVisible;\n  };\n  BasePicker.prototype._getTextFromItem = function (item, currentValue) {\n    if (this.props.getTextFromItem) {\n      return this.props.getTextFromItem(item, currentValue);\n    } else {\n      return '';\n    }\n  };\n  return BasePicker;\n}(React.Component);\nexport { BasePicker };\nvar BasePickerListBelow = /** @class */function (_super) {\n  __extends(BasePickerListBelow, _super);\n  function BasePickerListBelow() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  BasePickerListBelow.prototype.render = function () {\n    var _a = this.state,\n      suggestedDisplayValue = _a.suggestedDisplayValue,\n      isFocused = _a.isFocused;\n    var _b = this.props,\n      className = _b.className,\n      inputProps = _b.inputProps,\n      disabled = _b.disabled,\n      theme = _b.theme,\n      styles = _b.styles;\n    var suggestionsAvailable = this.state.suggestionsVisible ? this._ariaMap.suggestionList : '';\n    // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n    var classNames = styles ? getClassNames(styles, {\n      theme: theme,\n      className: className,\n      isFocused: isFocused,\n      inputClassName: inputProps && inputProps.className\n    }) : {\n      root: css('ms-BasePicker', className ? className : ''),\n      text: css('ms-BasePicker-text', legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused, disabled && legacyStyles.inputDisabled),\n      input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n      screenReaderText: legacyStyles.screenReaderOnly\n    };\n    return React.createElement(\"div\", {\n      ref: this.root,\n      onBlur: this.onBlur\n    }, React.createElement(\"div\", {\n      className: classNames.root,\n      onKeyDown: this.onKeyDown\n    }, this.getSuggestionsAlert(classNames.screenReaderText), React.createElement(\"div\", {\n      className: classNames.text\n    }, React.createElement(Autofill, __assign({}, inputProps, {\n      className: classNames.input,\n      componentRef: this.input,\n      onFocus: this.onInputFocus,\n      onBlur: this.onInputBlur,\n      onClick: this.onClick,\n      onInputValueChange: this.onInputChange,\n      suggestedDisplayValue: suggestedDisplayValue,\n      \"aria-activedescendant\": this.getActiveDescendant(),\n      \"aria-controls\": suggestionsAvailable || undefined,\n      \"aria-expanded\": !!this.state.suggestionsVisible,\n      \"aria-haspopup\": \"listbox\",\n      role: \"combobox\",\n      disabled: disabled,\n      onInputChange: this.props.onInputChange\n    })))), this.renderSuggestions(), React.createElement(SelectionZone, {\n      selection: this.selection,\n      selectionMode: SelectionMode.single\n    }, React.createElement(FocusZone, {\n      componentRef: this.focusZone,\n      className: \"ms-BasePicker-selectedItems\" // just a className hook without any styles applied to it.\n      ,\n      isCircularNavigation: true,\n      direction: FocusZoneDirection.bidirectional,\n      shouldEnterInnerZone: this._shouldFocusZoneEnterInnerZone,\n      id: this._ariaMap.selectedItems,\n      role: 'list'\n    }, this.renderItems())));\n  };\n  BasePickerListBelow.prototype.onBackspace = function (ev) {\n    // override the existing backspace method to not do anything because the list items appear below.\n  };\n  return BasePickerListBelow;\n}(BasePicker);\nexport { BasePickerListBelow };","map":{"version":3,"sources":["components/pickers/BasePicker.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  KeyCodes,\n  css,\n  elementContains,\n  getId,\n  classNamesFunction,\n  styled,\n  initializeComponentRef,\n} from '../../Utilities';\nimport { IProcessedStyleSet } from '../../Styling';\nimport { IFocusZone, FocusZone, FocusZoneDirection } from '../../FocusZone';\nimport { Callout, DirectionalHint } from '../../Callout';\nimport { Selection, SelectionZone, SelectionMode } from '../../utilities/selection/index';\nimport { Suggestions } from './Suggestions/Suggestions';\nimport {\n  ISuggestions,\n  ISuggestionsProps,\n  ISuggestionsStyleProps,\n  ISuggestionsStyles,\n} from './Suggestions/Suggestions.types';\nimport { getStyles as suggestionsStyles } from './Suggestions/Suggestions.styles';\nimport { SuggestionsController } from './Suggestions/SuggestionsController';\nimport {\n  IBasePicker,\n  IBasePickerProps,\n  ValidationState,\n  IBasePickerStyleProps,\n  IBasePickerStyles,\n} from './BasePicker.types';\nimport { IAutofill, Autofill } from '../Autofill/index';\nimport { IPickerItemProps } from './PickerItem.types';\nimport * as stylesImport from './BasePicker.scss';\nconst legacyStyles: any = stylesImport;\n\nexport interface IBasePickerState {\n  items?: any;\n  suggestedDisplayValue?: string;\n  moreSuggestionsAvailable?: boolean;\n  isFocused?: boolean;\n  isSearching?: boolean;\n  isMostRecentlyUsedVisible?: boolean;\n  suggestionsVisible?: boolean;\n  suggestionsLoading?: boolean;\n  isResultsFooterVisible?: boolean;\n  selectedIndices?: number[];\n}\n\n/**\n * Aria id's for internal picker components\n * {@docCategory Pickers}\n */\nexport type IPickerAriaIds = {\n  /**\n   * Aria id for selected suggestion alert component\n   */\n  selectedSuggestionAlert: string;\n  /**\n   * Aria id for selected items container component\n   */\n  selectedItems: string;\n  /**\n   * Aria id for suggestions list component\n   */\n  suggestionList: string;\n  /**\n   * Aria id for the component that has role=combobox\n   */\n  combobox: string;\n};\n\nconst getClassNames = classNamesFunction<IBasePickerStyleProps, IBasePickerStyles>();\n\n/**\n * Should be removed once new picker without inheritance is created\n */\nfunction getStyledSuggestions<T>(suggestionsType: new (props: ISuggestionsProps<T>) => Suggestions<T>) {\n  return styled<ISuggestionsProps<any>, ISuggestionsStyleProps, ISuggestionsStyles>(\n    suggestionsType,\n    suggestionsStyles,\n    undefined,\n    {\n      scope: 'Suggestions',\n    },\n  );\n}\n\n/**\n * {@docCategory Pickers}\n */\nexport class BasePicker<T, P extends IBasePickerProps<T>> extends React.Component<P, IBasePickerState>\n  implements IBasePicker<T> {\n  // Refs\n  protected root = React.createRef<HTMLDivElement>();\n  protected input = React.createRef<IAutofill>();\n  protected focusZone = React.createRef<IFocusZone>();\n  protected suggestionElement = React.createRef<ISuggestions<T>>();\n\n  protected selection: Selection;\n  protected suggestionStore: SuggestionsController<T>;\n  /**\n   * @deprecated this is no longer necessary as typescript now supports generic elements\n   */\n  protected SuggestionOfProperType = Suggestions as new (props: ISuggestionsProps<T>) => Suggestions<T>;\n  protected currentPromise: PromiseLike<any> | undefined;\n  protected _ariaMap: IPickerAriaIds;\n  // eslint-disable-next-line deprecation/deprecation\n  private _styledSuggestions = getStyledSuggestions(this.SuggestionOfProperType);\n  private _id: string;\n  private _async: Async;\n\n  public static getDerivedStateFromProps(newProps: IBasePickerProps<any>) {\n    if (newProps.selectedItems) {\n      return { items: newProps.selectedItems };\n    }\n    return null;\n  }\n\n  constructor(basePickerProps: P) {\n    super(basePickerProps);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n\n    const items: T[] = basePickerProps.selectedItems || basePickerProps.defaultSelectedItems || [];\n\n    this._id = getId();\n    this._ariaMap = {\n      selectedItems: `selected-items-${this._id}`,\n      selectedSuggestionAlert: `selected-suggestion-alert-${this._id}`,\n      suggestionList: `suggestion-list-${this._id}`,\n      combobox: `combobox-${this._id}`,\n    };\n    this.suggestionStore = new SuggestionsController<T>();\n    this.selection = new Selection({ onSelectionChanged: () => this.onSelectionChange() });\n    this.selection.setItems(items);\n    this.state = {\n      items: items,\n      suggestedDisplayValue: '',\n      isMostRecentlyUsedVisible: false,\n      moreSuggestionsAvailable: false,\n      isFocused: false,\n      isSearching: false,\n      selectedIndices: [],\n    };\n  }\n\n  public get items(): T[] {\n    return this.state.items;\n  }\n\n  public componentDidMount(): void {\n    this.selection.setItems(this.state.items);\n    this._onResolveSuggestions = this._async.debounce(this._onResolveSuggestions, this.props.resolveDelay);\n  }\n\n  public componentDidUpdate(oldProps: P, oldState: IBasePickerState) {\n    if (this.state.items && this.state.items !== oldState.items) {\n      const currentSelectedIndex = this.selection.getSelectedIndices()[0];\n      this.selection.setItems(this.state.items);\n      if (this.state.isFocused) {\n        // Reset focus and selection so that selected item stays in sync if something\n        // has been removed\n        if (this.state.items.length < oldState.items.length) {\n          this.selection.setIndexSelected(currentSelectedIndex, true, true);\n          this.resetFocus(currentSelectedIndex);\n        }\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    if (this.currentPromise) {\n      this.currentPromise = undefined;\n    }\n    this._async.dispose();\n  }\n\n  public focus() {\n    if (this.focusZone.current) {\n      this.focusZone.current.focus();\n    }\n  }\n\n  public focusInput() {\n    if (this.input.current) {\n      this.input.current.focus();\n    }\n  }\n\n  public dismissSuggestions = (ev?: any): void => {\n    const selectItemFunction = () => {\n      let addItemOnDismiss: boolean | void = true;\n      if (this.props.onDismiss) {\n        addItemOnDismiss = this.props.onDismiss(\n          ev,\n          this.suggestionStore.currentSuggestion ? this.suggestionStore.currentSuggestion.item : undefined,\n        );\n      }\n\n      if (!ev || (ev && !ev.defaultPrevented)) {\n        // Select the first suggestion if one is available and permitted by onDismiss when user leaves.\n        if (\n          addItemOnDismiss !== false &&\n          this.canAddItems() &&\n          this.suggestionStore.hasSelectedSuggestion() &&\n          this.state.suggestedDisplayValue\n        ) {\n          this.addItemByIndex(0);\n        }\n      }\n    };\n\n    if (this.currentPromise) {\n      this.currentPromise.then(() => selectItemFunction());\n    } else {\n      selectItemFunction();\n    }\n\n    this.setState({ suggestionsVisible: false });\n  };\n\n  public completeSuggestion(forceComplete?: boolean) {\n    if (this.suggestionStore.hasSelectedSuggestion() && this.input.current) {\n      this.completeSelection(this.suggestionStore.currentSuggestion!.item);\n    } else if (forceComplete) {\n      this._completeGenericSuggestion();\n    }\n  }\n\n  public refocusSuggestions = (keyCode: KeyCodes): void => {\n    this.resetFocus();\n    if (this.suggestionStore.suggestions && this.suggestionStore.suggestions.length > 0) {\n      if (keyCode === KeyCodes.up) {\n        this.suggestionStore.setSelectedSuggestion(this.suggestionStore.suggestions.length - 1);\n      } else if (keyCode === KeyCodes.down) {\n        this.suggestionStore.setSelectedSuggestion(0);\n      }\n    }\n  };\n\n  public render(): JSX.Element {\n    const { suggestedDisplayValue, isFocused, items } = this.state;\n    const { className, inputProps, disabled, theme, styles } = this.props;\n    const suggestionsAvailable = this.state.suggestionsVisible ? this._ariaMap.suggestionList : '';\n    // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n    const classNames: Partial<IProcessedStyleSet<IBasePickerStyles>> = styles\n      ? getClassNames(styles, {\n          theme,\n          className,\n          isFocused,\n          disabled,\n          inputClassName: inputProps && inputProps.className,\n        })\n      : {\n          root: css('ms-BasePicker', className ? className : ''),\n          text: css('ms-BasePicker-text', legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused),\n          itemsWrapper: legacyStyles.pickerItems,\n          input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n          screenReaderText: legacyStyles.screenReaderOnly,\n        };\n\n    return (\n      <div ref={this.root} className={classNames.root} onKeyDown={this.onKeyDown} onBlur={this.onBlur}>\n        <FocusZone\n          componentRef={this.focusZone}\n          direction={FocusZoneDirection.bidirectional}\n          shouldEnterInnerZone={this._shouldFocusZoneEnterInnerZone}\n        >\n          {this.getSuggestionsAlert(classNames.screenReaderText)}\n          <SelectionZone selection={this.selection} selectionMode={SelectionMode.multiple}>\n            <div className={classNames.text}>\n              {items.length > 0 && (\n                <span id={this._ariaMap.selectedItems} className={classNames.itemsWrapper} role={'list'}>\n                  {this.renderItems()}\n                </span>\n              )}\n              {this.canAddItems() && (\n                <Autofill\n                  spellCheck={false}\n                  {...(inputProps as any)}\n                  className={classNames.input}\n                  componentRef={this.input}\n                  id={inputProps?.id ? inputProps.id : this._ariaMap.combobox}\n                  onClick={this.onClick}\n                  onFocus={this.onInputFocus}\n                  onBlur={this.onInputBlur}\n                  onInputValueChange={this.onInputChange}\n                  suggestedDisplayValue={suggestedDisplayValue}\n                  aria-activedescendant={this.getActiveDescendant()}\n                  aria-controls={suggestionsAvailable}\n                  aria-describedby={items.length > 0 ? this._ariaMap.selectedItems : undefined}\n                  aria-expanded={!!this.state.suggestionsVisible}\n                  aria-haspopup=\"listbox\"\n                  aria-label={this.props['aria-label'] || inputProps?.['aria-label']}\n                  role=\"combobox\"\n                  disabled={disabled}\n                  onInputChange={this.props.onInputChange}\n                />\n              )}\n            </div>\n          </SelectionZone>\n        </FocusZone>\n        {this.renderSuggestions()}\n      </div>\n    );\n  }\n\n  protected canAddItems(): boolean {\n    const { items } = this.state;\n    const { itemLimit } = this.props;\n    return itemLimit === undefined || items.length < itemLimit;\n  }\n\n  protected renderSuggestions(): JSX.Element | null {\n    const StyledTypedSuggestions: React.FunctionComponent<ISuggestionsProps<T>> = this._styledSuggestions;\n\n    return this.state.suggestionsVisible && this.input ? (\n      <Callout\n        isBeakVisible={false}\n        gapSpace={5}\n        target={this.input.current ? this.input.current.inputElement : undefined}\n        onDismiss={this.dismissSuggestions}\n        directionalHint={DirectionalHint.bottomLeftEdge}\n        directionalHintForRTL={DirectionalHint.bottomRightEdge}\n        {...this.props.pickerCalloutProps}\n      >\n        <StyledTypedSuggestions\n          // Assumed to set in derived component's defaultProps\n          onRenderSuggestion={this.props.onRenderSuggestionsItem!}\n          onSuggestionClick={this.onSuggestionClick}\n          onSuggestionRemove={this.onSuggestionRemove}\n          suggestions={this.suggestionStore.getSuggestions()}\n          componentRef={this.suggestionElement}\n          onGetMoreResults={this.onGetMoreResults}\n          moreSuggestionsAvailable={this.state.moreSuggestionsAvailable}\n          isLoading={this.state.suggestionsLoading}\n          isSearching={this.state.isSearching}\n          isMostRecentlyUsedVisible={this.state.isMostRecentlyUsedVisible}\n          isResultsFooterVisible={this.state.isResultsFooterVisible}\n          refocusSuggestions={this.refocusSuggestions}\n          removeSuggestionAriaLabel={this.props.removeButtonAriaLabel}\n          suggestionsListId={this._ariaMap.suggestionList}\n          createGenericItem={this._completeGenericSuggestion}\n          {...this.props.pickerSuggestionsProps}\n        />\n      </Callout>\n    ) : null;\n  }\n\n  protected renderItems(): JSX.Element[] {\n    const { disabled, removeButtonAriaLabel } = this.props;\n    const onRenderItem = this.props.onRenderItem as (props: IPickerItemProps<T>) => JSX.Element;\n\n    const { items, selectedIndices } = this.state;\n    return items.map((item: any, index: number) =>\n      onRenderItem({\n        item,\n        index,\n        key: item.key ? item.key : index,\n        selected: selectedIndices!.indexOf(index) !== -1,\n        onRemoveItem: () => this.removeItem(item, true),\n        disabled: disabled,\n        onItemChange: this.onItemChange,\n        removeButtonAriaLabel: removeButtonAriaLabel,\n      }),\n    );\n  }\n\n  protected resetFocus(index?: number) {\n    const { items } = this.state;\n\n    if (items.length && index! >= 0) {\n      const newEl: HTMLElement | null =\n        this.root.current &&\n        (this.root.current.querySelectorAll('[data-selection-index]')[\n          Math.min(index!, items.length - 1)\n        ] as HTMLElement | null);\n      if (newEl && this.focusZone.current) {\n        this.focusZone.current.focusElement(newEl);\n      }\n    } else if (!this.canAddItems()) {\n      this.resetFocus(items.length - 1);\n    } else {\n      if (this.input.current) {\n        this.input.current.focus();\n      }\n    }\n  }\n\n  protected onSuggestionSelect() {\n    if (this.suggestionStore.currentSuggestion) {\n      const currentValue: string = this.input.current ? this.input.current.value : '';\n      const itemValue: string = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, currentValue);\n      this.setState({ suggestedDisplayValue: itemValue });\n    }\n  }\n\n  protected onSelectionChange() {\n    this.setState({\n      selectedIndices: this.selection.getSelectedIndices(),\n    });\n  }\n\n  protected updateSuggestions(suggestions: any[]) {\n    this.suggestionStore.updateSuggestions(suggestions, 0);\n    this.forceUpdate();\n  }\n\n  /**\n   * Only to be called when there is nothing in the input. Checks to see if the consumer has\n   * provided a function to resolve suggestions\n   */\n  protected onEmptyInputFocus() {\n    const emptyResolveSuggestions = this.props.onEmptyResolveSuggestions\n      ? this.props.onEmptyResolveSuggestions\n      : // eslint-disable-next-line deprecation/deprecation\n        this.props.onEmptyInputFocus;\n\n    // Only attempt to resolve suggestions if it exists\n    if (emptyResolveSuggestions) {\n      const suggestions = emptyResolveSuggestions(this.state.items);\n\n      this.updateSuggestionsList(suggestions);\n\n      this.setState({\n        isMostRecentlyUsedVisible: true,\n        suggestionsVisible: true,\n        moreSuggestionsAvailable: false,\n      });\n    }\n  }\n\n  protected updateValue(updatedValue: string) {\n    this._onResolveSuggestions(updatedValue);\n  }\n\n  protected updateSuggestionsList(suggestions: T[] | PromiseLike<T[]>, updatedValue?: string) {\n    const suggestionsArray: T[] = suggestions as T[];\n    const suggestionsPromiseLike: PromiseLike<T[]> = suggestions as PromiseLike<T[]>;\n\n    // Check to see if the returned value is an array, if it is then just pass it into the next function .\n    // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n    // If it is then resolve it asynchronously.\n    if (Array.isArray(suggestionsArray)) {\n      this._updateAndResolveValue(updatedValue, suggestionsArray);\n    } else if (suggestionsPromiseLike && suggestionsPromiseLike.then) {\n      this.setState({\n        suggestionsLoading: true,\n      });\n\n      // Clear suggestions\n      this.suggestionStore.updateSuggestions([]);\n\n      if (updatedValue !== undefined) {\n        this.setState({\n          suggestionsVisible: this._getShowSuggestions(),\n        });\n      } else {\n        this.setState({\n          suggestionsVisible: this.input.current! && this.input.current!.inputElement === document.activeElement,\n        });\n      }\n\n      // Ensure that the promise will only use the callback if it was the most recent one.\n      const promise: PromiseLike<T[]> = (this.currentPromise = suggestionsPromiseLike);\n      promise.then((newSuggestions: T[]) => {\n        if (promise === this.currentPromise) {\n          this._updateAndResolveValue(updatedValue, newSuggestions);\n        }\n      });\n    }\n  }\n\n  protected resolveNewValue(updatedValue: string, suggestions: T[]) {\n    this.updateSuggestions(suggestions);\n    let itemValue: string | undefined = undefined;\n\n    if (this.suggestionStore.currentSuggestion) {\n      itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, updatedValue);\n    }\n\n    // Only set suggestionloading to false after there has been time for the new suggestions to flow\n    // to the suggestions list. This is to ensure that the suggestions are available before aria-activedescendant\n    // is set so that screen readers will read out the first selected option.\n    this.setState(\n      {\n        suggestedDisplayValue: itemValue,\n        suggestionsVisible: this._getShowSuggestions(),\n      },\n      () => this.setState({ suggestionsLoading: false }),\n    );\n  }\n\n  protected onChange(items?: T[]) {\n    if (this.props.onChange) {\n      (this.props.onChange as any)(items);\n    }\n  }\n\n  protected onInputChange = (value: string): void => {\n    this.updateValue(value);\n    this.setState({\n      moreSuggestionsAvailable: true,\n      isMostRecentlyUsedVisible: false,\n    });\n  };\n\n  protected onSuggestionClick = (ev: React.MouseEvent<HTMLElement>, item: any, index: number): void => {\n    this.addItemByIndex(index);\n  };\n\n  protected onSuggestionRemove = (ev: React.MouseEvent<HTMLElement>, item: T, index: number): void => {\n    if (this.props.onRemoveSuggestion) {\n      this.props.onRemoveSuggestion(item);\n    }\n    this.suggestionStore.removeSuggestion(index);\n  };\n\n  protected onInputFocus = (ev: React.FocusEvent<HTMLInputElement | Autofill>): void => {\n    this.selection.setAllSelected(false);\n    // Only trigger all of the focus if this component isn't already focused.\n    // For example when an item is selected or removed from the selected list it should be treated\n    // as though the input is still focused.\n    if (!this.state.isFocused) {\n      this.setState({ isFocused: true });\n\n      this._userTriggeredSuggestions();\n\n      if (this.props.inputProps && this.props.inputProps.onFocus) {\n        this.props.inputProps.onFocus(ev as React.FocusEvent<HTMLInputElement>);\n      }\n    }\n  };\n\n  protected onInputBlur = (ev: React.FocusEvent<HTMLInputElement | Autofill>): void => {\n    if (this.props.inputProps && this.props.inputProps.onBlur) {\n      this.props.inputProps.onBlur(ev as React.FocusEvent<HTMLInputElement>);\n    }\n  };\n\n  protected onBlur = (ev: React.FocusEvent<HTMLElement | Autofill>): void => {\n    if (this.state.isFocused) {\n      // Only blur the entire component if an unrelated element gets focus.\n      // Otherwise treat it as though it still has focus.\n      // Do nothing if the blur is coming from something\n      // inside the comboBox root or the comboBox menu since\n      // it we are not really bluring from the whole comboBox\n      let relatedTarget: EventTarget | null = ev.relatedTarget;\n\n      if (ev.relatedTarget === null) {\n        // In IE11, due to lack of support, event.relatedTarget is always\n        // null making every onBlur call to be \"outside\" of the ComboBox\n        // even when it's not. Using document.activeElement is another way\n        // for us to be able to get what the relatedTarget without relying\n        // on the event\n        relatedTarget = document.activeElement;\n      }\n      if (relatedTarget && !elementContains(this.root.current!, relatedTarget as HTMLElement)) {\n        this.setState({ isFocused: false });\n        if (this.props.onBlur) {\n          this.props.onBlur(ev as React.FocusEvent<HTMLInputElement>);\n        }\n      }\n    }\n  };\n\n  /**\n   * Reveals suggestions any time the user clicks on the input element\n   * without shifting focus.\n   */\n  protected onClick = (ev: React.MouseEvent<HTMLInputElement>): void => {\n    if (this.props.inputProps !== undefined && this.props.inputProps.onClick !== undefined) {\n      this.props.inputProps.onClick(ev);\n    }\n\n    // Only primary (left) clicks show suggestions.\n    if (ev.button === 0) {\n      this._userTriggeredSuggestions();\n    }\n  };\n\n  protected onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    const keyCode = ev.which;\n    switch (keyCode) {\n      case KeyCodes.escape:\n        if (this.state.suggestionsVisible) {\n          this.setState({ suggestionsVisible: false });\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n        break;\n\n      case KeyCodes.tab:\n      case KeyCodes.enter:\n        if (this.suggestionElement.current && this.suggestionElement.current.hasSuggestedActionSelected()) {\n          this.suggestionElement.current.executeSelectedAction();\n        } else if (!ev.shiftKey && this.suggestionStore.hasSelectedSuggestion() && this.state.suggestionsVisible) {\n          this.completeSuggestion();\n          ev.preventDefault();\n          ev.stopPropagation();\n        } else {\n          this._completeGenericSuggestion();\n        }\n\n        break;\n\n      case KeyCodes.backspace:\n        if (!this.props.disabled) {\n          this.onBackspace(ev);\n        }\n        ev.stopPropagation();\n        break;\n\n      case KeyCodes.del:\n        if (!this.props.disabled) {\n          if (\n            this.input.current &&\n            ev.target === this.input.current.inputElement &&\n            this.state.suggestionsVisible &&\n            this.suggestionStore.currentIndex !== -1\n          ) {\n            if (this.props.onRemoveSuggestion) {\n              this.props.onRemoveSuggestion(this.suggestionStore.currentSuggestion!.item);\n            }\n            this.suggestionStore.removeSuggestion(this.suggestionStore.currentIndex);\n            this.forceUpdate();\n          } else {\n            this.onBackspace(ev);\n          }\n        }\n        ev.stopPropagation();\n        break;\n\n      case KeyCodes.up:\n        if (this.input.current && ev.target === this.input.current.inputElement && this.state.suggestionsVisible) {\n          if (\n            this.suggestionElement.current &&\n            this.suggestionElement.current.tryHandleKeyDown(keyCode, this.suggestionStore.currentIndex)\n          ) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            this.forceUpdate();\n          } else {\n            if (\n              this.suggestionElement.current &&\n              this.suggestionElement.current.hasSuggestedAction() &&\n              this.suggestionStore.currentIndex === 0\n            ) {\n              ev.preventDefault();\n              ev.stopPropagation();\n              this.suggestionElement.current.focusAboveSuggestions();\n              this.suggestionStore.deselectAllSuggestions();\n              this.forceUpdate();\n            } else {\n              if (this.suggestionStore.previousSuggestion()) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                this.onSuggestionSelect();\n              }\n            }\n          }\n        }\n        break;\n\n      case KeyCodes.down:\n        if (this.input.current && ev.target === this.input.current.inputElement && this.state.suggestionsVisible) {\n          if (\n            this.suggestionElement.current &&\n            this.suggestionElement.current.tryHandleKeyDown(keyCode, this.suggestionStore.currentIndex)\n          ) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            this.forceUpdate();\n          } else {\n            if (\n              this.suggestionElement.current &&\n              this.suggestionElement.current.hasSuggestedAction() &&\n              this.suggestionStore.currentIndex + 1 === this.suggestionStore.suggestions.length\n            ) {\n              ev.preventDefault();\n              ev.stopPropagation();\n              this.suggestionElement.current.focusBelowSuggestions();\n              this.suggestionStore.deselectAllSuggestions();\n              this.forceUpdate();\n            } else {\n              if (this.suggestionStore.nextSuggestion()) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                this.onSuggestionSelect();\n              }\n            }\n          }\n        }\n        break;\n    }\n  };\n\n  protected onItemChange = (changedItem: T, index: number): void => {\n    const { items } = this.state;\n\n    if (index >= 0) {\n      const newItems: T[] = items;\n      newItems[index] = changedItem;\n\n      this._updateSelectedItems(newItems);\n    }\n  };\n\n  protected onGetMoreResults = (): void => {\n    this.setState(\n      {\n        isSearching: true,\n      },\n      () => {\n        if (this.props.onGetMoreResults && this.input.current) {\n          const suggestions: T[] | PromiseLike<T[]> = (this.props.onGetMoreResults as any)(\n            this.input.current.value,\n            this.state.items,\n          );\n          const suggestionsArray: T[] = suggestions as T[];\n          const suggestionsPromiseLike: PromiseLike<T[]> = suggestions as PromiseLike<T[]>;\n\n          if (Array.isArray(suggestionsArray)) {\n            this.updateSuggestions(suggestionsArray);\n            this.setState({ isSearching: false });\n          } else if (suggestionsPromiseLike.then) {\n            suggestionsPromiseLike.then((newSuggestions: T[]) => {\n              this.updateSuggestions(newSuggestions);\n              this.setState({ isSearching: false });\n            });\n          }\n        } else {\n          this.setState({ isSearching: false });\n        }\n\n        if (this.input.current) {\n          this.input.current.focus();\n        }\n\n        this.setState({\n          moreSuggestionsAvailable: false,\n          isResultsFooterVisible: true,\n        });\n      },\n    );\n  };\n\n  protected completeSelection = (item: T) => {\n    this.addItem(item);\n    this.updateValue('');\n    if (this.input.current) {\n      this.input.current.clear();\n    }\n    this.setState({ suggestionsVisible: false });\n  };\n\n  protected addItemByIndex = (index: number): void => {\n    this.completeSelection(this.suggestionStore.getSuggestionAtIndex(index).item);\n  };\n\n  protected addItem = (item: T): void => {\n    const processedItem: T | PromiseLike<T> | null = this.props.onItemSelected\n      ? (this.props.onItemSelected as any)(item)\n      : item;\n\n    if (processedItem === null) {\n      return;\n    }\n\n    const processedItemObject: T = processedItem as T;\n    const processedItemPromiseLike: PromiseLike<T> = processedItem as PromiseLike<T>;\n\n    if (processedItemPromiseLike && processedItemPromiseLike.then) {\n      processedItemPromiseLike.then((resolvedProcessedItem: T) => {\n        const newItems: T[] = this.state.items.concat([resolvedProcessedItem]);\n        this._updateSelectedItems(newItems);\n      });\n    } else {\n      const newItems: T[] = this.state.items.concat([processedItemObject]);\n      this._updateSelectedItems(newItems);\n    }\n    this.setState({ suggestedDisplayValue: '' });\n  };\n\n  protected removeItem = (item: IPickerItemProps<T>, focusNextItem?: boolean): void => {\n    const { items } = this.state;\n    const index: number = items.indexOf(item);\n\n    if (index >= 0) {\n      const newItems: T[] = items.slice(0, index).concat(items.slice(index + 1));\n      this._updateSelectedItems(newItems);\n    }\n  };\n\n  protected removeItems = (itemsToRemove: any[]): void => {\n    const { items } = this.state;\n    const newItems: T[] = items.filter((item: any) => itemsToRemove.indexOf(item) === -1);\n\n    this._updateSelectedItems(newItems);\n  };\n\n  // This is protected because we may expect the backspace key to work differently in a different kind of picker.\n  // This lets the subclass override it and provide it's own onBackspace. For an example see the BasePickerListBelow\n  protected onBackspace(ev: React.KeyboardEvent<HTMLElement>) {\n    if (\n      (this.state.items.length && !this.input.current) ||\n      (this.input.current && !this.input.current.isValueSelected && this.input.current.cursorLocation === 0)\n    ) {\n      if (this.selection.getSelectedCount() > 0) {\n        this.removeItems(this.selection.getSelection());\n      } else {\n        this.removeItem(this.state.items[this.state.items.length - 1]);\n      }\n    }\n  }\n\n  protected _shouldFocusZoneEnterInnerZone = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    // If suggestions are shown const up/down keys control them, otherwise allow them through to control the focusZone.\n    if (this.state.suggestionsVisible) {\n      switch (ev.which) {\n        case KeyCodes.up:\n        case KeyCodes.down:\n          return true;\n      }\n    }\n\n    if (ev.which === KeyCodes.enter) {\n      return true;\n    }\n\n    return false;\n  };\n\n  protected getActiveDescendant() {\n    if (this.state.suggestionsLoading) {\n      return undefined;\n    }\n\n    const currentIndex = this.suggestionStore.currentIndex;\n    // if the suggestions element has actions and the currentIndex does not point to a suggestion, return the action id\n    if (currentIndex < 0 && this.suggestionElement.current && this.suggestionElement.current.hasSuggestedAction()) {\n      return 'sug-selectedAction';\n    }\n\n    return currentIndex > -1 && !this.state.suggestionsLoading ? 'sug-' + currentIndex : undefined;\n  }\n\n  protected getSuggestionsAlert(suggestionAlertClassName: string = legacyStyles.screenReaderOnly) {\n    const currentIndex = this.suggestionStore.currentIndex;\n    if (this.props.enableSelectedSuggestionAlert) {\n      const selectedSuggestion =\n        currentIndex > -1 ? this.suggestionStore.getSuggestionAtIndex(this.suggestionStore.currentIndex) : undefined;\n      const selectedSuggestionAlertText = selectedSuggestion ? selectedSuggestion.ariaLabel : undefined;\n      return (\n        <div\n          className={suggestionAlertClassName}\n          role=\"alert\"\n          id={this._ariaMap.selectedSuggestionAlert}\n          aria-live=\"assertive\"\n        >\n          {selectedSuggestionAlertText}{' '}\n        </div>\n      );\n    }\n  }\n\n  /**\n   * Takes in the current updated value and either resolves it with the new suggestions\n   * or if updated value is undefined then it clears out currently suggested items\n   */\n  private _updateAndResolveValue(updatedValue: string | undefined, newSuggestions: T[]) {\n    if (updatedValue !== undefined) {\n      this.resolveNewValue(updatedValue, newSuggestions);\n    } else {\n      this.suggestionStore.updateSuggestions(newSuggestions, -1);\n      if (this.state.suggestionsLoading) {\n        this.setState({\n          suggestionsLoading: false,\n        });\n      }\n    }\n  }\n\n  /**\n   * Controls what happens whenever there is an action that impacts the selected items.\n   * If `selectedItems` is provided, this will act as a controlled component and it will not update its own state.\n   */\n  private _updateSelectedItems(items: T[]): void {\n    if (this.props.selectedItems) {\n      // If the component is a controlled component then the controlling component will need to add or remove the items.\n      this.onChange(items);\n    } else {\n      this.setState({ items: items }, () => {\n        this._onSelectedItemsUpdated(items);\n      });\n    }\n  }\n\n  private _onSelectedItemsUpdated(items?: T[]): void {\n    this.onChange(items);\n  }\n\n  /**\n   * Suggestions are normally shown after the user updates text and the text\n   * is non-empty, but also when the user clicks on the input element.\n   * @returns True if suggestions should be shown.\n   */\n  private _getShowSuggestions(): boolean {\n    const areSuggestionsVisible =\n      this.input.current !== undefined &&\n      this.input.current !== null &&\n      this.input.current.inputElement === document.activeElement &&\n      this.input.current.value !== '';\n\n    return areSuggestionsVisible;\n  }\n\n  private _onResolveSuggestions = (updatedValue: string): void => {\n    const suggestions: T[] | PromiseLike<T[]> | null = this.props.onResolveSuggestions(updatedValue, this.state.items);\n\n    if (suggestions !== null) {\n      this.updateSuggestionsList(suggestions, updatedValue);\n    }\n  };\n\n  private _completeGenericSuggestion = (): void => {\n    if (\n      this.props.onValidateInput &&\n      this.input.current &&\n      (this.props.onValidateInput as any)(this.input.current.value) !== ValidationState.invalid &&\n      this.props.createGenericItem\n    ) {\n      const itemToConvert = this.props.createGenericItem(\n        this.input.current.value,\n        this.props.onValidateInput(this.input.current.value),\n      );\n      this.suggestionStore.createGenericSuggestion(itemToConvert);\n      this.completeSuggestion();\n    }\n  };\n\n  private _getTextFromItem(item: T, currentValue?: string): string {\n    if (this.props.getTextFromItem) {\n      return (this.props.getTextFromItem as any)(item, currentValue);\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * This should be called when the user does something other than use text entry to trigger suggestions.\n   *\n   */\n  private _userTriggeredSuggestions = () => {\n    if (!this.state.suggestionsVisible) {\n      const input = this.input.current ? this.input.current.value : '';\n      if (!input) {\n        this.onEmptyInputFocus();\n      } else {\n        if (this.suggestionStore.suggestions.length === 0) {\n          this._onResolveSuggestions(input);\n        } else {\n          this.setState({\n            isMostRecentlyUsedVisible: false,\n            suggestionsVisible: true,\n          });\n        }\n      }\n    }\n  };\n}\n\nexport class BasePickerListBelow<T, P extends IBasePickerProps<T>> extends BasePicker<T, P> {\n  public render(): JSX.Element {\n    const { suggestedDisplayValue, isFocused } = this.state;\n    const { className, inputProps, disabled, theme, styles } = this.props;\n\n    const suggestionsAvailable: string | undefined = this.state.suggestionsVisible ? this._ariaMap.suggestionList : '';\n\n    // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n    const classNames: Partial<IProcessedStyleSet<IBasePickerStyles>> = styles\n      ? getClassNames(styles, {\n          theme,\n          className,\n          isFocused,\n          inputClassName: inputProps && inputProps.className,\n        })\n      : {\n          root: css('ms-BasePicker', className ? className : ''),\n          text: css(\n            'ms-BasePicker-text',\n            legacyStyles.pickerText,\n            this.state.isFocused && legacyStyles.inputFocused,\n            disabled && legacyStyles.inputDisabled,\n          ),\n          input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n          screenReaderText: legacyStyles.screenReaderOnly,\n        };\n\n    return (\n      <div ref={this.root} onBlur={this.onBlur}>\n        <div className={classNames.root} onKeyDown={this.onKeyDown}>\n          {this.getSuggestionsAlert(classNames.screenReaderText)}\n          <div className={classNames.text}>\n            <Autofill\n              {...(inputProps as any)}\n              className={classNames.input}\n              componentRef={this.input}\n              onFocus={this.onInputFocus}\n              onBlur={this.onInputBlur}\n              onClick={this.onClick}\n              onInputValueChange={this.onInputChange}\n              suggestedDisplayValue={suggestedDisplayValue}\n              aria-activedescendant={this.getActiveDescendant()}\n              aria-controls={suggestionsAvailable || undefined}\n              aria-expanded={!!this.state.suggestionsVisible}\n              aria-haspopup=\"listbox\"\n              role=\"combobox\"\n              disabled={disabled}\n              onInputChange={this.props.onInputChange}\n            />\n          </div>\n        </div>\n        {this.renderSuggestions()}\n        <SelectionZone selection={this.selection} selectionMode={SelectionMode.single}>\n          <FocusZone\n            componentRef={this.focusZone}\n            className=\"ms-BasePicker-selectedItems\" // just a className hook without any styles applied to it.\n            isCircularNavigation={true}\n            direction={FocusZoneDirection.bidirectional}\n            shouldEnterInnerZone={this._shouldFocusZoneEnterInnerZone}\n            id={this._ariaMap.selectedItems}\n            role={'list'}\n          >\n            {this.renderItems()}\n          </FocusZone>\n        </SelectionZone>\n      </div>\n    );\n  }\n\n  protected onBackspace(ev: React.KeyboardEvent<HTMLElement>) {\n    // override the existing backspace method to not do anything because the list items appear below.\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}