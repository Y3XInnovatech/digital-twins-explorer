{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/* eslint-disable eqeqeq */\nimport { __assign } from \"tslib\";\nimport * as base64 from \"./util/base64\";\nimport * as utils from \"./util/utils\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\";\nvar Serializer = /** @class */function () {\n  function Serializer(modelMappers, isXML) {\n    if (modelMappers === void 0) {\n      modelMappers = {};\n    }\n    this.modelMappers = modelMappers;\n    this.isXML = isXML;\n  }\n  Serializer.prototype.validateConstraints = function (mapper, value, objectName) {\n    var failValidation = function (constraintName, constraintValue) {\n      throw new Error(\"\\\"\" + objectName + \"\\\" with value \\\"\" + value + \"\\\" should satisfy the constraint \\\"\" + constraintName + \"\\\": \" + constraintValue + \".\");\n    };\n    if (mapper.constraints && value != undefined) {\n      var valueAsNumber = value;\n      var _a = mapper.constraints,\n        ExclusiveMaximum = _a.ExclusiveMaximum,\n        ExclusiveMinimum = _a.ExclusiveMinimum,\n        InclusiveMaximum = _a.InclusiveMaximum,\n        InclusiveMinimum = _a.InclusiveMinimum,\n        MaxItems = _a.MaxItems,\n        MaxLength = _a.MaxLength,\n        MinItems = _a.MinItems,\n        MinLength = _a.MinLength,\n        MultipleOf = _a.MultipleOf,\n        Pattern = _a.Pattern,\n        UniqueItems = _a.UniqueItems;\n      if (ExclusiveMaximum != undefined && valueAsNumber >= ExclusiveMaximum) {\n        failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n      }\n      if (ExclusiveMinimum != undefined && valueAsNumber <= ExclusiveMinimum) {\n        failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n      }\n      if (InclusiveMaximum != undefined && valueAsNumber > InclusiveMaximum) {\n        failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n      }\n      if (InclusiveMinimum != undefined && valueAsNumber < InclusiveMinimum) {\n        failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n      }\n      var valueAsArray = value;\n      if (MaxItems != undefined && valueAsArray.length > MaxItems) {\n        failValidation(\"MaxItems\", MaxItems);\n      }\n      if (MaxLength != undefined && valueAsArray.length > MaxLength) {\n        failValidation(\"MaxLength\", MaxLength);\n      }\n      if (MinItems != undefined && valueAsArray.length < MinItems) {\n        failValidation(\"MinItems\", MinItems);\n      }\n      if (MinLength != undefined && valueAsArray.length < MinLength) {\n        failValidation(\"MinLength\", MinLength);\n      }\n      if (MultipleOf != undefined && valueAsNumber % MultipleOf !== 0) {\n        failValidation(\"MultipleOf\", MultipleOf);\n      }\n      if (Pattern) {\n        var pattern = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n        if (typeof value !== \"string\" || value.match(pattern) === null) {\n          failValidation(\"Pattern\", Pattern);\n        }\n      }\n      if (UniqueItems && valueAsArray.some(function (item, i, ar) {\n        return ar.indexOf(item) !== i;\n      })) {\n        failValidation(\"UniqueItems\", UniqueItems);\n      }\n    }\n  };\n  /**\n   * Serialize the given object based on its metadata defined in the mapper\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object\n   * @param object - A valid Javascript object to be serialized\n   * @param objectName - Name of the serialized object\n   * @param options - additional options to deserialization\n   * @returns A valid serialized Javascript object\n   */\n  Serializer.prototype.serialize = function (mapper, object, objectName, options) {\n    var _a, _b, _c;\n    if (options === void 0) {\n      options = {};\n    }\n    var updatedOptions = {\n      rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : \"\",\n      includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,\n      xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n    };\n    var payload = {};\n    var mapperType = mapper.type.name;\n    if (!objectName) {\n      objectName = mapper.serializedName;\n    }\n    if (mapperType.match(/^Sequence$/i) !== null) {\n      payload = [];\n    }\n    if (mapper.isConstant) {\n      object = mapper.defaultValue;\n    }\n    // This table of allowed values should help explain\n    // the mapper.required and mapper.nullable properties.\n    // X means \"neither undefined or null are allowed\".\n    //           || required\n    //           || true      | false\n    //  nullable || ==========================\n    //      true || null      | undefined/null\n    //     false || X         | undefined\n    // undefined || X         | undefined/null\n    var required = mapper.required,\n      nullable = mapper.nullable;\n    if (required && nullable && object === undefined) {\n      throw new Error(objectName + \" cannot be undefined.\");\n    }\n    if (required && !nullable && object == undefined) {\n      throw new Error(objectName + \" cannot be null or undefined.\");\n    }\n    if (!required && nullable === false && object === null) {\n      throw new Error(objectName + \" cannot be null.\");\n    }\n    if (object == undefined) {\n      payload = object;\n    } else {\n      // Validate Constraints if any\n      this.validateConstraints(mapper, object, objectName);\n      if (mapperType.match(/^any$/i) !== null) {\n        payload = object;\n      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {\n        payload = serializeBasicTypes(mapperType, objectName, object);\n      } else if (mapperType.match(/^Enum$/i) !== null) {\n        var enumMapper = mapper;\n        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n      } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {\n        payload = serializeDateTypes(mapperType, object, objectName);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = serializeByteArrayType(objectName, object);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = serializeBase64UrlType(objectName, object);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n      } else if (mapperType.match(/^Composite$/i) !== null) {\n        payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n      }\n    }\n    return payload;\n  };\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object\n   * @param responseBody - A valid Javascript entity to be deserialized\n   * @param objectName - Name of the deserialized object\n   * @param options - Controls behavior of XML parser and builder.\n   * @returns A valid deserialized Javascript object\n   */\n  Serializer.prototype.deserialize = function (mapper, responseBody, objectName, options) {\n    var _a, _b, _c;\n    if (options === void 0) {\n      options = {};\n    }\n    var updatedOptions = {\n      rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : \"\",\n      includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,\n      xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n    };\n    if (responseBody == undefined) {\n      if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n        // between the list being empty versus being missing,\n        // so let's do the more user-friendly thing and return an empty list.\n        responseBody = [];\n      }\n      // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n      if (mapper.defaultValue !== undefined) {\n        responseBody = mapper.defaultValue;\n      }\n      return responseBody;\n    }\n    var payload;\n    var mapperType = mapper.type.name;\n    if (!objectName) {\n      objectName = mapper.serializedName;\n    }\n    if (mapperType.match(/^Composite$/i) !== null) {\n      payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);\n    } else {\n      if (this.isXML) {\n        var xmlCharKey = updatedOptions.xmlCharKey;\n        var castResponseBody = responseBody;\n        /**\n         * If the mapper specifies this as a non-composite type value but the responseBody contains\n         * both header (\"$\" i.e., XML_ATTRKEY) and body (\"#\" i.e., XML_CHARKEY) properties,\n         * then just reduce the responseBody value to the body (\"#\" i.e., XML_CHARKEY) property.\n         */\n        if (castResponseBody[XML_ATTRKEY] != undefined && castResponseBody[xmlCharKey] != undefined) {\n          responseBody = castResponseBody[xmlCharKey];\n        }\n      }\n      if (mapperType.match(/^Number$/i) !== null) {\n        payload = parseFloat(responseBody);\n        if (isNaN(payload)) {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^Boolean$/i) !== null) {\n        if (responseBody === \"true\") {\n          payload = true;\n        } else if (responseBody === \"false\") {\n          payload = false;\n        } else {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {\n        payload = responseBody;\n      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {\n        payload = new Date(responseBody);\n      } else if (mapperType.match(/^UnixTime$/i) !== null) {\n        payload = unixTimeToDate(responseBody);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = base64.decodeString(responseBody);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = base64UrlToByteArray(responseBody);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);\n      }\n    }\n    if (mapper.isConstant) {\n      payload = mapper.defaultValue;\n    }\n    return payload;\n  };\n  return Serializer;\n}();\nexport { Serializer };\nfunction trimEnd(str, ch) {\n  var len = str.length;\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n  return str.substr(0, len);\n}\nfunction bufferToBase64Url(buffer) {\n  if (!buffer) {\n    return undefined;\n  }\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(\"Please provide an input of type Uint8Array for converting to Base64Url.\");\n  }\n  // Uint8Array to Base64.\n  var str = base64.encodeByteArray(buffer);\n  // Base64 to Base64Url.\n  return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction base64UrlToByteArray(str) {\n  if (!str) {\n    return undefined;\n  }\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  }\n  // Base64Url to Base64.\n  str = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Base64 to Uint8Array.\n  return base64.decodeString(str);\n}\nfunction splitSerializeName(prop) {\n  var classes = [];\n  var partialclass = \"\";\n  if (prop) {\n    var subwords = prop.split(\".\");\n    for (var _i = 0, subwords_1 = subwords; _i < subwords_1.length; _i++) {\n      var item = subwords_1[_i];\n      if (item.charAt(item.length - 1) === \"\\\\\") {\n        partialclass += item.substr(0, item.length - 1) + \".\";\n      } else {\n        partialclass += item;\n        classes.push(partialclass);\n        partialclass = \"\";\n      }\n    }\n  }\n  return classes;\n}\nfunction dateToUnixTime(d) {\n  if (!d) {\n    return undefined;\n  }\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d);\n  }\n  return Math.floor(d.getTime() / 1000);\n}\nfunction unixTimeToDate(n) {\n  if (!n) {\n    return undefined;\n  }\n  return new Date(n * 1000);\n}\nfunction serializeBasicTypes(typeName, objectName, value) {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/i) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(objectName + \" with value \" + value + \" must be of type number.\");\n      }\n    } else if (typeName.match(/^String$/i) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(objectName + \" with value \\\"\" + value + \"\\\" must be of type string.\");\n      }\n    } else if (typeName.match(/^Uuid$/i) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && utils.isValidUuid(value))) {\n        throw new Error(objectName + \" with value \\\"\" + value + \"\\\" must be of type string and a valid uuid.\");\n      }\n    } else if (typeName.match(/^Boolean$/i) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(objectName + \" with value \" + value + \" must be of type boolean.\");\n      }\n    } else if (typeName.match(/^Stream$/i) !== null) {\n      var objectType = typeof value;\n      if (objectType !== \"string\" && objectType !== \"function\" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !((typeof Blob === \"function\" || typeof Blob === \"object\") && value instanceof Blob)) {\n        throw new Error(objectName + \" must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.\");\n      }\n    }\n  }\n  return value;\n}\nfunction serializeEnumType(objectName, allowedValues, value) {\n  if (!allowedValues) {\n    throw new Error(\"Please provide a set of allowedValues to validate \" + objectName + \" as an Enum Type.\");\n  }\n  var isPresent = allowedValues.some(function (item) {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n    return item === value;\n  });\n  if (!isPresent) {\n    throw new Error(value + \" is not a valid value for \" + objectName + \". The valid values are: \" + JSON.stringify(allowedValues) + \".\");\n  }\n  return value;\n}\nfunction serializeByteArrayType(objectName, value) {\n  var returnValue = \"\";\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(objectName + \" must be of type Uint8Array.\");\n    }\n    returnValue = base64.encodeByteArray(value);\n  }\n  return returnValue;\n}\nfunction serializeBase64UrlType(objectName, value) {\n  var returnValue = \"\";\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(objectName + \" must be of type Uint8Array.\");\n    }\n    returnValue = bufferToBase64Url(value) || \"\";\n  }\n  return returnValue;\n}\nfunction serializeDateTypes(typeName, value, objectName) {\n  if (value != undefined) {\n    if (typeName.match(/^Date$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(objectName + \" must be an instanceof Date or a string in ISO8601 format.\");\n      }\n      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(objectName + \" must be an instanceof Date or a string in ISO8601 format.\");\n      }\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(objectName + \" must be an instanceof Date or a string in RFC-1123 format.\");\n      }\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(objectName + \" must be an instanceof Date or a string in RFC-1123/ISO8601 format \" + \"for it to be serialized in UnixTime/Epoch format.\");\n      }\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/i) !== null) {\n      if (!utils.isDuration(value)) {\n        throw new Error(objectName + \" must be a string in ISO 8601 format. Instead was \\\"\" + value + \"\\\".\");\n      }\n    }\n  }\n  return value;\n}\nfunction serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {\n  var _a, _b;\n  if (!Array.isArray(object)) {\n    throw new Error(objectName + \" must be of type Array.\");\n  }\n  var elementType = mapper.type.element;\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(\"element\\\" metadata for an Array must be defined in the \" + (\"mapper and it must of type \\\"object\\\" in \" + objectName + \".\"));\n  }\n  var tempArray = [];\n  for (var i = 0; i < object.length; i++) {\n    var serializedValue = serializer.serialize(elementType, object[i], objectName, options);\n    if (isXml && elementType.xmlNamespace) {\n      var xmlnsKey = elementType.xmlNamespacePrefix ? \"xmlns:\" + elementType.xmlNamespacePrefix : \"xmlns\";\n      if (elementType.type.name === \"Composite\") {\n        tempArray[i] = __assign({}, serializedValue);\n        tempArray[i][XML_ATTRKEY] = (_a = {}, _a[xmlnsKey] = elementType.xmlNamespace, _a);\n      } else {\n        tempArray[i] = {};\n        tempArray[i][options.xmlCharKey] = serializedValue;\n        tempArray[i][XML_ATTRKEY] = (_b = {}, _b[xmlnsKey] = elementType.xmlNamespace, _b);\n      }\n    } else {\n      tempArray[i] = serializedValue;\n    }\n  }\n  return tempArray;\n}\nfunction serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {\n  var _a;\n  if (typeof object !== \"object\") {\n    throw new Error(objectName + \" must be of type object.\");\n  }\n  var valueType = mapper.type.value;\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(\"\\\"value\\\" metadata for a Dictionary must be defined in the \" + (\"mapper and it must of type \\\"object\\\" in \" + objectName + \".\"));\n  }\n  var tempDictionary = {};\n  for (var _i = 0, _b = Object.keys(object); _i < _b.length; _i++) {\n    var key = _b[_i];\n    var serializedValue = serializer.serialize(valueType, object[key], objectName, options);\n    // If the element needs an XML namespace we need to add it within the $ property\n    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);\n  }\n  // Add the namespace to the root element if needed\n  if (isXml && mapper.xmlNamespace) {\n    var xmlnsKey = mapper.xmlNamespacePrefix ? \"xmlns:\" + mapper.xmlNamespacePrefix : \"xmlns\";\n    var result = tempDictionary;\n    result[XML_ATTRKEY] = (_a = {}, _a[xmlnsKey] = mapper.xmlNamespace, _a);\n    return result;\n  }\n  return tempDictionary;\n}\n/**\n * Resolves the additionalProperties property from a referenced mapper\n * @param serializer - The serializer containing the entire set of mappers\n * @param mapper - The composite mapper to resolve\n * @param objectName - Name of the object being serialized\n */\nfunction resolveAdditionalProperties(serializer, mapper, objectName) {\n  var additionalProperties = mapper.type.additionalProperties;\n  if (!additionalProperties && mapper.type.className) {\n    var modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;\n  }\n  return additionalProperties;\n}\n/**\n * Finds the mapper referenced by className\n * @param serializer - The serializer containing the entire set of mappers\n * @param mapper - The composite mapper to resolve\n * @param objectName - Name of the object being serialized\n */\nfunction resolveReferencedMapper(serializer, mapper, objectName) {\n  var className = mapper.type.className;\n  if (!className) {\n    throw new Error(\"Class name for model \\\"\" + objectName + \"\\\" is not provided in the mapper \\\"\" + JSON.stringify(mapper, undefined, 2) + \"\\\".\");\n  }\n  return serializer.modelMappers[className];\n}\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer - The serializer containing the entire set of mappers\n * @param mapper - The composite mapper to resolve\n */\nfunction resolveModelProperties(serializer, mapper, objectName) {\n  var modelProps = mapper.type.modelProperties;\n  if (!modelProps) {\n    var modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    if (!modelMapper) {\n      throw new Error(\"mapper() cannot be null or undefined for model \\\"\" + mapper.type.className + \"\\\".\");\n    }\n    modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;\n    if (!modelProps) {\n      throw new Error(\"modelProperties cannot be null or undefined in the \" + (\"mapper \\\"\" + JSON.stringify(modelMapper) + \"\\\" of type \\\"\" + mapper.type.className + \"\\\" for object \\\"\" + objectName + \"\\\".\"));\n    }\n  }\n  return modelProps;\n}\nfunction serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {\n  var _a, _b;\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n  if (object != undefined) {\n    var payload = {};\n    var modelProps = resolveModelProperties(serializer, mapper, objectName);\n    for (var _i = 0, _c = Object.keys(modelProps); _i < _c.length; _i++) {\n      var key = _c[_i];\n      var propertyMapper = modelProps[key];\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n      var propName = void 0;\n      var parentObject = payload;\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        var paths = splitSerializeName(propertyMapper.serializedName);\n        propName = paths.pop();\n        for (var _d = 0, paths_1 = paths; _d < paths_1.length; _d++) {\n          var pathName = paths_1[_d];\n          var childObject = parentObject[pathName];\n          if (childObject == undefined && (object[key] != undefined || propertyMapper.defaultValue !== undefined)) {\n            parentObject[pathName] = {};\n          }\n          parentObject = parentObject[pathName];\n        }\n      }\n      if (parentObject != undefined) {\n        if (isXml && mapper.xmlNamespace) {\n          var xmlnsKey = mapper.xmlNamespacePrefix ? \"xmlns:\" + mapper.xmlNamespacePrefix : \"xmlns\";\n          parentObject[XML_ATTRKEY] = __assign(__assign({}, parentObject[XML_ATTRKEY]), (_a = {}, _a[xmlnsKey] = mapper.xmlNamespace, _a));\n        }\n        var propertyObjectName = propertyMapper.serializedName !== \"\" ? objectName + \".\" + propertyMapper.serializedName : objectName;\n        var toSerialize = object[key];\n        var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && toSerialize == undefined) {\n          toSerialize = mapper.serializedName;\n        }\n        var serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);\n        if (serializedValue !== undefined && propName != undefined) {\n          var value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);\n          if (isXml && propertyMapper.xmlIsAttribute) {\n            // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};\n            parentObject[XML_ATTRKEY][propName] = serializedValue;\n          } else if (isXml && propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = (_b = {}, _b[propertyMapper.xmlElementName] = value, _b);\n          } else {\n            parentObject[propName] = value;\n          }\n        }\n      }\n    }\n    var additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);\n    if (additionalPropertiesMapper) {\n      var propNames = Object.keys(modelProps);\n      var _loop_1 = function (clientPropName) {\n        var isAdditionalProperty = propNames.every(function (pn) {\n          return pn !== clientPropName;\n        });\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '[\"' + clientPropName + '\"]', options);\n        }\n      };\n      for (var clientPropName in object) {\n        _loop_1(clientPropName);\n      }\n    }\n    return payload;\n  }\n  return object;\n}\nfunction getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {\n  var _a;\n  if (!isXml || !propertyMapper.xmlNamespace) {\n    return serializedValue;\n  }\n  var xmlnsKey = propertyMapper.xmlNamespacePrefix ? \"xmlns:\" + propertyMapper.xmlNamespacePrefix : \"xmlns\";\n  var xmlNamespace = (_a = {}, _a[xmlnsKey] = propertyMapper.xmlNamespace, _a);\n  if ([\"Composite\"].includes(propertyMapper.type.name)) {\n    if (serializedValue[XML_ATTRKEY]) {\n      return serializedValue;\n    } else {\n      var result_1 = __assign({}, serializedValue);\n      result_1[XML_ATTRKEY] = xmlNamespace;\n      return result_1;\n    }\n  }\n  var result = {};\n  result[options.xmlCharKey] = serializedValue;\n  result[XML_ATTRKEY] = xmlNamespace;\n  return result;\n}\nfunction isSpecialXmlProperty(propertyName, options) {\n  return [XML_ATTRKEY, options.xmlCharKey].includes(propertyName);\n}\nfunction deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {\n  var _a;\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n  var modelProps = resolveModelProperties(serializer, mapper, objectName);\n  var instance = {};\n  var handledPropertyNames = [];\n  for (var _i = 0, _b = Object.keys(modelProps); _i < _b.length; _i++) {\n    var key = _b[_i];\n    var propertyMapper = modelProps[key];\n    var paths = splitSerializeName(modelProps[key].serializedName);\n    handledPropertyNames.push(paths[0]);\n    var serializedName = propertyMapper.serializedName,\n      xmlName = propertyMapper.xmlName,\n      xmlElementName = propertyMapper.xmlElementName;\n    var propertyObjectName = objectName;\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n    var headerCollectionPrefix = propertyMapper.headerCollectionPrefix;\n    if (headerCollectionPrefix) {\n      var dictionary = {};\n      for (var _c = 0, _d = Object.keys(responseBody); _c < _d.length; _c++) {\n        var headerKey = _d[_c];\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);\n        }\n        handledPropertyNames.push(headerKey);\n      }\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {\n        instance[key] = serializer.deserialize(propertyMapper, responseBody[XML_ATTRKEY][xmlName], propertyObjectName, options);\n      } else {\n        var propertyName = xmlElementName || xmlName || serializedName;\n        if (propertyMapper.xmlIsWrapped) {\n          /* a list of <xmlElementName> wrapped by <xmlName>\n            For the xml example below\n              <Cors>\n                <CorsRule>...</CorsRule>\n                <CorsRule>...</CorsRule>\n              </Cors>\n            the responseBody has\n              {\n                Cors: {\n                  CorsRule: [{...}, {...}]\n                }\n              }\n            xmlName is \"Cors\" and xmlElementName is\"CorsRule\".\n          */\n          var wrapped = responseBody[xmlName];\n          var elementList = (_a = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _a !== void 0 ? _a : [];\n          instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);\n        } else {\n          var property = responseBody[propertyName];\n          instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);\n        }\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      var propertyInstance = void 0;\n      var res = responseBody;\n      // traversing the object step by step.\n      for (var _e = 0, paths_2 = paths; _e < paths_2.length; _e++) {\n        var item = paths_2[_e];\n        if (!res) break;\n        res = res[item];\n      }\n      propertyInstance = res;\n      var polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n      // checking that the model property name (key)(ex: \"fishtype\") and the\n      // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n      // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n      // is a better approach. The generator is not consistent with escaping '\\.' in the\n      // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n      // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n      // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n      // the transformation of model property name (ex: \"fishtype\") is done consistently.\n      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n      if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && propertyInstance == undefined) {\n        propertyInstance = mapper.serializedName;\n      }\n      var serializedValue = void 0;\n      // paging\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        instance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);\n      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n        serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);\n        instance[key] = serializedValue;\n      }\n    }\n  }\n  var additionalPropertiesMapper = mapper.type.additionalProperties;\n  if (additionalPropertiesMapper) {\n    var isAdditionalProperty = function (responsePropName) {\n      for (var clientPropName in modelProps) {\n        var paths = splitSerializeName(modelProps[clientPropName].serializedName);\n        if (paths[0] === responsePropName) {\n          return false;\n        }\n      }\n      return true;\n    };\n    for (var responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '[\"' + responsePropName + '\"]', options);\n      }\n    }\n  } else if (responseBody) {\n    for (var _f = 0, _g = Object.keys(responseBody); _f < _g.length; _f++) {\n      var key = _g[_f];\n      if (instance[key] === undefined && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) {\n        instance[key] = responseBody[key];\n      }\n    }\n  }\n  return instance;\n}\nfunction deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {\n  var value = mapper.type.value;\n  if (!value || typeof value !== \"object\") {\n    throw new Error(\"\\\"value\\\" metadata for a Dictionary must be defined in the \" + (\"mapper and it must of type \\\"object\\\" in \" + objectName));\n  }\n  if (responseBody) {\n    var tempDictionary = {};\n    for (var _i = 0, _a = Object.keys(responseBody); _i < _a.length; _i++) {\n      var key = _a[_i];\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);\n    }\n    return tempDictionary;\n  }\n  return responseBody;\n}\nfunction deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {\n  var element = mapper.type.element;\n  if (!element || typeof element !== \"object\") {\n    throw new Error(\"element\\\" metadata for an Array must be defined in the \" + (\"mapper and it must of type \\\"object\\\" in \" + objectName));\n  }\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n    var tempArray = [];\n    for (var i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(element, responseBody[i], objectName + \"[\" + i + \"]\", options);\n    }\n    return tempArray;\n  }\n  return responseBody;\n}\nfunction getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {\n  var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n  if (polymorphicDiscriminator) {\n    var discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n    if (discriminatorName != undefined) {\n      var discriminatorValue = object[discriminatorName];\n      if (discriminatorValue != undefined) {\n        var typeName = mapper.type.uberParent || mapper.type.className;\n        var indexDiscriminator = discriminatorValue === typeName ? discriminatorValue : typeName + \".\" + discriminatorValue;\n        var polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n  return mapper;\n}\nfunction getPolymorphicDiscriminatorRecursively(serializer, mapper) {\n  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);\n}\nfunction getPolymorphicDiscriminatorSafely(serializer, typeName) {\n  return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;\n}\n// TODO: why is this here?\nexport function serializeObject(toSerialize) {\n  var castToSerialize = toSerialize;\n  if (toSerialize == undefined) return undefined;\n  if (toSerialize instanceof Uint8Array) {\n    toSerialize = base64.encodeByteArray(toSerialize);\n    return toSerialize;\n  } else if (toSerialize instanceof Date) {\n    return toSerialize.toISOString();\n  } else if (Array.isArray(toSerialize)) {\n    var array = [];\n    for (var i = 0; i < toSerialize.length; i++) {\n      array.push(serializeObject(toSerialize[i]));\n    }\n    return array;\n  } else if (typeof toSerialize === \"object\") {\n    var dictionary = {};\n    for (var property in toSerialize) {\n      dictionary[property] = serializeObject(castToSerialize[property]);\n    }\n    return dictionary;\n  }\n  return toSerialize;\n}\n/**\n * Utility function to create a K:V from a list of strings\n */\nfunction strEnum(o) {\n  var result = {};\n  for (var _i = 0, o_1 = o; _i < o_1.length; _i++) {\n    var key = o_1[_i];\n    result[key] = key;\n  }\n  return result;\n}\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport var MapperType = strEnum([\"Base64Url\", \"Boolean\", \"ByteArray\", \"Composite\", \"Date\", \"DateTime\", \"DateTimeRfc1123\", \"Dictionary\", \"Enum\", \"Number\", \"Object\", \"Sequence\", \"String\", \"Stream\", \"TimeSpan\", \"UnixTime\"]);","map":{"version":3,"sources":["../../src/serializer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/* eslint-disable eqeqeq */\n\nimport * as base64 from \"./util/base64\";\nimport * as utils from \"./util/utils\";\nimport { XML_ATTRKEY, XML_CHARKEY, SerializerOptions } from \"./util/serializer.common\";\n\nexport class Serializer {\n  constructor(\n    public readonly modelMappers: { [key: string]: any } = {},\n    public readonly isXML?: boolean\n  ) {}\n\n  validateConstraints(mapper: Mapper, value: unknown, objectName: string): void {\n    const failValidation = (\n      constraintName: keyof MapperConstraints,\n      constraintValue: any\n    ): Error => {\n      throw new Error(\n        `\"${objectName}\" with value \"${value}\" should satisfy the constraint \"${constraintName}\": ${constraintValue}.`\n      );\n    };\n    if (mapper.constraints && value != undefined) {\n      const valueAsNumber = value as number;\n      const {\n        ExclusiveMaximum,\n        ExclusiveMinimum,\n        InclusiveMaximum,\n        InclusiveMinimum,\n        MaxItems,\n        MaxLength,\n        MinItems,\n        MinLength,\n        MultipleOf,\n        Pattern,\n        UniqueItems\n      } = mapper.constraints;\n      if (ExclusiveMaximum != undefined && valueAsNumber >= ExclusiveMaximum) {\n        failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n      }\n      if (ExclusiveMinimum != undefined && valueAsNumber <= ExclusiveMinimum) {\n        failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n      }\n      if (InclusiveMaximum != undefined && valueAsNumber > InclusiveMaximum) {\n        failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n      }\n      if (InclusiveMinimum != undefined && valueAsNumber < InclusiveMinimum) {\n        failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n      }\n      const valueAsArray = value as any[];\n      if (MaxItems != undefined && valueAsArray.length > MaxItems) {\n        failValidation(\"MaxItems\", MaxItems);\n      }\n      if (MaxLength != undefined && valueAsArray.length > MaxLength) {\n        failValidation(\"MaxLength\", MaxLength);\n      }\n      if (MinItems != undefined && valueAsArray.length < MinItems) {\n        failValidation(\"MinItems\", MinItems);\n      }\n      if (MinLength != undefined && valueAsArray.length < MinLength) {\n        failValidation(\"MinLength\", MinLength);\n      }\n      if (MultipleOf != undefined && valueAsNumber % MultipleOf !== 0) {\n        failValidation(\"MultipleOf\", MultipleOf);\n      }\n      if (Pattern) {\n        const pattern: RegExp = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n        if (typeof value !== \"string\" || value.match(pattern) === null) {\n          failValidation(\"Pattern\", Pattern);\n        }\n      }\n      if (\n        UniqueItems &&\n        valueAsArray.some((item: any, i: number, ar: Array<any>) => ar.indexOf(item) !== i)\n      ) {\n        failValidation(\"UniqueItems\", UniqueItems);\n      }\n    }\n  }\n\n  /**\n   * Serialize the given object based on its metadata defined in the mapper\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object\n   * @param object - A valid Javascript object to be serialized\n   * @param objectName - Name of the serialized object\n   * @param options - additional options to deserialization\n   * @returns A valid serialized Javascript object\n   */\n  serialize(\n    mapper: Mapper,\n    object: unknown,\n    objectName?: string,\n    options: SerializerOptions = {}\n  ): any {\n    const updatedOptions: Required<SerializerOptions> = {\n      rootName: options.rootName ?? \"\",\n      includeRoot: options.includeRoot ?? false,\n      xmlCharKey: options.xmlCharKey ?? XML_CHARKEY\n    };\n    let payload: any = {};\n    const mapperType = mapper.type.name as string;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n    if (mapperType.match(/^Sequence$/i) !== null) {\n      payload = [];\n    }\n\n    if (mapper.isConstant) {\n      object = mapper.defaultValue;\n    }\n\n    // This table of allowed values should help explain\n    // the mapper.required and mapper.nullable properties.\n    // X means \"neither undefined or null are allowed\".\n    //           || required\n    //           || true      | false\n    //  nullable || ==========================\n    //      true || null      | undefined/null\n    //     false || X         | undefined\n    // undefined || X         | undefined/null\n\n    const { required, nullable } = mapper;\n\n    if (required && nullable && object === undefined) {\n      throw new Error(`${objectName} cannot be undefined.`);\n    }\n    if (required && !nullable && object == undefined) {\n      throw new Error(`${objectName} cannot be null or undefined.`);\n    }\n    if (!required && nullable === false && object === null) {\n      throw new Error(`${objectName} cannot be null.`);\n    }\n\n    if (object == undefined) {\n      payload = object;\n    } else {\n      // Validate Constraints if any\n      this.validateConstraints(mapper, object, objectName);\n      if (mapperType.match(/^any$/i) !== null) {\n        payload = object;\n      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {\n        payload = serializeBasicTypes(mapperType, objectName, object);\n      } else if (mapperType.match(/^Enum$/i) !== null) {\n        const enumMapper: EnumMapper = mapper as EnumMapper;\n        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n      } else if (\n        mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null\n      ) {\n        payload = serializeDateTypes(mapperType, object, objectName);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = serializeByteArrayType(objectName, object as Uint8Array);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = serializeBase64UrlType(objectName, object as Uint8Array);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = serializeSequenceType(\n          this,\n          mapper as SequenceMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions\n        );\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = serializeDictionaryType(\n          this,\n          mapper as DictionaryMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions\n        );\n      } else if (mapperType.match(/^Composite$/i) !== null) {\n        payload = serializeCompositeType(\n          this,\n          mapper as CompositeMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions\n        );\n      }\n    }\n    return payload;\n  }\n\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object\n   * @param responseBody - A valid Javascript entity to be deserialized\n   * @param objectName - Name of the deserialized object\n   * @param options - Controls behavior of XML parser and builder.\n   * @returns A valid deserialized Javascript object\n   */\n  deserialize(\n    mapper: Mapper,\n    responseBody: unknown,\n    objectName: string,\n    options: SerializerOptions = {}\n  ): any {\n    const updatedOptions: Required<SerializerOptions> = {\n      rootName: options.rootName ?? \"\",\n      includeRoot: options.includeRoot ?? false,\n      xmlCharKey: options.xmlCharKey ?? XML_CHARKEY\n    };\n    if (responseBody == undefined) {\n      if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n        // between the list being empty versus being missing,\n        // so let's do the more user-friendly thing and return an empty list.\n        responseBody = [];\n      }\n      // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n      if (mapper.defaultValue !== undefined) {\n        responseBody = mapper.defaultValue;\n      }\n      return responseBody;\n    }\n\n    let payload: any;\n    const mapperType = mapper.type.name;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n\n    if (mapperType.match(/^Composite$/i) !== null) {\n      payload = deserializeCompositeType(\n        this,\n        mapper as CompositeMapper,\n        responseBody,\n        objectName,\n        updatedOptions\n      );\n    } else {\n      if (this.isXML) {\n        const xmlCharKey = updatedOptions.xmlCharKey;\n        const castResponseBody = responseBody as Record<string, unknown>;\n        /**\n         * If the mapper specifies this as a non-composite type value but the responseBody contains\n         * both header (\"$\" i.e., XML_ATTRKEY) and body (\"#\" i.e., XML_CHARKEY) properties,\n         * then just reduce the responseBody value to the body (\"#\" i.e., XML_CHARKEY) property.\n         */\n        if (\n          castResponseBody[XML_ATTRKEY] != undefined &&\n          castResponseBody[xmlCharKey] != undefined\n        ) {\n          responseBody = castResponseBody[xmlCharKey];\n        }\n      }\n\n      if (mapperType.match(/^Number$/i) !== null) {\n        payload = parseFloat(responseBody as string);\n        if (isNaN(payload)) {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^Boolean$/i) !== null) {\n        if (responseBody === \"true\") {\n          payload = true;\n        } else if (responseBody === \"false\") {\n          payload = false;\n        } else {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {\n        payload = responseBody;\n      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {\n        payload = new Date(responseBody as string);\n      } else if (mapperType.match(/^UnixTime$/i) !== null) {\n        payload = unixTimeToDate(responseBody as number);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = base64.decodeString(responseBody as string);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = base64UrlToByteArray(responseBody as string);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = deserializeSequenceType(\n          this,\n          mapper as SequenceMapper,\n          responseBody,\n          objectName,\n          updatedOptions\n        );\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = deserializeDictionaryType(\n          this,\n          mapper as DictionaryMapper,\n          responseBody,\n          objectName,\n          updatedOptions\n        );\n      }\n    }\n\n    if (mapper.isConstant) {\n      payload = mapper.defaultValue;\n    }\n\n    return payload;\n  }\n}\n\nfunction trimEnd(str: string, ch: string): string {\n  let len = str.length;\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n  return str.substr(0, len);\n}\n\nfunction bufferToBase64Url(buffer: any): string | undefined {\n  if (!buffer) {\n    return undefined;\n  }\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);\n  }\n  // Uint8Array to Base64.\n  const str = base64.encodeByteArray(buffer);\n  // Base64 to Base64Url.\n  return trimEnd(str, \"=\")\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\");\n}\n\nfunction base64UrlToByteArray(str: string): Uint8Array | undefined {\n  if (!str) {\n    return undefined;\n  }\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  }\n  // Base64Url to Base64.\n  str = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Base64 to Uint8Array.\n  return base64.decodeString(str);\n}\n\nfunction splitSerializeName(prop: string | undefined): string[] {\n  const classes: string[] = [];\n  let partialclass = \"\";\n  if (prop) {\n    const subwords = prop.split(\".\");\n\n    for (const item of subwords) {\n      if (item.charAt(item.length - 1) === \"\\\\\") {\n        partialclass += item.substr(0, item.length - 1) + \".\";\n      } else {\n        partialclass += item;\n        classes.push(partialclass);\n        partialclass = \"\";\n      }\n    }\n  }\n\n  return classes;\n}\n\nfunction dateToUnixTime(d: string | Date): number | undefined {\n  if (!d) {\n    return undefined;\n  }\n\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d as string);\n  }\n  return Math.floor((d as Date).getTime() / 1000);\n}\n\nfunction unixTimeToDate(n: number): Date | undefined {\n  if (!n) {\n    return undefined;\n  }\n  return new Date(n * 1000);\n}\n\nfunction serializeBasicTypes(typeName: string, objectName: string, value: any): any {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/i) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(`${objectName} with value ${value} must be of type number.`);\n      }\n    } else if (typeName.match(/^String$/i) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(`${objectName} with value \"${value}\" must be of type string.`);\n      }\n    } else if (typeName.match(/^Uuid$/i) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && utils.isValidUuid(value))) {\n        throw new Error(\n          `${objectName} with value \"${value}\" must be of type string and a valid uuid.`\n        );\n      }\n    } else if (typeName.match(/^Boolean$/i) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(`${objectName} with value ${value} must be of type boolean.`);\n      }\n    } else if (typeName.match(/^Stream$/i) !== null) {\n      const objectType = typeof value;\n      if (\n        objectType !== \"string\" &&\n        objectType !== \"function\" &&\n        !(value instanceof ArrayBuffer) &&\n        !ArrayBuffer.isView(value) &&\n        !((typeof Blob === \"function\" || typeof Blob === \"object\") && value instanceof Blob)\n      ) {\n        throw new Error(\n          `${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.`\n        );\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction serializeEnumType(objectName: string, allowedValues: Array<any>, value: any): any {\n  if (!allowedValues) {\n    throw new Error(\n      `Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`\n    );\n  }\n  const isPresent = allowedValues.some((item) => {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n    return item === value;\n  });\n  if (!isPresent) {\n    throw new Error(\n      `${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(\n        allowedValues\n      )}.`\n    );\n  }\n  return value;\n}\n\nfunction serializeByteArrayType(objectName: string, value: Uint8Array): string {\n  let returnValue: string = \"\";\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    returnValue = base64.encodeByteArray(value);\n  }\n  return returnValue;\n}\n\nfunction serializeBase64UrlType(objectName: string, value: Uint8Array): string {\n  let returnValue: string = \"\";\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    returnValue = bufferToBase64Url(value) || \"\";\n  }\n  return returnValue;\n}\n\nfunction serializeDateTypes(typeName: string, value: any, objectName: string): any {\n  if (value != undefined) {\n    if (typeName.match(/^Date$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value =\n        value instanceof Date\n          ? value.toISOString().substring(0, 10)\n          : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);\n      }\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(\n          `${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +\n            `for it to be serialized in UnixTime/Epoch format.`\n        );\n      }\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/i) !== null) {\n      if (!utils.isDuration(value)) {\n        throw new Error(\n          `${objectName} must be a string in ISO 8601 format. Instead was \"${value}\".`\n        );\n      }\n    }\n  }\n  return value;\n}\n\nfunction serializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: Required<SerializerOptions>\n): any[] {\n  if (!Array.isArray(object)) {\n    throw new Error(`${objectName} must be of type Array.`);\n  }\n  const elementType = mapper.type.element;\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`\n    );\n  }\n  const tempArray = [];\n  for (let i = 0; i < object.length; i++) {\n    const serializedValue = serializer.serialize(elementType, object[i], objectName, options);\n\n    if (isXml && elementType.xmlNamespace) {\n      const xmlnsKey = elementType.xmlNamespacePrefix\n        ? `xmlns:${elementType.xmlNamespacePrefix}`\n        : \"xmlns\";\n      if (elementType.type.name === \"Composite\") {\n        tempArray[i] = { ...serializedValue };\n        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n      } else {\n        tempArray[i] = {};\n        tempArray[i][options.xmlCharKey] = serializedValue;\n        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n      }\n    } else {\n      tempArray[i] = serializedValue;\n    }\n  }\n  return tempArray;\n}\n\nfunction serializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: Required<SerializerOptions>\n): { [key: string]: any } {\n  if (typeof object !== \"object\") {\n    throw new Error(`${objectName} must be of type object.`);\n  }\n  const valueType = mapper.type.value;\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`\n    );\n  }\n  const tempDictionary: { [key: string]: any } = {};\n  for (const key of Object.keys(object)) {\n    const serializedValue = serializer.serialize(valueType, object[key], objectName, options);\n    // If the element needs an XML namespace we need to add it within the $ property\n    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);\n  }\n\n  // Add the namespace to the root element if needed\n  if (isXml && mapper.xmlNamespace) {\n    const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : \"xmlns\";\n\n    const result = tempDictionary;\n    result[XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };\n    return result;\n  }\n\n  return tempDictionary;\n}\n\n/**\n * Resolves the additionalProperties property from a referenced mapper\n * @param serializer - The serializer containing the entire set of mappers\n * @param mapper - The composite mapper to resolve\n * @param objectName - Name of the object being serialized\n */\nfunction resolveAdditionalProperties(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string\n): SequenceMapper | BaseMapper | CompositeMapper | DictionaryMapper | EnumMapper | undefined {\n  const additionalProperties = mapper.type.additionalProperties;\n\n  if (!additionalProperties && mapper.type.className) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    return modelMapper?.type.additionalProperties;\n  }\n\n  return additionalProperties;\n}\n\n/**\n * Finds the mapper referenced by className\n * @param serializer - The serializer containing the entire set of mappers\n * @param mapper - The composite mapper to resolve\n * @param objectName - Name of the object being serialized\n */\nfunction resolveReferencedMapper(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string\n): CompositeMapper | undefined {\n  const className = mapper.type.className;\n  if (!className) {\n    throw new Error(\n      `Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(\n        mapper,\n        undefined,\n        2\n      )}\".`\n    );\n  }\n\n  return serializer.modelMappers[className];\n}\n\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer - The serializer containing the entire set of mappers\n * @param mapper - The composite mapper to resolve\n */\nfunction resolveModelProperties(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string\n): { [propertyName: string]: Mapper } {\n  let modelProps = mapper.type.modelProperties;\n  if (!modelProps) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    if (!modelMapper) {\n      throw new Error(`mapper() cannot be null or undefined for model \"${mapper.type.className}\".`);\n    }\n    modelProps = modelMapper?.type.modelProperties;\n    if (!modelProps) {\n      throw new Error(\n        `modelProperties cannot be null or undefined in the ` +\n          `mapper \"${JSON.stringify(modelMapper)}\" of type \"${\n            mapper.type.className\n          }\" for object \"${objectName}\".`\n      );\n    }\n  }\n\n  return modelProps;\n}\n\nfunction serializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: Required<SerializerOptions>\n): any {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n\n  if (object != undefined) {\n    const payload: any = {};\n    const modelProps = resolveModelProperties(serializer, mapper, objectName);\n    for (const key of Object.keys(modelProps)) {\n      const propertyMapper = modelProps[key];\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n\n      let propName: string | undefined;\n      let parentObject: any = payload;\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        const paths = splitSerializeName(propertyMapper.serializedName!);\n        propName = paths.pop();\n\n        for (const pathName of paths) {\n          const childObject = parentObject[pathName];\n          if (\n            childObject == undefined &&\n            (object[key] != undefined || propertyMapper.defaultValue !== undefined)\n          ) {\n            parentObject[pathName] = {};\n          }\n          parentObject = parentObject[pathName];\n        }\n      }\n\n      if (parentObject != undefined) {\n        if (isXml && mapper.xmlNamespace) {\n          const xmlnsKey = mapper.xmlNamespacePrefix\n            ? `xmlns:${mapper.xmlNamespacePrefix}`\n            : \"xmlns\";\n          parentObject[XML_ATTRKEY] = {\n            ...parentObject[XML_ATTRKEY],\n            [xmlnsKey]: mapper.xmlNamespace\n          };\n        }\n        const propertyObjectName =\n          propertyMapper.serializedName !== \"\"\n            ? objectName + \".\" + propertyMapper.serializedName\n            : objectName;\n\n        let toSerialize = object[key];\n        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n        if (\n          polymorphicDiscriminator &&\n          polymorphicDiscriminator.clientName === key &&\n          toSerialize == undefined\n        ) {\n          toSerialize = mapper.serializedName;\n        }\n\n        const serializedValue = serializer.serialize(\n          propertyMapper,\n          toSerialize,\n          propertyObjectName,\n          options\n        );\n\n        if (serializedValue !== undefined && propName != undefined) {\n          const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);\n          if (isXml && propertyMapper.xmlIsAttribute) {\n            // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};\n            parentObject[XML_ATTRKEY][propName] = serializedValue;\n          } else if (isXml && propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = { [propertyMapper.xmlElementName!]: value };\n          } else {\n            parentObject[propName] = value;\n          }\n        }\n      }\n    }\n\n    const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);\n    if (additionalPropertiesMapper) {\n      const propNames = Object.keys(modelProps);\n      for (const clientPropName in object) {\n        const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(\n            additionalPropertiesMapper,\n            object[clientPropName],\n            objectName + '[\"' + clientPropName + '\"]',\n            options\n          );\n        }\n      }\n    }\n\n    return payload;\n  }\n  return object;\n}\n\nfunction getXmlObjectValue(\n  propertyMapper: Mapper,\n  serializedValue: any,\n  isXml: boolean,\n  options: Required<SerializerOptions>\n): any {\n  if (!isXml || !propertyMapper.xmlNamespace) {\n    return serializedValue;\n  }\n\n  const xmlnsKey = propertyMapper.xmlNamespacePrefix\n    ? `xmlns:${propertyMapper.xmlNamespacePrefix}`\n    : \"xmlns\";\n  const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };\n\n  if ([\"Composite\"].includes(propertyMapper.type.name)) {\n    if (serializedValue[XML_ATTRKEY]) {\n      return serializedValue;\n    } else {\n      const result: any = { ...serializedValue };\n      result[XML_ATTRKEY] = xmlNamespace;\n      return result;\n    }\n  }\n  const result: any = {};\n  result[options.xmlCharKey] = serializedValue;\n  result[XML_ATTRKEY] = xmlNamespace;\n  return result;\n}\n\nfunction isSpecialXmlProperty(propertyName: string, options: Required<SerializerOptions>): boolean {\n  return [XML_ATTRKEY, options.xmlCharKey].includes(propertyName);\n}\n\nfunction deserializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  responseBody: any,\n  objectName: string,\n  options: Required<SerializerOptions>\n): any {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n\n  const modelProps = resolveModelProperties(serializer, mapper, objectName);\n  let instance: { [key: string]: any } = {};\n  const handledPropertyNames: string[] = [];\n\n  for (const key of Object.keys(modelProps)) {\n    const propertyMapper = modelProps[key];\n    const paths = splitSerializeName(modelProps[key].serializedName!);\n    handledPropertyNames.push(paths[0]);\n    const { serializedName, xmlName, xmlElementName } = propertyMapper;\n    let propertyObjectName = objectName;\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n\n    const headerCollectionPrefix = (propertyMapper as DictionaryMapper).headerCollectionPrefix;\n    if (headerCollectionPrefix) {\n      const dictionary: any = {};\n      for (const headerKey of Object.keys(responseBody)) {\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(\n            (propertyMapper as DictionaryMapper).type.value,\n            responseBody[headerKey],\n            propertyObjectName,\n            options\n          );\n        }\n\n        handledPropertyNames.push(headerKey);\n      }\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {\n        instance[key] = serializer.deserialize(\n          propertyMapper,\n          responseBody[XML_ATTRKEY][xmlName!],\n          propertyObjectName,\n          options\n        );\n      } else {\n        const propertyName = xmlElementName || xmlName || serializedName;\n        if (propertyMapper.xmlIsWrapped) {\n          /* a list of <xmlElementName> wrapped by <xmlName>\n            For the xml example below\n              <Cors>\n                <CorsRule>...</CorsRule>\n                <CorsRule>...</CorsRule>\n              </Cors>\n            the responseBody has\n              {\n                Cors: {\n                  CorsRule: [{...}, {...}]\n                }\n              }\n            xmlName is \"Cors\" and xmlElementName is\"CorsRule\".\n          */\n          const wrapped = responseBody[xmlName!];\n          const elementList = wrapped?.[xmlElementName!] ?? [];\n          instance[key] = serializer.deserialize(\n            propertyMapper,\n            elementList,\n            propertyObjectName,\n            options\n          );\n        } else {\n          const property = responseBody[propertyName!];\n          instance[key] = serializer.deserialize(\n            propertyMapper,\n            property,\n            propertyObjectName,\n            options\n          );\n        }\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      let propertyInstance;\n      let res = responseBody;\n      // traversing the object step by step.\n      for (const item of paths) {\n        if (!res) break;\n        res = res[item];\n      }\n      propertyInstance = res;\n      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n      // checking that the model property name (key)(ex: \"fishtype\") and the\n      // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n      // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n      // is a better approach. The generator is not consistent with escaping '\\.' in the\n      // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n      // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n      // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n      // the transformation of model property name (ex: \"fishtype\") is done consistently.\n      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n      if (\n        polymorphicDiscriminator &&\n        key === polymorphicDiscriminator.clientName &&\n        propertyInstance == undefined\n      ) {\n        propertyInstance = mapper.serializedName;\n      }\n\n      let serializedValue;\n      // paging\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        instance = serializer.deserialize(\n          propertyMapper,\n          propertyInstance,\n          propertyObjectName,\n          options\n        );\n      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n        serializedValue = serializer.deserialize(\n          propertyMapper,\n          propertyInstance,\n          propertyObjectName,\n          options\n        );\n        instance[key] = serializedValue;\n      }\n    }\n  }\n\n  const additionalPropertiesMapper = mapper.type.additionalProperties;\n  if (additionalPropertiesMapper) {\n    const isAdditionalProperty = (responsePropName: string): boolean => {\n      for (const clientPropName in modelProps) {\n        const paths = splitSerializeName(modelProps[clientPropName].serializedName);\n        if (paths[0] === responsePropName) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    for (const responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(\n          additionalPropertiesMapper,\n          responseBody[responsePropName],\n          objectName + '[\"' + responsePropName + '\"]',\n          options\n        );\n      }\n    }\n  } else if (responseBody) {\n    for (const key of Object.keys(responseBody)) {\n      if (\n        instance[key] === undefined &&\n        !handledPropertyNames.includes(key) &&\n        !isSpecialXmlProperty(key, options)\n      ) {\n        instance[key] = responseBody[key];\n      }\n    }\n  }\n\n  return instance;\n}\n\nfunction deserializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  responseBody: any,\n  objectName: string,\n  options: Required<SerializerOptions>\n): { [key: string]: any } {\n  const value = mapper.type.value;\n  if (!value || typeof value !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`\n    );\n  }\n  if (responseBody) {\n    const tempDictionary: { [key: string]: any } = {};\n    for (const key of Object.keys(responseBody)) {\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);\n    }\n    return tempDictionary;\n  }\n  return responseBody;\n}\n\nfunction deserializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  responseBody: any,\n  objectName: string,\n  options: Required<SerializerOptions>\n): any[] {\n  const element = mapper.type.element;\n  if (!element || typeof element !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`\n    );\n  }\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n\n    const tempArray = [];\n    for (let i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(\n        element,\n        responseBody[i],\n        `${objectName}[${i}]`,\n        options\n      );\n    }\n    return tempArray;\n  }\n  return responseBody;\n}\n\nfunction getPolymorphicMapper(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  polymorphicPropertyName: \"clientName\" | \"serializedName\"\n): CompositeMapper {\n  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n  if (polymorphicDiscriminator) {\n    const discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n    if (discriminatorName != undefined) {\n      const discriminatorValue = object[discriminatorName];\n      if (discriminatorValue != undefined) {\n        const typeName = mapper.type.uberParent || mapper.type.className;\n        const indexDiscriminator =\n          discriminatorValue === typeName\n            ? discriminatorValue\n            : typeName + \".\" + discriminatorValue;\n        const polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n  return mapper;\n}\n\nfunction getPolymorphicDiscriminatorRecursively(\n  serializer: Serializer,\n  mapper: CompositeMapper\n): PolymorphicDiscriminator | undefined {\n  return (\n    mapper.type.polymorphicDiscriminator ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.className)\n  );\n}\n\nfunction getPolymorphicDiscriminatorSafely(serializer: Serializer, typeName?: string): any {\n  return (\n    typeName &&\n    serializer.modelMappers[typeName] &&\n    serializer.modelMappers[typeName].type.polymorphicDiscriminator\n  );\n}\n\nexport interface MapperConstraints {\n  InclusiveMaximum?: number;\n  ExclusiveMaximum?: number;\n  InclusiveMinimum?: number;\n  ExclusiveMinimum?: number;\n  MaxLength?: number;\n  MinLength?: number;\n  Pattern?: RegExp;\n  MaxItems?: number;\n  MinItems?: number;\n  UniqueItems?: true;\n  MultipleOf?: number;\n}\n\nexport type MapperType =\n  | SimpleMapperType\n  | CompositeMapperType\n  | SequenceMapperType\n  | DictionaryMapperType\n  | EnumMapperType;\n\nexport interface SimpleMapperType {\n  name:\n    | \"Base64Url\"\n    | \"Boolean\"\n    | \"ByteArray\"\n    | \"Date\"\n    | \"DateTime\"\n    | \"DateTimeRfc1123\"\n    | \"Object\"\n    | \"Stream\"\n    | \"String\"\n    | \"TimeSpan\"\n    | \"UnixTime\"\n    | \"Uuid\"\n    | \"Number\"\n    | \"any\";\n}\n\nexport interface CompositeMapperType {\n  name: \"Composite\";\n\n  // Only one of the two below properties should be present.\n  // Use className to reference another type definition,\n  // and use modelProperties/additionalProperties when the reference to the other type has been resolved.\n  className?: string;\n\n  modelProperties?: { [propertyName: string]: Mapper };\n  additionalProperties?: Mapper;\n\n  uberParent?: string;\n  polymorphicDiscriminator?: PolymorphicDiscriminator;\n}\n\nexport interface SequenceMapperType {\n  name: \"Sequence\";\n  element: Mapper;\n}\n\nexport interface DictionaryMapperType {\n  name: \"Dictionary\";\n  value: Mapper;\n}\n\nexport interface EnumMapperType {\n  name: \"Enum\";\n  allowedValues: any[];\n}\n\nexport interface BaseMapper {\n  /**\n   * Name for the xml element\n   */\n  xmlName?: string;\n  /**\n   * Xml element namespace\n   */\n  xmlNamespace?: string;\n  /**\n   * Xml element namespace prefix\n   */\n  xmlNamespacePrefix?: string;\n  /**\n   * Determines if the current property should be serialized as an attribute of the parent xml element\n   */\n  xmlIsAttribute?: boolean;\n  /**\n   * Name for the xml elements when serializing an array\n   */\n  xmlElementName?: string;\n  /**\n   * Whether or not the current property should have a wrapping XML element\n   */\n  xmlIsWrapped?: boolean;\n  /**\n   * Whether or not the current property is readonly\n   */\n  readOnly?: boolean;\n  /**\n   * Whether or not the current property is a constant\n   */\n  isConstant?: boolean;\n  /**\n   * Whether or not the current property is required\n   */\n  required?: boolean;\n  /**\n   * Whether or not the current property allows mull as a value\n   */\n  nullable?: boolean;\n  /**\n   * The name to use when serializing\n   */\n  serializedName?: string;\n  /**\n   * Type of the mapper\n   */\n  type: MapperType;\n  /**\n   * Default value when one is not explicitly provided\n   */\n  defaultValue?: any;\n  /**\n   * Constraints to test the current value against\n   */\n  constraints?: MapperConstraints;\n}\n\nexport type Mapper = BaseMapper | CompositeMapper | SequenceMapper | DictionaryMapper | EnumMapper;\n\nexport interface PolymorphicDiscriminator {\n  serializedName: string;\n  clientName: string;\n  [key: string]: string;\n}\n\nexport interface CompositeMapper extends BaseMapper {\n  type: CompositeMapperType;\n}\n\nexport interface SequenceMapper extends BaseMapper {\n  type: SequenceMapperType;\n}\n\nexport interface DictionaryMapper extends BaseMapper {\n  type: DictionaryMapperType;\n  headerCollectionPrefix?: string;\n}\n\nexport interface EnumMapper extends BaseMapper {\n  type: EnumMapperType;\n}\n\nexport interface UrlParameterValue {\n  value: string;\n  skipUrlEncoding: boolean;\n}\n\n// TODO: why is this here?\nexport function serializeObject(toSerialize: unknown): any {\n  const castToSerialize = toSerialize as Record<string, unknown>;\n  if (toSerialize == undefined) return undefined;\n  if (toSerialize instanceof Uint8Array) {\n    toSerialize = base64.encodeByteArray(toSerialize);\n    return toSerialize;\n  } else if (toSerialize instanceof Date) {\n    return toSerialize.toISOString();\n  } else if (Array.isArray(toSerialize)) {\n    const array = [];\n    for (let i = 0; i < toSerialize.length; i++) {\n      array.push(serializeObject(toSerialize[i]));\n    }\n    return array;\n  } else if (typeof toSerialize === \"object\") {\n    const dictionary: { [key: string]: any } = {};\n    for (const property in toSerialize) {\n      dictionary[property] = serializeObject(castToSerialize[property]);\n    }\n    return dictionary;\n  }\n  return toSerialize;\n}\n\n/**\n * Utility function to create a K:V from a list of strings\n */\nfunction strEnum<T extends string>(o: Array<T>): { [K in T]: K } {\n  const result: any = {};\n  for (const key of o) {\n    result[key] = key;\n  }\n  return result;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const MapperType = strEnum([\n  \"Base64Url\",\n  \"Boolean\",\n  \"ByteArray\",\n  \"Composite\",\n  \"Date\",\n  \"DateTime\",\n  \"DateTimeRfc1123\",\n  \"Dictionary\",\n  \"Enum\",\n  \"Number\",\n  \"Object\",\n  \"Sequence\",\n  \"String\",\n  \"Stream\",\n  \"TimeSpan\",\n  \"UnixTime\"\n]);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}