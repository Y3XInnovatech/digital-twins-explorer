{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"cose-base\"), require(\"numeric\"));else if (typeof define === 'function' && define.amd) define([\"cose-base\", \"numeric\"], factory);else if (typeof exports === 'object') exports[\"cytoscapeFcose\"] = factory(require(\"cose-base\"), require(\"numeric\"));else root[\"cytoscapeFcose\"] = factory(root[\"coseBase\"], root[\"numeric\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_7__) {\n  return /******/function (modules) {\n    // webpackBootstrap\n    /******/ // The module cache\n    /******/\n    var installedModules = {};\n    /******/\n    /******/ // The require function\n    /******/\n    function __webpack_require__(moduleId) {\n      /******/\n      /******/ // Check if module is in cache\n      /******/if (installedModules[moduleId]) {\n        /******/return installedModules[moduleId].exports;\n        /******/\n      }\n      /******/ // Create a new module (and put it into the cache)\n      /******/\n      var module = installedModules[moduleId] = {\n        /******/i: moduleId,\n        /******/l: false,\n        /******/exports: {}\n        /******/\n      };\n      /******/\n      /******/ // Execute the module function\n      /******/\n      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n      /******/\n      /******/ // Flag the module as loaded\n      /******/\n      module.l = true;\n      /******/\n      /******/ // Return the exports of the module\n      /******/\n      return module.exports;\n      /******/\n    }\n    /******/\n    /******/\n    /******/ // expose the modules object (__webpack_modules__)\n    /******/\n    __webpack_require__.m = modules;\n    /******/\n    /******/ // expose the module cache\n    /******/\n    __webpack_require__.c = installedModules;\n    /******/\n    /******/ // identity function for calling harmony imports with the correct context\n    /******/\n    __webpack_require__.i = function (value) {\n      return value;\n    };\n    /******/\n    /******/ // define getter function for harmony exports\n    /******/\n    __webpack_require__.d = function (exports, name, getter) {\n      /******/if (!__webpack_require__.o(exports, name)) {\n        /******/Object.defineProperty(exports, name, {\n          /******/configurable: false,\n          /******/enumerable: true,\n          /******/get: getter\n          /******/\n        });\n        /******/\n      }\n      /******/\n    };\n    /******/\n    /******/ // getDefaultExport function for compatibility with non-harmony modules\n    /******/\n    __webpack_require__.n = function (module) {\n      /******/var getter = module && module.__esModule ? /******/function getDefault() {\n        return module['default'];\n      } : /******/function getModuleExports() {\n        return module;\n      };\n      /******/\n      __webpack_require__.d(getter, 'a', getter);\n      /******/\n      return getter;\n      /******/\n    };\n    /******/\n    /******/ // Object.prototype.hasOwnProperty.call\n    /******/\n    __webpack_require__.o = function (object, property) {\n      return Object.prototype.hasOwnProperty.call(object, property);\n    };\n    /******/\n    /******/ // __webpack_public_path__\n    /******/\n    __webpack_require__.p = \"\";\n    /******/\n    /******/ // Load entry module and return exports\n    /******/\n    return __webpack_require__(__webpack_require__.s = 6);\n    /******/\n  }\n  /************************************************************************/\n  /******/([(/* 0 */\n  /***/function (module, exports) {\n    module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n    /***/\n  }), (/* 1 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    /*\n     * Auxiliary functions\n     */\n    var LinkedList = __webpack_require__(0).layoutBase.LinkedList;\n    var auxiliary = {};\n    auxiliary.multMat = function (array1, array2) {\n      var result = [];\n      for (var i = 0; i < array1.length; i++) {\n        result[i] = [];\n        for (var j = 0; j < array2[0].length; j++) {\n          result[i][j] = 0;\n          for (var k = 0; k < array1[0].length; k++) {\n            result[i][j] += array1[i][k] * array2[k][j];\n          }\n        }\n      }\n      return result;\n    };\n    auxiliary.multGamma = function (array) {\n      var result = [];\n      var sum = 0;\n      for (var i = 0; i < array.length; i++) {\n        sum += array[i];\n      }\n      sum *= -1 / array.length;\n      for (var _i = 0; _i < array.length; _i++) {\n        result[_i] = sum + array[_i];\n      }\n      return result;\n    };\n    auxiliary.multL = function (array, C, INV) {\n      var result = [];\n      var temp1 = [];\n      var temp2 = [];\n\n      // multiply by C^T\n      for (var i = 0; i < C[0].length; i++) {\n        var sum = 0;\n        for (var j = 0; j < C.length; j++) {\n          sum += -0.5 * C[j][i] * array[j];\n        }\n        temp1[i] = sum;\n      }\n      // multiply the result by INV\n      for (var _i2 = 0; _i2 < INV.length; _i2++) {\n        var _sum = 0;\n        for (var _j = 0; _j < INV.length; _j++) {\n          _sum += INV[_i2][_j] * temp1[_j];\n        }\n        temp2[_i2] = _sum;\n      }\n      // multiply the result by C\n      for (var _i3 = 0; _i3 < C.length; _i3++) {\n        var _sum2 = 0;\n        for (var _j2 = 0; _j2 < C[0].length; _j2++) {\n          _sum2 += C[_i3][_j2] * temp2[_j2];\n        }\n        result[_i3] = _sum2;\n      }\n      return result;\n    };\n    auxiliary.multCons = function (array, constant) {\n      var result = [];\n      for (var i = 0; i < array.length; i++) {\n        result[i] = array[i] * constant;\n      }\n      return result;\n    };\n\n    // assumes arrays have same size\n    auxiliary.minusOp = function (array1, array2) {\n      var result = [];\n      for (var i = 0; i < array1.length; i++) {\n        result[i] = array1[i] - array2[i];\n      }\n      return result;\n    };\n\n    // assumes arrays have same size\n    auxiliary.dotProduct = function (array1, array2) {\n      var product = 0;\n      for (var i = 0; i < array1.length; i++) {\n        product += array1[i] * array2[i];\n      }\n      return product;\n    };\n    auxiliary.mag = function (array) {\n      return Math.sqrt(this.dotProduct(array, array));\n    };\n    auxiliary.normalize = function (array) {\n      var result = [];\n      var magnitude = this.mag(array);\n      for (var i = 0; i < array.length; i++) {\n        result[i] = array[i] / magnitude;\n      }\n      return result;\n    };\n\n    // get the top most nodes\n    auxiliary.getTopMostNodes = function (nodes) {\n      var nodesMap = {};\n      for (var i = 0; i < nodes.length; i++) {\n        nodesMap[nodes[i].id()] = true;\n      }\n      var roots = nodes.filter(function (ele, i) {\n        if (typeof ele === \"number\") {\n          ele = i;\n        }\n        var parent = ele.parent()[0];\n        while (parent != null) {\n          if (nodesMap[parent.id()]) {\n            return false;\n          }\n          parent = parent.parent()[0];\n        }\n        return true;\n      });\n      return roots;\n    };\n\n    // find disconnected components and create dummy nodes that connect them\n    auxiliary.connectComponents = function (cy, eles, topMostNodes, dummyNodes) {\n      var queue = new LinkedList();\n      var visited = new Set();\n      var visitedTopMostNodes = [];\n      var currentNeighbor = void 0;\n      var minDegreeNode = void 0;\n      var minDegree = void 0;\n      var isConnected = false;\n      var count = 1;\n      var nodesConnectedToDummy = [];\n      var components = [];\n      var _loop = function _loop() {\n        var cmpt = cy.collection();\n        components.push(cmpt);\n        var currentNode = topMostNodes[0];\n        var childrenOfCurrentNode = cy.collection();\n        childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants());\n        visitedTopMostNodes.push(currentNode);\n        childrenOfCurrentNode.forEach(function (node) {\n          queue.push(node);\n          visited.add(node);\n          cmpt.merge(node);\n        });\n        var _loop2 = function _loop2() {\n          currentNode = queue.shift();\n\n          // Traverse all neighbors of this node\n          var neighborNodes = cy.collection();\n          currentNode.neighborhood().nodes().forEach(function (node) {\n            if (eles.anySame(currentNode.edgesWith(node))) {\n              neighborNodes.merge(node);\n            }\n          });\n          for (var i = 0; i < neighborNodes.length; i++) {\n            var neighborNode = neighborNodes[i];\n            currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));\n            if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {\n              var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());\n              childrenOfNeighbor.forEach(function (node) {\n                queue.push(node);\n                visited.add(node);\n                cmpt.merge(node);\n                if (topMostNodes.has(node)) {\n                  visitedTopMostNodes.push(node);\n                }\n              });\n            }\n          }\n        };\n        while (queue.length != 0) {\n          _loop2();\n        }\n        cmpt.forEach(function (node) {\n          node.connectedEdges().forEach(function (e) {\n            // connectedEdges() usually cached\n            if (cmpt.has(e.source()) && cmpt.has(e.target())) {\n              // has() is cheap\n              cmpt.merge(e); // forEach() only considers nodes -- sets N at call time\n            }\n          });\n        });\n        if (visitedTopMostNodes.length == topMostNodes.length) {\n          isConnected = true;\n        }\n        if (!isConnected || isConnected && count > 1) {\n          minDegreeNode = visitedTopMostNodes[0];\n          minDegree = minDegreeNode.connectedEdges().length;\n          visitedTopMostNodes.forEach(function (node) {\n            if (node.connectedEdges().length < minDegree) {\n              minDegree = node.connectedEdges().length;\n              minDegreeNode = node;\n            }\n          });\n          nodesConnectedToDummy.push(minDegreeNode.id());\n          // TO DO: Check efficiency of this part\n          var temp = cy.collection();\n          temp.merge(visitedTopMostNodes[0]);\n          visitedTopMostNodes.forEach(function (node) {\n            temp.merge(node);\n          });\n          visitedTopMostNodes = [];\n          topMostNodes = topMostNodes.difference(temp);\n          count++;\n        }\n      };\n      do {\n        _loop();\n      } while (!isConnected);\n      if (dummyNodes) {\n        if (nodesConnectedToDummy.length > 0) {\n          dummyNodes.set('dummy' + (dummyNodes.size + 1), nodesConnectedToDummy);\n        }\n      }\n      return components;\n    };\n    auxiliary.calcBoundingBox = function (parentNode, xCoords, yCoords, nodeIndexes) {\n      // calculate bounds\n      var left = Number.MAX_VALUE;\n      var right = Number.MIN_VALUE;\n      var top = Number.MAX_VALUE;\n      var bottom = Number.MIN_VALUE;\n      var nodeLeft = void 0;\n      var nodeRight = void 0;\n      var nodeTop = void 0;\n      var nodeBottom = void 0;\n      var nodes = parentNode.descendants().not(\":parent\");\n      var s = nodes.length;\n      for (var i = 0; i < s; i++) {\n        var node = nodes[i];\n        nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;\n        nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;\n        nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;\n        nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;\n        if (left > nodeLeft) {\n          left = nodeLeft;\n        }\n        if (right < nodeRight) {\n          right = nodeRight;\n        }\n        if (top > nodeTop) {\n          top = nodeTop;\n        }\n        if (bottom < nodeBottom) {\n          bottom = nodeBottom;\n        }\n      }\n      var boundingBox = {};\n      boundingBox.topLeftX = left;\n      boundingBox.topLeftY = top;\n      boundingBox.width = right - left;\n      boundingBox.height = bottom - top;\n      return boundingBox;\n    };\n    module.exports = auxiliary;\n\n    /***/\n  }), (/* 2 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var _createClass = function () {\n      function defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n      return function (Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) defineProperties(Constructor, staticProps);\n        return Constructor;\n      };\n    }();\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n      }\n    }\n\n    /**\n      The implementation of the fcose layout algorithm\n    */\n\n    var assign = __webpack_require__(3);\n    var aux = __webpack_require__(1);\n    var _require = __webpack_require__(5),\n      spectralLayout = _require.spectralLayout;\n    var _require2 = __webpack_require__(4),\n      coseLayout = _require2.coseLayout;\n    var defaults = Object.freeze({\n      // 'draft', 'default' or 'proof' \n      // - 'draft' only applies spectral layout \n      // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)\n      // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) \n      quality: \"default\",\n      // Use random node positions at beginning of layout\n      // if this is set to false, then quality option must be \"proof\"\n      randomize: true,\n      // Whether or not to animate the layout\n      animate: true,\n      // Duration of animation in ms, if enabled\n      animationDuration: 1000,\n      // Easing of animation, if enabled\n      animationEasing: undefined,\n      // Fit the viewport to the repositioned nodes\n      fit: true,\n      // Padding around layout\n      padding: 30,\n      // Whether to include labels in node dimensions. Valid in \"proof\" quality\n      nodeDimensionsIncludeLabels: false,\n      // Whether or not simple nodes (non-compound nodes) are of uniform dimensions\n      uniformNodeDimensions: false,\n      // Whether to pack disconnected components - valid only if randomize: true\n      packComponents: true,\n      /* spectral layout options */\n\n      // False for random, true for greedy\n      samplingType: true,\n      // Sample size to construct distance matrix\n      sampleSize: 25,\n      // Separation amount between nodes\n      nodeSeparation: 75,\n      // Power iteration tolerance\n      piTol: 0.0000001,\n      /* CoSE layout options */\n\n      // Node repulsion (non overlapping) multiplier\n      nodeRepulsion: 4500,\n      // Ideal edge (non nested) length\n      idealEdgeLength: 50,\n      // Divisor to compute edge forces\n      edgeElasticity: 0.45,\n      // Nesting factor (multiplier) to compute ideal edge length for nested edges\n      nestingFactor: 0.1,\n      // Gravity force (constant)\n      gravity: 0.25,\n      // Maximum number of iterations to perform\n      numIter: 2500,\n      // For enabling tiling\n      tile: true,\n      // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n      tilingPaddingVertical: 10,\n      // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n      tilingPaddingHorizontal: 10,\n      // Gravity range (constant) for compounds\n      gravityRangeCompound: 1.5,\n      // Gravity force (constant) for compounds\n      gravityCompound: 1.0,\n      // Gravity range (constant)\n      gravityRange: 3.8,\n      // Initial cooling factor for incremental layout  \n      initialEnergyOnIncremental: 0.3,\n      /* layout event callbacks */\n      ready: function ready() {},\n      // on layoutready\n      stop: function stop() {} // on layoutstop\n    });\n    var Layout = function () {\n      function Layout(options) {\n        _classCallCheck(this, Layout);\n        this.options = assign({}, defaults, options);\n      }\n      _createClass(Layout, [{\n        key: 'run',\n        value: function run() {\n          var layout = this;\n          var options = this.options;\n          var cy = options.cy;\n          var eles = options.eles;\n          var spectralResult = [];\n          var xCoords = void 0;\n          var yCoords = void 0;\n          var coseResult = [];\n          var components = void 0;\n\n          // if there is no elements, return\n          if (options.eles.length == 0) return;\n\n          // decide component packing is enabled or not\n          var layUtil = void 0;\n          var packingEnabled = false;\n          if (cy.layoutUtilities && options.packComponents && options.randomize) {\n            layUtil = cy.layoutUtilities(\"get\");\n            if (!layUtil) layUtil = cy.layoutUtilities();\n            packingEnabled = true;\n          }\n\n          // if partial layout, update options.eles\n          if (options.eles.length != options.cy.elements().length) {\n            var prevNodes = eles.nodes();\n            eles = eles.union(eles.descendants());\n            eles.forEach(function (ele) {\n              if (ele.isNode()) {\n                var connectedEdges = ele.connectedEdges();\n                connectedEdges.forEach(function (edge) {\n                  if (eles.contains(edge.source()) && eles.contains(edge.target()) && !prevNodes.contains(edge.source().union(edge.target()))) {\n                    eles = eles.union(edge);\n                  }\n                });\n              }\n            });\n            options.eles = eles;\n          }\n\n          // if packing is not enabled, perform layout on the whole graph\n          if (!packingEnabled) {\n            if (options.randomize) {\n              // Apply spectral layout\n              spectralResult.push(spectralLayout(options));\n              xCoords = spectralResult[0][\"xCoords\"];\n              yCoords = spectralResult[0][\"yCoords\"];\n            }\n\n            // Apply cose layout as postprocessing\n            if (options.quality == \"default\" || options.quality == \"proof\") {\n              coseResult.push(coseLayout(options, spectralResult[0]));\n            }\n          } else {\n            // packing is enabled\n            var topMostNodes = aux.getTopMostNodes(options.eles.nodes());\n            components = aux.connectComponents(cy, options.eles, topMostNodes);\n\n            //send each component to spectral layout\n            if (options.randomize) {\n              components.forEach(function (component) {\n                options.eles = component;\n                spectralResult.push(spectralLayout(options));\n              });\n            }\n            if (options.quality == \"default\" || options.quality == \"proof\") {\n              var toBeTiledNodes = cy.collection();\n              if (options.tile) {\n                // behave nodes to be tiled as one component\n                var nodeIndexes = new Map();\n                var _xCoords = [];\n                var _yCoords = [];\n                var count = 0;\n                var tempSpectralResult = {\n                  nodeIndexes: nodeIndexes,\n                  xCoords: _xCoords,\n                  yCoords: _yCoords\n                };\n                var indexesToBeDeleted = [];\n                components.forEach(function (component, index) {\n                  if (component.edges().length == 0) {\n                    component.nodes().forEach(function (node, i) {\n                      toBeTiledNodes.merge(component.nodes()[i]);\n                      if (!node.isParent()) {\n                        tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);\n                        tempSpectralResult.xCoords.push(component.nodes()[0].position().x);\n                        tempSpectralResult.yCoords.push(component.nodes()[0].position().y);\n                      }\n                    });\n                    indexesToBeDeleted.push(index);\n                  }\n                });\n                if (toBeTiledNodes.length > 1) {\n                  components.push(toBeTiledNodes);\n                  spectralResult.push(tempSpectralResult);\n                  for (var i = indexesToBeDeleted.length - 1; i >= 0; i--) {\n                    components.splice(indexesToBeDeleted[i], 1);\n                    spectralResult.splice(indexesToBeDeleted[i], 1);\n                  }\n                  ;\n                }\n              }\n              components.forEach(function (component, index) {\n                // send each component to cose layout\n                options.eles = component;\n                coseResult.push(coseLayout(options, spectralResult[index]));\n              });\n            }\n\n            // packing\n            var subgraphs = [];\n            components.forEach(function (component, index) {\n              var nodeIndexes = void 0;\n              if (options.quality == \"draft\") {\n                nodeIndexes = spectralResult[index].nodeIndexes;\n              }\n              var subgraph = {};\n              subgraph.nodes = [];\n              subgraph.edges = [];\n              var nodeIndex = void 0;\n              component.nodes().forEach(function (node) {\n                if (options.quality == \"draft\") {\n                  if (!node.isParent()) {\n                    nodeIndex = nodeIndexes.get(node.id());\n                    subgraph.nodes.push({\n                      x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2,\n                      y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2,\n                      width: node.boundingbox().w,\n                      height: node.boundingbox().h\n                    });\n                  } else {\n                    var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                    subgraph.nodes.push({\n                      x: parentInfo.topLeftX,\n                      y: parentInfo.topLeftY,\n                      width: parentInfo.width,\n                      height: parentInfo.height\n                    });\n                  }\n                } else {\n                  subgraph.nodes.push({\n                    x: coseResult[index][node.id()].getLeft(),\n                    y: coseResult[index][node.id()].getTop(),\n                    width: coseResult[index][node.id()].getWidth(),\n                    height: coseResult[index][node.id()].getHeight()\n                  });\n                }\n              });\n              component.edges().forEach(function (node) {\n                var source = node.source();\n                var target = node.target();\n                if (options.quality == \"draft\") {\n                  var sourceNodeIndex = nodeIndexes.get(source.id());\n                  var targetNodeIndex = nodeIndexes.get(target.id());\n                  var sourceCenter = [];\n                  var targetCenter = [];\n                  if (source.isParent()) {\n                    var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                    sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);\n                    sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);\n                  } else {\n                    sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);\n                    sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);\n                  }\n                  if (target.isParent()) {\n                    var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                    targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);\n                    targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);\n                  } else {\n                    targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);\n                    targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);\n                  }\n                  subgraph.edges.push({\n                    startX: sourceCenter[0],\n                    startY: sourceCenter[1],\n                    endX: targetCenter[0],\n                    endY: targetCenter[1]\n                  });\n                } else {\n                  subgraph.edges.push({\n                    startX: coseResult[index][source.id()].getCenterX(),\n                    startY: coseResult[index][source.id()].getCenterY(),\n                    endX: coseResult[index][target.id()].getCenterX(),\n                    endY: coseResult[index][target.id()].getCenterY()\n                  });\n                }\n              });\n              subgraphs.push(subgraph);\n            });\n            var shiftResult = layUtil.packComponents(subgraphs).shifts;\n            if (options.quality == \"draft\") {\n              spectralResult.forEach(function (result, index) {\n                var newXCoords = result.xCoords.map(function (x) {\n                  return x + shiftResult[index].dx;\n                });\n                var newYCoords = result.yCoords.map(function (y) {\n                  return y + shiftResult[index].dy;\n                });\n                result.xCoords = newXCoords;\n                result.yCoords = newYCoords;\n              });\n            } else {\n              coseResult.forEach(function (result, index) {\n                Object.keys(result).forEach(function (item) {\n                  var nodeRectangle = result[item];\n                  nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[index].dx, nodeRectangle.getCenterY() + shiftResult[index].dy);\n                });\n              });\n            }\n          }\n\n          // get each element's calculated position\n          var getPositions = function getPositions(ele, i) {\n            if (options.quality == \"default\" || options.quality == \"proof\") {\n              if (typeof ele === \"number\") {\n                ele = i;\n              }\n              var pos = void 0;\n              var theId = ele.data('id');\n              coseResult.forEach(function (result) {\n                if (theId in result) {\n                  pos = {\n                    x: result[theId].getRect().getCenterX(),\n                    y: result[theId].getRect().getCenterY()\n                  };\n                }\n              });\n              return {\n                x: pos.x,\n                y: pos.y\n              };\n            } else {\n              var _pos = void 0;\n              spectralResult.forEach(function (result) {\n                var index = result.nodeIndexes.get(ele.id());\n                if (index != undefined) {\n                  _pos = {\n                    x: result.xCoords[index],\n                    y: result.yCoords[index]\n                  };\n                }\n              });\n              if (_pos == undefined) _pos = {\n                x: ele.position(\"x\"),\n                y: ele.position(\"y\")\n              };\n              return {\n                x: _pos.x,\n                y: _pos.y\n              };\n            }\n          };\n\n          // quality = \"draft\" and randomize = false are contradictive so in that case positions don't change\n          if (options.quality == \"default\" || options.quality == \"proof\" || options.randomize) {\n            // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)\n            options.eles = eles;\n            eles.nodes().not(\":parent\").layoutPositions(layout, options, getPositions);\n          } else {\n            console.log(\"If randomize option is set to false, then quality option must be 'default' or 'proof'.\");\n          }\n        }\n      }]);\n      return Layout;\n    }();\n    module.exports = Layout;\n\n    /***/\n  }), (/* 3 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    // Simple, internal Object.assign() polyfill for options objects etc.\n    module.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n      for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        srcs[_key - 1] = arguments[_key];\n      }\n      srcs.forEach(function (src) {\n        Object.keys(src).forEach(function (k) {\n          return tgt[k] = src[k];\n        });\n      });\n      return tgt;\n    };\n\n    /***/\n  }), (/* 4 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    /**\n      The implementation of the postprocessing part that applies CoSE layout over the spectral layout\n    */\n    var aux = __webpack_require__(1);\n    var CoSELayout = __webpack_require__(0).CoSELayout;\n    var CoSENode = __webpack_require__(0).CoSENode;\n    var PointD = __webpack_require__(0).layoutBase.PointD;\n    var DimensionD = __webpack_require__(0).layoutBase.DimensionD;\n    var LayoutConstants = __webpack_require__(0).layoutBase.LayoutConstants;\n    var FDLayoutConstants = __webpack_require__(0).layoutBase.FDLayoutConstants;\n    var CoSEConstants = __webpack_require__(0).CoSEConstants;\n\n    // main function that cose layout is processed\n    var coseLayout = function coseLayout(options, spectralResult) {\n      var eles = options.eles;\n      var nodes = eles.nodes();\n      var edges = eles.edges();\n      var nodeIndexes = void 0;\n      var xCoords = void 0;\n      var yCoords = void 0;\n      var idToLNode = {};\n      if (options.randomize) {\n        nodeIndexes = spectralResult[\"nodeIndexes\"];\n        xCoords = spectralResult[\"xCoords\"];\n        yCoords = spectralResult[\"yCoords\"];\n      }\n\n      /**** Postprocessing functions ****/\n\n      // transfer cytoscape nodes to cose nodes\n      var processChildrenList = function processChildrenList(parent, children, layout, options) {\n        var size = children.length;\n        for (var i = 0; i < size; i++) {\n          var theChild = children[i];\n          var children_of_children = theChild.children();\n          var theNode = void 0;\n          var dimensions = theChild.layoutDimensions({\n            nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels\n          });\n          if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n            if (options.randomize) {\n              if (!theChild.isParent()) {\n                theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n              } else {\n                var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);\n                theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));\n              }\n            } else {\n              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n            }\n          } else {\n            theNode = parent.add(new CoSENode(this.graphManager));\n          }\n          // Attach id to the layout node\n          theNode.id = theChild.data(\"id\");\n          // Attach the paddings of cy node to layout node\n          theNode.paddingLeft = parseInt(theChild.css('padding'));\n          theNode.paddingTop = parseInt(theChild.css('padding'));\n          theNode.paddingRight = parseInt(theChild.css('padding'));\n          theNode.paddingBottom = parseInt(theChild.css('padding'));\n\n          //Attach the label properties to compound if labels will be included in node dimensions  \n          if (options.nodeDimensionsIncludeLabels) {\n            if (theChild.isParent()) {\n              var labelWidth = theChild.boundingBox({\n                includeLabels: true,\n                includeNodes: false\n              }).w;\n              var labelHeight = theChild.boundingBox({\n                includeLabels: true,\n                includeNodes: false\n              }).h;\n              var labelPos = theChild.css(\"text-halign\");\n              theNode.labelWidth = labelWidth;\n              theNode.labelHeight = labelHeight;\n              theNode.labelPos = labelPos;\n            }\n          }\n\n          // Map the layout node\n          idToLNode[theChild.data(\"id\")] = theNode;\n          if (isNaN(theNode.rect.x)) {\n            theNode.rect.x = 0;\n          }\n          if (isNaN(theNode.rect.y)) {\n            theNode.rect.y = 0;\n          }\n          if (children_of_children != null && children_of_children.length > 0) {\n            var theNewGraph = void 0;\n            theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n            processChildrenList(theNewGraph, children_of_children, layout, options);\n          }\n        }\n      };\n\n      // transfer cytoscape edges to cose edges\n      var processEdges = function processEdges(layout, gm, edges) {\n        for (var i = 0; i < edges.length; i++) {\n          var edge = edges[i];\n          var sourceNode = idToLNode[edge.data(\"source\")];\n          var targetNode = idToLNode[edge.data(\"target\")];\n          if (sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n            var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n            e1.id = edge.id();\n          }\n        }\n      };\n\n      /**** Apply postprocessing ****/\n\n      if (options.nodeRepulsion != null) CoSEConstants.DEFAULT_REPULSION_STRENGTH = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = options.nodeRepulsion;\n      if (options.idealEdgeLength != null) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;\n      if (options.edgeElasticity != null) CoSEConstants.DEFAULT_SPRING_STRENGTH = FDLayoutConstants.DEFAULT_SPRING_STRENGTH = options.edgeElasticity;\n      if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n      if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n      if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n      if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n      if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n      if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n      if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n      if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 0;\n      CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n      CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n      CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n      CoSEConstants.TILE = options.tile;\n      CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n      CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n      CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;\n      LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;\n      var coseLayout = new CoSELayout();\n      var gm = coseLayout.newGraphManager();\n      processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);\n      processEdges(coseLayout, gm, edges);\n      coseLayout.runLayout();\n      return idToLNode;\n    };\n    module.exports = {\n      coseLayout: coseLayout\n    };\n\n    /***/\n  }), (/* 5 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    /**\n      The implementation of the spectral layout that is the first part of the fcose layout algorithm\n    */\n    var aux = __webpack_require__(1);\n    var numeric = __webpack_require__(7);\n\n    // main function that spectral layout is processed\n    var spectralLayout = function spectralLayout(options) {\n      var cy = options.cy;\n      var eles = options.eles;\n      var nodes = eles.nodes();\n      var parentNodes = eles.nodes(\":parent\");\n      var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors\n      var nodeIndexes = new Map(); // map to keep indexes to nodes\n      var parentChildMap = new Map(); // mapping btw. compound and its representative node \n      var allNodesNeighborhood = []; // array to keep neighborhood of all nodes\n      var xCoords = [];\n      var yCoords = [];\n      var samplesColumn = []; // sampled vertices\n      var minDistancesColumn = [];\n      var C = []; // column sampling matrix\n      var PHI = []; // intersection of column and row sampling matrices \n      var INV = []; // inverse of PHI \n\n      var firstSample = void 0; // the first sampled node\n      var nodeSize = void 0;\n      var infinity = 100000000;\n      var small = 0.000000001;\n      var piTol = options.piTol;\n      var samplingType = options.samplingType; // false for random, true for greedy\n      var nodeSeparation = options.nodeSeparation;\n      var sampleSize = void 0;\n\n      /**** Spectral-preprocessing functions ****/\n\n      /**** Spectral layout functions ****/\n\n      // determine which columns to be sampled\n      var randomSampleCR = function randomSampleCR() {\n        var sample = 0;\n        var count = 0;\n        var flag = false;\n        while (count < sampleSize) {\n          sample = Math.floor(Math.random() * nodeSize);\n          flag = false;\n          for (var i = 0; i < count; i++) {\n            if (samplesColumn[i] == sample) {\n              flag = true;\n              break;\n            }\n          }\n          if (!flag) {\n            samplesColumn[count] = sample;\n            count++;\n          } else {\n            continue;\n          }\n        }\n      };\n\n      // takes the index of the node(pivot) to initiate BFS as a parameter\n      var BFS = function BFS(pivot, index, samplingMethod) {\n        var path = []; // the front of the path\n        var front = 0; // the back of the path\n        var back = 0;\n        var current = 0;\n        var temp = void 0;\n        var distance = [];\n        var max_dist = 0; // the furthest node to be returned\n        var max_ind = 1;\n        for (var i = 0; i < nodeSize; i++) {\n          distance[i] = infinity;\n        }\n        path[back] = pivot;\n        distance[pivot] = 0;\n        while (back >= front) {\n          current = path[front++];\n          var neighbors = allNodesNeighborhood[current];\n          for (var _i = 0; _i < neighbors.length; _i++) {\n            temp = nodeIndexes.get(neighbors[_i]);\n            if (distance[temp] == infinity) {\n              distance[temp] = distance[current] + 1;\n              path[++back] = temp;\n            }\n          }\n          C[current][index] = distance[current] * nodeSeparation;\n        }\n        if (samplingMethod) {\n          for (var _i2 = 0; _i2 < nodeSize; _i2++) {\n            if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];\n          }\n          for (var _i3 = 0; _i3 < nodeSize; _i3++) {\n            if (minDistancesColumn[_i3] > max_dist) {\n              max_dist = minDistancesColumn[_i3];\n              max_ind = _i3;\n            }\n          }\n        }\n        return max_ind;\n      };\n\n      // apply BFS to all nodes or selected samples\n      var allBFS = function allBFS(samplingMethod) {\n        var sample = void 0;\n        if (!samplingMethod) {\n          randomSampleCR();\n\n          // call BFS\n          for (var i = 0; i < sampleSize; i++) {\n            BFS(samplesColumn[i], i, samplingMethod, false);\n          }\n        } else {\n          sample = Math.floor(Math.random() * nodeSize);\n          firstSample = sample;\n          for (var _i4 = 0; _i4 < nodeSize; _i4++) {\n            minDistancesColumn[_i4] = infinity;\n          }\n          for (var _i5 = 0; _i5 < sampleSize; _i5++) {\n            samplesColumn[_i5] = sample;\n            sample = BFS(sample, _i5, samplingMethod);\n          }\n        }\n\n        // form the squared distances for C\n        for (var _i6 = 0; _i6 < nodeSize; _i6++) {\n          for (var j = 0; j < sampleSize; j++) {\n            C[_i6][j] *= C[_i6][j];\n          }\n        }\n\n        // form PHI\n        for (var _i7 = 0; _i7 < sampleSize; _i7++) {\n          PHI[_i7] = [];\n        }\n        for (var _i8 = 0; _i8 < sampleSize; _i8++) {\n          for (var _j = 0; _j < sampleSize; _j++) {\n            PHI[_i8][_j] = C[samplesColumn[_j]][_i8];\n          }\n        }\n      };\n\n      // perform the SVD algorithm and apply a regularization step\n      var sample = function sample() {\n        var SVDResult = numeric.svd(PHI);\n        var a_w = SVDResult.S;\n        var a_u = SVDResult.U;\n        var a_v = SVDResult.V;\n        var max_s = a_w[0] * a_w[0] * a_w[0];\n        var a_Sig = [];\n\n        //  regularization\n        for (var i = 0; i < sampleSize; i++) {\n          a_Sig[i] = [];\n          for (var j = 0; j < sampleSize; j++) {\n            a_Sig[i][j] = 0;\n            if (i == j) {\n              a_Sig[i][j] = a_w[i] / (a_w[i] * a_w[i] + max_s / (a_w[i] * a_w[i]));\n            }\n          }\n        }\n        INV = aux.multMat(aux.multMat(a_v, a_Sig), numeric.transpose(a_u));\n      };\n\n      // calculate final coordinates \n      var powerIteration = function powerIteration() {\n        // two largest eigenvalues\n        var theta1 = void 0;\n        var theta2 = void 0;\n\n        // initial guesses for eigenvectors\n        var Y1 = [];\n        var Y2 = [];\n        var V1 = [];\n        var V2 = [];\n        for (var i = 0; i < nodeSize; i++) {\n          Y1[i] = Math.random();\n          Y2[i] = Math.random();\n        }\n        Y1 = aux.normalize(Y1);\n        Y2 = aux.normalize(Y2);\n        var count = 0;\n        // to keep track of the improvement ratio in power iteration\n        var current = small;\n        var previous = small;\n        var temp = void 0;\n        while (true) {\n          count++;\n          for (var _i9 = 0; _i9 < nodeSize; _i9++) {\n            V1[_i9] = Y1[_i9];\n          }\n          Y1 = aux.multGamma(aux.multL(aux.multGamma(V1), C, INV));\n          theta1 = aux.dotProduct(V1, Y1);\n          Y1 = aux.normalize(Y1);\n          current = aux.dotProduct(V1, Y1);\n          temp = Math.abs(current / previous);\n          if (temp <= 1 + piTol && temp >= 1) {\n            break;\n          }\n          previous = current;\n        }\n        for (var _i10 = 0; _i10 < nodeSize; _i10++) {\n          V1[_i10] = Y1[_i10];\n        }\n        count = 0;\n        previous = small;\n        while (true) {\n          count++;\n          for (var _i11 = 0; _i11 < nodeSize; _i11++) {\n            V2[_i11] = Y2[_i11];\n          }\n          V2 = aux.minusOp(V2, aux.multCons(V1, aux.dotProduct(V1, V2)));\n          Y2 = aux.multGamma(aux.multL(aux.multGamma(V2), C, INV));\n          theta2 = aux.dotProduct(V2, Y2);\n          Y2 = aux.normalize(Y2);\n          current = aux.dotProduct(V2, Y2);\n          temp = Math.abs(current / previous);\n          if (temp <= 1 + piTol && temp >= 1) {\n            break;\n          }\n          previous = current;\n        }\n        for (var _i12 = 0; _i12 < nodeSize; _i12++) {\n          V2[_i12] = Y2[_i12];\n        }\n\n        // theta1 now contains dominant eigenvalue\n        // theta2 now contains the second-largest eigenvalue\n        // V1 now contains theta1's eigenvector\n        // V2 now contains theta2's eigenvector\n\n        //populate the two vectors\n        xCoords = aux.multCons(V1, Math.sqrt(Math.abs(theta1)));\n        yCoords = aux.multCons(V2, Math.sqrt(Math.abs(theta2)));\n      };\n\n      /**** Preparation for spectral layout (Preprocessing) ****/\n\n      // connect disconnected components (first top level, then inside of each compound node)\n      aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);\n      parentNodes.forEach(function (ele) {\n        aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants()), dummyNodes);\n      });\n\n      // assign indexes to nodes (first real, then dummy nodes)\n      var index = 0;\n      for (var i = 0; i < nodes.length; i++) {\n        if (!nodes[i].isParent()) {\n          nodeIndexes.set(nodes[i].id(), index++);\n        }\n      }\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n      try {\n        for (var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n          nodeIndexes.set(key, index++);\n        }\n\n        // instantiate the neighborhood matrix\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      for (var _i13 = 0; _i13 < nodeIndexes.size; _i13++) {\n        allNodesNeighborhood[_i13] = [];\n      }\n\n      // form a parent-child map to keep representative node of each compound node  \n      parentNodes.forEach(function (ele) {\n        var children = ele.children();\n\n        //      let random = 0;\n        while (children.nodes(\":childless\").length == 0) {\n          //        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly\n          children = children.nodes()[0].children();\n        }\n        //  select the representative node - we can apply different methods here\n        //      random = Math.floor(Math.random() * children.nodes(\":childless\").length);\n        var index = 0;\n        var min = children.nodes(\":childless\")[0].connectedEdges().length;\n        children.nodes(\":childless\").forEach(function (ele2, i) {\n          if (ele2.connectedEdges().length < min) {\n            min = ele2.connectedEdges().length;\n            index = i;\n          }\n        });\n        parentChildMap.set(ele.id(), children.nodes(\":childless\")[index].id());\n      });\n\n      // add neighborhood relations (first real, then dummy nodes)\n      nodes.forEach(function (ele) {\n        var eleIndex = void 0;\n        if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));else eleIndex = nodeIndexes.get(ele.id());\n        ele.neighborhood().nodes().forEach(function (node) {\n          if (eles.anySame(ele.edgesWith(node))) {\n            if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));else allNodesNeighborhood[eleIndex].push(node.id());\n          }\n        });\n      });\n      var _loop = function _loop(_key) {\n        var eleIndex = nodeIndexes.get(_key);\n        var disconnectedId = void 0;\n        dummyNodes.get(_key).forEach(function (id) {\n          if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);else disconnectedId = id;\n          allNodesNeighborhood[eleIndex].push(disconnectedId);\n          allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);\n        });\n      };\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n      try {\n        for (var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _key = _step2.value;\n          _loop(_key);\n        }\n\n        // nodeSize now only considers the size of transformed graph\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n      nodeSize = nodeIndexes.size;\n      var spectralResult = void 0;\n\n      // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem\n      // So skip spectral and layout the graph with cose\n      if (nodeSize > 2) {\n        // if # of nodes in transformed graph is smaller than sample size,\n        // then use # of nodes as sample size\n        sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;\n\n        // instantiates the partial matrices that will be used in spectral layout\n        for (var _i14 = 0; _i14 < nodeSize; _i14++) {\n          C[_i14] = [];\n        }\n        for (var _i15 = 0; _i15 < sampleSize; _i15++) {\n          INV[_i15] = [];\n        }\n\n        /**** Apply spectral layout ****/\n\n        allBFS(samplingType);\n        sample();\n        powerIteration();\n        spectralResult = {\n          nodeIndexes: nodeIndexes,\n          xCoords: xCoords,\n          yCoords: yCoords\n        };\n        return spectralResult;\n      } else {\n        var iterator = nodeIndexes.keys();\n        var firstNode = cy.getElementById(iterator.next().value);\n        var firstNodePos = firstNode.position();\n        var firstNodeWidth = firstNode.outerWidth();\n        xCoords.push(firstNodePos.x);\n        yCoords.push(firstNodePos.y);\n        if (nodeSize == 2) {\n          var secondNode = cy.getElementById(iterator.next().value);\n          var secondNodeWidth = secondNode.outerWidth();\n          xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);\n          yCoords.push(firstNodePos.y);\n        }\n        spectralResult = {\n          nodeIndexes: nodeIndexes,\n          xCoords: xCoords,\n          yCoords: yCoords\n        };\n        return spectralResult;\n      }\n    };\n    module.exports = {\n      spectralLayout: spectralLayout\n    };\n\n    /***/\n  }), (/* 6 */\n  /***/function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var impl = __webpack_require__(2);\n\n    // registers the extension on a cytoscape lib ref\n    var register = function register(cytoscape) {\n      if (!cytoscape) {\n        return;\n      } // can't register if cytoscape unspecified\n\n      cytoscape('layout', 'fcose', impl); // register with cytoscape.js\n    };\n    if (typeof cytoscape !== 'undefined') {\n      // expose to global cytoscape (i.e. window.cytoscape)\n      register(cytoscape);\n    }\n    module.exports = register;\n\n    /***/\n  }), (/* 7 */\n  /***/function (module, exports) {\n    module.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n    /***/\n  }\n  /******/)]);\n});","map":{"version":3,"names":["webpackUniversalModuleDefinition","root","factory","exports","module","require","define","amd","__WEBPACK_EXTERNAL_MODULE_0__","__WEBPACK_EXTERNAL_MODULE_7__","modules","installedModules","__webpack_require__","moduleId","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","LinkedList","layoutBase","auxiliary","multMat","array1","array2","result","length","j","k","multGamma","array","sum","_i","multL","C","INV","temp1","temp2","_i2","_sum","_j","_i3","_sum2","_j2","multCons","constant","minusOp","dotProduct","product","mag","Math","sqrt","normalize","magnitude","getTopMostNodes","nodes","nodesMap","id","roots","filter","ele","parent","connectComponents","cy","eles","topMostNodes","dummyNodes","queue","visited","Set","visitedTopMostNodes","currentNeighbor","minDegreeNode","minDegree","isConnected","count","nodesConnectedToDummy","components","_loop","cmpt","collection","push","currentNode","childrenOfCurrentNode","merge","descendants","forEach","node","add","_loop2","shift","neighborNodes","neighborhood","anySame","edgesWith","neighborNode","intersection","union","ancestors","has","childrenOfNeighbor","connectedEdges","e","source","target","temp","difference","set","size","calcBoundingBox","parentNode","xCoords","yCoords","nodeIndexes","left","Number","MAX_VALUE","right","MIN_VALUE","top","bottom","nodeLeft","nodeRight","nodeTop","nodeBottom","not","width","height","boundingBox","topLeftX","topLeftY","_createClass","defineProperties","props","descriptor","writable","key","Constructor","protoProps","staticProps","_classCallCheck","instance","TypeError","assign","aux","_require","spectralLayout","_require2","coseLayout","defaults","freeze","quality","randomize","animate","animationDuration","animationEasing","undefined","fit","padding","nodeDimensionsIncludeLabels","uniformNodeDimensions","packComponents","samplingType","sampleSize","nodeSeparation","piTol","nodeRepulsion","idealEdgeLength","edgeElasticity","nestingFactor","gravity","numIter","tile","tilingPaddingVertical","tilingPaddingHorizontal","gravityRangeCompound","gravityCompound","gravityRange","initialEnergyOnIncremental","ready","stop","Layout","options","run","layout","spectralResult","coseResult","layUtil","packingEnabled","layoutUtilities","elements","prevNodes","isNode","edge","contains","component","toBeTiledNodes","Map","_xCoords","_yCoords","tempSpectralResult","indexesToBeDeleted","index","edges","isParent","position","x","y","splice","subgraphs","subgraph","nodeIndex","boundingbox","w","h","parentInfo","getLeft","getTop","getWidth","getHeight","sourceNodeIndex","targetNodeIndex","sourceCenter","targetCenter","_parentInfo","startX","startY","endX","endY","getCenterX","getCenterY","shiftResult","shifts","newXCoords","map","dx","newYCoords","dy","keys","item","nodeRectangle","setCenter","getPositions","pos","theId","data","getRect","_pos","layoutPositions","console","log","bind","tgt","_len","arguments","srcs","Array","_key","src","CoSELayout","CoSENode","PointD","DimensionD","LayoutConstants","FDLayoutConstants","CoSEConstants","idToLNode","processChildrenList","children","theChild","children_of_children","theNode","dimensions","layoutDimensions","outerWidth","outerHeight","graphManager","parseFloat","paddingLeft","parseInt","css","paddingTop","paddingRight","paddingBottom","labelWidth","includeLabels","includeNodes","labelHeight","labelPos","isNaN","rect","theNewGraph","getGraphManager","newGraph","processEdges","gm","sourceNode","targetNode","getEdgesBetween","e1","newEdge","DEFAULT_REPULSION_STRENGTH","DEFAULT_EDGE_LENGTH","DEFAULT_SPRING_STRENGTH","PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR","DEFAULT_GRAVITY_STRENGTH","MAX_ITERATIONS","DEFAULT_GRAVITY_RANGE_FACTOR","DEFAULT_COMPOUND_GRAVITY_STRENGTH","DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR","DEFAULT_COOLING_FACTOR_INCREMENTAL","QUALITY","NODE_DIMENSIONS_INCLUDE_LABELS","DEFAULT_INCREMENTAL","ANIMATE","TILE","TILING_PADDING_VERTICAL","TILING_PADDING_HORIZONTAL","DEFAULT_UNIFORM_LEAF_NODE_SIZES","newGraphManager","addRoot","runLayout","numeric","parentNodes","parentChildMap","allNodesNeighborhood","samplesColumn","minDistancesColumn","PHI","firstSample","nodeSize","infinity","small","randomSampleCR","sample","flag","floor","random","BFS","pivot","samplingMethod","path","front","back","current","distance","max_dist","max_ind","neighbors","allBFS","_i4","_i5","_i6","_i7","_i8","SVDResult","svd","a_w","S","a_u","U","a_v","V","max_s","a_Sig","transpose","powerIteration","theta1","theta2","Y1","Y2","V1","V2","previous","_i9","abs","_i10","_i11","_i12","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","Symbol","iterator","_step","next","done","err","return","_i13","min","ele2","eleIndex","disconnectedId","getElementById","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_i14","_i15","firstNode","firstNodePos","firstNodeWidth","secondNode","secondNodeWidth","impl","register","cytoscape"],"sources":["/home/saharsh/Music/digital-twins-explorer/client/node_modules/cytoscape-fcose/cytoscape-fcose.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"cose-base\"), require(\"numeric\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"cose-base\", \"numeric\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cytoscapeFcose\"] = factory(require(\"cose-base\"), require(\"numeric\"));\n\telse\n\t\troot[\"cytoscapeFcose\"] = factory(root[\"coseBase\"], root[\"numeric\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_7__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\n * Auxiliary functions\n */\n\nvar LinkedList = __webpack_require__(0).layoutBase.LinkedList;\n\nvar auxiliary = {};\n\nauxiliary.multMat = function (array1, array2) {\n  var result = [];\n\n  for (var i = 0; i < array1.length; i++) {\n    result[i] = [];\n    for (var j = 0; j < array2[0].length; j++) {\n      result[i][j] = 0;\n      for (var k = 0; k < array1[0].length; k++) {\n        result[i][j] += array1[i][k] * array2[k][j];\n      }\n    }\n  }\n  return result;\n};\n\nauxiliary.multGamma = function (array) {\n  var result = [];\n  var sum = 0;\n\n  for (var i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n\n  sum *= -1 / array.length;\n\n  for (var _i = 0; _i < array.length; _i++) {\n    result[_i] = sum + array[_i];\n  }\n  return result;\n};\n\nauxiliary.multL = function (array, C, INV) {\n  var result = [];\n  var temp1 = [];\n  var temp2 = [];\n\n  // multiply by C^T\n  for (var i = 0; i < C[0].length; i++) {\n    var sum = 0;\n    for (var j = 0; j < C.length; j++) {\n      sum += -0.5 * C[j][i] * array[j];\n    }\n    temp1[i] = sum;\n  }\n  // multiply the result by INV\n  for (var _i2 = 0; _i2 < INV.length; _i2++) {\n    var _sum = 0;\n    for (var _j = 0; _j < INV.length; _j++) {\n      _sum += INV[_i2][_j] * temp1[_j];\n    }\n    temp2[_i2] = _sum;\n  }\n  // multiply the result by C\n  for (var _i3 = 0; _i3 < C.length; _i3++) {\n    var _sum2 = 0;\n    for (var _j2 = 0; _j2 < C[0].length; _j2++) {\n      _sum2 += C[_i3][_j2] * temp2[_j2];\n    }\n    result[_i3] = _sum2;\n  }\n\n  return result;\n};\n\nauxiliary.multCons = function (array, constant) {\n  var result = [];\n\n  for (var i = 0; i < array.length; i++) {\n    result[i] = array[i] * constant;\n  }\n\n  return result;\n};\n\n// assumes arrays have same size\nauxiliary.minusOp = function (array1, array2) {\n  var result = [];\n\n  for (var i = 0; i < array1.length; i++) {\n    result[i] = array1[i] - array2[i];\n  }\n\n  return result;\n};\n\n// assumes arrays have same size\nauxiliary.dotProduct = function (array1, array2) {\n  var product = 0;\n\n  for (var i = 0; i < array1.length; i++) {\n    product += array1[i] * array2[i];\n  }\n\n  return product;\n};\n\nauxiliary.mag = function (array) {\n  return Math.sqrt(this.dotProduct(array, array));\n};\n\nauxiliary.normalize = function (array) {\n  var result = [];\n  var magnitude = this.mag(array);\n\n  for (var i = 0; i < array.length; i++) {\n    result[i] = array[i] / magnitude;\n  }\n\n  return result;\n};\n\n// get the top most nodes\nauxiliary.getTopMostNodes = function (nodes) {\n  var nodesMap = {};\n  for (var i = 0; i < nodes.length; i++) {\n    nodesMap[nodes[i].id()] = true;\n  }\n  var roots = nodes.filter(function (ele, i) {\n    if (typeof ele === \"number\") {\n      ele = i;\n    }\n    var parent = ele.parent()[0];\n    while (parent != null) {\n      if (nodesMap[parent.id()]) {\n        return false;\n      }\n      parent = parent.parent()[0];\n    }\n    return true;\n  });\n\n  return roots;\n};\n\n// find disconnected components and create dummy nodes that connect them\nauxiliary.connectComponents = function (cy, eles, topMostNodes, dummyNodes) {\n  var queue = new LinkedList();\n  var visited = new Set();\n  var visitedTopMostNodes = [];\n  var currentNeighbor = void 0;\n  var minDegreeNode = void 0;\n  var minDegree = void 0;\n\n  var isConnected = false;\n  var count = 1;\n  var nodesConnectedToDummy = [];\n  var components = [];\n\n  var _loop = function _loop() {\n    var cmpt = cy.collection();\n    components.push(cmpt);\n\n    var currentNode = topMostNodes[0];\n    var childrenOfCurrentNode = cy.collection();\n    childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants());\n    visitedTopMostNodes.push(currentNode);\n\n    childrenOfCurrentNode.forEach(function (node) {\n      queue.push(node);\n      visited.add(node);\n      cmpt.merge(node);\n    });\n\n    var _loop2 = function _loop2() {\n      currentNode = queue.shift();\n\n      // Traverse all neighbors of this node\n      var neighborNodes = cy.collection();\n      currentNode.neighborhood().nodes().forEach(function (node) {\n        if (eles.anySame(currentNode.edgesWith(node))) {\n          neighborNodes.merge(node);\n        }\n      });\n\n      for (var i = 0; i < neighborNodes.length; i++) {\n        var neighborNode = neighborNodes[i];\n        currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));\n        if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {\n          var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());\n\n          childrenOfNeighbor.forEach(function (node) {\n            queue.push(node);\n            visited.add(node);\n            cmpt.merge(node);\n            if (topMostNodes.has(node)) {\n              visitedTopMostNodes.push(node);\n            }\n          });\n        }\n      }\n    };\n\n    while (queue.length != 0) {\n      _loop2();\n    }\n\n    cmpt.forEach(function (node) {\n      node.connectedEdges().forEach(function (e) {\n        // connectedEdges() usually cached\n        if (cmpt.has(e.source()) && cmpt.has(e.target())) {\n          // has() is cheap\n          cmpt.merge(e); // forEach() only considers nodes -- sets N at call time\n        }\n      });\n    });\n\n    if (visitedTopMostNodes.length == topMostNodes.length) {\n      isConnected = true;\n    }\n\n    if (!isConnected || isConnected && count > 1) {\n      minDegreeNode = visitedTopMostNodes[0];\n      minDegree = minDegreeNode.connectedEdges().length;\n      visitedTopMostNodes.forEach(function (node) {\n        if (node.connectedEdges().length < minDegree) {\n          minDegree = node.connectedEdges().length;\n          minDegreeNode = node;\n        }\n      });\n      nodesConnectedToDummy.push(minDegreeNode.id());\n      // TO DO: Check efficiency of this part\n      var temp = cy.collection();\n      temp.merge(visitedTopMostNodes[0]);\n      visitedTopMostNodes.forEach(function (node) {\n        temp.merge(node);\n      });\n      visitedTopMostNodes = [];\n      topMostNodes = topMostNodes.difference(temp);\n      count++;\n    }\n  };\n\n  do {\n    _loop();\n  } while (!isConnected);\n\n  if (dummyNodes) {\n    if (nodesConnectedToDummy.length > 0) {\n      dummyNodes.set('dummy' + (dummyNodes.size + 1), nodesConnectedToDummy);\n    }\n  }\n  return components;\n};\n\nauxiliary.calcBoundingBox = function (parentNode, xCoords, yCoords, nodeIndexes) {\n  // calculate bounds\n  var left = Number.MAX_VALUE;\n  var right = Number.MIN_VALUE;\n  var top = Number.MAX_VALUE;\n  var bottom = Number.MIN_VALUE;\n  var nodeLeft = void 0;\n  var nodeRight = void 0;\n  var nodeTop = void 0;\n  var nodeBottom = void 0;\n\n  var nodes = parentNode.descendants().not(\":parent\");\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var node = nodes[i];\n\n    nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;\n    nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;\n    nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;\n    nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingBox = {};\n  boundingBox.topLeftX = left;\n  boundingBox.topLeftY = top;\n  boundingBox.width = right - left;\n  boundingBox.height = bottom - top;\n  return boundingBox;\n};\n\nmodule.exports = auxiliary;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n  The implementation of the fcose layout algorithm\n*/\n\nvar assign = __webpack_require__(3);\nvar aux = __webpack_require__(1);\n\nvar _require = __webpack_require__(5),\n    spectralLayout = _require.spectralLayout;\n\nvar _require2 = __webpack_require__(4),\n    coseLayout = _require2.coseLayout;\n\nvar defaults = Object.freeze({\n\n  // 'draft', 'default' or 'proof' \n  // - 'draft' only applies spectral layout \n  // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)\n  // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) \n  quality: \"default\",\n  // Use random node positions at beginning of layout\n  // if this is set to false, then quality option must be \"proof\"\n  randomize: true,\n  // Whether or not to animate the layout\n  animate: true,\n  // Duration of animation in ms, if enabled\n  animationDuration: 1000,\n  // Easing of animation, if enabled\n  animationEasing: undefined,\n  // Fit the viewport to the repositioned nodes\n  fit: true,\n  // Padding around layout\n  padding: 30,\n  // Whether to include labels in node dimensions. Valid in \"proof\" quality\n  nodeDimensionsIncludeLabels: false,\n  // Whether or not simple nodes (non-compound nodes) are of uniform dimensions\n  uniformNodeDimensions: false,\n  // Whether to pack disconnected components - valid only if randomize: true\n  packComponents: true,\n\n  /* spectral layout options */\n\n  // False for random, true for greedy\n  samplingType: true,\n  // Sample size to construct distance matrix\n  sampleSize: 25,\n  // Separation amount between nodes\n  nodeSeparation: 75,\n  // Power iteration tolerance\n  piTol: 0.0000001,\n\n  /* CoSE layout options */\n\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: 4500,\n  // Ideal edge (non nested) length\n  idealEdgeLength: 50,\n  // Divisor to compute edge forces\n  edgeElasticity: 0.45,\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 0.1,\n  // Gravity force (constant)\n  gravity: 0.25,\n  // Maximum number of iterations to perform\n  numIter: 2500,\n  // For enabling tiling\n  tile: true,\n  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingVertical: 10,\n  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingHorizontal: 10,\n  // Gravity range (constant) for compounds\n  gravityRangeCompound: 1.5,\n  // Gravity force (constant) for compounds\n  gravityCompound: 1.0,\n  // Gravity range (constant)\n  gravityRange: 3.8,\n  // Initial cooling factor for incremental layout  \n  initialEnergyOnIncremental: 0.3,\n\n  /* layout event callbacks */\n  ready: function ready() {}, // on layoutready\n  stop: function stop() {} // on layoutstop\n});\n\nvar Layout = function () {\n  function Layout(options) {\n    _classCallCheck(this, Layout);\n\n    this.options = assign({}, defaults, options);\n  }\n\n  _createClass(Layout, [{\n    key: 'run',\n    value: function run() {\n      var layout = this;\n      var options = this.options;\n      var cy = options.cy;\n      var eles = options.eles;\n\n      var spectralResult = [];\n      var xCoords = void 0;\n      var yCoords = void 0;\n      var coseResult = [];\n      var components = void 0;\n\n      // if there is no elements, return\n      if (options.eles.length == 0) return;\n\n      // decide component packing is enabled or not\n      var layUtil = void 0;\n      var packingEnabled = false;\n      if (cy.layoutUtilities && options.packComponents && options.randomize) {\n        layUtil = cy.layoutUtilities(\"get\");\n        if (!layUtil) layUtil = cy.layoutUtilities();\n        packingEnabled = true;\n      }\n\n      // if partial layout, update options.eles\n      if (options.eles.length != options.cy.elements().length) {\n        var prevNodes = eles.nodes();\n        eles = eles.union(eles.descendants());\n\n        eles.forEach(function (ele) {\n          if (ele.isNode()) {\n            var connectedEdges = ele.connectedEdges();\n            connectedEdges.forEach(function (edge) {\n              if (eles.contains(edge.source()) && eles.contains(edge.target()) && !prevNodes.contains(edge.source().union(edge.target()))) {\n                eles = eles.union(edge);\n              }\n            });\n          }\n        });\n\n        options.eles = eles;\n      }\n\n      // if packing is not enabled, perform layout on the whole graph\n      if (!packingEnabled) {\n        if (options.randomize) {\n          // Apply spectral layout\n          spectralResult.push(spectralLayout(options));\n          xCoords = spectralResult[0][\"xCoords\"];\n          yCoords = spectralResult[0][\"yCoords\"];\n        }\n\n        // Apply cose layout as postprocessing\n        if (options.quality == \"default\" || options.quality == \"proof\") {\n          coseResult.push(coseLayout(options, spectralResult[0]));\n        }\n      } else {\n        // packing is enabled\n        var topMostNodes = aux.getTopMostNodes(options.eles.nodes());\n        components = aux.connectComponents(cy, options.eles, topMostNodes);\n\n        //send each component to spectral layout\n        if (options.randomize) {\n          components.forEach(function (component) {\n            options.eles = component;\n            spectralResult.push(spectralLayout(options));\n          });\n        }\n\n        if (options.quality == \"default\" || options.quality == \"proof\") {\n          var toBeTiledNodes = cy.collection();\n          if (options.tile) {\n            // behave nodes to be tiled as one component\n            var nodeIndexes = new Map();\n            var _xCoords = [];\n            var _yCoords = [];\n            var count = 0;\n            var tempSpectralResult = { nodeIndexes: nodeIndexes, xCoords: _xCoords, yCoords: _yCoords };\n            var indexesToBeDeleted = [];\n            components.forEach(function (component, index) {\n              if (component.edges().length == 0) {\n                component.nodes().forEach(function (node, i) {\n                  toBeTiledNodes.merge(component.nodes()[i]);\n                  if (!node.isParent()) {\n                    tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);\n                    tempSpectralResult.xCoords.push(component.nodes()[0].position().x);\n                    tempSpectralResult.yCoords.push(component.nodes()[0].position().y);\n                  }\n                });\n                indexesToBeDeleted.push(index);\n              }\n            });\n            if (toBeTiledNodes.length > 1) {\n              components.push(toBeTiledNodes);\n              spectralResult.push(tempSpectralResult);\n              for (var i = indexesToBeDeleted.length - 1; i >= 0; i--) {\n                components.splice(indexesToBeDeleted[i], 1);\n                spectralResult.splice(indexesToBeDeleted[i], 1);\n              };\n            }\n          }\n          components.forEach(function (component, index) {\n            // send each component to cose layout\n            options.eles = component;\n            coseResult.push(coseLayout(options, spectralResult[index]));\n          });\n        }\n\n        // packing\n        var subgraphs = [];\n        components.forEach(function (component, index) {\n          var nodeIndexes = void 0;\n          if (options.quality == \"draft\") {\n            nodeIndexes = spectralResult[index].nodeIndexes;\n          }\n          var subgraph = {};\n          subgraph.nodes = [];\n          subgraph.edges = [];\n          var nodeIndex = void 0;\n          component.nodes().forEach(function (node) {\n            if (options.quality == \"draft\") {\n              if (!node.isParent()) {\n                nodeIndex = nodeIndexes.get(node.id());\n                subgraph.nodes.push({ x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2, y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2, width: node.boundingbox().w, height: node.boundingbox().h });\n              } else {\n                var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                subgraph.nodes.push({ x: parentInfo.topLeftX, y: parentInfo.topLeftY, width: parentInfo.width, height: parentInfo.height });\n              }\n            } else {\n              subgraph.nodes.push({ x: coseResult[index][node.id()].getLeft(), y: coseResult[index][node.id()].getTop(), width: coseResult[index][node.id()].getWidth(), height: coseResult[index][node.id()].getHeight() });\n            }\n          });\n          component.edges().forEach(function (node) {\n            var source = node.source();\n            var target = node.target();\n            if (options.quality == \"draft\") {\n              var sourceNodeIndex = nodeIndexes.get(source.id());\n              var targetNodeIndex = nodeIndexes.get(target.id());\n              var sourceCenter = [];\n              var targetCenter = [];\n              if (source.isParent()) {\n                var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);\n                sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);\n              } else {\n                sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);\n                sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);\n              }\n              if (target.isParent()) {\n                var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);\n                targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);\n              } else {\n                targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);\n                targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);\n              }\n              subgraph.edges.push({ startX: sourceCenter[0], startY: sourceCenter[1], endX: targetCenter[0], endY: targetCenter[1] });\n            } else {\n              subgraph.edges.push({ startX: coseResult[index][source.id()].getCenterX(), startY: coseResult[index][source.id()].getCenterY(), endX: coseResult[index][target.id()].getCenterX(), endY: coseResult[index][target.id()].getCenterY() });\n            }\n          });\n          subgraphs.push(subgraph);\n        });\n        var shiftResult = layUtil.packComponents(subgraphs).shifts;\n        if (options.quality == \"draft\") {\n          spectralResult.forEach(function (result, index) {\n            var newXCoords = result.xCoords.map(function (x) {\n              return x + shiftResult[index].dx;\n            });\n            var newYCoords = result.yCoords.map(function (y) {\n              return y + shiftResult[index].dy;\n            });\n            result.xCoords = newXCoords;\n            result.yCoords = newYCoords;\n          });\n        } else {\n          coseResult.forEach(function (result, index) {\n            Object.keys(result).forEach(function (item) {\n              var nodeRectangle = result[item];\n              nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[index].dx, nodeRectangle.getCenterY() + shiftResult[index].dy);\n            });\n          });\n        }\n      }\n\n      // get each element's calculated position\n      var getPositions = function getPositions(ele, i) {\n        if (options.quality == \"default\" || options.quality == \"proof\") {\n          if (typeof ele === \"number\") {\n            ele = i;\n          }\n          var pos = void 0;\n          var theId = ele.data('id');\n          coseResult.forEach(function (result) {\n            if (theId in result) {\n              pos = { x: result[theId].getRect().getCenterX(), y: result[theId].getRect().getCenterY() };\n            }\n          });\n          return {\n            x: pos.x,\n            y: pos.y\n          };\n        } else {\n          var _pos = void 0;\n          spectralResult.forEach(function (result) {\n            var index = result.nodeIndexes.get(ele.id());\n            if (index != undefined) {\n              _pos = { x: result.xCoords[index], y: result.yCoords[index] };\n            }\n          });\n          if (_pos == undefined) _pos = { x: ele.position(\"x\"), y: ele.position(\"y\") };\n          return {\n            x: _pos.x,\n            y: _pos.y\n          };\n        }\n      };\n\n      // quality = \"draft\" and randomize = false are contradictive so in that case positions don't change\n      if (options.quality == \"default\" || options.quality == \"proof\" || options.randomize) {\n        // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)\n        options.eles = eles;\n        eles.nodes().not(\":parent\").layoutPositions(layout, options, getPositions);\n      } else {\n        console.log(\"If randomize option is set to false, then quality option must be 'default' or 'proof'.\");\n      }\n    }\n  }]);\n\n  return Layout;\n}();\n\nmodule.exports = Layout;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// Simple, internal Object.assign() polyfill for options objects etc.\n\nmodule.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n  for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    srcs[_key - 1] = arguments[_key];\n  }\n\n  srcs.forEach(function (src) {\n    Object.keys(src).forEach(function (k) {\n      return tgt[k] = src[k];\n    });\n  });\n\n  return tgt;\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n  The implementation of the postprocessing part that applies CoSE layout over the spectral layout\n*/\n\nvar aux = __webpack_require__(1);\nvar CoSELayout = __webpack_require__(0).CoSELayout;\nvar CoSENode = __webpack_require__(0).CoSENode;\nvar PointD = __webpack_require__(0).layoutBase.PointD;\nvar DimensionD = __webpack_require__(0).layoutBase.DimensionD;\nvar LayoutConstants = __webpack_require__(0).layoutBase.LayoutConstants;\nvar FDLayoutConstants = __webpack_require__(0).layoutBase.FDLayoutConstants;\nvar CoSEConstants = __webpack_require__(0).CoSEConstants;\n\n// main function that cose layout is processed\nvar coseLayout = function coseLayout(options, spectralResult) {\n\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var edges = eles.edges();\n\n  var nodeIndexes = void 0;\n  var xCoords = void 0;\n  var yCoords = void 0;\n  var idToLNode = {};\n\n  if (options.randomize) {\n    nodeIndexes = spectralResult[\"nodeIndexes\"];\n    xCoords = spectralResult[\"xCoords\"];\n    yCoords = spectralResult[\"yCoords\"];\n  }\n\n  /**** Postprocessing functions ****/\n\n  // transfer cytoscape nodes to cose nodes\n  var processChildrenList = function processChildrenList(parent, children, layout, options) {\n    var size = children.length;\n    for (var i = 0; i < size; i++) {\n      var theChild = children[i];\n      var children_of_children = theChild.children();\n      var theNode = void 0;\n\n      var dimensions = theChild.layoutDimensions({\n        nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels\n      });\n\n      if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n        if (options.randomize) {\n          if (!theChild.isParent()) {\n            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n          } else {\n            var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);\n            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));\n          }\n        } else {\n          theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n        }\n      } else {\n        theNode = parent.add(new CoSENode(this.graphManager));\n      }\n      // Attach id to the layout node\n      theNode.id = theChild.data(\"id\");\n      // Attach the paddings of cy node to layout node\n      theNode.paddingLeft = parseInt(theChild.css('padding'));\n      theNode.paddingTop = parseInt(theChild.css('padding'));\n      theNode.paddingRight = parseInt(theChild.css('padding'));\n      theNode.paddingBottom = parseInt(theChild.css('padding'));\n\n      //Attach the label properties to compound if labels will be included in node dimensions  \n      if (options.nodeDimensionsIncludeLabels) {\n        if (theChild.isParent()) {\n          var labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false }).w;\n          var labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false }).h;\n          var labelPos = theChild.css(\"text-halign\");\n          theNode.labelWidth = labelWidth;\n          theNode.labelHeight = labelHeight;\n          theNode.labelPos = labelPos;\n        }\n      }\n\n      // Map the layout node\n      idToLNode[theChild.data(\"id\")] = theNode;\n\n      if (isNaN(theNode.rect.x)) {\n        theNode.rect.x = 0;\n      }\n\n      if (isNaN(theNode.rect.y)) {\n        theNode.rect.y = 0;\n      }\n\n      if (children_of_children != null && children_of_children.length > 0) {\n        var theNewGraph = void 0;\n        theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n        processChildrenList(theNewGraph, children_of_children, layout, options);\n      }\n    }\n  };\n\n  // transfer cytoscape edges to cose edges\n  var processEdges = function processEdges(layout, gm, edges) {\n    for (var i = 0; i < edges.length; i++) {\n      var edge = edges[i];\n      var sourceNode = idToLNode[edge.data(\"source\")];\n      var targetNode = idToLNode[edge.data(\"target\")];\n      if (sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n        var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n        e1.id = edge.id();\n      }\n    }\n  };\n\n  /**** Apply postprocessing ****/\n\n  if (options.nodeRepulsion != null) CoSEConstants.DEFAULT_REPULSION_STRENGTH = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = options.nodeRepulsion;\n  if (options.idealEdgeLength != null) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;\n  if (options.edgeElasticity != null) CoSEConstants.DEFAULT_SPRING_STRENGTH = FDLayoutConstants.DEFAULT_SPRING_STRENGTH = options.edgeElasticity;\n  if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n  if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n  if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n  if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n  if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n  if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n  if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n\n  if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 0;\n\n  CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n  CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n  CoSEConstants.TILE = options.tile;\n  CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n  CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;\n  LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;\n\n  var coseLayout = new CoSELayout();\n  var gm = coseLayout.newGraphManager();\n\n  processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);\n\n  processEdges(coseLayout, gm, edges);\n\n  coseLayout.runLayout();\n\n  return idToLNode;\n};\n\nmodule.exports = { coseLayout: coseLayout };\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n  The implementation of the spectral layout that is the first part of the fcose layout algorithm\n*/\n\nvar aux = __webpack_require__(1);\nvar numeric = __webpack_require__(7);\n\n// main function that spectral layout is processed\nvar spectralLayout = function spectralLayout(options) {\n\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var parentNodes = eles.nodes(\":parent\");\n\n  var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors\n  var nodeIndexes = new Map(); // map to keep indexes to nodes\n  var parentChildMap = new Map(); // mapping btw. compound and its representative node \n  var allNodesNeighborhood = []; // array to keep neighborhood of all nodes\n  var xCoords = [];\n  var yCoords = [];\n\n  var samplesColumn = []; // sampled vertices\n  var minDistancesColumn = [];\n  var C = []; // column sampling matrix\n  var PHI = []; // intersection of column and row sampling matrices \n  var INV = []; // inverse of PHI \n\n  var firstSample = void 0; // the first sampled node\n  var nodeSize = void 0;\n\n  var infinity = 100000000;\n  var small = 0.000000001;\n\n  var piTol = options.piTol;\n  var samplingType = options.samplingType; // false for random, true for greedy\n  var nodeSeparation = options.nodeSeparation;\n  var sampleSize = void 0;\n\n  /**** Spectral-preprocessing functions ****/\n\n  /**** Spectral layout functions ****/\n\n  // determine which columns to be sampled\n  var randomSampleCR = function randomSampleCR() {\n    var sample = 0;\n    var count = 0;\n    var flag = false;\n\n    while (count < sampleSize) {\n      sample = Math.floor(Math.random() * nodeSize);\n\n      flag = false;\n      for (var i = 0; i < count; i++) {\n        if (samplesColumn[i] == sample) {\n          flag = true;\n          break;\n        }\n      }\n\n      if (!flag) {\n        samplesColumn[count] = sample;\n        count++;\n      } else {\n        continue;\n      }\n    }\n  };\n\n  // takes the index of the node(pivot) to initiate BFS as a parameter\n  var BFS = function BFS(pivot, index, samplingMethod) {\n    var path = []; // the front of the path\n    var front = 0; // the back of the path\n    var back = 0;\n    var current = 0;\n    var temp = void 0;\n    var distance = [];\n\n    var max_dist = 0; // the furthest node to be returned\n    var max_ind = 1;\n\n    for (var i = 0; i < nodeSize; i++) {\n      distance[i] = infinity;\n    }\n\n    path[back] = pivot;\n    distance[pivot] = 0;\n\n    while (back >= front) {\n      current = path[front++];\n      var neighbors = allNodesNeighborhood[current];\n      for (var _i = 0; _i < neighbors.length; _i++) {\n        temp = nodeIndexes.get(neighbors[_i]);\n        if (distance[temp] == infinity) {\n          distance[temp] = distance[current] + 1;\n          path[++back] = temp;\n        }\n      }\n      C[current][index] = distance[current] * nodeSeparation;\n    }\n\n    if (samplingMethod) {\n      for (var _i2 = 0; _i2 < nodeSize; _i2++) {\n        if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];\n      }\n\n      for (var _i3 = 0; _i3 < nodeSize; _i3++) {\n        if (minDistancesColumn[_i3] > max_dist) {\n          max_dist = minDistancesColumn[_i3];\n          max_ind = _i3;\n        }\n      }\n    }\n    return max_ind;\n  };\n\n  // apply BFS to all nodes or selected samples\n  var allBFS = function allBFS(samplingMethod) {\n\n    var sample = void 0;\n\n    if (!samplingMethod) {\n      randomSampleCR();\n\n      // call BFS\n      for (var i = 0; i < sampleSize; i++) {\n        BFS(samplesColumn[i], i, samplingMethod, false);\n      }\n    } else {\n      sample = Math.floor(Math.random() * nodeSize);\n      firstSample = sample;\n\n      for (var _i4 = 0; _i4 < nodeSize; _i4++) {\n        minDistancesColumn[_i4] = infinity;\n      }\n\n      for (var _i5 = 0; _i5 < sampleSize; _i5++) {\n        samplesColumn[_i5] = sample;\n        sample = BFS(sample, _i5, samplingMethod);\n      }\n    }\n\n    // form the squared distances for C\n    for (var _i6 = 0; _i6 < nodeSize; _i6++) {\n      for (var j = 0; j < sampleSize; j++) {\n        C[_i6][j] *= C[_i6][j];\n      }\n    }\n\n    // form PHI\n    for (var _i7 = 0; _i7 < sampleSize; _i7++) {\n      PHI[_i7] = [];\n    }\n\n    for (var _i8 = 0; _i8 < sampleSize; _i8++) {\n      for (var _j = 0; _j < sampleSize; _j++) {\n        PHI[_i8][_j] = C[samplesColumn[_j]][_i8];\n      }\n    }\n  };\n\n  // perform the SVD algorithm and apply a regularization step\n  var sample = function sample() {\n\n    var SVDResult = numeric.svd(PHI);\n\n    var a_w = SVDResult.S;\n    var a_u = SVDResult.U;\n    var a_v = SVDResult.V;\n\n    var max_s = a_w[0] * a_w[0] * a_w[0];\n\n    var a_Sig = [];\n\n    //  regularization\n    for (var i = 0; i < sampleSize; i++) {\n      a_Sig[i] = [];\n      for (var j = 0; j < sampleSize; j++) {\n        a_Sig[i][j] = 0;\n        if (i == j) {\n          a_Sig[i][j] = a_w[i] / (a_w[i] * a_w[i] + max_s / (a_w[i] * a_w[i]));\n        }\n      }\n    }\n\n    INV = aux.multMat(aux.multMat(a_v, a_Sig), numeric.transpose(a_u));\n  };\n\n  // calculate final coordinates \n  var powerIteration = function powerIteration() {\n    // two largest eigenvalues\n    var theta1 = void 0;\n    var theta2 = void 0;\n\n    // initial guesses for eigenvectors\n    var Y1 = [];\n    var Y2 = [];\n\n    var V1 = [];\n    var V2 = [];\n\n    for (var i = 0; i < nodeSize; i++) {\n      Y1[i] = Math.random();\n      Y2[i] = Math.random();\n    }\n\n    Y1 = aux.normalize(Y1);\n    Y2 = aux.normalize(Y2);\n\n    var count = 0;\n    // to keep track of the improvement ratio in power iteration\n    var current = small;\n    var previous = small;\n\n    var temp = void 0;\n\n    while (true) {\n      count++;\n\n      for (var _i9 = 0; _i9 < nodeSize; _i9++) {\n        V1[_i9] = Y1[_i9];\n      }\n\n      Y1 = aux.multGamma(aux.multL(aux.multGamma(V1), C, INV));\n      theta1 = aux.dotProduct(V1, Y1);\n      Y1 = aux.normalize(Y1);\n\n      current = aux.dotProduct(V1, Y1);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i10 = 0; _i10 < nodeSize; _i10++) {\n      V1[_i10] = Y1[_i10];\n    }\n\n    count = 0;\n    previous = small;\n    while (true) {\n      count++;\n\n      for (var _i11 = 0; _i11 < nodeSize; _i11++) {\n        V2[_i11] = Y2[_i11];\n      }\n\n      V2 = aux.minusOp(V2, aux.multCons(V1, aux.dotProduct(V1, V2)));\n      Y2 = aux.multGamma(aux.multL(aux.multGamma(V2), C, INV));\n      theta2 = aux.dotProduct(V2, Y2);\n      Y2 = aux.normalize(Y2);\n\n      current = aux.dotProduct(V2, Y2);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i12 = 0; _i12 < nodeSize; _i12++) {\n      V2[_i12] = Y2[_i12];\n    }\n\n    // theta1 now contains dominant eigenvalue\n    // theta2 now contains the second-largest eigenvalue\n    // V1 now contains theta1's eigenvector\n    // V2 now contains theta2's eigenvector\n\n    //populate the two vectors\n    xCoords = aux.multCons(V1, Math.sqrt(Math.abs(theta1)));\n    yCoords = aux.multCons(V2, Math.sqrt(Math.abs(theta2)));\n  };\n\n  /**** Preparation for spectral layout (Preprocessing) ****/\n\n  // connect disconnected components (first top level, then inside of each compound node)\n  aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);\n\n  parentNodes.forEach(function (ele) {\n    aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants()), dummyNodes);\n  });\n\n  // assign indexes to nodes (first real, then dummy nodes)\n  var index = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    if (!nodes[i].isParent()) {\n      nodeIndexes.set(nodes[i].id(), index++);\n    }\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n\n      nodeIndexes.set(key, index++);\n    }\n\n    // instantiate the neighborhood matrix\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  for (var _i13 = 0; _i13 < nodeIndexes.size; _i13++) {\n    allNodesNeighborhood[_i13] = [];\n  }\n\n  // form a parent-child map to keep representative node of each compound node  \n  parentNodes.forEach(function (ele) {\n    var children = ele.children();\n\n    //      let random = 0;\n    while (children.nodes(\":childless\").length == 0) {\n      //        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly\n      children = children.nodes()[0].children();\n    }\n    //  select the representative node - we can apply different methods here\n    //      random = Math.floor(Math.random() * children.nodes(\":childless\").length);\n    var index = 0;\n    var min = children.nodes(\":childless\")[0].connectedEdges().length;\n    children.nodes(\":childless\").forEach(function (ele2, i) {\n      if (ele2.connectedEdges().length < min) {\n        min = ele2.connectedEdges().length;\n        index = i;\n      }\n    });\n    parentChildMap.set(ele.id(), children.nodes(\":childless\")[index].id());\n  });\n\n  // add neighborhood relations (first real, then dummy nodes)\n  nodes.forEach(function (ele) {\n    var eleIndex = void 0;\n\n    if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));else eleIndex = nodeIndexes.get(ele.id());\n\n    ele.neighborhood().nodes().forEach(function (node) {\n      if (eles.anySame(ele.edgesWith(node))) {\n        if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));else allNodesNeighborhood[eleIndex].push(node.id());\n      }\n    });\n  });\n\n  var _loop = function _loop(_key) {\n    var eleIndex = nodeIndexes.get(_key);\n    var disconnectedId = void 0;\n    dummyNodes.get(_key).forEach(function (id) {\n      if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);else disconnectedId = id;\n\n      allNodesNeighborhood[eleIndex].push(disconnectedId);\n      allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);\n    });\n  };\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _key = _step2.value;\n\n      _loop(_key);\n    }\n\n    // nodeSize now only considers the size of transformed graph\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  nodeSize = nodeIndexes.size;\n\n  var spectralResult = void 0;\n\n  // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem\n  // So skip spectral and layout the graph with cose\n  if (nodeSize > 2) {\n    // if # of nodes in transformed graph is smaller than sample size,\n    // then use # of nodes as sample size\n    sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;\n\n    // instantiates the partial matrices that will be used in spectral layout\n    for (var _i14 = 0; _i14 < nodeSize; _i14++) {\n      C[_i14] = [];\n    }\n    for (var _i15 = 0; _i15 < sampleSize; _i15++) {\n      INV[_i15] = [];\n    }\n\n    /**** Apply spectral layout ****/\n\n    allBFS(samplingType);\n    sample();\n    powerIteration();\n\n    spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    return spectralResult;\n  } else {\n    var iterator = nodeIndexes.keys();\n    var firstNode = cy.getElementById(iterator.next().value);\n    var firstNodePos = firstNode.position();\n    var firstNodeWidth = firstNode.outerWidth();\n    xCoords.push(firstNodePos.x);\n    yCoords.push(firstNodePos.y);\n    if (nodeSize == 2) {\n      var secondNode = cy.getElementById(iterator.next().value);\n      var secondNodeWidth = secondNode.outerWidth();\n      xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);\n      yCoords.push(firstNodePos.y);\n    }\n\n    spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    return spectralResult;\n  }\n};\n\nmodule.exports = { spectralLayout: spectralLayout };\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar impl = __webpack_require__(2);\n\n// registers the extension on a cytoscape lib ref\nvar register = function register(cytoscape) {\n  if (!cytoscape) {\n    return;\n  } // can't register if cytoscape unspecified\n\n  cytoscape('layout', 'fcose', impl); // register with cytoscape.js\n};\n\nif (typeof cytoscape !== 'undefined') {\n  // expose to global cytoscape (i.e. window.cytoscape)\n  register(cytoscape);\n}\n\nmodule.exports = register;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n/***/ })\n/******/ ]);\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}