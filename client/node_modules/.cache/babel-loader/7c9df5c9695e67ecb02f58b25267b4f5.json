{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst jsiterable_1 = __importDefault(require(\"jsiterable\"));\nconst constants_1 = require(\"./constants\");\n/**\n * @description Vertex filter type that can be used to match vertices based on a supplied filter.\n * @export\n * @class VertexFilter\n */\nclass VertexFilter {\n  /**\n   * @description Creates an instance of VertexFilter.\n   * @param {(string | types.VertexSelector)} selector The filter definition to use.\n   * @memberof VertexFilter\n   */\n  constructor(selector) {\n    this._selector = selector;\n  }\n  /**\n   * @description Checks if the filter matches the specified vertex.\n   * @param {Vertex} vertex The vertex to check.\n   * @returns {boolean} True if the vertex is a match, else false.\n   * @memberof VertexFilter\n   */\n  match(vertex) {\n    if (!this._selector) {\n      return true;\n    }\n    if (typeof this._selector === 'string') {\n      return vertex.id === this._selector;\n    }\n    return this._selector(vertex);\n  }\n}\nexports.VertexFilter = VertexFilter;\n/**\n * @description Represents a vertex in the graph.\n * @export\n * @class Vertex\n */\nclass Vertex {\n  /**\n   * @description Creates an instance of Vertex.\n   * @param {GraphNode} node The graph node this vertex wraps.\n   * @memberof Vertex\n   */\n  constructor(node, index) {\n    if (!node) {\n      throw new ReferenceError(`Invalid node. node is ${node}`);\n    }\n    if (!index) {\n      throw new ReferenceError(`Invalid index. index is ${index}`);\n    }\n    this._node = node;\n    this._index = index;\n  }\n  /**\n   * @description Gets the id of the vertex.\n   * @type {string}\n   * @memberof Vertex\n   */\n  get id() {\n    return this._node.id;\n  }\n  /**\n   * @description Sets the id of the vertex.\n   * @memberof Vertex\n   */\n  set id(id) {\n    this._node.id = id;\n  }\n  /**\n   * @description Gets all attributes defined in the vertex.\n   * @readonly\n   * @type {Iterable<[string, any]>}\n   * @memberof Vertex\n   */\n  get attributes() {\n    return this._node.attributes;\n  }\n  /**\n   * @description Returns true if the vertex is a blank node, else false.\n   * @readonly\n   * @type {boolean}\n   * @memberof Vertex\n   */\n  get isBlankNode() {\n    return this._node.id.startsWith(constants_1.BlankNodePrefix);\n  }\n  /**\n   * @description Gets all vertices that have a @type outgoing edge to this vertex.\n   * @readonly\n   * @type {Iterable<Vertex>}\n   * @memberof Vertex\n   */\n  get instances() {\n    return this.getIncoming(constants_1.JsonldKeywords.type).map(({\n      fromVertex\n    }) => fromVertex);\n  }\n  /**\n   * @description Gets metadata stored for the vertex.\n   * @readonly\n   * @type {*}\n   * @memberof Vertex\n   */\n  get metadata() {\n    return this._node.metadata;\n  }\n  /**\n   * @description Gets all vertices that this vertex is a @type of.\n   * @readonly\n   * @type {Iterable<Vertex>}\n   * @memberof Vertex\n   */\n  get types() {\n    return this.getOutgoing(constants_1.JsonldKeywords.type).map(({\n      toVertex\n    }) => toVertex);\n  }\n  /**\n   * @description Adds an attribute value.\n   * @param {string} name The name of the attribute.\n   * @param {*} value The value to add.\n   * @param {string} language The language the add an attribute value.\n   * @returns {this}\n   * @memberof Vertex\n   */\n  addAttributeValue(name, value, language) {\n    this._node.addAttributeValue(name, value, language);\n    return this;\n  }\n  /**\n   * @description Deletes a specific attribute of the vertex.\n   * @param {string} name The attribute name to delete.\n   * @param {string} [language] The optional language whose value should be deleted.\n   * @returns {this}\n   * @memberof Vertex\n   */\n  deleteAttribute(name, language) {\n    this._node.deleteAttribute(name, language);\n    return this;\n  }\n  /**\n   * @description Gets the value of an attribute.\n   * @template T\n   * @param {string} name The attribute label to get.\n   * @param {string} [language] Optional localized language of the value.\n   * @returns {T}\n   * @memberof Vertex\n   */\n  getAttributeValue(name, language) {\n    const values = this._node.getAttributeValues(name);\n    if (!values || values.length === 0) {\n      return undefined;\n    }\n    if (language) {\n      const localizedValue = values.find(x => x.language === language);\n      return localizedValue ? localizedValue.value : undefined;\n    } else {\n      return values[0].value;\n    }\n  }\n  /**\n   * @description Gets all values set for an attribute.\n   * @template T\n   * @param {string} name\n   * @param {string} [language]\n   * @returns {T[]}\n   * @memberof Vertex\n   */\n  getAttributeValues(name) {\n    return this._node.getAttributeValues(name);\n  }\n  /**\n   * @description Gets all incoming vertices to this vertex.\n   * @param {string} [edgeLabel] Optional edge label used to filter matching vertices with incoming edges with the specified label.\n   * @returns {Iterable<{ label: string, fromVertex: Vertex }>}\n   * @memberof Vertex\n   */\n  getIncoming(edgeLabel) {\n    return new jsiterable_1.default(this._index.getNodeIncoming(this._node.id, edgeLabel)).map(({\n      edge,\n      node\n    }) => {\n      return {\n        label: edge.label,\n        fromVertex: new Vertex(node, this._index)\n      };\n    });\n  }\n  /**\n   * @description Gets all outgoing vertices from this vertex.\n   * @param {string} [edgeLabel] Optional edge label used to filter matching vertices with outgoing edges with the specified label.\n   * @returns {Iterable<{ label: string, toVertex: Vertex }>}\n   * @memberof Vertex\n   */\n  getOutgoing(edgeLabel) {\n    return new jsiterable_1.default(this._index.getNodeOutgoing(this._node.id, edgeLabel)).map(({\n      edge,\n      node\n    }) => {\n      return {\n        label: edge.label,\n        toVertex: new Vertex(node, this._index)\n      };\n    });\n  }\n  /**\n   * @description Checks if an attribute has been defined on the vertex.\n   * @param {string} name The name of the attribute to check.\n   * @returns {boolean} True if the attribute has been defined, else false.\n   * @memberof Vertex\n   */\n  hasAttribute(name) {\n    return this._node.hasAttribute(name);\n  }\n  /**\n   * @description Checks if an attribute exists and if has the specified value.\n   * @param {string} name The name of the attribute to check.\n   * @param {*} value The value of the attribute to check.\n   * @returns {boolean} True if the value exists, else false.\n   * @memberof Vertex\n   */\n  hasAttributeValue(name, value, language) {\n    return this._node.hasAttributeValue(name, value, language);\n  }\n  /**\n   * @description Checks if the vertex is of a specific @type.\n   * @param {string} typeId The type id to check for.\n   * @returns {boolean} True if the vertex has a @type outgoing edge to the specified type id, else false.\n   * @memberof Vertex\n   */\n  isType(typeId) {\n    if (!typeId) {\n      throw new ReferenceError(`Invalid typeId. typeId is ${typeId}`);\n    }\n    return [...this.types.filter(x => x.id === typeId)].length === 1;\n  }\n  /**\n   * @description Removes incoming edges.\n   * @param {string} [edgeLabel] Optional edge label used to remove only matching edges.\n   * @param {(string | VertexSelector)} [selector] Optional vertex selector used to remove only matching vertices.\n   * @returns {this}\n   * @memberof Vertex\n   */\n  removeIncoming(edgeLabel, selector) {\n    const filter = new VertexFilter(selector);\n    for (const {\n      edge,\n      node\n    } of this._index.getNodeIncoming(this._node.id, edgeLabel)) {\n      const outgoingVertex = new Vertex(node, this._index);\n      if (filter.match(outgoingVertex)) {\n        this._index.removeEdge(edge);\n      }\n    }\n    return this;\n  }\n  /**\n   * @description Removes outgoing edges.\n   * @param {string} [edgeLabel] Optional edge label used to remove only matching edges.\n   * @param {(string | VertexSelector)} [selector] Optional vertex selector used to remove only matching vertices.\n   * @returns {this}\n   * @memberof Vertex\n   */\n  removeOutgoing(edgeLabel, selector) {\n    const filter = new VertexFilter(selector);\n    for (const {\n      edge,\n      node\n    } of this._index.getNodeOutgoing(this._node.id, edgeLabel)) {\n      const incomingVertex = new Vertex(node, this._index);\n      if (filter.match(incomingVertex)) {\n        this._index.removeEdge(edge);\n      }\n    }\n    return this;\n  }\n  /**\n   * @description Removes one or more @type edges.\n   * @param {...string[]} typeIds One or more type ids to remove.\n   * @returns {this}\n   * @memberof Vertex\n   */\n  removeType(...typeIds) {\n    if (!typeIds || typeIds.length === 0) {\n      for (const typeEdge of this.getOutgoing(constants_1.JsonldKeywords.type)) {\n        this.removeOutgoing(constants_1.JsonldKeywords.type, typeEdge.toVertex.id);\n      }\n    } else {\n      for (const typeId of typeIds) {\n        this.removeOutgoing(constants_1.JsonldKeywords.type, typeId);\n      }\n    }\n    return this;\n  }\n  /**\n   * @description Replaces an attribute value.\n   * @param {string} name The attribute name whose value should be replaced.\n   * @param {*} value The value to replace.\n   * @returns {this}\n   * @memberof Vertex\n   */\n  replaceAttributeValue(name, value, language) {\n    this._node.setAttributeValue(name, value, language);\n    return this;\n  }\n  /**\n   * @description Removes an attribute value.\n   * @param {string} name The attribute name whose value should be removed.\n   * @param {*} value The value to remove.\n   * @returns {this}\n   * @memberof Vertex\n   */\n  removeAttributeValue(name, value) {\n    this._node.removeAttributeValue(name, value);\n    return this;\n  }\n  /**\n   * @description Sets an incoming relationship to another vertex.\n   * @param {string} label The label of the incoming edge relationship.\n   * @param {string} fromVertexId Id of the vertex to set the incoming relationship from.\n   * @param {boolean} [createIfNotExists=false] True to create the incoming vertex if it doesn't exist. If false and the vertex is not found, a VertexNotFoundError is thrown.\n   * @returns {this}\n   * @memberof Vertex\n   */\n  setIncoming(label, fromVertexId, createIfNotExists = false) {\n    if (!label) {\n      throw new ReferenceError(`Invalid label. label is ${label}`);\n    }\n    if (!fromVertexId) {\n      throw new ReferenceError(`Invalid id. id is ${fromVertexId}`);\n    }\n    if (!this._index.hasNode(fromVertexId) && createIfNotExists) {\n      this._index.createNode(fromVertexId);\n    }\n    this._index.createEdge(label, fromVertexId, this.id);\n    return this;\n  }\n  /**\n   * @description Sets an outgoing relationship to another vertex.\n   * @param {string} label The label of the outgoing edge relationship.\n   * @param {string} toVertexId Id of the vertex to set the outgoing relationship to.\n   * @param {boolean} [createIfNotExists=false] True to create the outgoing vertex if not found. If false and the vertex does not exist, a VertexNotFoundError is thrown.\n   * @returns {this}\n   * @memberof Vertex\n   */\n  setOutgoing(label, toVertexId, createIfNotExists = false) {\n    if (!label) {\n      throw new ReferenceError(`Invalid label. label is ${label}`);\n    }\n    if (!toVertexId) {\n      throw new ReferenceError(`Invalid toVertexId. id is ${toVertexId}`);\n    }\n    if (!this._index.getNode(toVertexId) && createIfNotExists) {\n      this._index.createNode(toVertexId);\n    }\n    this._index.createEdge(label, this.id, toVertexId);\n    return this;\n  }\n  /**\n   * @description Sets the @type of the vertex to one more types.\n   * @param {...string[]} typeIds One more or type ids to set the @type of the vertex.\n   * @returns {this}\n   * @memberof Vertex\n   */\n  setType(...typeIds) {\n    if (!typeIds || typeIds.length === 0) {\n      return;\n    }\n    const existingTypes = new Set(this.getOutgoing(constants_1.JsonldKeywords.type).map(({\n      toVertex\n    }) => toVertex.id));\n    const typesToAdd = typeIds.filter(id => !existingTypes.has(id));\n    for (const typeId of typesToAdd) {\n      if (!this._index.hasNode(typeId)) {\n        this._index.createNode(typeId);\n      }\n      this.setOutgoing(constants_1.JsonldKeywords.type, typeId);\n    }\n    return this;\n  }\n  /**\n   * @description Returns a JSON representation of the vertex.\n   * @param {string[]} contexts Contexts to use for compaction.\n   * @param {any} [frame] Optional framing instruction for JSON formatting.\n   * @returns {Promise<any>}\n   * @memberof Vertex\n   */\n  /* tslint:disable:promise-function-async*/\n  toJson(options = {}) {\n    return this._node.toJson(options);\n  }\n}\nexports.Vertex = Vertex;\nexports.default = Vertex;","map":{"version":3,"sources":["../src/vertex.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,MAAA,YAAA,GAAA,eAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAaA;;;;AAIG;AACH,MAAa,YAAY,CAAA;EAGrB;;;;AAIG;EACH,WAAA,CAAY,QAAkC,EAAA;IAC1C,IAAI,CAAC,SAAS,GAAG,QAAQ;EAC7B;EAEA;;;;;AAKG;EACH,KAAK,CAAC,MAAc,EAAA;IAChB,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;MACjB,OAAO,IAAI;IACd;IAED,IAAI,OAAO,IAAI,CAAC,SAAS,KAAK,QAAQ,EAAE;MACpC,OAAO,MAAM,CAAC,EAAE,KAAK,IAAI,CAAC,SAAS;IACtC;IAED,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;EACjC;AACH;AA7BD,OAAA,CAAA,YAAA,GAAA,YAAA;AA+BA;;;;AAIG;AACH,MAAa,MAAM,CAAA;EAIf;;;;AAIG;EACH,WAAA,CAAY,IAAe,EAAE,KAAiB,EAAA;IAC1C,IAAI,CAAC,IAAI,EAAE;MACP,MAAM,IAAI,cAAc,CAAC,yBAAyB,IAAI,EAAE,CAAC;IAC5D;IAED,IAAI,CAAC,KAAK,EAAE;MACR,MAAM,IAAI,cAAc,CAAC,2BAA2B,KAAK,EAAE,CAAC;IAC/D;IAED,IAAI,CAAC,KAAK,GAAG,IAAI;IACjB,IAAI,CAAC,MAAM,GAAG,KAAK;EACvB;EAEA;;;;AAIG;EACH,IAAI,EAAE,CAAA,EAAA;IACF,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE;EACxB;EAEA;;;AAGG;EACH,IAAI,EAAE,CAAC,EAAU,EAAA;IACb,IAAI,CAAC,KAAK,CAAC,EAAE,GAAG,EAAE;EACtB;EAEA;;;;;AAKG;EACH,IAAI,UAAU,CAAA,EAAA;IACV,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU;EAChC;EAEA;;;;;AAKG;EACH,IAAI,WAAW,CAAA,EAAA;IACX,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,UAAU,CAAC,WAAA,CAAA,eAAe,CAAC;EACpD;EAEA;;;;;AAKG;EACH,IAAI,SAAS,CAAA,EAAA;IACT,OAAO,IAAI,CAAC,WAAW,CAAC,WAAA,CAAA,cAAc,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;MAAE;IAAU,CAAE,KAAK,UAAU,CAAC;EACpF;EAEA;;;;;AAKG;EACH,IAAI,QAAQ,CAAA,EAAA;IACR,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ;EAC9B;EAEA;;;;;AAKG;EACH,IAAI,KAAK,CAAA,EAAA;IACL,OAAO,IAAI,CAAC,WAAW,CAAC,WAAA,CAAA,cAAc,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;MAAE;IAAQ,CAAE,KAAK,QAAQ,CAAC;EAChF;EAEA;;;;;;;AAOG;EACH,iBAAiB,CAAC,IAAY,EAAE,KAAU,EAAE,QAAiB,EAAA;IACzD,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,IAAI,EAAE,KAAK,EAAE,QAAQ,CAAC;IACnD,OAAO,IAAI;EACf;EAEA;;;;;;AAMG;EACH,eAAe,CAAC,IAAY,EAAE,QAAiB,EAAA;IAC3C,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,IAAI,EAAE,QAAQ,CAAC;IAC1C,OAAO,IAAI;EACf;EAEA;;;;;;;AAOG;EACH,iBAAiB,CAAa,IAAY,EAAE,QAAiB,EAAA;IACzD,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAI,IAAI,CAAC;IACrD,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;MAChC,OAAO,SAAS;IACnB;IAED,IAAI,QAAQ,EAAE;MACV,MAAM,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,QAAQ,KAAK,QAAQ,CAAC;MAChE,OAAO,cAAc,GAAG,cAAc,CAAC,KAAK,GAAG,SAAS;KAC3D,MAAM;MACH,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK;IACzB;EACL;EAEA;;;;;;;AAOG;EACH,kBAAkB,CAAa,IAAY,EAAA;IACvC,OAAO,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAI,IAAI,CAAC;EACjD;EAEA;;;;;AAKG;EACH,WAAW,CAAC,SAAkB,EAAA;IAC1B,OAAO,IAAI,YAAA,CAAA,OAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;MAAE,IAAI;MAAE;IAAI,CAAE,KAAI;MAC9F,OAAO;QACH,KAAK,EAAE,IAAI,CAAC,KAAK;QACjB,UAAU,EAAE,IAAI,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM;OAC3C;IACL,CAAC,CAAC;EACN;EAEA;;;;;AAKG;EACH,WAAW,CAAC,SAAkB,EAAA;IAC1B,OAAO,IAAI,YAAA,CAAA,OAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;MAAE,IAAI;MAAE;IAAI,CAAE,KAAI;MAC9F,OAAO;QACH,KAAK,EAAE,IAAI,CAAC,KAAK;QACjB,QAAQ,EAAE,IAAI,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM;OACzC;IACL,CAAC,CAAC;EACN;EAEA;;;;;AAKG;EACH,YAAY,CAAC,IAAY,EAAA;IACrB,OAAO,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,IAAI,CAAC;EACxC;EAEA;;;;;;AAMG;EACH,iBAAiB,CAAC,IAAY,EAAE,KAAU,EAAE,QAAiB,EAAA;IACzD,OAAO,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,IAAI,EAAE,KAAK,EAAE,QAAQ,CAAC;EAC9D;EAEA;;;;;AAKG;EACH,MAAM,CAAC,MAAc,EAAA;IACjB,IAAI,CAAC,MAAM,EAAE;MACT,MAAM,IAAI,cAAc,CAAC,6BAA6B,MAAM,EAAE,CAAC;IAClE;IAED,OAAO,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC;EACpE;EAEA;;;;;;AAMG;EACH,cAAc,CAAC,SAAkB,EAAE,QAAkC,EAAA;IACjE,MAAM,MAAM,GAAG,IAAI,YAAY,CAAC,QAAQ,CAAC;IACzC,KAAK,MAAM;MAAE,IAAI;MAAE;IAAI,CAAE,IAAI,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,SAAS,CAAC,EAAE;MAChF,MAAM,cAAc,GAAG,IAAI,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC;MACpD,IAAI,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,EAAE;QAC9B,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC;MAC/B;IACJ;IAED,OAAO,IAAI;EACf;EAEA;;;;;;AAMG;EACH,cAAc,CAAC,SAAkB,EAAE,QAAkC,EAAA;IACjE,MAAM,MAAM,GAAG,IAAI,YAAY,CAAC,QAAQ,CAAC;IACzC,KAAK,MAAM;MAAE,IAAI;MAAE;IAAI,CAAE,IAAI,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,SAAS,CAAC,EAAE;MAChF,MAAM,cAAc,GAAG,IAAI,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC;MACpD,IAAI,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,EAAE;QAC9B,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC;MAC/B;IACJ;IAED,OAAO,IAAI;EACf;EAEA;;;;;AAKG;EACH,UAAU,CAAC,GAAG,OAAiB,EAAA;IAC3B,IAAI,CAAC,OAAO,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;MAClC,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,WAAW,CAAC,WAAA,CAAA,cAAc,CAAC,IAAI,CAAC,EAAE;QAC1D,IAAI,CAAC,cAAc,CAAC,WAAA,CAAA,cAAc,CAAC,IAAI,EAAE,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC;MACjE;KACJ,MAAM;MACH,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;QAC1B,IAAI,CAAC,cAAc,CAAC,WAAA,CAAA,cAAc,CAAC,IAAI,EAAE,MAAM,CAAC;MACnD;IACJ;IAED,OAAO,IAAI;EACf;EAEA;;;;;;AAMG;EACH,qBAAqB,CAAC,IAAY,EAAE,KAAU,EAAE,QAAiB,EAAA;IAC7D,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,IAAI,EAAE,KAAK,EAAE,QAAQ,CAAC;IACnD,OAAO,IAAI;EACf;EAEA;;;;;;AAMG;EACH,oBAAoB,CAAC,IAAY,EAAE,KAAU,EAAA;IACzC,IAAI,CAAC,KAAK,CAAC,oBAAoB,CAAC,IAAI,EAAE,KAAK,CAAC;IAC5C,OAAO,IAAI;EACf;EAEA;;;;;;;AAOG;EACH,WAAW,CAAC,KAAa,EAAE,YAAoB,EAAE,iBAAA,GAA6B,KAAK,EAAA;IAC/E,IAAI,CAAC,KAAK,EAAE;MACR,MAAM,IAAI,cAAc,CAAC,2BAA2B,KAAK,EAAE,CAAC;IAC/D;IAED,IAAI,CAAC,YAAY,EAAE;MACf,MAAM,IAAI,cAAc,CAAC,qBAAqB,YAAY,EAAE,CAAC;IAChE;IAED,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,YAAY,CAAC,IAAI,iBAAiB,EAAE;MACzD,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,YAAY,CAAC;IACvC;IAED,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,EAAE,YAAY,EAAE,IAAI,CAAC,EAAE,CAAC;IACpD,OAAO,IAAI;EACf;EAEA;;;;;;;AAOG;EACH,WAAW,CAAC,KAAa,EAAE,UAAkB,EAAE,iBAAA,GAA6B,KAAK,EAAA;IAC7E,IAAI,CAAC,KAAK,EAAE;MACR,MAAM,IAAI,cAAc,CAAC,2BAA2B,KAAK,EAAE,CAAC;IAC/D;IAED,IAAI,CAAC,UAAU,EAAE;MACb,MAAM,IAAI,cAAc,CAAC,6BAA6B,UAAU,EAAE,CAAC;IACtE;IAED,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,iBAAiB,EAAE;MACvD,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,UAAU,CAAC;IACrC;IAED,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,EAAE,IAAI,CAAC,EAAE,EAAE,UAAU,CAAC;IAClD,OAAO,IAAI;EACf;EAEA;;;;;AAKG;EACH,OAAO,CAAC,GAAG,OAAiB,EAAA;IACxB,IAAI,CAAC,OAAO,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;MAClC;IACH;IAED,MAAM,aAAa,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,WAAA,CAAA,cAAc,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;MAAE;IAAQ,CAAE,KAAK,QAAQ,CAAC,EAAE,CAAC,CAAC;IACvG,MAAM,UAAU,GAAG,OAAO,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IAC/D,KAAK,MAAM,MAAM,IAAI,UAAU,EAAE;MAC7B,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;QAC9B,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC;MACjC;MAED,IAAI,CAAC,WAAW,CAAC,WAAA,CAAA,cAAc,CAAC,IAAI,EAAE,MAAM,CAAC;IAChD;IAED,OAAO,IAAI;EACf;EAEA;;;;;;AAMG;EACH;EACA,MAAM,CAAC,OAAA,GAA6B,CAAA,CAAE,EAAA;IAClC,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC;EACrC;AACH;AA5XD,OAAA,CAAA,MAAA,GAAA,MAAA;AA8XA,OAAA,CAAA,OAAA,GAAe,MAAM","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst jsiterable_1 = __importDefault(require(\"jsiterable\"));\nconst constants_1 = require(\"./constants\");\n/**\n * @description Vertex filter type that can be used to match vertices based on a supplied filter.\n * @export\n * @class VertexFilter\n */\nclass VertexFilter {\n    /**\n     * @description Creates an instance of VertexFilter.\n     * @param {(string | types.VertexSelector)} selector The filter definition to use.\n     * @memberof VertexFilter\n     */\n    constructor(selector) {\n        this._selector = selector;\n    }\n    /**\n     * @description Checks if the filter matches the specified vertex.\n     * @param {Vertex} vertex The vertex to check.\n     * @returns {boolean} True if the vertex is a match, else false.\n     * @memberof VertexFilter\n     */\n    match(vertex) {\n        if (!this._selector) {\n            return true;\n        }\n        if (typeof this._selector === 'string') {\n            return vertex.id === this._selector;\n        }\n        return this._selector(vertex);\n    }\n}\nexports.VertexFilter = VertexFilter;\n/**\n * @description Represents a vertex in the graph.\n * @export\n * @class Vertex\n */\nclass Vertex {\n    /**\n     * @description Creates an instance of Vertex.\n     * @param {GraphNode} node The graph node this vertex wraps.\n     * @memberof Vertex\n     */\n    constructor(node, index) {\n        if (!node) {\n            throw new ReferenceError(`Invalid node. node is ${node}`);\n        }\n        if (!index) {\n            throw new ReferenceError(`Invalid index. index is ${index}`);\n        }\n        this._node = node;\n        this._index = index;\n    }\n    /**\n     * @description Gets the id of the vertex.\n     * @type {string}\n     * @memberof Vertex\n     */\n    get id() {\n        return this._node.id;\n    }\n    /**\n     * @description Sets the id of the vertex.\n     * @memberof Vertex\n     */\n    set id(id) {\n        this._node.id = id;\n    }\n    /**\n     * @description Gets all attributes defined in the vertex.\n     * @readonly\n     * @type {Iterable<[string, any]>}\n     * @memberof Vertex\n     */\n    get attributes() {\n        return this._node.attributes;\n    }\n    /**\n     * @description Returns true if the vertex is a blank node, else false.\n     * @readonly\n     * @type {boolean}\n     * @memberof Vertex\n     */\n    get isBlankNode() {\n        return this._node.id.startsWith(constants_1.BlankNodePrefix);\n    }\n    /**\n     * @description Gets all vertices that have a @type outgoing edge to this vertex.\n     * @readonly\n     * @type {Iterable<Vertex>}\n     * @memberof Vertex\n     */\n    get instances() {\n        return this.getIncoming(constants_1.JsonldKeywords.type).map(({ fromVertex }) => fromVertex);\n    }\n    /**\n     * @description Gets metadata stored for the vertex.\n     * @readonly\n     * @type {*}\n     * @memberof Vertex\n     */\n    get metadata() {\n        return this._node.metadata;\n    }\n    /**\n     * @description Gets all vertices that this vertex is a @type of.\n     * @readonly\n     * @type {Iterable<Vertex>}\n     * @memberof Vertex\n     */\n    get types() {\n        return this.getOutgoing(constants_1.JsonldKeywords.type).map(({ toVertex }) => toVertex);\n    }\n    /**\n     * @description Adds an attribute value.\n     * @param {string} name The name of the attribute.\n     * @param {*} value The value to add.\n     * @param {string} language The language the add an attribute value.\n     * @returns {this}\n     * @memberof Vertex\n     */\n    addAttributeValue(name, value, language) {\n        this._node.addAttributeValue(name, value, language);\n        return this;\n    }\n    /**\n     * @description Deletes a specific attribute of the vertex.\n     * @param {string} name The attribute name to delete.\n     * @param {string} [language] The optional language whose value should be deleted.\n     * @returns {this}\n     * @memberof Vertex\n     */\n    deleteAttribute(name, language) {\n        this._node.deleteAttribute(name, language);\n        return this;\n    }\n    /**\n     * @description Gets the value of an attribute.\n     * @template T\n     * @param {string} name The attribute label to get.\n     * @param {string} [language] Optional localized language of the value.\n     * @returns {T}\n     * @memberof Vertex\n     */\n    getAttributeValue(name, language) {\n        const values = this._node.getAttributeValues(name);\n        if (!values || values.length === 0) {\n            return undefined;\n        }\n        if (language) {\n            const localizedValue = values.find(x => x.language === language);\n            return localizedValue ? localizedValue.value : undefined;\n        }\n        else {\n            return values[0].value;\n        }\n    }\n    /**\n     * @description Gets all values set for an attribute.\n     * @template T\n     * @param {string} name\n     * @param {string} [language]\n     * @returns {T[]}\n     * @memberof Vertex\n     */\n    getAttributeValues(name) {\n        return this._node.getAttributeValues(name);\n    }\n    /**\n     * @description Gets all incoming vertices to this vertex.\n     * @param {string} [edgeLabel] Optional edge label used to filter matching vertices with incoming edges with the specified label.\n     * @returns {Iterable<{ label: string, fromVertex: Vertex }>}\n     * @memberof Vertex\n     */\n    getIncoming(edgeLabel) {\n        return new jsiterable_1.default(this._index.getNodeIncoming(this._node.id, edgeLabel)).map(({ edge, node }) => {\n            return {\n                label: edge.label,\n                fromVertex: new Vertex(node, this._index)\n            };\n        });\n    }\n    /**\n     * @description Gets all outgoing vertices from this vertex.\n     * @param {string} [edgeLabel] Optional edge label used to filter matching vertices with outgoing edges with the specified label.\n     * @returns {Iterable<{ label: string, toVertex: Vertex }>}\n     * @memberof Vertex\n     */\n    getOutgoing(edgeLabel) {\n        return new jsiterable_1.default(this._index.getNodeOutgoing(this._node.id, edgeLabel)).map(({ edge, node }) => {\n            return {\n                label: edge.label,\n                toVertex: new Vertex(node, this._index)\n            };\n        });\n    }\n    /**\n     * @description Checks if an attribute has been defined on the vertex.\n     * @param {string} name The name of the attribute to check.\n     * @returns {boolean} True if the attribute has been defined, else false.\n     * @memberof Vertex\n     */\n    hasAttribute(name) {\n        return this._node.hasAttribute(name);\n    }\n    /**\n     * @description Checks if an attribute exists and if has the specified value.\n     * @param {string} name The name of the attribute to check.\n     * @param {*} value The value of the attribute to check.\n     * @returns {boolean} True if the value exists, else false.\n     * @memberof Vertex\n     */\n    hasAttributeValue(name, value, language) {\n        return this._node.hasAttributeValue(name, value, language);\n    }\n    /**\n     * @description Checks if the vertex is of a specific @type.\n     * @param {string} typeId The type id to check for.\n     * @returns {boolean} True if the vertex has a @type outgoing edge to the specified type id, else false.\n     * @memberof Vertex\n     */\n    isType(typeId) {\n        if (!typeId) {\n            throw new ReferenceError(`Invalid typeId. typeId is ${typeId}`);\n        }\n        return [...this.types.filter(x => x.id === typeId)].length === 1;\n    }\n    /**\n     * @description Removes incoming edges.\n     * @param {string} [edgeLabel] Optional edge label used to remove only matching edges.\n     * @param {(string | VertexSelector)} [selector] Optional vertex selector used to remove only matching vertices.\n     * @returns {this}\n     * @memberof Vertex\n     */\n    removeIncoming(edgeLabel, selector) {\n        const filter = new VertexFilter(selector);\n        for (const { edge, node } of this._index.getNodeIncoming(this._node.id, edgeLabel)) {\n            const outgoingVertex = new Vertex(node, this._index);\n            if (filter.match(outgoingVertex)) {\n                this._index.removeEdge(edge);\n            }\n        }\n        return this;\n    }\n    /**\n     * @description Removes outgoing edges.\n     * @param {string} [edgeLabel] Optional edge label used to remove only matching edges.\n     * @param {(string | VertexSelector)} [selector] Optional vertex selector used to remove only matching vertices.\n     * @returns {this}\n     * @memberof Vertex\n     */\n    removeOutgoing(edgeLabel, selector) {\n        const filter = new VertexFilter(selector);\n        for (const { edge, node } of this._index.getNodeOutgoing(this._node.id, edgeLabel)) {\n            const incomingVertex = new Vertex(node, this._index);\n            if (filter.match(incomingVertex)) {\n                this._index.removeEdge(edge);\n            }\n        }\n        return this;\n    }\n    /**\n     * @description Removes one or more @type edges.\n     * @param {...string[]} typeIds One or more type ids to remove.\n     * @returns {this}\n     * @memberof Vertex\n     */\n    removeType(...typeIds) {\n        if (!typeIds || typeIds.length === 0) {\n            for (const typeEdge of this.getOutgoing(constants_1.JsonldKeywords.type)) {\n                this.removeOutgoing(constants_1.JsonldKeywords.type, typeEdge.toVertex.id);\n            }\n        }\n        else {\n            for (const typeId of typeIds) {\n                this.removeOutgoing(constants_1.JsonldKeywords.type, typeId);\n            }\n        }\n        return this;\n    }\n    /**\n     * @description Replaces an attribute value.\n     * @param {string} name The attribute name whose value should be replaced.\n     * @param {*} value The value to replace.\n     * @returns {this}\n     * @memberof Vertex\n     */\n    replaceAttributeValue(name, value, language) {\n        this._node.setAttributeValue(name, value, language);\n        return this;\n    }\n    /**\n     * @description Removes an attribute value.\n     * @param {string} name The attribute name whose value should be removed.\n     * @param {*} value The value to remove.\n     * @returns {this}\n     * @memberof Vertex\n     */\n    removeAttributeValue(name, value) {\n        this._node.removeAttributeValue(name, value);\n        return this;\n    }\n    /**\n     * @description Sets an incoming relationship to another vertex.\n     * @param {string} label The label of the incoming edge relationship.\n     * @param {string} fromVertexId Id of the vertex to set the incoming relationship from.\n     * @param {boolean} [createIfNotExists=false] True to create the incoming vertex if it doesn't exist. If false and the vertex is not found, a VertexNotFoundError is thrown.\n     * @returns {this}\n     * @memberof Vertex\n     */\n    setIncoming(label, fromVertexId, createIfNotExists = false) {\n        if (!label) {\n            throw new ReferenceError(`Invalid label. label is ${label}`);\n        }\n        if (!fromVertexId) {\n            throw new ReferenceError(`Invalid id. id is ${fromVertexId}`);\n        }\n        if (!this._index.hasNode(fromVertexId) && createIfNotExists) {\n            this._index.createNode(fromVertexId);\n        }\n        this._index.createEdge(label, fromVertexId, this.id);\n        return this;\n    }\n    /**\n     * @description Sets an outgoing relationship to another vertex.\n     * @param {string} label The label of the outgoing edge relationship.\n     * @param {string} toVertexId Id of the vertex to set the outgoing relationship to.\n     * @param {boolean} [createIfNotExists=false] True to create the outgoing vertex if not found. If false and the vertex does not exist, a VertexNotFoundError is thrown.\n     * @returns {this}\n     * @memberof Vertex\n     */\n    setOutgoing(label, toVertexId, createIfNotExists = false) {\n        if (!label) {\n            throw new ReferenceError(`Invalid label. label is ${label}`);\n        }\n        if (!toVertexId) {\n            throw new ReferenceError(`Invalid toVertexId. id is ${toVertexId}`);\n        }\n        if (!this._index.getNode(toVertexId) && createIfNotExists) {\n            this._index.createNode(toVertexId);\n        }\n        this._index.createEdge(label, this.id, toVertexId);\n        return this;\n    }\n    /**\n     * @description Sets the @type of the vertex to one more types.\n     * @param {...string[]} typeIds One more or type ids to set the @type of the vertex.\n     * @returns {this}\n     * @memberof Vertex\n     */\n    setType(...typeIds) {\n        if (!typeIds || typeIds.length === 0) {\n            return;\n        }\n        const existingTypes = new Set(this.getOutgoing(constants_1.JsonldKeywords.type).map(({ toVertex }) => toVertex.id));\n        const typesToAdd = typeIds.filter(id => !existingTypes.has(id));\n        for (const typeId of typesToAdd) {\n            if (!this._index.hasNode(typeId)) {\n                this._index.createNode(typeId);\n            }\n            this.setOutgoing(constants_1.JsonldKeywords.type, typeId);\n        }\n        return this;\n    }\n    /**\n     * @description Returns a JSON representation of the vertex.\n     * @param {string[]} contexts Contexts to use for compaction.\n     * @param {any} [frame] Optional framing instruction for JSON formatting.\n     * @returns {Promise<any>}\n     * @memberof Vertex\n     */\n    /* tslint:disable:promise-function-async*/\n    toJson(options = {}) {\n        return this._node.toJson(options);\n    }\n}\nexports.Vertex = Vertex;\nexports.default = Vertex;\n//# sourceMappingURL=vertex.js.map"]},"metadata":{},"sourceType":"script"}