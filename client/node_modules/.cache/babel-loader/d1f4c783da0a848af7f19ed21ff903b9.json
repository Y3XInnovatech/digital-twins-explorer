{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { getClassNames } from './DraggableZone.styles';\nimport { on } from '../../Utilities';\nvar eventMapping = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend'\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup'\n  }\n};\nvar DraggableZone = /** @class */function (_super) {\n  __extends(DraggableZone, _super);\n  function DraggableZone(props) {\n    var _this = _super.call(this, props) || this;\n    _this._currentEventType = eventMapping.mouse;\n    _this._events = [];\n    _this._onMouseDown = function (event) {\n      var onMouseDown = React.Children.only(_this.props.children).props.onMouseDown;\n      if (onMouseDown) {\n        onMouseDown(event);\n      }\n      _this._currentEventType = eventMapping.mouse;\n      return _this._onDragStart(event);\n    };\n    _this._onMouseUp = function (event) {\n      var onMouseUp = React.Children.only(_this.props.children).props.onMouseUp;\n      if (onMouseUp) {\n        onMouseUp(event);\n      }\n      _this._currentEventType = eventMapping.mouse;\n      return _this._onDragStop(event);\n    };\n    _this._onTouchStart = function (event) {\n      var onTouchStart = React.Children.only(_this.props.children).props.onTouchStart;\n      if (onTouchStart) {\n        onTouchStart(event);\n      }\n      _this._currentEventType = eventMapping.touch;\n      return _this._onDragStart(event);\n    };\n    _this._onTouchEnd = function (event) {\n      var onTouchEnd = React.Children.only(_this.props.children).props.onTouchEnd;\n      if (onTouchEnd) {\n        onTouchEnd(event);\n      }\n      _this._currentEventType = eventMapping.touch;\n      _this._onDragStop(event);\n    };\n    _this._onDragStart = function (event) {\n      // Only handle left click for dragging\n      if (typeof event.button === 'number' && event.button !== 0) {\n        return false;\n      }\n      // If the target doesn't match the handleSelector OR\n      // if the target does match the preventDragSelector, bail out\n      if (_this.props.handleSelector && !_this._matchesSelector(event.target, _this.props.handleSelector) || _this.props.preventDragSelector && _this._matchesSelector(event.target, _this.props.preventDragSelector)) {\n        return;\n      }\n      // Remember the touch identifier if this is a touch event so we can\n      // distinguish between individual touches in multitouch scenarios\n      // by remembering which touch point we were given\n      _this._touchId = _this._getTouchId(event);\n      var position = _this._getControlPosition(event);\n      if (position === undefined) {\n        return;\n      }\n      var dragData = _this._createDragDataFromPosition(position);\n      _this.props.onStart && _this.props.onStart(event, dragData);\n      _this.setState({\n        isDragging: true,\n        lastPosition: position\n      });\n      // hook up the appropriate mouse/touch events to the body to ensure\n      // smooth dragging\n      _this._events = [on(document.body, _this._currentEventType.move, _this._onDrag, true /* use capture phase */), on(document.body, _this._currentEventType.stop, _this._onDragStop, true /* use capture phase */)];\n    };\n    _this._onDrag = function (event) {\n      // Prevent scrolling on mobile devices\n      if (event.type === 'touchmove') {\n        event.preventDefault();\n      }\n      var position = _this._getControlPosition(event);\n      if (!position) {\n        return;\n      }\n      // create the updated drag data from the position data\n      var updatedData = _this._createUpdatedDragData(_this._createDragDataFromPosition(position));\n      var updatedPosition = updatedData.position;\n      _this.props.onDragChange && _this.props.onDragChange(event, updatedData);\n      _this.setState({\n        position: updatedPosition,\n        lastPosition: position\n      });\n    };\n    _this._onDragStop = function (event) {\n      if (!_this.state.isDragging) {\n        return;\n      }\n      var position = _this._getControlPosition(event);\n      if (!position) {\n        return;\n      }\n      var baseDragData = _this._createDragDataFromPosition(position);\n      // Set dragging to false and reset the lastPosition\n      _this.setState({\n        isDragging: false,\n        lastPosition: undefined\n      });\n      _this.props.onStop && _this.props.onStop(event, baseDragData);\n      if (_this.props.position) {\n        _this.setState({\n          position: _this.props.position\n        });\n      }\n      // Remove event handlers\n      _this._events.forEach(function (dispose) {\n        return dispose();\n      });\n    };\n    _this.state = {\n      isDragging: false,\n      position: _this.props.position || {\n        x: 0,\n        y: 0\n      },\n      lastPosition: undefined\n    };\n    return _this;\n  }\n  DraggableZone.prototype.componentDidUpdate = function (prevProps) {\n    if (this.props.position && (!prevProps.position || this.props.position !== prevProps.position)) {\n      this.setState({\n        position: this.props.position\n      });\n    }\n  };\n  DraggableZone.prototype.componentWillUnmount = function () {\n    this._events.forEach(function (dispose) {\n      return dispose();\n    });\n  };\n  DraggableZone.prototype.render = function () {\n    var child = React.Children.only(this.props.children);\n    var props = child.props;\n    var position = this.props.position;\n    var _a = this.state,\n      statePosition = _a.position,\n      isDragging = _a.isDragging;\n    var x = statePosition.x;\n    var y = statePosition.y;\n    if (position && !isDragging) {\n      x = position.x;\n      y = position.y;\n    }\n    return React.cloneElement(child, {\n      style: __assign(__assign({}, props.style), {\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\"\n      }),\n      className: getClassNames(props.className, this.state.isDragging).root,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onTouchStart: this._onTouchStart,\n      onTouchEnd: this._onTouchEnd\n    });\n  };\n  /**\n   * Get the control position based off the event that fired\n   * @param event - The event to get offsets from\n   */\n  DraggableZone.prototype._getControlPosition = function (event) {\n    var touchObj = this._getActiveTouch(event);\n    // did we get the right touch?\n    if (this._touchId !== undefined && !touchObj) {\n      return undefined;\n    }\n    var eventToGetOffset = touchObj || event;\n    return {\n      x: eventToGetOffset.clientX,\n      y: eventToGetOffset.clientY\n    };\n  };\n  /**\n   * Get the active touch point that we have saved from the event's TouchList\n   * @param event - The event used to get the TouchList for the active touch point\n   */\n  DraggableZone.prototype._getActiveTouch = function (event) {\n    return event.targetTouches && this._findTouchInTouchList(event.targetTouches) || event.changedTouches && this._findTouchInTouchList(event.changedTouches);\n  };\n  /**\n   * Get the initial touch identifier associated with the given event\n   * @param event - The event that contains the TouchList\n   */\n  DraggableZone.prototype._getTouchId = function (event) {\n    var touch = event.targetTouches && event.targetTouches[0] || event.changedTouches && event.changedTouches[0];\n    if (touch) {\n      return touch.identifier;\n    }\n  };\n  /**\n   * Returns if an element (or any of the element's parents) match the given selector\n   */\n  DraggableZone.prototype._matchesSelector = function (element, selector) {\n    if (!element || element === document.body) {\n      return false;\n    }\n    var matchesSelectorFn = element.matches || element.webkitMatchesSelector || element.msMatchesSelector /* for IE */;\n    if (!matchesSelectorFn) {\n      return false;\n    }\n    return matchesSelectorFn.call(element, selector) || this._matchesSelector(element.parentElement, selector);\n  };\n  /**\n   * Attempts to find the Touch that matches the identifier  we stored in dragStart\n   * @param touchList The TouchList to look for the stored identifier from dragStart\n   */\n  DraggableZone.prototype._findTouchInTouchList = function (touchList) {\n    if (this._touchId === undefined) {\n      return;\n    }\n    for (var i = 0; i < touchList.length; i++) {\n      if (touchList[i].identifier === this._touchId) {\n        return touchList[i];\n      }\n    }\n    return undefined;\n  };\n  /**\n   * Create DragData based off of the last known position and the new position passed in\n   * @param position The new position as part of the drag\n   */\n  DraggableZone.prototype._createDragDataFromPosition = function (position) {\n    var lastPosition = this.state.lastPosition;\n    // If we have no lastPosition, use the given position\n    // for last position\n    if (lastPosition === undefined) {\n      return {\n        delta: {\n          x: 0,\n          y: 0\n        },\n        lastPosition: position,\n        position: position\n      };\n    }\n    return {\n      delta: {\n        x: position.x - lastPosition.x,\n        y: position.y - lastPosition.y\n      },\n      lastPosition: lastPosition,\n      position: position\n    };\n  };\n  /**\n   * Creates an updated DragData based off the current position and given baseDragData\n   * @param baseDragData The base DragData (from _createDragDataFromPosition) used to calculate the updated positions\n   */\n  DraggableZone.prototype._createUpdatedDragData = function (baseDragData) {\n    var position = this.state.position;\n    return {\n      position: {\n        x: position.x + baseDragData.delta.x,\n        y: position.y + baseDragData.delta.y\n      },\n      delta: baseDragData.delta,\n      lastPosition: position\n    };\n  };\n  return DraggableZone;\n}(React.Component);\nexport { DraggableZone };","map":{"version":3,"sources":["utilities/DraggableZone/DraggableZone.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { IDraggableZoneProps, ICoordinates, IDragData } from './DraggableZone.types';\nimport { getClassNames } from './DraggableZone.styles';\nimport { on } from '../../Utilities';\n\nexport interface IDraggableZoneState {\n  isDragging: boolean;\n  position: ICoordinates;\n  lastPosition?: ICoordinates;\n}\n\nconst eventMapping = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend',\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup',\n  },\n};\n\n// These are needed so that we can generalize the events\n// and so we have access to clientX and clientY in the touch events\ntype MouseTouchEvent<T> = React.MouseEvent<T> & React.TouchEvent<T> & Event;\n\nexport class DraggableZone extends React.Component<IDraggableZoneProps, IDraggableZoneState> {\n  private _touchId?: number;\n  private _currentEventType = eventMapping.mouse;\n  private _events: (() => void)[] = [];\n\n  constructor(props: IDraggableZoneProps) {\n    super(props);\n\n    this.state = {\n      isDragging: false,\n      position: this.props.position || { x: 0, y: 0 },\n      lastPosition: undefined,\n    };\n  }\n\n  public componentDidUpdate(prevProps: IDraggableZoneProps) {\n    if (this.props.position && (!prevProps.position || this.props.position !== prevProps.position)) {\n      this.setState({ position: this.props.position });\n    }\n  }\n\n  public componentWillUnmount() {\n    this._events.forEach(dispose => dispose());\n  }\n\n  public render() {\n    const child: any = React.Children.only(this.props.children);\n    const { props } = child;\n    const { position } = this.props;\n    const { position: statePosition, isDragging } = this.state;\n    let x = statePosition.x;\n    let y = statePosition.y;\n\n    if (position && !isDragging) {\n      x = position.x;\n      y = position.y;\n    }\n\n    return React.cloneElement(child, {\n      style: {\n        ...props.style,\n        transform: `translate(${x}px, ${y}px)`,\n      },\n      className: getClassNames(props.className, this.state.isDragging).root,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onTouchStart: this._onTouchStart,\n      onTouchEnd: this._onTouchEnd,\n    });\n  }\n\n  private _onMouseDown = (event: MouseTouchEvent<HTMLElement>) => {\n    const onMouseDown = (React.Children.only(this.props.children) as any).props.onMouseDown;\n    if (onMouseDown) {\n      onMouseDown(event);\n    }\n\n    this._currentEventType = eventMapping.mouse;\n    return this._onDragStart(event);\n  };\n\n  private _onMouseUp = (event: MouseTouchEvent<HTMLElement>) => {\n    const onMouseUp = (React.Children.only(this.props.children) as any).props.onMouseUp;\n    if (onMouseUp) {\n      onMouseUp(event);\n    }\n\n    this._currentEventType = eventMapping.mouse;\n    return this._onDragStop(event);\n  };\n\n  private _onTouchStart = (event: MouseTouchEvent<HTMLElement>) => {\n    const onTouchStart = (React.Children.only(this.props.children) as any).props.onTouchStart;\n    if (onTouchStart) {\n      onTouchStart(event);\n    }\n\n    this._currentEventType = eventMapping.touch;\n    return this._onDragStart(event);\n  };\n\n  private _onTouchEnd = (event: MouseTouchEvent<HTMLElement>) => {\n    const onTouchEnd = (React.Children.only(this.props.children) as any).props.onTouchEnd;\n    if (onTouchEnd) {\n      onTouchEnd(event);\n    }\n\n    this._currentEventType = eventMapping.touch;\n    this._onDragStop(event);\n  };\n\n  private _onDragStart = (event: MouseTouchEvent<HTMLElement>) => {\n    // Only handle left click for dragging\n    if (typeof event.button === 'number' && event.button !== 0) {\n      return false;\n    }\n\n    // If the target doesn't match the handleSelector OR\n    // if the target does match the preventDragSelector, bail out\n    if (\n      (this.props.handleSelector && !this._matchesSelector(event.target as HTMLElement, this.props.handleSelector)) ||\n      (this.props.preventDragSelector &&\n        this._matchesSelector(event.target as HTMLElement, this.props.preventDragSelector))\n    ) {\n      return;\n    }\n\n    // Remember the touch identifier if this is a touch event so we can\n    // distinguish between individual touches in multitouch scenarios\n    // by remembering which touch point we were given\n    this._touchId = this._getTouchId(event);\n\n    const position = this._getControlPosition(event);\n    if (position === undefined) {\n      return;\n    }\n\n    const dragData = this._createDragDataFromPosition(position);\n    this.props.onStart && this.props.onStart(event, dragData);\n\n    this.setState({\n      isDragging: true,\n      lastPosition: position,\n    });\n\n    // hook up the appropriate mouse/touch events to the body to ensure\n    // smooth dragging\n    this._events = [\n      on(document.body, this._currentEventType.move, this._onDrag, true /* use capture phase */),\n      on(document.body, this._currentEventType.stop, this._onDragStop, true /* use capture phase */),\n    ];\n  };\n\n  private _onDrag = (event: MouseTouchEvent<HTMLElement>) => {\n    // Prevent scrolling on mobile devices\n    if (event.type === 'touchmove') {\n      event.preventDefault();\n    }\n\n    const position = this._getControlPosition(event);\n    if (!position) {\n      return;\n    }\n\n    // create the updated drag data from the position data\n    const updatedData = this._createUpdatedDragData(this._createDragDataFromPosition(position));\n    const updatedPosition = updatedData.position;\n\n    this.props.onDragChange && this.props.onDragChange(event, updatedData);\n\n    this.setState({\n      position: updatedPosition,\n      lastPosition: position,\n    });\n  };\n\n  private _onDragStop = (event: MouseTouchEvent<HTMLElement>) => {\n    if (!this.state.isDragging) {\n      return;\n    }\n\n    const position = this._getControlPosition(event);\n    if (!position) {\n      return;\n    }\n\n    const baseDragData = this._createDragDataFromPosition(position);\n\n    // Set dragging to false and reset the lastPosition\n    this.setState({\n      isDragging: false,\n      lastPosition: undefined,\n    });\n\n    this.props.onStop && this.props.onStop(event, baseDragData);\n\n    if (this.props.position) {\n      this.setState({\n        position: this.props.position,\n      });\n    }\n\n    // Remove event handlers\n    this._events.forEach(dispose => dispose());\n  };\n\n  /**\n   * Get the control position based off the event that fired\n   * @param event - The event to get offsets from\n   */\n  private _getControlPosition(event: MouseTouchEvent<HTMLElement>): ICoordinates | undefined {\n    const touchObj = this._getActiveTouch(event);\n\n    // did we get the right touch?\n    if (this._touchId !== undefined && !touchObj) {\n      return undefined;\n    }\n\n    const eventToGetOffset = touchObj || event;\n    return {\n      x: eventToGetOffset.clientX,\n      y: eventToGetOffset.clientY,\n    };\n  }\n\n  /**\n   * Get the active touch point that we have saved from the event's TouchList\n   * @param event - The event used to get the TouchList for the active touch point\n   */\n  private _getActiveTouch(event: MouseTouchEvent<HTMLElement>): React.Touch | undefined {\n    return (\n      (event.targetTouches && this._findTouchInTouchList(event.targetTouches)) ||\n      (event.changedTouches && this._findTouchInTouchList(event.changedTouches))\n    );\n  }\n\n  /**\n   * Get the initial touch identifier associated with the given event\n   * @param event - The event that contains the TouchList\n   */\n  private _getTouchId(event: MouseTouchEvent<HTMLElement>): number | undefined {\n    const touch: React.Touch | undefined =\n      (event.targetTouches && event.targetTouches[0]) || (event.changedTouches && event.changedTouches[0]);\n\n    if (touch) {\n      return touch.identifier;\n    }\n  }\n\n  /**\n   * Returns if an element (or any of the element's parents) match the given selector\n   */\n  private _matchesSelector(element: HTMLElement | null, selector: string): boolean {\n    if (!element || element === document.body) {\n      return false;\n    }\n\n    const matchesSelectorFn: Function =\n        element.matches || element.webkitMatchesSelector || (element as any).msMatchesSelector /* for IE */;\n\n    if (!matchesSelectorFn) {\n      return false;\n    }\n\n    return matchesSelectorFn.call(element, selector) || this._matchesSelector(element.parentElement, selector);\n  }\n\n  /**\n   * Attempts to find the Touch that matches the identifier  we stored in dragStart\n   * @param touchList The TouchList to look for the stored identifier from dragStart\n   */\n  private _findTouchInTouchList(touchList: React.TouchList): React.Touch | undefined {\n    if (this._touchId === undefined) {\n      return;\n    }\n\n    for (let i = 0; i < touchList.length; i++) {\n      if (touchList[i].identifier === this._touchId) {\n        return touchList[i];\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Create DragData based off of the last known position and the new position passed in\n   * @param position The new position as part of the drag\n   */\n  private _createDragDataFromPosition(position: ICoordinates): IDragData {\n    const { lastPosition } = this.state;\n\n    // If we have no lastPosition, use the given position\n    // for last position\n    if (lastPosition === undefined) {\n      return {\n        delta: { x: 0, y: 0 },\n        lastPosition: position,\n        position,\n      };\n    }\n\n    return {\n      delta: {\n        x: position.x - lastPosition.x,\n        y: position.y - lastPosition.y,\n      },\n      lastPosition,\n      position,\n    };\n  }\n\n  /**\n   * Creates an updated DragData based off the current position and given baseDragData\n   * @param baseDragData The base DragData (from _createDragDataFromPosition) used to calculate the updated positions\n   */\n  private _createUpdatedDragData(baseDragData: IDragData): IDragData {\n    const { position } = this.state;\n    return {\n      position: {\n        x: position.x + baseDragData.delta.x,\n        y: position.y + baseDragData.delta.y,\n      },\n      delta: baseDragData.delta,\n      lastPosition: position,\n    };\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}