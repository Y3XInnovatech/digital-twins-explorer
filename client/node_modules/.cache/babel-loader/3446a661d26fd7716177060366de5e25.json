{"ast":null,"code":"import { __extends } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, on, initializeComponentRef, KeyCodes, getId } from '../../../Utilities';\nimport { MAX_COLOR_SATURATION, MAX_COLOR_VALUE } from '../../../utilities/color/consts';\nimport { getFullColorString } from '../../../utilities/color/getFullColorString';\nimport { updateSV } from '../../../utilities/color/updateSV';\nimport { clamp } from '../../../utilities/color/clamp';\nvar getClassNames = classNamesFunction();\n/**\n * {@docCategory ColorPicker}\n */\nvar ColorRectangleBase = /** @class */function (_super) {\n  __extends(ColorRectangleBase, _super);\n  function ColorRectangleBase(props) {\n    var _this = _super.call(this, props) || this;\n    _this._disposables = [];\n    _this._root = React.createRef();\n    _this._isAdjustingSaturation = true;\n    _this._descriptionId = getId('ColorRectangle-description');\n    _this._onKeyDown = function (ev) {\n      var color = _this.state.color;\n      var s = color.s,\n        v = color.v;\n      var increment = ev.shiftKey ? 10 : 1;\n      // Intentionally DO NOT flip the color picker in RTL: its orientation is not very meaningful,\n      // and getting all the math and styles flipped correctly is tricky\n      switch (ev.which) {\n        case KeyCodes.up:\n          {\n            _this._isAdjustingSaturation = false;\n            v += increment; // V = 100 (lightest) is at the top\n            break;\n          }\n        case KeyCodes.down:\n          {\n            _this._isAdjustingSaturation = false;\n            v -= increment; // V = 0 (darkest) is at the bottom\n            break;\n          }\n        case KeyCodes.left:\n          {\n            _this._isAdjustingSaturation = true;\n            s -= increment;\n            break;\n          }\n        case KeyCodes.right:\n          {\n            _this._isAdjustingSaturation = true;\n            s += increment;\n            break;\n          }\n        default:\n          return;\n      }\n      _this._updateColor(ev, updateSV(color, clamp(s, MAX_COLOR_SATURATION), clamp(v, MAX_COLOR_VALUE)));\n    };\n    _this._onMouseDown = function (ev) {\n      _this._disposables.push(on(window, 'mousemove', _this._onMouseMove, true), on(window, 'mouseup', _this._disposeListeners, true));\n      _this._onMouseMove(ev);\n    };\n    _this._onMouseMove = function (ev) {\n      if (!_this._root.current) {\n        return;\n      }\n      // Leaving the following commented code which is sometimes necessary for debugging:\n      // If the primary button (1) isn't pressed, the user is no longer dragging, so turn off\n      // the event handlers and exit.\n      // if (!(ev.buttons & 1)) {\n      //   this._disposeListeners();\n      //   return;\n      // }\n      var newColor = _getNewColor(ev, _this.state.color, _this._root.current);\n      if (newColor) {\n        _this._updateColor(ev, newColor);\n      }\n    };\n    _this._disposeListeners = function () {\n      _this._disposables.forEach(function (dispose) {\n        return dispose();\n      });\n      _this._disposables = [];\n    };\n    initializeComponentRef(_this);\n    _this.state = {\n      color: props.color\n    };\n    return _this;\n  }\n  Object.defineProperty(ColorRectangleBase.prototype, \"color\", {\n    get: function () {\n      return this.state.color;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  ColorRectangleBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    // if props changed (as opposed to a state update), set the value\n    // TODO: switch to strict controlled pattern instead\n    if (prevProps !== this.props && this.props.color) {\n      this.setState({\n        color: this.props.color\n      });\n    }\n  };\n  ColorRectangleBase.prototype.componentWillUnmount = function () {\n    this._disposeListeners();\n  };\n  ColorRectangleBase.prototype.render = function () {\n    var _a = this.props,\n      minSize = _a.minSize,\n      theme = _a.theme,\n      className = _a.className,\n      styles = _a.styles,\n      ariaValueFormat = _a.ariaValueFormat,\n      ariaLabel = _a.ariaLabel,\n      ariaDescription = _a.ariaDescription;\n    var color = this.state.color;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      minSize: minSize\n    });\n    var valueText = ariaValueFormat.replace('{0}', String(color.s)).replace('{1}', String(color.v));\n    return React.createElement(\"div\", {\n      ref: this._root,\n      tabIndex: 0,\n      className: classNames.root,\n      style: {\n        backgroundColor: getFullColorString(color)\n      },\n      onMouseDown: this._onMouseDown,\n      onKeyDown: this._onKeyDown,\n      role: \"slider\",\n      \"aria-valuetext\": valueText,\n      \"aria-valuenow\": this._isAdjustingSaturation ? color.s : color.v,\n      \"aria-valuemin\": 0,\n      \"aria-valuemax\": MAX_COLOR_VALUE,\n      \"aria-label\": ariaLabel,\n      \"aria-describedby\": this._descriptionId,\n      \"data-is-focusable\": true\n    }, React.createElement(\"div\", {\n      className: classNames.description,\n      id: this._descriptionId\n    }, ariaDescription), React.createElement(\"div\", {\n      className: classNames.light\n    }), React.createElement(\"div\", {\n      className: classNames.dark\n    }), React.createElement(\"div\", {\n      className: classNames.thumb,\n      style: {\n        left: color.s + '%',\n        top: MAX_COLOR_VALUE - color.v + '%',\n        backgroundColor: color.str\n      }\n    }));\n  };\n  ColorRectangleBase.prototype._updateColor = function (ev, color) {\n    var onChange = this.props.onChange;\n    var oldColor = this.state.color;\n    if (color.s === oldColor.s && color.v === oldColor.v) {\n      return; // no change\n    }\n    if (onChange) {\n      onChange(ev, color);\n    }\n    if (!ev.defaultPrevented) {\n      this.setState({\n        color: color\n      });\n      ev.preventDefault();\n    }\n  };\n  ColorRectangleBase.defaultProps = {\n    minSize: 220,\n    ariaLabel: 'Saturation and brightness',\n    ariaValueFormat: 'Saturation {0} brightness {1}',\n    ariaDescription: 'Use left and right arrow keys to set saturation. Use up and down arrow keys to set brightness.'\n  };\n  return ColorRectangleBase;\n}(React.Component);\nexport { ColorRectangleBase };\n/**\n * Exported for testing only.\n * @internal\n */\nexport function _getNewColor(ev, prevColor, root) {\n  var rectSize = root.getBoundingClientRect();\n  var sPercentage = (ev.clientX - rectSize.left) / rectSize.width;\n  var vPercentage = (ev.clientY - rectSize.top) / rectSize.height;\n  return updateSV(prevColor, clamp(Math.round(sPercentage * MAX_COLOR_SATURATION), MAX_COLOR_SATURATION), clamp(Math.round(MAX_COLOR_VALUE - vPercentage * MAX_COLOR_VALUE), MAX_COLOR_VALUE));\n}","map":{"version":3,"sources":["components/ColorPicker/ColorRectangle/ColorRectangle.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { classNamesFunction, on, initializeComponentRef, KeyCodes, getId } from '../../../Utilities';\nimport {\n  IColorRectangleProps,\n  IColorRectangleStyleProps,\n  IColorRectangleStyles,\n  IColorRectangle,\n} from './ColorRectangle.types';\n\n// These imports are separated to help with bundling\nimport { IColor } from '../../../utilities/color/interfaces';\nimport { MAX_COLOR_SATURATION, MAX_COLOR_VALUE } from '../../../utilities/color/consts';\nimport { getFullColorString } from '../../../utilities/color/getFullColorString';\nimport { updateSV } from '../../../utilities/color/updateSV';\nimport { clamp } from '../../../utilities/color/clamp';\n\nconst getClassNames = classNamesFunction<IColorRectangleStyleProps, IColorRectangleStyles>();\n\nexport interface IColorRectangleState {\n  color: IColor;\n}\n\n/**\n * {@docCategory ColorPicker}\n */\nexport class ColorRectangleBase extends React.Component<IColorRectangleProps, IColorRectangleState>\n  implements IColorRectangle {\n  public static defaultProps: Partial<IColorRectangleProps> = {\n    minSize: 220,\n    ariaLabel: 'Saturation and brightness',\n    ariaValueFormat: 'Saturation {0} brightness {1}',\n    ariaDescription: 'Use left and right arrow keys to set saturation. Use up and down arrow keys to set brightness.',\n  };\n\n  private _disposables: (() => void)[] = [];\n  private _root = React.createRef<HTMLDivElement>();\n  private _isAdjustingSaturation: boolean = true;\n  private _descriptionId = getId('ColorRectangle-description');\n\n  constructor(props: IColorRectangleProps) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    this.state = { color: props.color };\n  }\n\n  public get color(): IColor {\n    return this.state.color;\n  }\n\n  public componentDidUpdate(\n    prevProps: Readonly<IColorRectangleProps>,\n    prevState: Readonly<IColorRectangleState>,\n  ): void {\n    // if props changed (as opposed to a state update), set the value\n    // TODO: switch to strict controlled pattern instead\n    if (prevProps !== this.props && this.props.color) {\n      this.setState({ color: this.props.color });\n    }\n  }\n\n  public componentWillUnmount() {\n    this._disposeListeners();\n  }\n\n  public render(): JSX.Element {\n    const { minSize, theme, className, styles, ariaValueFormat, ariaLabel, ariaDescription } = this.props;\n    const { color } = this.state;\n\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      minSize,\n    });\n\n    const valueText = ariaValueFormat!.replace('{0}', String(color.s)).replace('{1}', String(color.v));\n\n    return (\n      <div\n        ref={this._root}\n        tabIndex={0}\n        className={classNames.root}\n        style={{ backgroundColor: getFullColorString(color) }}\n        onMouseDown={this._onMouseDown}\n        onKeyDown={this._onKeyDown}\n        role=\"slider\"\n        // Proper description of the current hue *and* saturation\n        // (screen reader typically chooses this over aria-valuenow)\n        aria-valuetext={valueText}\n        // Narrator reads aria-valuetext first, but it also reads aria-valuenow after a pause, and\n        // per the aria spec this defaults to halfway between min/max (50) if we don't provide it.\n        // So provide the value of the most recently adjusted thing.\n        aria-valuenow={this._isAdjustingSaturation ? color.s : color.v}\n        aria-valuemin={0}\n        aria-valuemax={MAX_COLOR_VALUE}\n        aria-label={ariaLabel}\n        aria-describedby={this._descriptionId}\n        data-is-focusable={true}\n      >\n        <div className={classNames.description} id={this._descriptionId}>\n          {ariaDescription}\n        </div>\n        <div className={classNames.light} />\n        <div className={classNames.dark} />\n        <div\n          className={classNames.thumb}\n          style={{ left: color!.s + '%', top: MAX_COLOR_VALUE - color!.v + '%', backgroundColor: color!.str }}\n        />\n      </div>\n    );\n  }\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    const { color } = this.state;\n    let { s, v } = color;\n\n    const increment = ev.shiftKey ? 10 : 1;\n\n    // Intentionally DO NOT flip the color picker in RTL: its orientation is not very meaningful,\n    // and getting all the math and styles flipped correctly is tricky\n    switch (ev.which) {\n      case KeyCodes.up: {\n        this._isAdjustingSaturation = false;\n        v += increment; // V = 100 (lightest) is at the top\n        break;\n      }\n      case KeyCodes.down: {\n        this._isAdjustingSaturation = false;\n        v -= increment; // V = 0 (darkest) is at the bottom\n        break;\n      }\n      case KeyCodes.left: {\n        this._isAdjustingSaturation = true;\n        s -= increment;\n        break;\n      }\n      case KeyCodes.right: {\n        this._isAdjustingSaturation = true;\n        s += increment;\n        break;\n      }\n      default:\n        return;\n    }\n\n    this._updateColor(ev, updateSV(color, clamp(s, MAX_COLOR_SATURATION), clamp(v, MAX_COLOR_VALUE)));\n  };\n\n  private _updateColor(ev: MouseEvent | KeyboardEvent | React.MouseEvent | React.KeyboardEvent, color: IColor): void {\n    const { onChange } = this.props;\n\n    const oldColor = this.state.color;\n    if (color.s === oldColor.s && color.v === oldColor.v) {\n      return; // no change\n    }\n\n    if (onChange) {\n      onChange(ev as React.MouseEvent | React.KeyboardEvent, color);\n    }\n\n    if (!ev.defaultPrevented) {\n      this.setState({ color });\n      ev.preventDefault();\n    }\n  }\n\n  private _onMouseDown = (ev: React.MouseEvent): void => {\n    this._disposables.push(\n      on(window, 'mousemove', this._onMouseMove as (ev: MouseEvent) => void, true),\n      on(window, 'mouseup', this._disposeListeners, true),\n    );\n\n    this._onMouseMove(ev);\n  };\n\n  private _onMouseMove = (ev: MouseEvent | React.MouseEvent): void => {\n    if (!this._root.current) {\n      return;\n    }\n\n    // Leaving the following commented code which is sometimes necessary for debugging:\n    // If the primary button (1) isn't pressed, the user is no longer dragging, so turn off\n    // the event handlers and exit.\n    // if (!(ev.buttons & 1)) {\n    //   this._disposeListeners();\n    //   return;\n    // }\n\n    const newColor = _getNewColor(ev, this.state.color, this._root.current);\n    if (newColor) {\n      this._updateColor(ev, newColor);\n    }\n  };\n\n  private _disposeListeners = (): void => {\n    this._disposables.forEach(dispose => dispose());\n    this._disposables = [];\n  };\n}\n\n/**\n * Exported for testing only.\n * @internal\n */\nexport function _getNewColor(\n  ev: MouseEvent | React.MouseEvent,\n  prevColor: IColor,\n  root: HTMLElement,\n): IColor | undefined {\n  const rectSize = root.getBoundingClientRect();\n\n  const sPercentage = (ev.clientX - rectSize.left) / rectSize.width;\n  const vPercentage = (ev.clientY - rectSize.top) / rectSize.height;\n\n  return updateSV(\n    prevColor,\n    clamp(Math.round(sPercentage * MAX_COLOR_SATURATION), MAX_COLOR_SATURATION),\n    clamp(Math.round(MAX_COLOR_VALUE - vPercentage * MAX_COLOR_VALUE), MAX_COLOR_VALUE),\n  );\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}