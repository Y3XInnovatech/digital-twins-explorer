{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nexport var DEFAULT_CLIENT_RETRY_COUNT = 3;\n// intervals are in ms\nexport var DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\nexport var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\nexport var DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\nexport function isNumber(n) {\n  return typeof n === \"number\";\n}\n/**\n * @internal\n * Determines if the operation should be retried.\n *\n * @param retryLimit - Specifies the max number of retries.\n * @param predicate - Initial chekck on whether to retry based on given responses or errors\n * @param retryData -  The retry data.\n * @returns True if the operation qualifies for a retry; false otherwise.\n */\nexport function shouldRetry(retryLimit, predicate, retryData, response, error) {\n  if (!predicate(response, error)) {\n    return false;\n  }\n  return retryData.retryCount < retryLimit;\n}\n/**\n * @internal\n * Updates the retry data for the next attempt.\n *\n * @param retryOptions - specifies retry interval, and its lower bound and upper bound.\n * @param retryData -  The retry data.\n * @param err - The operation\"s error, if any.\n */\nexport function updateRetryData(retryOptions, retryData, err) {\n  if (retryData === void 0) {\n    retryData = {\n      retryCount: 0,\n      retryInterval: 0\n    };\n  }\n  if (err) {\n    if (retryData.error) {\n      err.innerError = retryData.error;\n    }\n    retryData.error = err;\n  }\n  // Adjust retry count\n  retryData.retryCount++;\n  // Adjust retry interval\n  var incrementDelta = Math.pow(2, retryData.retryCount - 1) - 1;\n  var boundedRandDelta = retryOptions.retryInterval * 0.8 + Math.floor(Math.random() * (retryOptions.retryInterval * 0.4));\n  incrementDelta *= boundedRandDelta;\n  retryData.retryInterval = Math.min(retryOptions.minRetryInterval + incrementDelta, retryOptions.maxRetryInterval);\n  return retryData;\n}","map":{"version":3,"sources":["../../../src/util/exponentialBackoffStrategy.ts"],"names":[],"mappings":"AAAA;AACA;AAIA,OAAO,IAAM,0BAA0B,GAAG,CAAC;AAC3C;AACA,OAAO,IAAM,6BAA6B,GAAG,IAAI,GAAG,EAAE;AACtD,OAAO,IAAM,iCAAiC,GAAG,IAAI,GAAG,EAAE;AAC1D,OAAO,IAAM,iCAAiC,GAAG,IAAI,GAAG,CAAC;AAEzD,OAAM,SAAU,QAAQ,CAAC,CAAU,EAAA;EACjC,OAAO,OAAO,CAAC,KAAK,QAAQ;AAC9B;AAaA;;;;;;;;AAQG;AACH,OAAM,SAAU,WAAW,CACzB,UAAkB,EAClB,SAA4E,EAC5E,SAAoB,EACpB,QAAgC,EAChC,KAAkB,EAAA;EAElB,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,KAAK,CAAC,EAAE;IAC/B,OAAO,KAAK;EACb;EAED,OAAO,SAAS,CAAC,UAAU,GAAG,UAAU;AAC1C;AAEA;;;;;;;AAOG;AACH,OAAM,SAAU,eAAe,CAC7B,YAA2F,EAC3F,SAA0D,EAC1D,GAAgB,EAAA;EADhB,IAAA,SAAA,KAAA,KAAA,CAAA,EAAA;IAAA,SAAA,GAAA;MAAyB,UAAU,EAAE,CAAC;MAAE,aAAa,EAAE;IAAC,CAAE;EAAA;EAG1D,IAAI,GAAG,EAAE;IACP,IAAI,SAAS,CAAC,KAAK,EAAE;MACnB,GAAG,CAAC,UAAU,GAAG,SAAS,CAAC,KAAK;IACjC;IAED,SAAS,CAAC,KAAK,GAAG,GAAG;EACtB;EAED;EACA,SAAS,CAAC,UAAU,EAAE;EAEtB;EACA,IAAI,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC;EAC9D,IAAM,gBAAgB,GACpB,YAAY,CAAC,aAAa,GAAG,GAAG,GAChC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAA,CAAE,IAAI,YAAY,CAAC,aAAa,GAAG,GAAG,CAAC,CAAC;EAChE,cAAc,IAAI,gBAAgB;EAElC,SAAS,CAAC,aAAa,GAAG,IAAI,CAAC,GAAG,CAChC,YAAY,CAAC,gBAAgB,GAAG,cAAc,EAC9C,YAAY,CAAC,gBAAgB,CAC9B;EAED,OAAO,SAAS;AAClB","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpOperationResponse } from \"../coreHttp\";\n\nexport const DEFAULT_CLIENT_RETRY_COUNT = 3;\n// intervals are in ms\nexport const DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\nexport const DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\nexport const DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\n\nexport function isNumber(n: unknown): n is number {\n  return typeof n === \"number\";\n}\nexport interface RetryData {\n  retryCount: number;\n  retryInterval: number;\n  error?: RetryError;\n}\n\nexport interface RetryError extends Error {\n  message: string;\n  code?: string;\n  innerError?: RetryError;\n}\n\n/**\n * @internal\n * Determines if the operation should be retried.\n *\n * @param retryLimit - Specifies the max number of retries.\n * @param predicate - Initial chekck on whether to retry based on given responses or errors\n * @param retryData -  The retry data.\n * @returns True if the operation qualifies for a retry; false otherwise.\n */\nexport function shouldRetry(\n  retryLimit: number,\n  predicate: (response?: HttpOperationResponse, error?: RetryError) => boolean,\n  retryData: RetryData,\n  response?: HttpOperationResponse,\n  error?: RetryError\n): boolean {\n  if (!predicate(response, error)) {\n    return false;\n  }\n\n  return retryData.retryCount < retryLimit;\n}\n\n/**\n * @internal\n * Updates the retry data for the next attempt.\n *\n * @param retryOptions - specifies retry interval, and its lower bound and upper bound.\n * @param retryData -  The retry data.\n * @param err - The operation\"s error, if any.\n */\nexport function updateRetryData(\n  retryOptions: { retryInterval: number; minRetryInterval: number; maxRetryInterval: number },\n  retryData: RetryData = { retryCount: 0, retryInterval: 0 },\n  err?: RetryError\n): RetryData {\n  if (err) {\n    if (retryData.error) {\n      err.innerError = retryData.error;\n    }\n\n    retryData.error = err;\n  }\n\n  // Adjust retry count\n  retryData.retryCount++;\n\n  // Adjust retry interval\n  let incrementDelta = Math.pow(2, retryData.retryCount - 1) - 1;\n  const boundedRandDelta =\n    retryOptions.retryInterval * 0.8 +\n    Math.floor(Math.random() * (retryOptions.retryInterval * 0.4));\n  incrementDelta *= boundedRandDelta;\n\n  retryData.retryInterval = Math.min(\n    retryOptions.minRetryInterval + incrementDelta,\n    retryOptions.maxRetryInterval\n  );\n\n  return retryData;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}