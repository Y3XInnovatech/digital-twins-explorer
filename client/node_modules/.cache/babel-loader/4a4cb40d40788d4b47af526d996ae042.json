{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { modalize } from '@uifabric/utilities';\nimport { elementContains, getNativeProps, divProperties, getFirstTabbable, getLastTabbable, getNextElement, getDocument, focusAsync, initializeComponentRef, on } from '../../Utilities';\nvar FocusTrapZone = /** @class */function (_super) {\n  __extends(FocusTrapZone, _super);\n  function FocusTrapZone(props) {\n    var _this = _super.call(this, props) || this;\n    _this._root = React.createRef();\n    _this._firstBumper = React.createRef();\n    _this._lastBumper = React.createRef();\n    _this._hasFocus = false;\n    _this._onRootFocus = function (ev) {\n      if (_this.props.onFocus) {\n        _this.props.onFocus(ev);\n      }\n      _this._hasFocus = true;\n    };\n    _this._onRootBlur = function (ev) {\n      if (_this.props.onBlur) {\n        _this.props.onBlur(ev);\n      }\n      var relatedTarget = ev.relatedTarget;\n      if (ev.relatedTarget === null) {\n        // In IE11, due to lack of support, event.relatedTarget is always\n        // null making every onBlur call to be \"outside\" of the ComboBox\n        // even when it's not. Using document.activeElement is another way\n        // for us to be able to get what the relatedTarget without relying\n        // on the event\n        relatedTarget = _this._getDocument().activeElement;\n      }\n      if (!elementContains(_this._root.current, relatedTarget)) {\n        _this._hasFocus = false;\n      }\n    };\n    _this._onFirstBumperFocus = function () {\n      _this._onBumperFocus(true);\n    };\n    _this._onLastBumperFocus = function () {\n      _this._onBumperFocus(false);\n    };\n    _this._onBumperFocus = function (isFirstBumper) {\n      if (_this.props.disabled) {\n        return;\n      }\n      var currentBumper = isFirstBumper === _this._hasFocus ? _this._lastBumper.current : _this._firstBumper.current;\n      if (_this._root.current) {\n        var nextFocusable = isFirstBumper === _this._hasFocus ? getLastTabbable(_this._root.current, currentBumper, true, false) : getFirstTabbable(_this._root.current, currentBumper, true, false);\n        if (nextFocusable) {\n          if (_this._isBumper(nextFocusable)) {\n            // This can happen when FTZ contains no tabbable elements.\n            // focus will take care of finding a focusable element in FTZ.\n            _this.focus();\n          } else {\n            nextFocusable.focus();\n          }\n        }\n      }\n    };\n    _this._onFocusCapture = function (ev) {\n      if (_this.props.onFocusCapture) {\n        _this.props.onFocusCapture(ev);\n      }\n      if (ev.target !== ev.currentTarget && !_this._isBumper(ev.target)) {\n        // every time focus changes within the trap zone, remember the focused element so that\n        // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n        _this._previouslyFocusedElementInTrapZone = ev.target;\n      }\n    };\n    _this._forceFocusInTrap = function (ev) {\n      if (_this.props.disabled) {\n        return;\n      }\n      if (FocusTrapZone._focusStack.length && _this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n        var focusedElement = _this._getDocument().activeElement;\n        if (!elementContains(_this._root.current, focusedElement)) {\n          _this.focus();\n          _this._hasFocus = true; // set focus here since we stop event propagation\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n    _this._forceClickInTrap = function (ev) {\n      if (_this.props.disabled) {\n        return;\n      }\n      if (FocusTrapZone._focusStack.length && _this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n        var clickedElement = ev.target;\n        if (clickedElement && !elementContains(_this._root.current, clickedElement)) {\n          _this.focus();\n          _this._hasFocus = true; // set focus here since we stop event propagation\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n    initializeComponentRef(_this);\n    return _this;\n  }\n  FocusTrapZone.prototype.componentDidMount = function () {\n    this._bringFocusIntoZone();\n    this._updateEventHandlers(this.props);\n    if (!this.props.disabled && this._root.current && this.props.enableAriaHiddenSiblings) {\n      this._unmodalize = modalize(this._root.current);\n    }\n  };\n  FocusTrapZone.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    var elementToFocusOnDismiss = nextProps.elementToFocusOnDismiss;\n    if (elementToFocusOnDismiss && this._previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    }\n    this._updateEventHandlers(nextProps);\n  };\n  FocusTrapZone.prototype.componentDidUpdate = function (prevProps) {\n    var prevForceFocusInsideTrap = prevProps.forceFocusInsideTrap !== undefined ? prevProps.forceFocusInsideTrap : true;\n    var newForceFocusInsideTrap = this.props.forceFocusInsideTrap !== undefined ? this.props.forceFocusInsideTrap : true;\n    var prevDisabled = prevProps.disabled !== undefined ? prevProps.disabled : false;\n    var newDisabled = this.props.disabled !== undefined ? this.props.disabled : false;\n    if (!prevForceFocusInsideTrap && newForceFocusInsideTrap || prevDisabled && !newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n      // Emulate what happens when a FocusTrapZone gets mounted.\n      this._bringFocusIntoZone();\n      if (!this._unmodalize && this._root.current && this.props.enableAriaHiddenSiblings) {\n        this._unmodalize = modalize(this._root.current);\n      }\n    } else if (prevForceFocusInsideTrap && !newForceFocusInsideTrap || !prevDisabled && newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      // Emulate what happens when a FocusTrapZone gets unmounted.\n      this._returnFocusToInitiator();\n      if (this._unmodalize) {\n        this._unmodalize();\n      }\n    }\n  };\n  FocusTrapZone.prototype.componentWillUnmount = function () {\n    // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone\n    if (!this.props.disabled || this.props.forceFocusInsideTrap || !elementContains(this._root.current, this._getDocument().activeElement)) {\n      this._returnFocusToInitiator();\n    }\n    // Dispose of event handlers so their closures can be garbage-collected\n    if (this._disposeClickHandler) {\n      this._disposeClickHandler();\n      this._disposeClickHandler = undefined;\n    }\n    if (this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n      this._disposeFocusHandler = undefined;\n    }\n    if (this._unmodalize) {\n      this._unmodalize();\n    }\n    // Dispose of element references so the DOM Nodes can be garbage-collected\n    delete this._previouslyFocusedElementInTrapZone;\n    delete this._previouslyFocusedElementOutsideTrapZone;\n  };\n  FocusTrapZone.prototype.render = function () {\n    var _a = this.props,\n      className = _a.className,\n      _b = _a.disabled,\n      disabled = _b === void 0 ? false : _b,\n      ariaLabelledBy = _a.ariaLabelledBy;\n    var divProps = getNativeProps(this.props, divProperties);\n    var bumperProps = {\n      'aria-hidden': true,\n      style: {\n        pointerEvents: 'none',\n        position: 'fixed'\n      },\n      tabIndex: disabled ? -1 : 0,\n      'data-is-visible': true\n    };\n    return React.createElement(\"div\", __assign({}, divProps, {\n      className: className,\n      ref: this._root,\n      \"aria-labelledby\": ariaLabelledBy,\n      onFocusCapture: this._onFocusCapture,\n      onFocus: this._onRootFocus,\n      onBlur: this._onRootBlur\n    }), React.createElement(\"div\", __assign({}, bumperProps, {\n      ref: this._firstBumper,\n      onFocus: this._onFirstBumperFocus\n    })), this.props.children, React.createElement(\"div\", __assign({}, bumperProps, {\n      ref: this._lastBumper,\n      onFocus: this._onLastBumperFocus\n    })));\n  };\n  FocusTrapZone.prototype.focus = function () {\n    // eslint-disable-next-line deprecation/deprecation\n    var _a = this.props,\n      focusPreviouslyFocusedInnerElement = _a.focusPreviouslyFocusedInnerElement,\n      firstFocusableSelector = _a.firstFocusableSelector,\n      firstFocusableTarget = _a.firstFocusableTarget;\n    if (focusPreviouslyFocusedInnerElement && this._previouslyFocusedElementInTrapZone && elementContains(this._root.current, this._previouslyFocusedElementInTrapZone)) {\n      // focus on the last item that had focus in the zone before we left the zone\n      this._focusAsync(this._previouslyFocusedElementInTrapZone);\n      return;\n    }\n    var focusSelector = typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector && firstFocusableSelector();\n    var _firstFocusableChild = null;\n    if (this._root.current) {\n      if (typeof firstFocusableTarget === 'string') {\n        _firstFocusableChild = this._root.current.querySelector(firstFocusableTarget);\n      } else if (firstFocusableTarget) {\n        _firstFocusableChild = firstFocusableTarget(this._root.current);\n      } else if (focusSelector) {\n        _firstFocusableChild = this._root.current.querySelector('.' + focusSelector);\n      }\n      // Fall back to first element if query selector did not match any elements.\n      if (!_firstFocusableChild) {\n        _firstFocusableChild = getNextElement(this._root.current, this._root.current.firstChild, false, false, false, true);\n      }\n    }\n    if (_firstFocusableChild) {\n      this._focusAsync(_firstFocusableChild);\n    }\n  };\n  FocusTrapZone.prototype._focusAsync = function (element) {\n    if (!this._isBumper(element)) {\n      focusAsync(element);\n    }\n  };\n  FocusTrapZone.prototype._bringFocusIntoZone = function () {\n    var _a = this.props,\n      elementToFocusOnDismiss = _a.elementToFocusOnDismiss,\n      _b = _a.disabled,\n      disabled = _b === void 0 ? false : _b,\n      _c = _a.disableFirstFocus,\n      disableFirstFocus = _c === void 0 ? false : _c;\n    if (disabled) {\n      return;\n    }\n    FocusTrapZone._focusStack.push(this);\n    this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss ? elementToFocusOnDismiss : this._getDocument().activeElement;\n    if (!disableFirstFocus && !elementContains(this._root.current, this._previouslyFocusedElementOutsideTrapZone)) {\n      this.focus();\n    }\n  };\n  FocusTrapZone.prototype._returnFocusToInitiator = function () {\n    var _this = this;\n    var ignoreExternalFocusing = this.props.ignoreExternalFocusing;\n    FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter(function (value) {\n      return _this !== value;\n    });\n    var doc = this._getDocument();\n    var activeElement = doc.activeElement;\n    if (!ignoreExternalFocusing && this._previouslyFocusedElementOutsideTrapZone && typeof this._previouslyFocusedElementOutsideTrapZone.focus === 'function' && (elementContains(this._root.current, activeElement) || activeElement === doc.body)) {\n      this._focusAsync(this._previouslyFocusedElementOutsideTrapZone);\n    }\n  };\n  FocusTrapZone.prototype._updateEventHandlers = function (newProps) {\n    var _a = newProps.isClickableOutsideFocusTrap,\n      isClickableOutsideFocusTrap = _a === void 0 ? false : _a,\n      _b = newProps.forceFocusInsideTrap,\n      forceFocusInsideTrap = _b === void 0 ? true : _b;\n    if (forceFocusInsideTrap && !this._disposeFocusHandler) {\n      this._disposeFocusHandler = on(window, 'focus', this._forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n      this._disposeFocusHandler = undefined;\n    }\n    if (!isClickableOutsideFocusTrap && !this._disposeClickHandler) {\n      this._disposeClickHandler = on(window, 'click', this._forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && this._disposeClickHandler) {\n      this._disposeClickHandler();\n      this._disposeClickHandler = undefined;\n    }\n  };\n  FocusTrapZone.prototype._isBumper = function (element) {\n    return element === this._firstBumper.current || element === this._lastBumper.current;\n  };\n  FocusTrapZone.prototype._getDocument = function () {\n    return getDocument(this._root.current);\n  };\n  FocusTrapZone._focusStack = [];\n  return FocusTrapZone;\n}(React.Component);\nexport { FocusTrapZone };","map":{"version":3,"sources":["components/FocusTrapZone/FocusTrapZone.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { modalize } from '@uifabric/utilities';\nimport {\n  elementContains,\n  getNativeProps,\n  divProperties,\n  getFirstTabbable,\n  getLastTabbable,\n  getNextElement,\n  getDocument,\n  focusAsync,\n  initializeComponentRef,\n  on,\n} from '../../Utilities';\nimport { IFocusTrapZone, IFocusTrapZoneProps } from './FocusTrapZone.types';\n\nexport class FocusTrapZone extends React.Component<IFocusTrapZoneProps, {}> implements IFocusTrapZone {\n  private static _focusStack: FocusTrapZone[] = [];\n\n  private _root = React.createRef<HTMLDivElement>();\n  private _firstBumper = React.createRef<HTMLDivElement>();\n  private _lastBumper = React.createRef<HTMLDivElement>();\n  private _hasFocus: boolean = false;\n  private _unmodalize?: () => void;\n\n  private _previouslyFocusedElementOutsideTrapZone: HTMLElement;\n  private _previouslyFocusedElementInTrapZone?: HTMLElement;\n  private _disposeFocusHandler: (() => void) | undefined;\n  private _disposeClickHandler: (() => void) | undefined;\n\n  public constructor(props: IFocusTrapZoneProps) {\n    super(props);\n    initializeComponentRef(this);\n  }\n\n  public componentDidMount(): void {\n    this._bringFocusIntoZone();\n    this._updateEventHandlers(this.props);\n\n    if (!this.props.disabled && this._root.current && this.props.enableAriaHiddenSiblings) {\n      this._unmodalize = modalize(this._root.current);\n    }\n  }\n\n  public UNSAFE_componentWillReceiveProps(nextProps: IFocusTrapZoneProps): void {\n    const { elementToFocusOnDismiss } = nextProps;\n    if (elementToFocusOnDismiss && this._previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    }\n\n    this._updateEventHandlers(nextProps);\n  }\n\n  public componentDidUpdate(prevProps: IFocusTrapZoneProps) {\n    const prevForceFocusInsideTrap =\n      prevProps.forceFocusInsideTrap !== undefined ? prevProps.forceFocusInsideTrap : true;\n    const newForceFocusInsideTrap =\n      this.props.forceFocusInsideTrap !== undefined ? this.props.forceFocusInsideTrap : true;\n    const prevDisabled = prevProps.disabled !== undefined ? prevProps.disabled : false;\n    const newDisabled = this.props.disabled !== undefined ? this.props.disabled : false;\n\n    if ((!prevForceFocusInsideTrap && newForceFocusInsideTrap) || (prevDisabled && !newDisabled)) {\n      // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n      // Emulate what happens when a FocusTrapZone gets mounted.\n      this._bringFocusIntoZone();\n      if (!this._unmodalize && this._root.current && this.props.enableAriaHiddenSiblings) {\n        this._unmodalize = modalize(this._root.current);\n      }\n    } else if ((prevForceFocusInsideTrap && !newForceFocusInsideTrap) || (!prevDisabled && newDisabled)) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      // Emulate what happens when a FocusTrapZone gets unmounted.\n      this._returnFocusToInitiator();\n      if (this._unmodalize) {\n        this._unmodalize();\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone\n    if (\n      !this.props.disabled ||\n      this.props.forceFocusInsideTrap ||\n      !elementContains(this._root.current, this._getDocument().activeElement as HTMLElement)\n    ) {\n      this._returnFocusToInitiator();\n    }\n\n    // Dispose of event handlers so their closures can be garbage-collected\n    if (this._disposeClickHandler) {\n      this._disposeClickHandler();\n      this._disposeClickHandler = undefined;\n    }\n\n    if (this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n      this._disposeFocusHandler = undefined;\n    }\n\n    if (this._unmodalize) {\n      this._unmodalize();\n    }\n\n    // Dispose of element references so the DOM Nodes can be garbage-collected\n    delete this._previouslyFocusedElementInTrapZone;\n    delete this._previouslyFocusedElementOutsideTrapZone;\n  }\n\n  public render(): JSX.Element {\n    const { className, disabled = false, ariaLabelledBy } = this.props;\n    const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties);\n\n    const bumperProps = {\n      'aria-hidden': true,\n      style: {\n        pointerEvents: 'none',\n        position: 'fixed', // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n      },\n      tabIndex: disabled ? -1 : 0, // make bumpers tabbable only when enabled\n      'data-is-visible': true,\n    } as React.HTMLAttributes<HTMLDivElement>;\n\n    return (\n      <div\n        {...divProps}\n        className={className}\n        ref={this._root}\n        aria-labelledby={ariaLabelledBy}\n        onFocusCapture={this._onFocusCapture}\n        onFocus={this._onRootFocus}\n        onBlur={this._onRootBlur}\n      >\n        <div {...bumperProps} ref={this._firstBumper} onFocus={this._onFirstBumperFocus} />\n        {this.props.children}\n        <div {...bumperProps} ref={this._lastBumper} onFocus={this._onLastBumperFocus} />\n      </div>\n    );\n  }\n\n  public focus() {\n    // eslint-disable-next-line deprecation/deprecation\n    const { focusPreviouslyFocusedInnerElement, firstFocusableSelector, firstFocusableTarget } = this.props;\n\n    if (\n      focusPreviouslyFocusedInnerElement &&\n      this._previouslyFocusedElementInTrapZone &&\n      elementContains(this._root.current, this._previouslyFocusedElementInTrapZone)\n    ) {\n      // focus on the last item that had focus in the zone before we left the zone\n      this._focusAsync(this._previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    const focusSelector =\n      typeof firstFocusableSelector === 'string'\n        ? firstFocusableSelector\n        : firstFocusableSelector && firstFocusableSelector();\n\n    let _firstFocusableChild: HTMLElement | null = null;\n\n    if (this._root.current) {\n      if (typeof firstFocusableTarget === 'string') {\n        _firstFocusableChild = this._root.current.querySelector(firstFocusableTarget);\n      } else if (firstFocusableTarget) {\n        _firstFocusableChild = firstFocusableTarget(this._root.current);\n      } else if (focusSelector) {\n        _firstFocusableChild = this._root.current.querySelector('.' + focusSelector);\n      }\n\n      // Fall back to first element if query selector did not match any elements.\n      if (!_firstFocusableChild) {\n        _firstFocusableChild = getNextElement(\n          this._root.current,\n          this._root.current.firstChild as HTMLElement,\n          false,\n          false,\n          false,\n          true,\n        );\n      }\n    }\n    if (_firstFocusableChild) {\n      this._focusAsync(_firstFocusableChild);\n    }\n  }\n\n  private _focusAsync(element: HTMLElement): void {\n    if (!this._isBumper(element)) {\n      focusAsync(element);\n    }\n  }\n\n  private _onRootFocus = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onFocus) {\n      this.props.onFocus(ev);\n    }\n\n    this._hasFocus = true;\n  };\n\n  private _onRootBlur = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onBlur) {\n      this.props.onBlur(ev);\n    }\n\n    let relatedTarget = ev.relatedTarget;\n    if (ev.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the ComboBox\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = this._getDocument().activeElement as Element;\n    }\n\n    if (!elementContains(this._root.current, relatedTarget as HTMLElement)) {\n      this._hasFocus = false;\n    }\n  };\n\n  private _onFirstBumperFocus = () => {\n    this._onBumperFocus(true);\n  };\n\n  private _onLastBumperFocus = () => {\n    this._onBumperFocus(false);\n  };\n\n  private _onBumperFocus = (isFirstBumper: boolean) => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    const currentBumper = (isFirstBumper === this._hasFocus\n      ? this._lastBumper.current\n      : this._firstBumper.current) as HTMLElement;\n\n    if (this._root.current) {\n      const nextFocusable =\n        isFirstBumper === this._hasFocus\n          ? getLastTabbable(this._root.current, currentBumper, true, false)\n          : getFirstTabbable(this._root.current, currentBumper, true, false);\n\n      if (nextFocusable) {\n        if (this._isBumper(nextFocusable)) {\n          // This can happen when FTZ contains no tabbable elements.\n          // focus will take care of finding a focusable element in FTZ.\n          this.focus();\n        } else {\n          nextFocusable.focus();\n        }\n      }\n    }\n  };\n\n  private _bringFocusIntoZone(): void {\n    const { elementToFocusOnDismiss, disabled = false, disableFirstFocus = false } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    FocusTrapZone._focusStack.push(this);\n\n    this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss\n      ? elementToFocusOnDismiss\n      : (this._getDocument().activeElement as HTMLElement);\n    if (!disableFirstFocus && !elementContains(this._root.current, this._previouslyFocusedElementOutsideTrapZone)) {\n      this.focus();\n    }\n  }\n\n  private _returnFocusToInitiator(): void {\n    const { ignoreExternalFocusing } = this.props;\n\n    FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter((value: FocusTrapZone) => {\n      return this !== value;\n    });\n\n    const doc = this._getDocument();\n    const activeElement = doc.activeElement as HTMLElement;\n    if (\n      !ignoreExternalFocusing &&\n      this._previouslyFocusedElementOutsideTrapZone &&\n      typeof this._previouslyFocusedElementOutsideTrapZone.focus === 'function' &&\n      (elementContains(this._root.current, activeElement) || activeElement === doc.body)\n    ) {\n      this._focusAsync(this._previouslyFocusedElementOutsideTrapZone);\n    }\n  }\n\n  private _updateEventHandlers(newProps: IFocusTrapZoneProps): void {\n    const { isClickableOutsideFocusTrap = false, forceFocusInsideTrap = true } = newProps;\n\n    if (forceFocusInsideTrap && !this._disposeFocusHandler) {\n      this._disposeFocusHandler = on(window, 'focus', this._forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n      this._disposeFocusHandler = undefined;\n    }\n\n    if (!isClickableOutsideFocusTrap && !this._disposeClickHandler) {\n      this._disposeClickHandler = on(window, 'click', this._forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && this._disposeClickHandler) {\n      this._disposeClickHandler();\n      this._disposeClickHandler = undefined;\n    }\n  }\n\n  private _onFocusCapture = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onFocusCapture) {\n      this.props.onFocusCapture(ev);\n    }\n\n    if (ev.target !== ev.currentTarget && !this._isBumper(ev.target)) {\n      // every time focus changes within the trap zone, remember the focused element so that\n      // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n      this._previouslyFocusedElementInTrapZone = ev.target as HTMLElement;\n    }\n  };\n\n  private _isBumper(element: HTMLElement): boolean {\n    return element === this._firstBumper.current || element === this._lastBumper.current;\n  }\n\n  private _forceFocusInTrap = (ev: FocusEvent): void => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n      const focusedElement = this._getDocument().activeElement as HTMLElement;\n\n      if (!elementContains(this._root.current, focusedElement)) {\n        this.focus();\n        this._hasFocus = true; // set focus here since we stop event propagation\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  private _forceClickInTrap = (ev: MouseEvent): void => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n      const clickedElement = ev.target as HTMLElement;\n\n      if (clickedElement && !elementContains(this._root.current, clickedElement)) {\n        this.focus();\n        this._hasFocus = true; // set focus here since we stop event propagation\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  private _getDocument(): Document {\n    return getDocument(this._root.current)!;\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}