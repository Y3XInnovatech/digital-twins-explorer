{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ExcelRenderer as excelRenderer } from \"react-excel-renderer\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { DataModel } from \"../models/DataModel\";\nconst ModelColumn = \"model\",\n  IdColumn = \"id\",\n  RelationshipFromColumn = \"relFrom\",\n  RelationshipTypeColumn = \"relType\",\n  InitialDataColumn = \"initData\",\n  RelationshipInitialDataColumn = \"relInitData\";\nconst ColumnMapping = [{\n  name: \"ModelID\",\n  id: ModelColumn\n}, {\n  name: \"ID (must be unique)\",\n  id: IdColumn\n}, {\n  name: \"Relationship (From)\",\n  id: RelationshipFromColumn\n}, {\n  name: \"Relationship Name\",\n  id: RelationshipTypeColumn\n}, {\n  name: \"Init Data\",\n  id: InitialDataColumn\n}, {\n  name: \"Relationship Init Data\",\n  id: RelationshipInitialDataColumn\n}];\nclass StandardExcelImportFormat {\n  getData(resp) {\n    const headers = this._mapHeaders(resp.rows[0]);\n    if (!headers) {\n      return null;\n    }\n    const data = new DataModel();\n    const errors = [];\n    for (let i = 1; i < resp.rows.length; i++) {\n      const row = resp.rows[i];\n      if (row.length === 0) {\n        continue;\n      }\n      const twinId = row[headers[IdColumn]];\n      if (!twinId) {\n        errors.push(`Missing twin ID on row ${i}`);\n        continue;\n      }\n      try {\n        const modelId = row[headers[ModelColumn]];\n        const initDataRaw = row[headers[InitialDataColumn]];\n        const initData = initDataRaw ? JSON.parse(initDataRaw) : {};\n        initData.$metadata = {\n          $model: modelId\n        };\n        if (modelId) {\n          const addedTwin = data.digitalTwinsGraph.digitalTwins.find(twin => twin.$dtId === twinId);\n          if (addedTwin) {\n            errors.push(`Twin ID is duplicated on row ${i}`);\n            continue;\n          }\n          data.digitalTwinsGraph.digitalTwins.push({\n            $dtId: twinId,\n            ...initData\n          });\n        }\n        const parent = row[headers[RelationshipFromColumn]];\n        const relationship = row[headers[RelationshipTypeColumn]];\n        const initRelationshipDataRaw = row[headers[RelationshipInitialDataColumn]];\n        const initRelationshipData = initRelationshipDataRaw ? JSON.parse(initRelationshipDataRaw) : {};\n        if (parent) {\n          const parentTwin = data.digitalTwinsGraph.digitalTwins.find(twin => twin.$dtId === twinId);\n          if (!parentTwin) {\n            errors.push(`Parent Twin with ID ${parent} is not defined yet on row ${i}`);\n            continue;\n          }\n          if (!relationship) {\n            errors.push(`Relationship parent is defined with ID ${parent} but there isn't a relationship name on row ${i}`);\n            continue;\n          }\n          data.digitalTwinsGraph.relationships.push({\n            $sourceId: parent,\n            $targetId: twinId,\n            $relationshipName: relationship,\n            $relationshipId: uuidv4(),\n            $properties: initRelationshipData\n          });\n        }\n      } catch (error) {\n        errors.push(`${error.message} on row ${i}`);\n      }\n    }\n    if (errors.length > 0) {\n      throw new Error(errors.join(\"\\n\"));\n    }\n    return data;\n  }\n  _mapHeaders(row) {\n    const mapping = ColumnMapping.reduce((p, c) => {\n      const index = row.findIndex(x => x === c.name);\n      if (index >= 0) {\n        p[c.id] = index;\n      }\n      return p;\n    }, {});\n    return mapping;\n  }\n}\nexport class ExcelImportPlugin {\n  async tryLoad(file) {\n    if (!file.name.endsWith(\".xlsx\")) {\n      return false;\n    }\n    const results = await new Promise((resolve, reject) => {\n      excelRenderer(file, (err, resp) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(resp);\n      });\n    });\n    const data = new StandardExcelImportFormat().getData(results);\n    if (!data) {\n      throw new Error(`Failed to parse format`);\n    }\n    return data;\n  }\n}","map":{"version":3,"names":["ExcelRenderer","excelRenderer","v4","uuidv4","DataModel","ModelColumn","IdColumn","RelationshipFromColumn","RelationshipTypeColumn","InitialDataColumn","RelationshipInitialDataColumn","ColumnMapping","name","id","StandardExcelImportFormat","getData","resp","headers","_mapHeaders","rows","data","errors","i","length","row","twinId","push","modelId","initDataRaw","initData","JSON","parse","$metadata","$model","addedTwin","digitalTwinsGraph","digitalTwins","find","twin","$dtId","parent","relationship","initRelationshipDataRaw","initRelationshipData","parentTwin","relationships","$sourceId","$targetId","$relationshipName","$relationshipId","$properties","error","message","Error","join","mapping","reduce","p","c","index","findIndex","x","ExcelImportPlugin","tryLoad","file","endsWith","results","Promise","resolve","reject","err"],"sources":["/home/saharsh/digital-twins-explorer/client/src/services/plugins/ExcelImportPlugin.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ExcelRenderer as excelRenderer } from \"react-excel-renderer\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nimport { DataModel } from \"../models/DataModel\";\n\nconst ModelColumn = \"model\",\n  IdColumn = \"id\",\n  RelationshipFromColumn = \"relFrom\",\n  RelationshipTypeColumn = \"relType\",\n  InitialDataColumn = \"initData\",\n  RelationshipInitialDataColumn = \"relInitData\";\n\nconst ColumnMapping = [\n  { name: \"ModelID\", id: ModelColumn },\n  { name: \"ID (must be unique)\", id: IdColumn },\n  { name: \"Relationship (From)\", id: RelationshipFromColumn },\n  { name: \"Relationship Name\", id: RelationshipTypeColumn },\n  { name: \"Init Data\", id: InitialDataColumn },\n  { name: \"Relationship Init Data\", id: RelationshipInitialDataColumn }\n];\n\nclass StandardExcelImportFormat {\n\n  getData(resp) {\n    const headers = this._mapHeaders(resp.rows[0]);\n    if (!headers) {\n      return null;\n    }\n    const data = new DataModel();\n    const errors = [];\n    for (let i = 1; i < resp.rows.length; i++) {\n      const row = resp.rows[i];\n      if (row.length === 0) {\n        continue;\n      }\n      const twinId = row[headers[IdColumn]];\n      if (!twinId) {\n        errors.push(`Missing twin ID on row ${i}`);\n        continue;\n      }\n\n      try {\n        const modelId = row[headers[ModelColumn]];\n        const initDataRaw = row[headers[InitialDataColumn]];\n        const initData = initDataRaw ? JSON.parse(initDataRaw) : {};\n        initData.$metadata = { $model: modelId };\n        if (modelId) {\n          const addedTwin = data.digitalTwinsGraph.digitalTwins.find(twin => twin.$dtId === twinId);\n          if (addedTwin) {\n            errors.push(`Twin ID is duplicated on row ${i}`);\n            continue;\n          }\n          data.digitalTwinsGraph.digitalTwins.push({ $dtId: twinId, ...initData });\n        }\n\n        const parent = row[headers[RelationshipFromColumn]];\n        const relationship = row[headers[RelationshipTypeColumn]];\n        const initRelationshipDataRaw = row[headers[RelationshipInitialDataColumn]];\n        const initRelationshipData = initRelationshipDataRaw ? JSON.parse(initRelationshipDataRaw) : {};\n        if (parent) {\n          const parentTwin = data.digitalTwinsGraph.digitalTwins.find(twin => twin.$dtId === twinId);\n          if (!parentTwin) {\n            errors.push(`Parent Twin with ID ${parent} is not defined yet on row ${i}`);\n            continue;\n          }\n          if (!relationship) {\n            errors.push(`Relationship parent is defined with ID ${parent} but there isn't a relationship name on row ${i}`);\n            continue;\n          }\n          data.digitalTwinsGraph.relationships.push({\n            $sourceId: parent,\n            $targetId: twinId,\n            $relationshipName: relationship,\n            $relationshipId: uuidv4(),\n            $properties: initRelationshipData\n          });\n        }\n      } catch (error) {\n        errors.push(`${error.message} on row ${i}`);\n      }\n    }\n\n    if (errors.length > 0) {\n      throw new Error(errors.join(\"\\n\"));\n    }\n\n    return data;\n  }\n\n  _mapHeaders(row) {\n    const mapping = ColumnMapping.reduce((p, c) => {\n      const index = row.findIndex(x => x === c.name);\n      if (index >= 0) {\n        p[c.id] = index;\n      }\n\n      return p;\n    }, {});\n\n    return mapping;\n  }\n\n}\n\nexport class ExcelImportPlugin {\n\n  async tryLoad(file) {\n    if (!file.name.endsWith(\".xlsx\")) {\n      return false;\n    }\n\n    const results = await new Promise((resolve, reject) => {\n      excelRenderer(file, (err, resp) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        resolve(resp);\n      });\n    });\n\n    const data = new StandardExcelImportFormat().getData(results);\n    if (!data) {\n      throw new Error(`Failed to parse format`);\n    }\n\n    return data;\n  }\n\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}