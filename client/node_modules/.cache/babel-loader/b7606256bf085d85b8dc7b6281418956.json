{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __awaiter, __extends, __generator } from \"tslib\";\nimport * as utils from \"../util/utils\";\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { shouldRetry, updateRetryData, DEFAULT_CLIENT_MAX_RETRY_INTERVAL, DEFAULT_CLIENT_RETRY_COUNT, DEFAULT_CLIENT_RETRY_INTERVAL, DEFAULT_CLIENT_MIN_RETRY_INTERVAL, isNumber } from \"../util/exponentialBackoffStrategy\";\nexport function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n  return {\n    create: function (nextPolicy, options) {\n      return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);\n    }\n  };\n}\n/**\n * @param retryCount - The client retry count.\n * @param retryInterval - The client retry interval, in milliseconds.\n * @param minRetryInterval - The minimum retry interval, in milliseconds.\n * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n */\nvar SystemErrorRetryPolicy = /** @class */function (_super) {\n  __extends(SystemErrorRetryPolicy, _super);\n  function SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n    var _this = _super.call(this, nextPolicy, options) || this;\n    _this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    _this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    _this.minRetryInterval = isNumber(minRetryInterval) ? minRetryInterval : DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n    _this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n    return _this;\n  }\n  SystemErrorRetryPolicy.prototype.sendRequest = function (request) {\n    var _this = this;\n    return this._nextPolicy.sendRequest(request.clone()).catch(function (error) {\n      return retry(_this, request, error.response, error);\n    });\n  };\n  return SystemErrorRetryPolicy;\n}(BaseRequestPolicy);\nexport { SystemErrorRetryPolicy };\nfunction retry(policy, request, operationResponse, err, retryData) {\n  return __awaiter(this, void 0, void 0, function () {\n    function shouldPolicyRetry(_response, error) {\n      if (error && error.code && (error.code === \"ETIMEDOUT\" || error.code === \"ESOCKETTIMEDOUT\" || error.code === \"ECONNREFUSED\" || error.code === \"ECONNRESET\" || error.code === \"ENOENT\")) {\n        return true;\n      }\n      return false;\n    }\n    var nestedErr_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          retryData = updateRetryData(policy, retryData, err);\n          if (!shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, operationResponse, err)) return [3 /*break*/, 5];\n          _a.label = 1;\n        case 1:\n          _a.trys.push([1, 3,, 4]);\n          return [4 /*yield*/, utils.delay(retryData.retryInterval)];\n        case 2:\n          _a.sent();\n          return [2 /*return*/, policy._nextPolicy.sendRequest(request.clone())];\n        case 3:\n          nestedErr_1 = _a.sent();\n          return [2 /*return*/, retry(policy, request, operationResponse, nestedErr_1, retryData)];\n        case 4:\n          return [3 /*break*/, 6];\n        case 5:\n          if (err) {\n            // If the operation failed in the end, return all errors instead of just the last one\n            return [2 /*return*/, Promise.reject(retryData.error)];\n          }\n          return [2 /*return*/, operationResponse];\n        case 6:\n          return [2 /*return*/];\n      }\n    });\n  });\n}","map":{"version":3,"sources":["../../../src/policies/systemErrorRetryPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport * as utils from \"../util/utils\";\nimport { WebResourceLike } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\nimport {\n  RetryData,\n  RetryError,\n  shouldRetry,\n  updateRetryData,\n  DEFAULT_CLIENT_MAX_RETRY_INTERVAL,\n  DEFAULT_CLIENT_RETRY_COUNT,\n  DEFAULT_CLIENT_RETRY_INTERVAL,\n  DEFAULT_CLIENT_MIN_RETRY_INTERVAL,\n  isNumber\n} from \"../util/exponentialBackoffStrategy\";\n\nexport function systemErrorRetryPolicy(\n  retryCount?: number,\n  retryInterval?: number,\n  minRetryInterval?: number,\n  maxRetryInterval?: number\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new SystemErrorRetryPolicy(\n        nextPolicy,\n        options,\n        retryCount,\n        retryInterval,\n        minRetryInterval,\n        maxRetryInterval\n      );\n    }\n  };\n}\n\n/**\n * @param retryCount - The client retry count.\n * @param retryInterval - The client retry interval, in milliseconds.\n * @param minRetryInterval - The minimum retry interval, in milliseconds.\n * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n */\nexport class SystemErrorRetryPolicy extends BaseRequestPolicy {\n  retryCount: number;\n  retryInterval: number;\n  minRetryInterval: number;\n  maxRetryInterval: number;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    retryCount?: number,\n    retryInterval?: number,\n    minRetryInterval?: number,\n    maxRetryInterval?: number\n  ) {\n    super(nextPolicy, options);\n    this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.minRetryInterval = isNumber(minRetryInterval)\n      ? minRetryInterval\n      : DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n    this.maxRetryInterval = isNumber(maxRetryInterval)\n      ? maxRetryInterval\n      : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n\n  public sendRequest(request: WebResourceLike): Promise<HttpOperationResponse> {\n    return this._nextPolicy\n      .sendRequest(request.clone())\n      .catch((error) => retry(this, request, error.response, error));\n  }\n}\n\nasync function retry(\n  policy: SystemErrorRetryPolicy,\n  request: WebResourceLike,\n  operationResponse: HttpOperationResponse,\n  err?: RetryError,\n  retryData?: RetryData\n): Promise<HttpOperationResponse> {\n  retryData = updateRetryData(policy, retryData, err);\n\n  function shouldPolicyRetry(_response?: HttpOperationResponse, error?: RetryError): boolean {\n    if (\n      error &&\n      error.code &&\n      (error.code === \"ETIMEDOUT\" ||\n        error.code === \"ESOCKETTIMEDOUT\" ||\n        error.code === \"ECONNREFUSED\" ||\n        error.code === \"ECONNRESET\" ||\n        error.code === \"ENOENT\")\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  if (shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, operationResponse, err)) {\n    // If previous operation ended with an error and the policy allows a retry, do that\n    try {\n      await utils.delay(retryData.retryInterval);\n      return policy._nextPolicy.sendRequest(request.clone());\n    } catch (nestedErr) {\n      return retry(policy, request, operationResponse, nestedErr, retryData);\n    }\n  } else {\n    if (err) {\n      // If the operation failed in the end, return all errors instead of just the last one\n      return Promise.reject(retryData.error);\n    }\n    return operationResponse;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}