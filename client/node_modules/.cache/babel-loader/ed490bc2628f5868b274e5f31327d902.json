{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSimpleGraph: _isSimpleGraph,\n  isSubjectReference: _isSubjectReference\n} = require('./graphTypes');\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\nconst {\n  removeBase: _removeBase\n} = require('./url');\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = require('./util');\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return a promise that resolves to the compacted value.\n */\napi.compact = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  compactionMap = () => undefined\n}) => {\n  // recursively compact array\n  if (_isArray(element)) {\n    let rval = [];\n    for (let i = 0; i < element.length; ++i) {\n      // compact, dropping any null values unless custom mapped\n      let compacted = await api.compact({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        compactionMap\n      });\n      if (compacted === null) {\n        compacted = await compactionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options\n        });\n        if (compacted === undefined) {\n          continue;\n        }\n      }\n      rval.push(compacted);\n    }\n    if (options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      const container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n      if (container.length === 0) {\n        rval = rval[0];\n      }\n    }\n    return rval;\n  }\n\n  // use any scoped context on activeProperty\n  const ctx = _getContextValue(activeCtx, activeProperty, '@context');\n  if (!_isUndefined(ctx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: ctx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // recursively compact object\n  if (_isObject(element)) {\n    if (options.link && '@id' in element && options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      const linked = options.link[element['@id']];\n      for (let i = 0; i < linked.length; ++i) {\n        if (linked[i].expanded === element) {\n          return linked[i].compacted;\n        }\n      }\n    }\n\n    // do value compaction on @values and subject references\n    if (_isValue(element) || _isSubjectReference(element)) {\n      const rval = api.compactValue({\n        activeCtx,\n        activeProperty,\n        value: element,\n        options\n      });\n      if (options.link && _isSubjectReference(element)) {\n        // store linked element\n        if (!options.link.hasOwnProperty(element['@id'])) {\n          options.link[element['@id']] = [];\n        }\n        options.link[element['@id']].push({\n          expanded: element,\n          compacted: rval\n        });\n      }\n      return rval;\n    }\n\n    // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n    if (_isList(element)) {\n      const container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n      if (container.includes('@list')) {\n        return api.compact({\n          activeCtx,\n          activeProperty,\n          element: element['@list'],\n          options,\n          compactionMap\n        });\n      }\n    }\n\n    // FIXME: avoid misuse of active property as an expanded property?\n    const insideReverse = activeProperty === '@reverse';\n    const rval = {};\n\n    // original context before applying property-scoped and local contexts\n    const inputCtx = activeCtx;\n\n    // revert to previous context, if there is one,\n    // and element is not a value object or a node reference\n    if (!_isValue(element) && !_isSubjectReference(element)) {\n      activeCtx = activeCtx.revertToPreviousContext();\n    }\n\n    // apply property-scoped context after reverting term-scoped context\n    const propertyScopedCtx = _getContextValue(inputCtx, activeProperty, '@context');\n    if (!_isUndefined(propertyScopedCtx)) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx: propertyScopedCtx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n    if (options.link && '@id' in element) {\n      // store linked element\n      if (!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n      options.link[element['@id']].push({\n        expanded: element,\n        compacted: rval\n      });\n    }\n\n    // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n    let types = element['@type'] || [];\n    if (types.length > 1) {\n      types = Array.from(types).sort();\n    }\n    // find all type-scoped contexts based on current context, prior to\n    // updating it\n    const typeContext = activeCtx;\n    for (const type of types) {\n      const compactedType = api.compactIri({\n        activeCtx: typeContext,\n        iri: type,\n        relativeTo: {\n          vocab: true\n        }\n      });\n\n      // Use any type-scoped context defined on this value\n      const ctx = _getContextValue(inputCtx, compactedType, '@context');\n      if (!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          options,\n          propagate: false\n        });\n      }\n    }\n\n    // process element keys in order\n    const keys = Object.keys(element).sort();\n    for (const expandedProperty of keys) {\n      const expandedValue = element[expandedProperty];\n\n      // compact @id\n      if (expandedProperty === '@id') {\n        let compactedValue = _asArray(expandedValue).map(expandedIri => api.compactIri({\n          activeCtx,\n          iri: expandedIri,\n          relativeTo: {\n            vocab: false\n          }\n        }));\n        if (compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: '@id',\n          relativeTo: {\n            vocab: true\n          }\n        });\n        rval[alias] = compactedValue;\n        continue;\n      }\n\n      // compact @type(s)\n      if (expandedProperty === '@type') {\n        // resolve type values against previous context\n        let compactedValue = _asArray(expandedValue).map(expandedIri => api.compactIri({\n          activeCtx: inputCtx,\n          iri: expandedIri,\n          relativeTo: {\n            vocab: true\n          }\n        }));\n        if (compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: '@type',\n          relativeTo: {\n            vocab: true\n          }\n        });\n        const container = _getContextValue(activeCtx, alias, '@container') || [];\n\n        // treat as array for @type if @container includes @set\n        const typeAsSet = container.includes('@set') && _processingMode(activeCtx, 1.1);\n        const isArray = typeAsSet || _isArray(compactedValue) && expandedValue.length === 0;\n        _addValue(rval, alias, compactedValue, {\n          propertyIsArray: isArray\n        });\n        continue;\n      }\n\n      // handle @reverse\n      if (expandedProperty === '@reverse') {\n        // recursively compact expanded value\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty: '@reverse',\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        // handle double-reversed properties\n        for (const compactedProperty in compactedValue) {\n          if (activeCtx.mappings.has(compactedProperty) && activeCtx.mappings.get(compactedProperty).reverse) {\n            const value = compactedValue[compactedProperty];\n            const container = _getContextValue(activeCtx, compactedProperty, '@container') || [];\n            const useArray = container.includes('@set') || !options.compactArrays;\n            _addValue(rval, compactedProperty, value, {\n              propertyIsArray: useArray\n            });\n            delete compactedValue[compactedProperty];\n          }\n        }\n        if (Object.keys(compactedValue).length > 0) {\n          // use keyword alias and add value\n          const alias = api.compactIri({\n            activeCtx,\n            iri: expandedProperty,\n            relativeTo: {\n              vocab: true\n            }\n          });\n          _addValue(rval, alias, compactedValue);\n        }\n        continue;\n      }\n      if (expandedProperty === '@preserve') {\n        // compact using activeProperty\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty,\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n        if (!(_isArray(compactedValue) && compactedValue.length === 0)) {\n          _addValue(rval, expandedProperty, compactedValue);\n        }\n        continue;\n      }\n\n      // handle @index property\n      if (expandedProperty === '@index') {\n        // drop @index if inside an @index container\n        const container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n        if (container.includes('@index')) {\n          continue;\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {\n            vocab: true\n          }\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // skip array processing for keywords that aren't @graph or @list\n      if (expandedProperty !== '@graph' && expandedProperty !== '@list' && _isKeyword(expandedProperty)) {\n        // use keyword alias and add value as is\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {\n            vocab: true\n          }\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // Note: expanded value must be an array due to expansion algorithm.\n      if (!_isArray(expandedValue)) {\n        throw new JsonLdError('JSON-LD expansion error; expanded value must be an array.', 'jsonld.SyntaxError');\n      }\n\n      // preserve empty arrays\n      if (expandedValue.length === 0) {\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedValue,\n          relativeTo: {\n            vocab: true\n          },\n          reverse: insideReverse\n        });\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if (nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if (!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n        _addValue(nestResult, itemActiveProperty, expandedValue, {\n          propertyIsArray: true\n        });\n      }\n\n      // recusively process array values\n      for (const expandedItem of expandedValue) {\n        // compact property and get container type\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedItem,\n          relativeTo: {\n            vocab: true\n          },\n          reverse: insideReverse\n        });\n\n        // if itemActiveProperty is a @nest property, add values to nestResult,\n        // otherwise rval\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if (nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if (!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n        const container = _getContextValue(activeCtx, itemActiveProperty, '@container') || [];\n\n        // get simple @graph or @list value if appropriate\n        const isGraph = _isGraph(expandedItem);\n        const isList = _isList(expandedItem);\n        let inner;\n        if (isList) {\n          inner = expandedItem['@list'];\n        } else if (isGraph) {\n          inner = expandedItem['@graph'];\n        }\n\n        // recursively compact expanded item\n        let compactedItem = await api.compact({\n          activeCtx,\n          activeProperty: itemActiveProperty,\n          element: isList || isGraph ? inner : expandedItem,\n          options,\n          compactionMap\n        });\n\n        // handle @list\n        if (isList) {\n          // ensure @list value is an array\n          if (!_isArray(compactedItem)) {\n            compactedItem = [compactedItem];\n          }\n          if (!container.includes('@list')) {\n            // wrap using @list alias\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@list',\n                relativeTo: {\n                  vocab: true\n                }\n              })]: compactedItem\n            };\n\n            // include @index from expanded @list, if any\n            if ('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {\n                  vocab: true\n                }\n              })] = expandedItem['@index'];\n            }\n          } else {\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              valueIsArray: true,\n              allowDuplicate: true\n            });\n            continue;\n          }\n        }\n\n        // Graph object compaction cases\n        if (isGraph) {\n          if (container.includes('@graph') && (container.includes('@id') || container.includes('@index') && _isSimpleGraph(expandedItem))) {\n            // get or create the map object\n            let mapObject;\n            if (nestResult.hasOwnProperty(itemActiveProperty)) {\n              mapObject = nestResult[itemActiveProperty];\n            } else {\n              nestResult[itemActiveProperty] = mapObject = {};\n            }\n\n            // index on @id or @index or alias of @none\n            const key = (container.includes('@id') ? expandedItem['@id'] : expandedItem['@index']) || api.compactIri({\n              activeCtx,\n              iri: '@none',\n              vocab: true\n            });\n            // add compactedItem to map, using value of `@id` or a new blank\n            // node identifier\n\n            _addValue(mapObject, key, compactedItem, {\n              propertyIsArray: !options.compactArrays || container.includes('@set')\n            });\n          } else if (container.includes('@graph') && _isSimpleGraph(expandedItem)) {\n            // container includes @graph but not @id or @index and value is a\n            // simple graph object add compact value\n            // if compactedItem contains multiple values, it is wrapped in\n            // `@included`\n            if (_isArray(compactedItem) && compactedItem.length > 1) {\n              compactedItem = {\n                '@included': compactedItem\n              };\n            }\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              propertyIsArray: !options.compactArrays || container.includes('@set')\n            });\n          } else {\n            // wrap using @graph alias, remove array if only one item and\n            // compactArrays not set\n            if (_isArray(compactedItem) && compactedItem.length === 1 && options.compactArrays) {\n              compactedItem = compactedItem[0];\n            }\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@graph',\n                relativeTo: {\n                  vocab: true\n                }\n              })]: compactedItem\n            };\n\n            // include @id from expanded graph, if any\n            if ('@id' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@id',\n                relativeTo: {\n                  vocab: true\n                }\n              })] = expandedItem['@id'];\n            }\n\n            // include @index from expanded graph, if any\n            if ('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {\n                  vocab: true\n                }\n              })] = expandedItem['@index'];\n            }\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              propertyIsArray: !options.compactArrays || container.includes('@set')\n            });\n          }\n        } else if (container.includes('@language') || container.includes('@index') || container.includes('@id') || container.includes('@type')) {\n          // handle language and index maps\n          // get or create the map object\n          let mapObject;\n          if (nestResult.hasOwnProperty(itemActiveProperty)) {\n            mapObject = nestResult[itemActiveProperty];\n          } else {\n            nestResult[itemActiveProperty] = mapObject = {};\n          }\n          let key;\n          if (container.includes('@language')) {\n            // if container is a language map, simplify compacted value to\n            // a simple string\n            if (_isValue(compactedItem)) {\n              compactedItem = compactedItem['@value'];\n            }\n            key = expandedItem['@language'];\n          } else if (container.includes('@index')) {\n            const indexKey = _getContextValue(activeCtx, itemActiveProperty, '@index') || '@index';\n            const containerKey = api.compactIri({\n              activeCtx,\n              iri: indexKey,\n              vocab: true\n            });\n            if (indexKey === '@index') {\n              key = expandedItem['@index'];\n              delete compactedItem[containerKey];\n            } else {\n              let others;\n              [key, ...others] = _asArray(compactedItem[indexKey] || []);\n              if (!_isString(key)) {\n                // Will use @none if it isn't a string.\n                key = null;\n              } else {\n                switch (others.length) {\n                  case 0:\n                    delete compactedItem[indexKey];\n                    break;\n                  case 1:\n                    compactedItem[indexKey] = others[0];\n                    break;\n                  default:\n                    compactedItem[indexKey] = others;\n                    break;\n                }\n              }\n            }\n          } else if (container.includes('@id')) {\n            const idKey = api.compactIri({\n              activeCtx,\n              iri: '@id',\n              vocab: true\n            });\n            key = compactedItem[idKey];\n            delete compactedItem[idKey];\n          } else if (container.includes('@type')) {\n            const typeKey = api.compactIri({\n              activeCtx,\n              iri: '@type',\n              vocab: true\n            });\n            let types;\n            [key, ...types] = _asArray(compactedItem[typeKey] || []);\n            switch (types.length) {\n              case 0:\n                delete compactedItem[typeKey];\n                break;\n              case 1:\n                compactedItem[typeKey] = types[0];\n                break;\n              default:\n                compactedItem[typeKey] = types;\n                break;\n            }\n\n            // If compactedItem contains a single entry\n            // whose key maps to @id, recompact without @type\n            if (Object.keys(compactedItem).length === 1 && '@id' in expandedItem) {\n              compactedItem = await api.compact({\n                activeCtx,\n                activeProperty: itemActiveProperty,\n                element: {\n                  '@id': expandedItem['@id']\n                },\n                options,\n                compactionMap\n              });\n            }\n          }\n\n          // if compacting this value which has no key, index on @none\n          if (!key) {\n            key = api.compactIri({\n              activeCtx,\n              iri: '@none',\n              vocab: true\n            });\n          }\n          // add compact value to map object using key from expanded value\n          // based on the container type\n          _addValue(mapObject, key, compactedItem, {\n            propertyIsArray: container.includes('@set')\n          });\n        } else {\n          // use an array if: compactArrays flag is false,\n          // @container is @set or @list , value is an empty\n          // array, or key is @graph\n          const isArray = !options.compactArrays || container.includes('@set') || container.includes('@list') || _isArray(compactedItem) && compactedItem.length === 0 || expandedProperty === '@list' || expandedProperty === '@graph';\n\n          // add compact value\n          _addValue(nestResult, itemActiveProperty, compactedItem, {\n            propertyIsArray: isArray\n          });\n        }\n      }\n    }\n    return rval;\n  }\n\n  // only primitives remain which are already compact\n  return element;\n};\n\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\napi.compactIri = ({\n  activeCtx,\n  iri,\n  value = null,\n  relativeTo = {\n    vocab: false\n  },\n  reverse = false\n}) => {\n  // can't compact null\n  if (iri === null) {\n    return iri;\n  }\n\n  // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n  if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n  const inverseCtx = activeCtx.getInverse();\n\n  // if term is a keyword, it may be compacted to a simple alias\n  if (_isKeyword(iri) && iri in inverseCtx && '@none' in inverseCtx[iri] && '@type' in inverseCtx[iri]['@none'] && '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  }\n\n  // use inverse context to pick a term if iri is relative to vocab\n  if (relativeTo.vocab && iri in inverseCtx) {\n    const defaultLanguage = activeCtx['@language'] || '@none';\n\n    // prefer @index if available in value\n    const containers = [];\n    if (_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    }\n\n    // if value is a preserve object, use its value\n    if (_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    }\n\n    // prefer most specific container including @graph, prefering @set\n    // variations\n    if (_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if ('@index' in value) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // favor idmap if the graph is has an @id\n      if ('@id' in value) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n      containers.push('@graph', '@graph@set', '@set');\n      // allow indexmap if the graph is not indexed\n      if (!('@index' in value)) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // allow idmap if the graph does not have an @id\n      if (!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if (_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    }\n\n    // defaults for term selection based on type/language\n    let typeOrLanguage = '@language';\n    let typeOrLanguageValue = '@null';\n    if (reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if (_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if (!('@index' in value)) {\n        containers.push('@list');\n      }\n      const list = value['@list'];\n      if (list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        let commonLanguage = list.length === 0 ? defaultLanguage : null;\n        let commonType = null;\n        for (let i = 0; i < list.length; ++i) {\n          const item = list[i];\n          let itemLanguage = '@none';\n          let itemType = '@none';\n          if (_isValue(item)) {\n            if ('@language' in item) {\n              itemLanguage = item['@language'];\n            } else if ('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n          if (commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if (itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n          if (commonType === null) {\n            commonType = itemType;\n          } else if (itemType !== commonType) {\n            commonType = '@none';\n          }\n          // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n          if (commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n        if (commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if (_isValue(value)) {\n        if ('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n        } else if ('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n      containers.push('@set');\n    }\n\n    // do term selection\n    containers.push('@none');\n\n    // an index map can be used to index values using @none, so add as a low\n    // priority\n    if (_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    }\n\n    // values without type or language can use @language map\n    if (_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n    const term = _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n    if (term !== null) {\n      return term;\n    }\n  }\n\n  // no term match, use @vocab if available\n  if (relativeTo.vocab) {\n    if ('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      const vocab = activeCtx['@vocab'];\n      if (iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        const suffix = iri.substr(vocab.length);\n        if (!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  }\n\n  // no term or @vocab match, check for possible CURIEs\n  let choice = null;\n  // TODO: make FastCurieMap a class with a method to do this lookup\n  const partialMatches = [];\n  let iriMap = activeCtx.fastCurieMap;\n  // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n  const maxPartialLength = iri.length - 1;\n  for (let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {\n    iriMap = iriMap[iri[i]];\n    if ('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  }\n  // check partial matches in reverse order to prefer longest ones first\n  for (let i = partialMatches.length - 1; i >= 0; --i) {\n    const entry = partialMatches[i];\n    const terms = entry.terms;\n    for (const term of terms) {\n      // a CURIE is usable if:\n      // 1. it has no mapping, OR\n      // 2. value is null, which means we're not compacting an @value, AND\n      //   the mapping matches the IRI\n      const curie = term + ':' + iri.substr(entry.iri.length);\n      const isUsableCurie = activeCtx.mappings.get(term)._prefix && (!activeCtx.mappings.has(curie) || value === null && activeCtx.mappings.get(curie)['@id'] === iri);\n\n      // select curie if it is shorter or the same length but lexicographically\n      // less than the current choice\n      if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {\n        choice = curie;\n      }\n    }\n  }\n\n  // return chosen curie\n  if (choice !== null) {\n    return choice;\n  }\n\n  // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n  for (const [term, td] of activeCtx.mappings) {\n    if (td && td._prefix && iri.startsWith(term + ':')) {\n      throw new JsonLdError(`Absolute IRI \"${iri}\" confused with prefix \"${term}\".`, 'jsonld.SyntaxError', {\n        code: 'IRI confused with prefix',\n        context: activeCtx\n      });\n    }\n  }\n\n  // compact IRI relative to base\n  if (!relativeTo.vocab) {\n    return _removeBase(activeCtx['@base'], iri);\n  }\n\n  // return IRI as is\n  return iri;\n};\n\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\napi.compactValue = ({\n  activeCtx,\n  activeProperty,\n  value,\n  options\n}) => {\n  // value is a @value\n  if (_isValue(value)) {\n    // get context rules\n    const type = _getContextValue(activeCtx, activeProperty, '@type');\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    const container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n    // whether or not the value has an @index that must be preserved\n    const preserveIndex = '@index' in value && !container.includes('@index');\n\n    // if there's no @index to preserve ...\n    if (!preserveIndex && type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if (value['@type'] === type || value['@language'] === language) {\n        return value['@value'];\n      }\n    }\n\n    // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n    const keyCount = Object.keys(value).length;\n    const isValueOnlyKey = keyCount === 1 || keyCount === 2 && '@index' in value && !preserveIndex;\n    const hasDefaultLanguage = '@language' in activeCtx;\n    const isValueString = _isString(value['@value']);\n    const hasNullMapping = activeCtx.mappings.has(activeProperty) && activeCtx.mappings.get(activeProperty)['@language'] === null;\n    if (isValueOnlyKey && type !== '@none' && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n    const rval = {};\n\n    // preserve @index\n    if (preserveIndex) {\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@index',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@index'];\n    }\n    if ('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@type',\n        relativeTo: {\n          vocab: true\n        }\n      })] = api.compactIri({\n        activeCtx,\n        iri: value['@type'],\n        relativeTo: {\n          vocab: true\n        }\n      });\n    } else if ('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@language',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@language'];\n    }\n\n    // alias @value\n    rval[api.compactIri({\n      activeCtx,\n      iri: '@value',\n      relativeTo: {\n        vocab: true\n      }\n    })] = value['@value'];\n    return rval;\n  }\n\n  // value is a subject reference\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options);\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n  const compacted = api.compactIri({\n    activeCtx,\n    iri: value['@id'],\n    relativeTo: {\n      vocab: type === '@vocab'\n    }\n  });\n\n  // compact to scalar\n  if (type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n  return {\n    [api.compactIri({\n      activeCtx,\n      iri: '@id',\n      relativeTo: {\n        vocab: true\n      }\n    })]: compacted\n  };\n};\n\n/**\n * Removes the @preserve keywords as the last step of the compaction\n * algorithm when it is running on framed output.\n *\n * @param ctx the active context used to compact the input.\n * @param input the framed, compacted output.\n * @param options the compaction options used.\n *\n * @return the resulting output.\n */\napi.removePreserve = (ctx, input, options) => {\n  // recurse through arrays\n  if (_isArray(input)) {\n    const output = [];\n    for (let i = 0; i < input.length; ++i) {\n      const result = api.removePreserve(ctx, input[i], options);\n      // drop nulls from arrays\n      if (result !== null) {\n        output.push(result);\n      }\n    }\n    input = output;\n  } else if (_isObject(input)) {\n    // remove @preserve\n    if ('@preserve' in input) {\n      if (input['@preserve'] === '@null') {\n        return null;\n      }\n      return input['@preserve'];\n    }\n\n    // skip @values\n    if (_isValue(input)) {\n      return input;\n    }\n\n    // recurse through @lists\n    if (_isList(input)) {\n      input['@list'] = api.removePreserve(ctx, input['@list'], options);\n      return input;\n    }\n\n    // handle in-memory linked nodes\n    const idAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@id',\n      relativeTo: {\n        vocab: true\n      }\n    });\n    if (input.hasOwnProperty(idAlias)) {\n      const id = input[idAlias];\n      if (options.link.hasOwnProperty(id)) {\n        const idx = options.link[id].indexOf(input);\n        if (idx !== -1) {\n          // already visited\n          return options.link[id][idx];\n        }\n        // prevent circular visitation\n        options.link[id].push(input);\n      } else {\n        // prevent circular visitation\n        options.link[id] = [input];\n      }\n    }\n\n    // recurse through properties\n    const graphAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@graph',\n      relativeTo: {\n        vocab: true\n      }\n    });\n    for (const prop in input) {\n      // potentially remove the id, if it is an unreference bnode\n      if (prop === idAlias && options.bnodesToClear.includes(input[prop])) {\n        delete input[idAlias];\n        continue;\n      }\n      let result = api.removePreserve(ctx, input[prop], options);\n      const container = _getContextValue(ctx, prop, '@container') || [];\n      if (options.compactArrays && _isArray(result) && result.length === 1 && container.length === 0 && prop !== graphAlias) {\n        result = result[0];\n      }\n      input[prop] = result;\n    }\n  }\n  return input;\n};\n\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\nfunction _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if (typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  }\n\n  // preferences for the value of @type or @language\n  const prefs = [];\n\n  // determine prefs for @id based on whether or not value compacts to a term\n  if ((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') && _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if (typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    }\n    // try to compact value to a term\n    const term = api.compactIri({\n      activeCtx,\n      iri: value['@id'],\n      relativeTo: {\n        vocab: true\n      }\n    });\n    if (activeCtx.mappings.has(term) && activeCtx.mappings.get(term) && activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n  }\n  prefs.push('@none');\n  const containerMap = activeCtx.inverse[iri];\n  for (const container of containers) {\n    // if container not available in the map, continue\n    if (!(container in containerMap)) {\n      continue;\n    }\n    const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n    for (const pref of prefs) {\n      // if type/language option not available in the map, continue\n      if (!(pref in typeOrLanguageValueMap)) {\n        continue;\n      }\n\n      // select term\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n  return null;\n}\n\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if (_expandIri(activeCtx, nestProperty, {\n    vocab: true\n  }, options) !== '@nest') {\n    throw new JsonLdError('JSON-LD compact error; nested property must have an @nest value ' + 'resolving to @nest.', 'jsonld.SyntaxError', {\n      code: 'invalid @nest value'\n    });\n  }\n}","map":{"version":3,"names":["JsonLdError","require","isArray","_isArray","isObject","_isObject","isString","_isString","isUndefined","_isUndefined","isList","_isList","isValue","_isValue","isGraph","_isGraph","isSimpleGraph","_isSimpleGraph","isSubjectReference","_isSubjectReference","expandIri","_expandIri","getContextValue","_getContextValue","isKeyword","_isKeyword","process","_processContext","processingMode","_processingMode","removeBase","_removeBase","addValue","_addValue","asArray","_asArray","compareShortestLeast","_compareShortestLeast","api","module","exports","compact","activeCtx","activeProperty","element","options","compactionMap","undefined","rval","i","length","compacted","unmappedValue","parent","index","push","compactArrays","container","ctx","localCtx","propagate","overrideProtected","link","hasOwnProperty","linked","expanded","compactValue","value","includes","insideReverse","inputCtx","revertToPreviousContext","propertyScopedCtx","types","Array","from","sort","typeContext","type","compactedType","compactIri","iri","relativeTo","vocab","keys","Object","expandedProperty","expandedValue","compactedValue","map","expandedIri","alias","typeAsSet","propertyIsArray","compactedProperty","mappings","has","get","reverse","useArray","itemActiveProperty","nestProperty","nestResult","_checkNestProperty","expandedItem","inner","compactedItem","valueIsArray","allowDuplicate","mapObject","key","indexKey","containerKey","others","idKey","typeKey","isPropertyTermScoped","previousContext","inverseCtx","getInverse","defaultLanguage","containers","typeOrLanguage","typeOrLanguageValue","list","commonLanguage","commonType","item","itemLanguage","itemType","term","_selectTerm","indexOf","suffix","substr","choice","partialMatches","iriMap","fastCurieMap","maxPartialLength","entry","terms","curie","isUsableCurie","_prefix","td","startsWith","code","context","language","preserveIndex","keyCount","isValueOnlyKey","hasDefaultLanguage","isValueString","hasNullMapping","removePreserve","input","output","result","idAlias","id","idx","graphAlias","prop","bnodesToClear","prefs","apply","containerMap","inverse","typeOrLanguageValueMap","pref"],"sources":["/home/saharsh/digital-twins-explorer/client/node_modules/jsonld/lib/compact.js"],"sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSimpleGraph: _isSimpleGraph,\n  isSubjectReference: _isSubjectReference\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  removeBase: _removeBase\n} = require('./url');\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = require('./util');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return a promise that resolves to the compacted value.\n */\napi.compact = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  compactionMap = () => undefined\n}) => {\n  // recursively compact array\n  if(_isArray(element)) {\n    let rval = [];\n    for(let i = 0; i < element.length; ++i) {\n      // compact, dropping any null values unless custom mapped\n      let compacted = await api.compact({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        compactionMap\n      });\n      if(compacted === null) {\n        compacted = await compactionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options\n        });\n        if(compacted === undefined) {\n          continue;\n        }\n      }\n      rval.push(compacted);\n    }\n    if(options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.length === 0) {\n        rval = rval[0];\n      }\n    }\n    return rval;\n  }\n\n  // use any scoped context on activeProperty\n  const ctx = _getContextValue(activeCtx, activeProperty, '@context');\n  if(!_isUndefined(ctx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: ctx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // recursively compact object\n  if(_isObject(element)) {\n    if(options.link && '@id' in element &&\n      options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      const linked = options.link[element['@id']];\n      for(let i = 0; i < linked.length; ++i) {\n        if(linked[i].expanded === element) {\n          return linked[i].compacted;\n        }\n      }\n    }\n\n    // do value compaction on @values and subject references\n    if(_isValue(element) || _isSubjectReference(element)) {\n      const rval =\n        api.compactValue({activeCtx, activeProperty, value: element, options});\n      if(options.link && _isSubjectReference(element)) {\n        // store linked element\n        if(!(options.link.hasOwnProperty(element['@id']))) {\n          options.link[element['@id']] = [];\n        }\n        options.link[element['@id']].push({expanded: element, compacted: rval});\n      }\n      return rval;\n    }\n\n    // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n    if(_isList(element)) {\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.includes('@list')) {\n        return api.compact({\n          activeCtx,\n          activeProperty,\n          element: element['@list'],\n          options,\n          compactionMap\n        });\n      }\n    }\n\n    // FIXME: avoid misuse of active property as an expanded property?\n    const insideReverse = (activeProperty === '@reverse');\n\n    const rval = {};\n\n    // original context before applying property-scoped and local contexts\n    const inputCtx = activeCtx;\n\n    // revert to previous context, if there is one,\n    // and element is not a value object or a node reference\n    if(!_isValue(element) && !_isSubjectReference(element)) {\n      activeCtx = activeCtx.revertToPreviousContext();\n    }\n\n    // apply property-scoped context after reverting term-scoped context\n    const propertyScopedCtx =\n      _getContextValue(inputCtx, activeProperty, '@context');\n    if(!_isUndefined(propertyScopedCtx)) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx: propertyScopedCtx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    if(options.link && '@id' in element) {\n      // store linked element\n      if(!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n      options.link[element['@id']].push({expanded: element, compacted: rval});\n    }\n\n    // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n    let types = element['@type'] || [];\n    if(types.length > 1) {\n      types = Array.from(types).sort();\n    }\n    // find all type-scoped contexts based on current context, prior to\n    // updating it\n    const typeContext = activeCtx;\n    for(const type of types) {\n      const compactedType = api.compactIri(\n        {activeCtx: typeContext, iri: type, relativeTo: {vocab: true}});\n\n      // Use any type-scoped context defined on this value\n      const ctx = _getContextValue(inputCtx, compactedType, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          options,\n          propagate: false\n        });\n      }\n    }\n\n    // process element keys in order\n    const keys = Object.keys(element).sort();\n    for(const expandedProperty of keys) {\n      const expandedValue = element[expandedProperty];\n\n      // compact @id\n      if(expandedProperty === '@id') {\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: false}\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@id', relativeTo: {vocab: true}});\n\n        rval[alias] = compactedValue;\n        continue;\n      }\n\n      // compact @type(s)\n      if(expandedProperty === '@type') {\n        // resolve type values against previous context\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx: inputCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: true}\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@type', relativeTo: {vocab: true}});\n        const container = _getContextValue(\n          activeCtx, alias, '@container') || [];\n\n        // treat as array for @type if @container includes @set\n        const typeAsSet =\n          container.includes('@set') &&\n          _processingMode(activeCtx, 1.1);\n        const isArray =\n          typeAsSet || (_isArray(compactedValue) && expandedValue.length === 0);\n        _addValue(rval, alias, compactedValue, {propertyIsArray: isArray});\n        continue;\n      }\n\n      // handle @reverse\n      if(expandedProperty === '@reverse') {\n        // recursively compact expanded value\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty: '@reverse',\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        // handle double-reversed properties\n        for(const compactedProperty in compactedValue) {\n          if(activeCtx.mappings.has(compactedProperty) &&\n            activeCtx.mappings.get(compactedProperty).reverse) {\n            const value = compactedValue[compactedProperty];\n            const container = _getContextValue(\n              activeCtx, compactedProperty, '@container') || [];\n            const useArray = (\n              container.includes('@set') || !options.compactArrays);\n            _addValue(\n              rval, compactedProperty, value, {propertyIsArray: useArray});\n            delete compactedValue[compactedProperty];\n          }\n        }\n\n        if(Object.keys(compactedValue).length > 0) {\n          // use keyword alias and add value\n          const alias = api.compactIri({\n            activeCtx,\n            iri: expandedProperty,\n            relativeTo: {vocab: true}\n          });\n          _addValue(rval, alias, compactedValue);\n        }\n\n        continue;\n      }\n\n      if(expandedProperty === '@preserve') {\n        // compact using activeProperty\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty,\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        if(!(_isArray(compactedValue) && compactedValue.length === 0)) {\n          _addValue(rval, expandedProperty, compactedValue);\n        }\n        continue;\n      }\n\n      // handle @index property\n      if(expandedProperty === '@index') {\n        // drop @index if inside an @index container\n        const container = _getContextValue(\n          activeCtx, activeProperty, '@container') || [];\n        if(container.includes('@index')) {\n          continue;\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // skip array processing for keywords that aren't @graph or @list\n      if(expandedProperty !== '@graph' && expandedProperty !== '@list' &&\n        _isKeyword(expandedProperty)) {\n        // use keyword alias and add value as is\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // Note: expanded value must be an array due to expansion algorithm.\n      if(!_isArray(expandedValue)) {\n        throw new JsonLdError(\n          'JSON-LD expansion error; expanded value must be an array.',\n          'jsonld.SyntaxError');\n      }\n\n      // preserve empty arrays\n      if(expandedValue.length === 0) {\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedValue,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n        _addValue(\n          nestResult, itemActiveProperty, expandedValue, {\n            propertyIsArray: true\n          });\n      }\n\n      // recusively process array values\n      for(const expandedItem of expandedValue) {\n        // compact property and get container type\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedItem,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n\n        // if itemActiveProperty is a @nest property, add values to nestResult,\n        // otherwise rval\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n\n        const container = _getContextValue(\n          activeCtx, itemActiveProperty, '@container') || [];\n\n        // get simple @graph or @list value if appropriate\n        const isGraph = _isGraph(expandedItem);\n        const isList = _isList(expandedItem);\n        let inner;\n        if(isList) {\n          inner = expandedItem['@list'];\n        } else if(isGraph) {\n          inner = expandedItem['@graph'];\n        }\n\n        // recursively compact expanded item\n        let compactedItem = await api.compact({\n          activeCtx,\n          activeProperty: itemActiveProperty,\n          element: (isList || isGraph) ? inner : expandedItem,\n          options,\n          compactionMap\n        });\n\n        // handle @list\n        if(isList) {\n          // ensure @list value is an array\n          if(!_isArray(compactedItem)) {\n            compactedItem = [compactedItem];\n          }\n\n          if(!container.includes('@list')) {\n            // wrap using @list alias\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@list',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @index from expanded @list, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n          } else {\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              valueIsArray: true,\n              allowDuplicate: true\n            });\n            continue;\n          }\n        }\n\n        // Graph object compaction cases\n        if(isGraph) {\n          if(container.includes('@graph') && (container.includes('@id') ||\n            container.includes('@index') && _isSimpleGraph(expandedItem))) {\n            // get or create the map object\n            let mapObject;\n            if(nestResult.hasOwnProperty(itemActiveProperty)) {\n              mapObject = nestResult[itemActiveProperty];\n            } else {\n              nestResult[itemActiveProperty] = mapObject = {};\n            }\n\n            // index on @id or @index or alias of @none\n            const key = (container.includes('@id') ?\n              expandedItem['@id'] : expandedItem['@index']) ||\n              api.compactIri({activeCtx, iri: '@none', vocab: true});\n            // add compactedItem to map, using value of `@id` or a new blank\n            // node identifier\n\n            _addValue(\n              mapObject, key, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else if(container.includes('@graph') &&\n            _isSimpleGraph(expandedItem)) {\n            // container includes @graph but not @id or @index and value is a\n            // simple graph object add compact value\n            // if compactedItem contains multiple values, it is wrapped in\n            // `@included`\n            if(_isArray(compactedItem) && compactedItem.length > 1) {\n              compactedItem = {'@included': compactedItem};\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else {\n            // wrap using @graph alias, remove array if only one item and\n            // compactArrays not set\n            if(_isArray(compactedItem) && compactedItem.length === 1 &&\n              options.compactArrays) {\n              compactedItem = compactedItem[0];\n            }\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@graph',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @id from expanded graph, if any\n            if('@id' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@id',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@id'];\n            }\n\n            // include @index from expanded graph, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          }\n        } else if(container.includes('@language') ||\n          container.includes('@index') || container.includes('@id') ||\n          container.includes('@type')) {\n          // handle language and index maps\n          // get or create the map object\n          let mapObject;\n          if(nestResult.hasOwnProperty(itemActiveProperty)) {\n            mapObject = nestResult[itemActiveProperty];\n          } else {\n            nestResult[itemActiveProperty] = mapObject = {};\n          }\n\n          let key;\n          if(container.includes('@language')) {\n          // if container is a language map, simplify compacted value to\n          // a simple string\n            if(_isValue(compactedItem)) {\n              compactedItem = compactedItem['@value'];\n            }\n            key = expandedItem['@language'];\n          } else if(container.includes('@index')) {\n            const indexKey = _getContextValue(\n              activeCtx, itemActiveProperty, '@index') || '@index';\n            const containerKey = api.compactIri(\n              {activeCtx, iri: indexKey, vocab: true});\n            if(indexKey === '@index') {\n              key = expandedItem['@index'];\n              delete compactedItem[containerKey];\n            } else {\n              let others;\n              [key, ...others] = _asArray(compactedItem[indexKey] || []);\n              if(!_isString(key)) {\n                // Will use @none if it isn't a string.\n                key = null;\n              } else {\n                switch(others.length) {\n                  case 0:\n                    delete compactedItem[indexKey];\n                    break;\n                  case 1:\n                    compactedItem[indexKey] = others[0];\n                    break;\n                  default:\n                    compactedItem[indexKey] = others;\n                    break;\n                }\n              }\n            }\n          } else if(container.includes('@id')) {\n            const idKey = api.compactIri({activeCtx, iri: '@id', vocab: true});\n            key = compactedItem[idKey];\n            delete compactedItem[idKey];\n          } else if(container.includes('@type')) {\n            const typeKey = api.compactIri({\n              activeCtx,\n              iri: '@type',\n              vocab: true\n            });\n            let types;\n            [key, ...types] = _asArray(compactedItem[typeKey] || []);\n            switch(types.length) {\n              case 0:\n                delete compactedItem[typeKey];\n                break;\n              case 1:\n                compactedItem[typeKey] = types[0];\n                break;\n              default:\n                compactedItem[typeKey] = types;\n                break;\n            }\n\n            // If compactedItem contains a single entry\n            // whose key maps to @id, recompact without @type\n            if(Object.keys(compactedItem).length === 1 &&\n              '@id' in expandedItem) {\n              compactedItem = await api.compact({\n                activeCtx,\n                activeProperty: itemActiveProperty,\n                element: {'@id': expandedItem['@id']},\n                options,\n                compactionMap\n              });\n            }\n          }\n\n          // if compacting this value which has no key, index on @none\n          if(!key) {\n            key = api.compactIri({activeCtx, iri: '@none', vocab: true});\n          }\n          // add compact value to map object using key from expanded value\n          // based on the container type\n          _addValue(\n            mapObject, key, compactedItem, {\n              propertyIsArray: container.includes('@set')\n            });\n        } else {\n          // use an array if: compactArrays flag is false,\n          // @container is @set or @list , value is an empty\n          // array, or key is @graph\n          const isArray = (!options.compactArrays ||\n            container.includes('@set') || container.includes('@list') ||\n            (_isArray(compactedItem) && compactedItem.length === 0) ||\n            expandedProperty === '@list' || expandedProperty === '@graph');\n\n          // add compact value\n          _addValue(\n            nestResult, itemActiveProperty, compactedItem,\n            {propertyIsArray: isArray});\n        }\n      }\n    }\n\n    return rval;\n  }\n\n  // only primitives remain which are already compact\n  return element;\n};\n\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\napi.compactIri = ({\n  activeCtx,\n  iri,\n  value = null,\n  relativeTo = {vocab: false},\n  reverse = false\n}) => {\n  // can't compact null\n  if(iri === null) {\n    return iri;\n  }\n\n  // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n  if(activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  const inverseCtx = activeCtx.getInverse();\n\n  // if term is a keyword, it may be compacted to a simple alias\n  if(_isKeyword(iri) &&\n    iri in inverseCtx &&\n    '@none' in inverseCtx[iri] &&\n    '@type' in inverseCtx[iri]['@none'] &&\n    '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  }\n\n  // use inverse context to pick a term if iri is relative to vocab\n  if(relativeTo.vocab && iri in inverseCtx) {\n    const defaultLanguage = activeCtx['@language'] || '@none';\n\n    // prefer @index if available in value\n    const containers = [];\n    if(_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    }\n\n    // if value is a preserve object, use its value\n    if(_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    }\n\n    // prefer most specific container including @graph, prefering @set\n    // variations\n    if(_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if('@index' in value) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // favor idmap if the graph is has an @id\n      if('@id' in value) {\n        containers.push(\n          '@graph@id', '@graph@id@set');\n      }\n      containers.push('@graph', '@graph@set', '@set');\n      // allow indexmap if the graph is not indexed\n      if(!('@index' in value)) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // allow idmap if the graph does not have an @id\n      if(!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if(_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    }\n\n    // defaults for term selection based on type/language\n    let typeOrLanguage = '@language';\n    let typeOrLanguageValue = '@null';\n\n    if(reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if(_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if(!('@index' in value)) {\n        containers.push('@list');\n      }\n      const list = value['@list'];\n      if(list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        let commonLanguage = (list.length === 0) ? defaultLanguage : null;\n        let commonType = null;\n        for(let i = 0; i < list.length; ++i) {\n          const item = list[i];\n          let itemLanguage = '@none';\n          let itemType = '@none';\n          if(_isValue(item)) {\n            if('@language' in item) {\n              itemLanguage = item['@language'];\n            } else if('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n          if(commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if(itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n          if(commonType === null) {\n            commonType = itemType;\n          } else if(itemType !== commonType) {\n            commonType = '@none';\n          }\n          // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n          if(commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n        if(commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if(_isValue(value)) {\n        if('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n        } else if('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n      containers.push('@set');\n    }\n\n    // do term selection\n    containers.push('@none');\n\n    // an index map can be used to index values using @none, so add as a low\n    // priority\n    if(_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    }\n\n    // values without type or language can use @language map\n    if(_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    const term = _selectTerm(\n      activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n    if(term !== null) {\n      return term;\n    }\n  }\n\n  // no term match, use @vocab if available\n  if(relativeTo.vocab) {\n    if('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      const vocab = activeCtx['@vocab'];\n      if(iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        const suffix = iri.substr(vocab.length);\n        if(!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  }\n\n  // no term or @vocab match, check for possible CURIEs\n  let choice = null;\n  // TODO: make FastCurieMap a class with a method to do this lookup\n  const partialMatches = [];\n  let iriMap = activeCtx.fastCurieMap;\n  // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n  const maxPartialLength = iri.length - 1;\n  for(let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {\n    iriMap = iriMap[iri[i]];\n    if('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  }\n  // check partial matches in reverse order to prefer longest ones first\n  for(let i = partialMatches.length - 1; i >= 0; --i) {\n    const entry = partialMatches[i];\n    const terms = entry.terms;\n    for(const term of terms) {\n      // a CURIE is usable if:\n      // 1. it has no mapping, OR\n      // 2. value is null, which means we're not compacting an @value, AND\n      //   the mapping matches the IRI\n      const curie = term + ':' + iri.substr(entry.iri.length);\n      const isUsableCurie = (activeCtx.mappings.get(term)._prefix &&\n        (!activeCtx.mappings.has(curie) ||\n        (value === null && activeCtx.mappings.get(curie)['@id'] === iri)));\n\n      // select curie if it is shorter or the same length but lexicographically\n      // less than the current choice\n      if(isUsableCurie && (choice === null ||\n        _compareShortestLeast(curie, choice) < 0)) {\n        choice = curie;\n      }\n    }\n  }\n\n  // return chosen curie\n  if(choice !== null) {\n    return choice;\n  }\n\n  // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n  for(const [term, td] of activeCtx.mappings) {\n    if(td && td._prefix && iri.startsWith(term + ':')) {\n      throw new JsonLdError(\n        `Absolute IRI \"${iri}\" confused with prefix \"${term}\".`,\n        'jsonld.SyntaxError',\n        {code: 'IRI confused with prefix', context: activeCtx});\n    }\n  }\n\n  // compact IRI relative to base\n  if(!relativeTo.vocab) {\n    return _removeBase(activeCtx['@base'], iri);\n  }\n\n  // return IRI as is\n  return iri;\n};\n\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\napi.compactValue = ({activeCtx, activeProperty, value, options}) => {\n  // value is a @value\n  if(_isValue(value)) {\n    // get context rules\n    const type = _getContextValue(activeCtx, activeProperty, '@type');\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    const container =\n      _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n    // whether or not the value has an @index that must be preserved\n    const preserveIndex = '@index' in value && !container.includes('@index');\n\n    // if there's no @index to preserve ...\n    if(!preserveIndex && type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if(value['@type'] === type || value['@language'] === language) {\n        return value['@value'];\n      }\n    }\n\n    // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n    const keyCount = Object.keys(value).length;\n    const isValueOnlyKey = (keyCount === 1 ||\n      (keyCount === 2 && '@index' in value && !preserveIndex));\n    const hasDefaultLanguage = ('@language' in activeCtx);\n    const isValueString = _isString(value['@value']);\n    const hasNullMapping = (activeCtx.mappings.has(activeProperty) &&\n      activeCtx.mappings.get(activeProperty)['@language'] === null);\n    if(isValueOnlyKey &&\n      type !== '@none' &&\n      (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    const rval = {};\n\n    // preserve @index\n    if(preserveIndex) {\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@index',\n        relativeTo: {vocab: true}\n      })] = value['@index'];\n    }\n\n    if('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@type',\n        relativeTo: {vocab: true}\n      })] = api.compactIri(\n        {activeCtx, iri: value['@type'], relativeTo: {vocab: true}});\n    } else if('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@language',\n        relativeTo: {vocab: true}\n      })] = value['@language'];\n    }\n\n    // alias @value\n    rval[api.compactIri({\n      activeCtx,\n      iri: '@value',\n      relativeTo: {vocab: true}\n    })] = value['@value'];\n\n    return rval;\n  }\n\n  // value is a subject reference\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {vocab: true},\n    options);\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n  const compacted = api.compactIri(\n    {activeCtx, iri: value['@id'], relativeTo: {vocab: type === '@vocab'}});\n\n  // compact to scalar\n  if(type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return {\n    [api.compactIri({\n      activeCtx,\n      iri: '@id',\n      relativeTo: {vocab: true}\n    })]: compacted\n  };\n};\n\n/**\n * Removes the @preserve keywords as the last step of the compaction\n * algorithm when it is running on framed output.\n *\n * @param ctx the active context used to compact the input.\n * @param input the framed, compacted output.\n * @param options the compaction options used.\n *\n * @return the resulting output.\n */\napi.removePreserve = (ctx, input, options) => {\n  // recurse through arrays\n  if(_isArray(input)) {\n    const output = [];\n    for(let i = 0; i < input.length; ++i) {\n      const result = api.removePreserve(ctx, input[i], options);\n      // drop nulls from arrays\n      if(result !== null) {\n        output.push(result);\n      }\n    }\n    input = output;\n  } else if(_isObject(input)) {\n    // remove @preserve\n    if('@preserve' in input) {\n      if(input['@preserve'] === '@null') {\n        return null;\n      }\n      return input['@preserve'];\n    }\n\n    // skip @values\n    if(_isValue(input)) {\n      return input;\n    }\n\n    // recurse through @lists\n    if(_isList(input)) {\n      input['@list'] = api.removePreserve(ctx, input['@list'], options);\n      return input;\n    }\n\n    // handle in-memory linked nodes\n    const idAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@id',\n      relativeTo: {vocab: true}\n    });\n    if(input.hasOwnProperty(idAlias)) {\n      const id = input[idAlias];\n      if(options.link.hasOwnProperty(id)) {\n        const idx = options.link[id].indexOf(input);\n        if(idx !== -1) {\n          // already visited\n          return options.link[id][idx];\n        }\n        // prevent circular visitation\n        options.link[id].push(input);\n      } else {\n        // prevent circular visitation\n        options.link[id] = [input];\n      }\n    }\n\n    // recurse through properties\n    const graphAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@graph',\n      relativeTo: {vocab: true}\n    });\n    for(const prop in input) {\n      // potentially remove the id, if it is an unreference bnode\n      if(prop === idAlias && options.bnodesToClear.includes(input[prop])) {\n        delete input[idAlias];\n        continue;\n      }\n\n      let result = api.removePreserve(ctx, input[prop], options);\n      const container = _getContextValue(ctx, prop, '@container') || [];\n      if(options.compactArrays && _isArray(result) && result.length === 1 &&\n        container.length === 0 && prop !== graphAlias) {\n        result = result[0];\n      }\n      input[prop] = result;\n    }\n  }\n  return input;\n};\n\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\nfunction _selectTerm(\n  activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if(typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  }\n\n  // preferences for the value of @type or @language\n  const prefs = [];\n\n  // determine prefs for @id based on whether or not value compacts to a term\n  if((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') &&\n    _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if(typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    }\n    // try to compact value to a term\n    const term = api.compactIri(\n      {activeCtx, iri: value['@id'], relativeTo: {vocab: true}});\n    if(activeCtx.mappings.has(term) &&\n      activeCtx.mappings.get(term) &&\n      activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n  }\n  prefs.push('@none');\n\n  const containerMap = activeCtx.inverse[iri];\n  for(const container of containers) {\n    // if container not available in the map, continue\n    if(!(container in containerMap)) {\n      continue;\n    }\n\n    const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n    for(const pref of prefs) {\n      // if type/language option not available in the map, continue\n      if(!(pref in typeOrLanguageValueMap)) {\n        continue;\n      }\n\n      // select term\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if(_expandIri(activeCtx, nestProperty, {vocab: true}, options) !== '@nest') {\n    throw new JsonLdError(\n      'JSON-LD compact error; nested property must have an @nest value ' +\n      'resolving to @nest.',\n      'jsonld.SyntaxError', {code: 'invalid @nest value'});\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}