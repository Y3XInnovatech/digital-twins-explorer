{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { BaseDecorator } from './BaseDecorator';\nimport { findScrollableParent, getRect, getWindow, Async, EventGroup } from '../../Utilities';\nvar RESIZE_DELAY = 500;\nvar MAX_RESIZE_ATTEMPTS = 3;\n/**\n * A decorator to update decorated component on viewport or window resize events.\n *\n * @param ComposedComponent decorated React component reference.\n */\nexport function withViewport(ComposedComponent) {\n  return /** @class */function (_super) {\n    __extends(WithViewportComponent, _super);\n    function WithViewportComponent(props) {\n      var _this = _super.call(this, props) || this;\n      _this._root = React.createRef();\n      _this._registerResizeObserver = function () {\n        var win = getWindow(_this._root.current);\n        _this._viewportResizeObserver = new win.ResizeObserver(_this._onAsyncResize);\n        _this._viewportResizeObserver.observe(_this._root.current);\n      };\n      _this._unregisterResizeObserver = function () {\n        if (_this._viewportResizeObserver) {\n          _this._viewportResizeObserver.disconnect();\n          delete _this._viewportResizeObserver;\n        }\n      };\n      /* Note: using lambda here because decorators don't seem to work in decorators. */\n      _this._updateViewport = function (withForceUpdate) {\n        var viewport = _this.state.viewport;\n        var viewportElement = _this._root.current;\n        var scrollElement = findScrollableParent(viewportElement);\n        var scrollRect = getRect(scrollElement);\n        var clientRect = getRect(viewportElement);\n        var updateComponent = function () {\n          if (withForceUpdate && _this._composedComponentInstance) {\n            _this._composedComponentInstance.forceUpdate();\n          }\n        };\n        var isSizeChanged = (clientRect && clientRect.width) !== viewport.width || (scrollRect && scrollRect.height) !== viewport.height;\n        if (isSizeChanged && _this._resizeAttempts < MAX_RESIZE_ATTEMPTS && clientRect && scrollRect) {\n          _this._resizeAttempts++;\n          _this.setState({\n            viewport: {\n              width: clientRect.width,\n              height: scrollRect.height\n            }\n          }, function () {\n            _this._updateViewport(withForceUpdate);\n          });\n        } else {\n          _this._resizeAttempts = 0;\n          updateComponent();\n        }\n      };\n      _this._async = new Async(_this);\n      _this._events = new EventGroup(_this);\n      _this._resizeAttempts = 0;\n      _this.state = {\n        viewport: {\n          width: 0,\n          height: 0\n        }\n      };\n      return _this;\n    }\n    WithViewportComponent.prototype.componentDidMount = function () {\n      var _a = this.props,\n        skipViewportMeasures = _a.skipViewportMeasures,\n        disableResizeObserver = _a.disableResizeObserver;\n      var win = getWindow(this._root.current);\n      this._onAsyncResize = this._async.debounce(this._onAsyncResize, RESIZE_DELAY, {\n        leading: false\n      });\n      if (!skipViewportMeasures) {\n        if (!disableResizeObserver && this._isResizeObserverAvailable()) {\n          this._registerResizeObserver();\n        } else {\n          this._events.on(win, 'resize', this._onAsyncResize);\n        }\n        this._updateViewport();\n      }\n    };\n    WithViewportComponent.prototype.componentDidUpdate = function (previousProps) {\n      var previousSkipViewportMeasures = previousProps.skipViewportMeasures;\n      var _a = this.props,\n        skipViewportMeasures = _a.skipViewportMeasures,\n        disableResizeObserver = _a.disableResizeObserver;\n      var win = getWindow(this._root.current);\n      if (skipViewportMeasures !== previousSkipViewportMeasures) {\n        if (!skipViewportMeasures) {\n          if (!disableResizeObserver && this._isResizeObserverAvailable()) {\n            if (!this._viewportResizeObserver) {\n              this._registerResizeObserver();\n            }\n          } else {\n            this._events.on(win, 'resize', this._onAsyncResize);\n          }\n          this._updateViewport();\n        } else {\n          this._unregisterResizeObserver();\n          this._events.off(win, 'resize', this._onAsyncResize);\n        }\n      }\n    };\n    WithViewportComponent.prototype.componentWillUnmount = function () {\n      this._events.dispose();\n      this._async.dispose();\n      this._unregisterResizeObserver();\n    };\n    WithViewportComponent.prototype.render = function () {\n      var viewport = this.state.viewport;\n      var newViewport = viewport.width > 0 && viewport.height > 0 ? viewport : undefined;\n      return React.createElement(\"div\", {\n        className: \"ms-Viewport\",\n        ref: this._root,\n        style: {\n          minWidth: 1,\n          minHeight: 1\n        }\n      }, React.createElement(ComposedComponent, __assign({\n        ref: this._updateComposedComponentRef,\n        viewport: newViewport\n      }, this.props)));\n    };\n    WithViewportComponent.prototype.forceUpdate = function () {\n      this._updateViewport(true);\n    };\n    WithViewportComponent.prototype._onAsyncResize = function () {\n      this._updateViewport();\n    };\n    WithViewportComponent.prototype._isResizeObserverAvailable = function () {\n      var win = getWindow(this._root.current);\n      return win && win.ResizeObserver;\n    };\n    return WithViewportComponent;\n  }(BaseDecorator);\n}","map":{"version":3,"sources":["utilities/decorators/withViewport.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { BaseDecorator } from './BaseDecorator';\nimport { findScrollableParent, getRect, getWindow, Async, EventGroup } from '../../Utilities';\n\n/**\n * Viewport rectangle dimensions.\n *\n * {@docCategory DetailsList}\n */\nexport interface IViewport {\n  /**\n   * Width in pixels.\n   */\n  width: number;\n  /**\n   * Height in pixels.\n   */\n  height: number;\n}\n\nexport interface IWithViewportState {\n  viewport?: IViewport;\n}\n\n/**\n * Props interface for the withViewport component.\n *\n * {@docCategory DetailsList}\n */\nexport interface IWithViewportProps {\n  /**\n   * Whether or not `withViewport` should disable its viewport measurements, effectively making this decorator\n   * pass-through with no impact on the rendered component.\n   *\n   * Since `withViewport` measures the `viewport` on mount, after each React update, and in response to events,\n   * it may cause a component which does not currently need this information due to its configuration to re-render\n   * too often. `skipViewportMeasures` may be toggled on and off based on current state, and will suspend and resume\n   * measurement as-needed.\n   *\n   * For example, when this wraps `DetailsList`, set `skipViewportMeasures` to `true` when the `layoutMode` is\n   * `fixedColumns`, since the `DetailsList` does not use the viewport size in any calculations.\n   *\n   * In addition, consider setting `skipViewportMeasures` to `true` when running within a React test renderer, to avoid\n   * direct DOM dependencies.\n   */\n  skipViewportMeasures?: boolean;\n  /**\n   * Whether or not to explicitly disable usage of the `ResizeObserver` in favor of a `'resize'` event on `window`,\n   * even if the browser supports `ResizeObserver`. This may be necessary if use of `ResizeObserver` results in too\n   * many re-renders of the wrapped component due to the frequency at which events are fired.\n   *\n   * This has no impact if `skipViewportMeasures` is `true`, as no viewport measurement strategy is used.\n   */\n  disableResizeObserver?: boolean;\n}\n\nconst RESIZE_DELAY = 500;\nconst MAX_RESIZE_ATTEMPTS = 3;\n\n/**\n * A decorator to update decorated component on viewport or window resize events.\n *\n * @param ComposedComponent decorated React component reference.\n */\nexport function withViewport<TProps extends { viewport?: IViewport }, TState>(\n  ComposedComponent: new (props: TProps, ...args: any[]) => React.Component<TProps, TState>,\n): any {\n  return class WithViewportComponent extends BaseDecorator<TProps, IWithViewportState> {\n    private _root = React.createRef<HTMLDivElement>();\n    private _resizeAttempts: number;\n    private _viewportResizeObserver: any;\n    private _async: Async;\n    private _events: EventGroup;\n\n    constructor(props: TProps) {\n      super(props);\n\n      this._async = new Async(this);\n      this._events = new EventGroup(this);\n      this._resizeAttempts = 0;\n\n      this.state = {\n        viewport: {\n          width: 0,\n          height: 0,\n        },\n      };\n    }\n\n    public componentDidMount(): void {\n      const { skipViewportMeasures, disableResizeObserver } = this.props as IWithViewportProps;\n      const win = getWindow(this._root.current);\n\n      this._onAsyncResize = this._async.debounce(this._onAsyncResize, RESIZE_DELAY, {\n        leading: false,\n      });\n\n      if (!skipViewportMeasures) {\n        if (!disableResizeObserver && this._isResizeObserverAvailable()) {\n          this._registerResizeObserver();\n        } else {\n          this._events.on(win, 'resize', this._onAsyncResize);\n        }\n\n        this._updateViewport();\n      }\n    }\n\n    public componentDidUpdate(previousProps: TProps) {\n      const { skipViewportMeasures: previousSkipViewportMeasures } = previousProps as IWithViewportProps;\n      const { skipViewportMeasures, disableResizeObserver } = this.props as IWithViewportProps;\n      const win = getWindow(this._root.current);\n\n      if (skipViewportMeasures !== previousSkipViewportMeasures) {\n        if (!skipViewportMeasures) {\n          if (!disableResizeObserver && this._isResizeObserverAvailable()) {\n            if (!this._viewportResizeObserver) {\n              this._registerResizeObserver();\n            }\n          } else {\n            this._events.on(win, 'resize', this._onAsyncResize);\n          }\n\n          this._updateViewport();\n        } else {\n          this._unregisterResizeObserver();\n          this._events.off(win, 'resize', this._onAsyncResize);\n        }\n      }\n    }\n\n    public componentWillUnmount(): void {\n      this._events.dispose();\n      this._async.dispose();\n      this._unregisterResizeObserver();\n    }\n\n    public render(): JSX.Element {\n      const { viewport } = this.state;\n      const newViewport = viewport!.width > 0 && viewport!.height > 0 ? viewport : undefined;\n\n      return (\n        <div className=\"ms-Viewport\" ref={this._root} style={{ minWidth: 1, minHeight: 1 }}>\n          <ComposedComponent ref={this._updateComposedComponentRef} viewport={newViewport} {...(this.props as any)} />\n        </div>\n      );\n    }\n\n    public forceUpdate(): void {\n      this._updateViewport(true);\n    }\n\n    private _onAsyncResize(): void {\n      this._updateViewport();\n    }\n\n    private _isResizeObserverAvailable(): boolean {\n      const win = getWindow(this._root.current);\n\n      return win && (win as any).ResizeObserver;\n    }\n\n    private _registerResizeObserver = () => {\n      const win = getWindow(this._root.current);\n\n      this._viewportResizeObserver = new (win as any).ResizeObserver(this._onAsyncResize);\n      this._viewportResizeObserver.observe(this._root.current);\n    };\n\n    private _unregisterResizeObserver = () => {\n      if (this._viewportResizeObserver) {\n        this._viewportResizeObserver.disconnect();\n        delete this._viewportResizeObserver;\n      }\n    };\n\n    /* Note: using lambda here because decorators don't seem to work in decorators. */\n    private _updateViewport = (withForceUpdate?: boolean) => {\n      const { viewport } = this.state;\n      const viewportElement = this._root.current;\n      const scrollElement = findScrollableParent(viewportElement) as HTMLElement;\n      const scrollRect = getRect(scrollElement);\n      const clientRect = getRect(viewportElement);\n      const updateComponent = () => {\n        if (withForceUpdate && this._composedComponentInstance) {\n          this._composedComponentInstance.forceUpdate();\n        }\n      };\n\n      const isSizeChanged =\n        (clientRect && clientRect.width) !== viewport!.width || (scrollRect && scrollRect.height) !== viewport!.height;\n\n      if (isSizeChanged && this._resizeAttempts < MAX_RESIZE_ATTEMPTS && clientRect && scrollRect) {\n        this._resizeAttempts++;\n        this.setState(\n          {\n            viewport: {\n              width: clientRect.width,\n              height: scrollRect.height,\n            },\n          },\n          () => {\n            this._updateViewport(withForceUpdate);\n          },\n        );\n      } else {\n        this._resizeAttempts = 0;\n        updateComponent();\n      }\n    };\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}