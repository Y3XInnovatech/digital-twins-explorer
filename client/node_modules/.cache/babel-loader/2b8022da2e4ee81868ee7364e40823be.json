{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __awaiter, __extends, __generator } from \"tslib\";\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { Constants } from \"../util/constants\";\nimport { delay } from \"../util/utils\";\nvar StatusCodes = Constants.HttpConstants.StatusCodes;\nexport function throttlingRetryPolicy() {\n  return {\n    create: function (nextPolicy, options) {\n      return new ThrottlingRetryPolicy(nextPolicy, options);\n    }\n  };\n}\n/**\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n */\nvar ThrottlingRetryPolicy = /** @class */function (_super) {\n  __extends(ThrottlingRetryPolicy, _super);\n  function ThrottlingRetryPolicy(nextPolicy, options, _handleResponse) {\n    var _this = _super.call(this, nextPolicy, options) || this;\n    _this._handleResponse = _handleResponse || _this._defaultResponseHandler;\n    return _this;\n  }\n  ThrottlingRetryPolicy.prototype.sendRequest = function (httpRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this._nextPolicy.sendRequest(httpRequest.clone()).then(function (response) {\n          if (response.status !== StatusCodes.TooManyRequests) {\n            return response;\n          } else {\n            return _this._handleResponse(httpRequest, response);\n          }\n        })];\n      });\n    });\n  };\n  ThrottlingRetryPolicy.prototype._defaultResponseHandler = function (httpRequest, httpResponse) {\n    return __awaiter(this, void 0, void 0, function () {\n      var retryAfterHeader, delayInMs;\n      var _this = this;\n      return __generator(this, function (_a) {\n        retryAfterHeader = httpResponse.headers.get(Constants.HeaderConstants.RETRY_AFTER);\n        if (retryAfterHeader) {\n          delayInMs = ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterHeader);\n          if (delayInMs) {\n            return [2 /*return*/, delay(delayInMs).then(function (_) {\n              return _this._nextPolicy.sendRequest(httpRequest);\n            })];\n          }\n        }\n        return [2 /*return*/, httpResponse];\n      });\n    });\n  };\n  ThrottlingRetryPolicy.parseRetryAfterHeader = function (headerValue) {\n    var retryAfterInSeconds = Number(headerValue);\n    if (Number.isNaN(retryAfterInSeconds)) {\n      return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);\n    } else {\n      return retryAfterInSeconds * 1000;\n    }\n  };\n  ThrottlingRetryPolicy.parseDateRetryAfterHeader = function (headerValue) {\n    try {\n      var now = Date.now();\n      var date = Date.parse(headerValue);\n      var diff = date - now;\n      return Number.isNaN(diff) ? undefined : diff;\n    } catch (error) {\n      return undefined;\n    }\n  };\n  return ThrottlingRetryPolicy;\n}(BaseRequestPolicy);\nexport { ThrottlingRetryPolicy };","map":{"version":3,"sources":["../../../src/policies/throttlingRetryPolicy.ts"],"names":[],"mappings":"AAAA;AACA;;AAEA,SACE,iBAAiB,QAIZ,iBAAiB;AAGxB,SAAS,SAAS,QAAQ,mBAAmB;AAC7C,SAAS,KAAK,QAAQ,eAAe;AAMrC,IAAM,WAAW,GAAG,SAAS,CAAC,aAAa,CAAC,WAAW;AAEvD,OAAM,SAAU,qBAAqB,CAAA,EAAA;EACnC,OAAO;IACL,MAAM,EAAE,SAAA,CAAC,UAAyB,EAAE,OAA6B,EAAA;MAC/D,OAAO,IAAI,qBAAqB,CAAC,UAAU,EAAE,OAAO,CAAC;IACvD;GACD;AACH;AAEA;;;;;AAKG;AACH,IAAA,qBAAA,GAAA,aAAA,UAAA,MAAA,EAAA;EAA2C,SAAA,CAAA,qBAAA,EAAA,MAAA,CAAA;EAGzC,SAAA,qBAAA,CACE,UAAyB,EACzB,OAA6B,EAC7B,eAAiC,EAAA;IAHnC,IAAA,KAAA,GAKE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,UAAU,EAAE,OAAO,CAAC,IAAA,IAAA;IAC1B,KAAI,CAAC,eAAe,GAAG,eAAe,IAAI,KAAI,CAAC,uBAAuB;;EACxE;EAEa,qBAAA,CAAA,SAAA,CAAA,WAAW,GAAxB,UAAyB,WAA4B,EAAA;;;;QACnD,OAAA,CAAA,CAAA,CAAA,YAAO,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,WAAW,CAAC,KAAK,CAAA,CAAE,CAAC,CAAC,IAAI,CAAC,UAAC,QAAQ,EAAA;UACrE,IAAI,QAAQ,CAAC,MAAM,KAAK,WAAW,CAAC,eAAe,EAAE;YACnD,OAAO,QAAQ;WAChB,MAAM;YACL,OAAO,KAAI,CAAC,eAAe,CAAC,WAAW,EAAE,QAAQ,CAAC;UACnD;QACH,CAAC,CAAC,CAAA;;;GACH;EAEa,qBAAA,CAAA,SAAA,CAAA,uBAAuB,GAArC,UACE,WAA4B,EAC5B,YAAmC,EAAA;;;;;QAE7B,gBAAgB,GAAuB,YAAY,CAAC,OAAO,CAAC,GAAG,CACnE,SAAS,CAAC,eAAe,CAAC,WAAW,CACtC;QAED,IAAI,gBAAgB,EAAE;UACd,SAAS,GAAuB,qBAAqB,CAAC,qBAAqB,CAC/E,gBAAgB,CACjB;UACD,IAAI,SAAS,EAAE;YACb,OAAA,CAAA,CAAA,CAAA,YAAO,KAAK,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,UAAC,CAAM,EAAA;cAAK,OAAA,KAAI,CAAC,WAAW,CAAC,WAAW,CAAC,WAAW,CAAC;YAAzC,CAAyC,CAAC,CAAA;UACpF;QACF;QAED,OAAA,CAAA,CAAA,CAAA,YAAO,YAAY,CAAA;;;GACpB;EAEa,qBAAA,CAAA,qBAAqB,GAAnC,UAAoC,WAAmB,EAAA;IACrD,IAAM,mBAAmB,GAAG,MAAM,CAAC,WAAW,CAAC;IAC/C,IAAI,MAAM,CAAC,KAAK,CAAC,mBAAmB,CAAC,EAAE;MACrC,OAAO,qBAAqB,CAAC,yBAAyB,CAAC,WAAW,CAAC;KACpE,MAAM;MACL,OAAO,mBAAmB,GAAG,IAAI;IAClC;EACH,CAAC;EAEa,qBAAA,CAAA,yBAAyB,GAAvC,UAAwC,WAAmB,EAAA;IACzD,IAAI;MACF,IAAM,GAAG,GAAW,IAAI,CAAC,GAAG,CAAA,CAAE;MAC9B,IAAM,IAAI,GAAW,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC;MAC5C,IAAM,IAAI,GAAG,IAAI,GAAG,GAAG;MAEvB,OAAO,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,SAAS,GAAG,IAAI;KAC7C,CAAC,OAAO,KAAK,EAAE;MACd,OAAO,SAAS;IACjB;EACH,CAAC;EACH,OAAA,qBAAC;AAAD,CAAC,CA9D0C,iBAAiB,CAAA","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyOptions,\n  RequestPolicyFactory\n} from \"./requestPolicy\";\nimport { WebResourceLike } from \"../webResource\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { Constants } from \"../util/constants\";\nimport { delay } from \"../util/utils\";\n\ntype ResponseHandler = (\n  httpRequest: WebResourceLike,\n  response: HttpOperationResponse\n) => Promise<HttpOperationResponse>;\nconst StatusCodes = Constants.HttpConstants.StatusCodes;\n\nexport function throttlingRetryPolicy(): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new ThrottlingRetryPolicy(nextPolicy, options);\n    }\n  };\n}\n\n/**\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n */\nexport class ThrottlingRetryPolicy extends BaseRequestPolicy {\n  private _handleResponse: ResponseHandler;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    _handleResponse?: ResponseHandler\n  ) {\n    super(nextPolicy, options);\n    this._handleResponse = _handleResponse || this._defaultResponseHandler;\n  }\n\n  public async sendRequest(httpRequest: WebResourceLike): Promise<HttpOperationResponse> {\n    return this._nextPolicy.sendRequest(httpRequest.clone()).then((response) => {\n      if (response.status !== StatusCodes.TooManyRequests) {\n        return response;\n      } else {\n        return this._handleResponse(httpRequest, response);\n      }\n    });\n  }\n\n  private async _defaultResponseHandler(\n    httpRequest: WebResourceLike,\n    httpResponse: HttpOperationResponse\n  ): Promise<HttpOperationResponse> {\n    const retryAfterHeader: string | undefined = httpResponse.headers.get(\n      Constants.HeaderConstants.RETRY_AFTER\n    );\n\n    if (retryAfterHeader) {\n      const delayInMs: number | undefined = ThrottlingRetryPolicy.parseRetryAfterHeader(\n        retryAfterHeader\n      );\n      if (delayInMs) {\n        return delay(delayInMs).then((_: any) => this._nextPolicy.sendRequest(httpRequest));\n      }\n    }\n\n    return httpResponse;\n  }\n\n  public static parseRetryAfterHeader(headerValue: string): number | undefined {\n    const retryAfterInSeconds = Number(headerValue);\n    if (Number.isNaN(retryAfterInSeconds)) {\n      return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);\n    } else {\n      return retryAfterInSeconds * 1000;\n    }\n  }\n\n  public static parseDateRetryAfterHeader(headerValue: string): number | undefined {\n    try {\n      const now: number = Date.now();\n      const date: number = Date.parse(headerValue);\n      const diff = date - now;\n\n      return Number.isNaN(diff) ? undefined : diff;\n    } catch (error) {\n      return undefined;\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}