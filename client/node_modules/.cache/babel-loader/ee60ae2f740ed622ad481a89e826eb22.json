{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { buttonProperties, getNativeProps, memoizeFunction, getId, mergeAriaAttributeValues } from '../../../Utilities';\nimport { ContextualMenuItemWrapper } from './ContextualMenuItemWrapper';\nimport { KeytipData } from '../../../KeytipData';\nimport { getIsChecked, isItemDisabled, hasSubmenu, getMenuItemAriaRole } from '../../../utilities/contextualMenu/index';\nimport { ContextualMenuItem } from '../ContextualMenuItem';\nvar ContextualMenuButton = /** @class */function (_super) {\n  __extends(ContextualMenuButton, _super);\n  function ContextualMenuButton() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this._btn = React.createRef();\n    _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function (keytipProps) {\n      return __assign(__assign({}, keytipProps), {\n        hasMenu: true\n      });\n    });\n    _this._renderAriaDescription = function (ariaDescription, className) {\n      // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan\n      return ariaDescription ? React.createElement(\"span\", {\n        id: _this._ariaDescriptionId,\n        className: className\n      }, ariaDescription) : null;\n    };\n    _this._getSubmenuTarget = function () {\n      return _this._btn.current ? _this._btn.current : undefined;\n    };\n    return _this;\n  }\n  ContextualMenuButton.prototype.render = function () {\n    var _this = this;\n    var _a = this.props,\n      item = _a.item,\n      classNames = _a.classNames,\n      index = _a.index,\n      focusableElementIndex = _a.focusableElementIndex,\n      totalItemCount = _a.totalItemCount,\n      hasCheckmarks = _a.hasCheckmarks,\n      hasIcons = _a.hasIcons,\n      _b = _a.contextualMenuItemAs,\n      ChildrenRenderer = _b === void 0 ? ContextualMenuItem : _b,\n      expandedMenuItemKey = _a.expandedMenuItemKey,\n      onItemMouseDown = _a.onItemMouseDown,\n      onItemClick = _a.onItemClick,\n      openSubMenu = _a.openSubMenu,\n      dismissSubMenu = _a.dismissSubMenu,\n      dismissMenu = _a.dismissMenu;\n    var subMenuId = this._getSubMenuId(item);\n    var isChecked = getIsChecked(item);\n    var canCheck = isChecked !== null;\n    var defaultRole = getMenuItemAriaRole(item);\n    var itemHasSubmenu = hasSubmenu(item);\n    var itemProps = item.itemProps,\n      ariaLabel = item.ariaLabel,\n      ariaDescription = item.ariaDescription;\n    var buttonNativeProperties = getNativeProps(item, buttonProperties);\n    // Do not add the disabled attribute to the button so that it is focusable\n    delete buttonNativeProperties.disabled;\n    var itemRole = item.role || defaultRole;\n    // Check for ariaDescription to set the _ariaDescriptionId and render a hidden span with\n    // the description in it to be added to ariaDescribedBy\n    if (ariaDescription) {\n      this._ariaDescriptionId = getId();\n    }\n    var ariaDescribedByIds = ariaDescription ? this._ariaDescriptionId : undefined;\n    var itemButtonProperties = {\n      className: classNames.root,\n      onClick: this._onItemClick,\n      onKeyDown: itemHasSubmenu ? this._onItemKeyDown : undefined,\n      onMouseEnter: this._onItemMouseEnter,\n      onMouseLeave: this._onItemMouseLeave,\n      onMouseDown: function (ev) {\n        return onItemMouseDown ? onItemMouseDown(item, ev) : undefined;\n      },\n      onMouseMove: this._onItemMouseMove,\n      href: item.href,\n      title: item.title,\n      'aria-label': ariaLabel,\n      'aria-describedby': ariaDescribedByIds,\n      'aria-haspopup': itemHasSubmenu || undefined,\n      'aria-owns': item.key === expandedMenuItemKey ? subMenuId : undefined,\n      'aria-expanded': itemHasSubmenu ? item.key === expandedMenuItemKey : undefined,\n      'aria-posinset': focusableElementIndex + 1,\n      'aria-setsize': totalItemCount,\n      'aria-disabled': isItemDisabled(item),\n      'aria-checked': (itemRole === 'menuitemcheckbox' || itemRole === 'menuitemradio') && canCheck ? !!isChecked : undefined,\n      'aria-selected': itemRole === 'menuitem' && canCheck ? !!isChecked : undefined,\n      role: itemRole,\n      // eslint-disable-next-line deprecation/deprecation\n      style: item.style\n    };\n    var keytipProps = item.keytipProps;\n    if (keytipProps && itemHasSubmenu) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n    return React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      ariaDescribedBy: buttonNativeProperties['aria-describedby'],\n      disabled: isItemDisabled(item)\n    }, function (keytipAttributes) {\n      return React.createElement(\"button\", __assign({\n        ref: _this._btn\n      }, buttonNativeProperties, itemButtonProperties, keytipAttributes, {\n        \"aria-describedby\": mergeAriaAttributeValues(itemButtonProperties['aria-describedby'], keytipAttributes ? keytipAttributes['aria-describedby'] : undefined)\n      }), React.createElement(ChildrenRenderer, __assign({\n        componentRef: item.componentRef,\n        item: item,\n        classNames: classNames,\n        index: index,\n        onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : undefined,\n        hasIcons: hasIcons,\n        openSubMenu: openSubMenu,\n        dismissSubMenu: dismissSubMenu,\n        dismissMenu: dismissMenu,\n        getSubmenuTarget: _this._getSubmenuTarget\n      }, itemProps)), _this._renderAriaDescription(ariaDescription, classNames.screenReaderText));\n    });\n  };\n  return ContextualMenuButton;\n}(ContextualMenuItemWrapper);\nexport { ContextualMenuButton };","map":{"version":3,"sources":["components/ContextualMenu/ContextualMenuItemWrapper/ContextualMenuButton.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { buttonProperties, getNativeProps, memoizeFunction, getId, mergeAriaAttributeValues } from '../../../Utilities';\nimport { ContextualMenuItemWrapper } from './ContextualMenuItemWrapper';\nimport { KeytipData } from '../../../KeytipData';\nimport { getIsChecked, isItemDisabled, hasSubmenu, getMenuItemAriaRole } from '../../../utilities/contextualMenu/index';\nimport { ContextualMenuItem } from '../ContextualMenuItem';\nimport { IKeytipProps } from '../../Keytip/Keytip.types';\n\nexport class ContextualMenuButton extends ContextualMenuItemWrapper {\n  private _btn = React.createRef<HTMLButtonElement>();\n  private _ariaDescriptionId: string;\n\n  private _getMemoizedMenuButtonKeytipProps = memoizeFunction((keytipProps: IKeytipProps) => {\n    return {\n      ...keytipProps,\n      hasMenu: true,\n    };\n  });\n\n  public render() {\n    const {\n      item,\n      classNames,\n      index,\n      focusableElementIndex,\n      totalItemCount,\n      hasCheckmarks,\n      hasIcons,\n      contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem,\n      expandedMenuItemKey,\n      onItemMouseDown,\n      onItemClick,\n      openSubMenu,\n      dismissSubMenu,\n      dismissMenu,\n    } = this.props;\n\n    const subMenuId = this._getSubMenuId(item);\n\n    const isChecked: boolean | null | undefined = getIsChecked(item);\n    const canCheck: boolean = isChecked !== null;\n    const defaultRole = getMenuItemAriaRole(item);\n    const itemHasSubmenu = hasSubmenu(item);\n    const { itemProps, ariaLabel, ariaDescription } = item;\n\n    const buttonNativeProperties = getNativeProps<React.ButtonHTMLAttributes<HTMLButtonElement>>(\n      item,\n      buttonProperties,\n    );\n    // Do not add the disabled attribute to the button so that it is focusable\n    delete buttonNativeProperties.disabled;\n\n    const itemRole = item.role || defaultRole;\n\n    // Check for ariaDescription to set the _ariaDescriptionId and render a hidden span with\n    // the description in it to be added to ariaDescribedBy\n    if (ariaDescription) {\n      this._ariaDescriptionId = getId();\n    }\n    const ariaDescribedByIds = ariaDescription ? this._ariaDescriptionId : undefined;\n\n    const itemButtonProperties = {\n      className: classNames.root,\n      onClick: this._onItemClick,\n      onKeyDown: itemHasSubmenu ? this._onItemKeyDown : undefined,\n      onMouseEnter: this._onItemMouseEnter,\n      onMouseLeave: this._onItemMouseLeave,\n      onMouseDown: (ev: React.MouseEvent<HTMLButtonElement>) =>\n        onItemMouseDown ? onItemMouseDown(item, ev) : undefined,\n      onMouseMove: this._onItemMouseMove,\n      href: item.href,\n      title: item.title,\n      'aria-label': ariaLabel,\n      'aria-describedby': ariaDescribedByIds,\n      'aria-haspopup': itemHasSubmenu || undefined,\n      'aria-owns': item.key === expandedMenuItemKey ? subMenuId : undefined,\n      'aria-expanded': itemHasSubmenu ? item.key === expandedMenuItemKey : undefined,\n      'aria-posinset': focusableElementIndex + 1,\n      'aria-setsize': totalItemCount,\n      'aria-disabled': isItemDisabled(item),\n      'aria-checked':\n        (itemRole === 'menuitemcheckbox' || itemRole === 'menuitemradio') && canCheck ? !!isChecked : undefined,\n      'aria-selected': itemRole === 'menuitem' && canCheck ? !!isChecked : undefined,\n      role: itemRole,\n      // eslint-disable-next-line deprecation/deprecation\n      style: item.style,\n    };\n\n    let { keytipProps } = item;\n    if (keytipProps && itemHasSubmenu) {\n      keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);\n    }\n\n    return (\n      <KeytipData\n        keytipProps={keytipProps}\n        ariaDescribedBy={buttonNativeProperties['aria-describedby']}\n        disabled={isItemDisabled(item)}\n      >\n        {(keytipAttributes: any): JSX.Element => (\n          <button\n            ref={this._btn}\n            {...buttonNativeProperties}\n            {...itemButtonProperties}\n            {...keytipAttributes}\n            aria-describedby={mergeAriaAttributeValues(\n              itemButtonProperties['aria-describedby'],\n              keytipAttributes ? keytipAttributes['aria-describedby'] : undefined,\n            )}\n          >\n            <ChildrenRenderer\n              componentRef={item.componentRef}\n              item={item}\n              classNames={classNames}\n              index={index}\n              onCheckmarkClick={hasCheckmarks && onItemClick ? onItemClick : undefined}\n              hasIcons={hasIcons}\n              openSubMenu={openSubMenu}\n              dismissSubMenu={dismissSubMenu}\n              dismissMenu={dismissMenu}\n              getSubmenuTarget={this._getSubmenuTarget}\n              {...itemProps}\n            />\n            {this._renderAriaDescription(ariaDescription, classNames.screenReaderText)}\n          </button>\n        )}\n      </KeytipData>\n    );\n  }\n\n  protected _renderAriaDescription = (ariaDescription?: string, className?: string) => {\n    // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan\n    return ariaDescription ? (\n      <span id={this._ariaDescriptionId} className={className}>\n        {ariaDescription}\n      </span>\n    ) : null;\n  };\n\n  protected _getSubmenuTarget = (): HTMLElement | undefined => {\n    return this._btn.current ? this._btn.current : undefined;\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}