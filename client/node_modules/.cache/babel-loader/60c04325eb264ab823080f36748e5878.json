{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nvar _cleanArray = _interopRequireDefault(require(\"../utils/cleanArray\"));\nvar _sendCursorToEnd = _interopRequireDefault(require(\"../utils/sendCursorToEnd\"));\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal[\"default\"].signature : function (a) {\n  return a;\n};\nvar _default = function _default(direction, options) {\n  var history = options.history,\n    historyPosition = options.historyPosition,\n    previousHistoryPosition = options.previousHistoryPosition,\n    terminalInput = options.terminalInput; // BUG: I have to duplicate sendCursorToEnd for each condition, because doing so in a catch-all manner doesn't seem to work at all\n  // Clean potential empty items and reverse order to ease position tracking\n  // (Reverse = starting from the newest first when going up and vice versa)\n\n  var commandHistory = (0, _cleanArray[\"default\"])(history).reverse();\n  var position = historyPosition;\n  var previousPosition = previousHistoryPosition;\n  var terminal = terminalInput.current;\n  if (commandHistory.length > 0) {\n    // Only run if history is non-empty and in use\n    switch (direction) {\n      case 'up':\n        {\n          // Declaring variables for these here to better clarify this block which can get pretty convoluted\n          var latest = commandHistory[0];\n          var first = commandHistory[commandHistory.length - 1];\n          var next = commandHistory[position + 1];\n          if (position === null) {\n            // If at no yet defined position, get most recent entry\n            terminal.value = latest;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: 0,\n              previousHistoryPosition: null\n            };\n          } else if (position + 1 === commandHistory.length) {\n            // If the first entry will be reached on this press, get it and decrement position by 1 to avoid confusing downscroll\n            // EXCEPT: If there is only 1 unit in the history, our previous position was actually null, not zero as defined above\n            // Hence why in one-unit histories the previous position has to be set to null, not 0\n            terminal.value = first;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: commandHistory.length - 1,\n              previousHistoryPosition: commandHistory.length === 1 ? null : commandHistory.length - 2\n            };\n          } else {\n            // Normal increment by one\n            terminal.value = next;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: position + 1,\n              previousHistoryPosition: position\n            };\n          }\n        }\n      case 'down':\n        {\n          // Declaring variables for these here to better clarify this block which can get pretty convoluted\n          var _latest = commandHistory[0];\n          var empty = '';\n          var _next = commandHistory[position - 1];\n          if (position === null || !commandHistory[position]) {\n            // If at initial or out of range, clear (Unix-like behaviour)\n            terminal.value = empty;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: null,\n              previousHistoryPosition: null\n            };\n          } else if (position - 1 === -1) {\n            // Clear because user is either pressing up once and is now pressing down again, or is reaching the latest entry\n            if (previousPosition === null || position === 0 && previousPosition === 1) terminal.value = empty;else terminal.value = _latest;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: null,\n              previousHistoryPosition: null\n            };\n          } else {\n            // Normal decrement by one\n            terminal.value = _next;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: position - 1,\n              previousHistoryPosition: position\n            };\n          }\n        }\n    }\n  }\n};\n\n/**\r\n * Scrolls command history in a given direction\r\n * @param {String} direction Direction to scroll in ('up' or 'down')\r\n * @param {Object} options\r\n * @param {Array} options.history - Array of previous inputs from the user\r\n * @param {Number} options.historyPosition - Current position in the history\r\n * @param {Number} options.previousHistoryPosition - Previous position in the history\r\n * @param {React.Ref} options.terminalInput - Ref to the terminal input element\r\n */\nvar _default2 = _default;\nexports[\"default\"] = _default2;\n;\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n  if (!reactHotLoader) {\n    return;\n  }\n  reactHotLoader.register(_default, \"default\", \"C:\\\\Users\\\\LWTech Gaming\\\\Code Projects\\\\react-console-emulator\\\\src\\\\handlers\\\\scrollHistory.js\");\n})();\n;\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","_cleanArray","_sendCursorToEnd","enterModule","reactHotLoaderGlobal","undefined","module","__signature__","signature","a","_default","direction","options","history","historyPosition","previousHistoryPosition","terminalInput","commandHistory","reverse","position","previousPosition","terminal","current","length","latest","first","next","_latest","empty","_next","_default2","reactHotLoader","default","register","leaveModule"],"sources":["/home/saharsh/Music/digital-twins-explorer/client/node_modules/react-console-emulator/dist/handlers/scrollHistory.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _cleanArray = _interopRequireDefault(require(\"../utils/cleanArray\"));\n\nvar _sendCursorToEnd = _interopRequireDefault(require(\"../utils/sendCursorToEnd\"));\n\n(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\n\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal[\"default\"].signature : function (a) {\n  return a;\n};\n\nvar _default = function _default(direction, options) {\n  var history = options.history,\n      historyPosition = options.historyPosition,\n      previousHistoryPosition = options.previousHistoryPosition,\n      terminalInput = options.terminalInput; // BUG: I have to duplicate sendCursorToEnd for each condition, because doing so in a catch-all manner doesn't seem to work at all\n  // Clean potential empty items and reverse order to ease position tracking\n  // (Reverse = starting from the newest first when going up and vice versa)\n\n  var commandHistory = (0, _cleanArray[\"default\"])(history).reverse();\n  var position = historyPosition;\n  var previousPosition = previousHistoryPosition;\n  var terminal = terminalInput.current;\n\n  if (commandHistory.length > 0) {\n    // Only run if history is non-empty and in use\n    switch (direction) {\n      case 'up':\n        {\n          // Declaring variables for these here to better clarify this block which can get pretty convoluted\n          var latest = commandHistory[0];\n          var first = commandHistory[commandHistory.length - 1];\n          var next = commandHistory[position + 1];\n\n          if (position === null) {\n            // If at no yet defined position, get most recent entry\n            terminal.value = latest;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: 0,\n              previousHistoryPosition: null\n            };\n          } else if (position + 1 === commandHistory.length) {\n            // If the first entry will be reached on this press, get it and decrement position by 1 to avoid confusing downscroll\n            // EXCEPT: If there is only 1 unit in the history, our previous position was actually null, not zero as defined above\n            // Hence why in one-unit histories the previous position has to be set to null, not 0\n            terminal.value = first;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: commandHistory.length - 1,\n              previousHistoryPosition: commandHistory.length === 1 ? null : commandHistory.length - 2\n            };\n          } else {\n            // Normal increment by one\n            terminal.value = next;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: position + 1,\n              previousHistoryPosition: position\n            };\n          }\n        }\n\n      case 'down':\n        {\n          // Declaring variables for these here to better clarify this block which can get pretty convoluted\n          var _latest = commandHistory[0];\n          var empty = '';\n          var _next = commandHistory[position - 1];\n\n          if (position === null || !commandHistory[position]) {\n            // If at initial or out of range, clear (Unix-like behaviour)\n            terminal.value = empty;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: null,\n              previousHistoryPosition: null\n            };\n          } else if (position - 1 === -1) {\n            // Clear because user is either pressing up once and is now pressing down again, or is reaching the latest entry\n            if (previousPosition === null || position === 0 && previousPosition === 1) terminal.value = empty;else terminal.value = _latest;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: null,\n              previousHistoryPosition: null\n            };\n          } else {\n            // Normal decrement by one\n            terminal.value = _next;\n            (0, _sendCursorToEnd[\"default\"])(terminal);\n            return {\n              historyPosition: position - 1,\n              previousHistoryPosition: position\n            };\n          }\n        }\n    }\n  }\n};\n\n/**\r\n * Scrolls command history in a given direction\r\n * @param {String} direction Direction to scroll in ('up' or 'down')\r\n * @param {Object} options\r\n * @param {Array} options.history - Array of previous inputs from the user\r\n * @param {Number} options.historyPosition - Current position in the history\r\n * @param {Number} options.previousHistoryPosition - Previous position in the history\r\n * @param {React.Ref} options.terminalInput - Ref to the terminal input element\r\n */\nvar _default2 = _default;\nexports[\"default\"] = _default2;\n;\n\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n\n  if (!reactHotLoader) {\n    return;\n  }\n\n  reactHotLoader.register(_default, \"default\", \"C:\\\\Users\\\\LWTech Gaming\\\\Code Projects\\\\react-console-emulator\\\\src\\\\handlers\\\\scrollHistory.js\");\n})();\n\n;\n\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}