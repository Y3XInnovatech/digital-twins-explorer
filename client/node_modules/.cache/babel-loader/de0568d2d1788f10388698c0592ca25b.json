{"ast":null,"code":"import { __assign, __decorate, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport { initializeComponentRef, warnMutuallyExclusive, Async, getId, KeyCodes, customizable, calculatePrecision, precisionRound, mergeAriaAttributeValues, getNativeProps, divProperties } from '../../Utilities';\nimport { Position } from '../../utilities/positioning';\nimport { getStyles, getArrowButtonStyles } from './SpinButton.styles';\nimport { getClassNames } from './SpinButton.classNames';\nimport { KeytipData } from '../../KeytipData';\nexport var KeyboardSpinDirection;\n(function (KeyboardSpinDirection) {\n  KeyboardSpinDirection[KeyboardSpinDirection[\"down\"] = -1] = \"down\";\n  KeyboardSpinDirection[KeyboardSpinDirection[\"notSpinning\"] = 0] = \"notSpinning\";\n  KeyboardSpinDirection[KeyboardSpinDirection[\"up\"] = 1] = \"up\";\n})(KeyboardSpinDirection || (KeyboardSpinDirection = {}));\nvar SpinButton = /** @class */function (_super) {\n  __extends(SpinButton, _super);\n  function SpinButton(props) {\n    var _this = _super.call(this, props) || this;\n    _this._input = React.createRef();\n    _this._initialStepDelay = 400;\n    _this._stepDelay = 75;\n    _this._onFocus = function (ev) {\n      // We can't set focus on a non-existing element\n      if (!_this._input.current) {\n        return;\n      }\n      if (_this._spinningByMouse || _this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n        _this._stop();\n      }\n      _this._input.current.select();\n      _this.setState({\n        isFocused: true\n      });\n      if (_this.props.onFocus) {\n        _this.props.onFocus(ev);\n      }\n    };\n    _this._onBlur = function (ev) {\n      _this._validate(ev);\n      _this.setState({\n        isFocused: false\n      });\n      if (_this.props.onBlur) {\n        _this.props.onBlur(ev);\n      }\n    };\n    _this._onValidate = function (value, event) {\n      if (_this.props.onValidate) {\n        return _this.props.onValidate(value, event);\n      } else {\n        return _this._defaultOnValidate(value);\n      }\n    };\n    _this._calculatePrecision = function (props) {\n      var _a = props.precision,\n        precision = _a === void 0 ? Math.max(calculatePrecision(props.step), 0) : _a;\n      return precision;\n    };\n    /**\n     * Validate function to use if one is not passed in\n     */\n    _this._defaultOnValidate = function (value) {\n      if (value === null || value.trim().length === 0 || isNaN(Number(value))) {\n        return _this._lastValidValue;\n      }\n      var newValue = Math.min(_this.props.max, Math.max(_this.props.min, Number(value)));\n      return String(newValue);\n    };\n    _this._onIncrement = function (value, event) {\n      if (_this.props.onIncrement) {\n        return _this.props.onIncrement(value, event);\n      } else {\n        return _this._defaultOnIncrement(value);\n      }\n    };\n    /**\n     * Increment function to use if one is not passed in\n     */\n    _this._defaultOnIncrement = function (value) {\n      var _a = _this.props,\n        max = _a.max,\n        step = _a.step;\n      var newValue = Math.min(Number(value) + Number(step), max);\n      newValue = precisionRound(newValue, _this._precision);\n      return String(newValue);\n    };\n    _this._onDecrement = function (value, event) {\n      if (_this.props.onDecrement) {\n        return _this.props.onDecrement(value, event);\n      } else {\n        return _this._defaultOnDecrement(value);\n      }\n    };\n    /**\n     * Increment function to use if one is not passed in\n     */\n    _this._defaultOnDecrement = function (value) {\n      var _a = _this.props,\n        min = _a.min,\n        step = _a.step;\n      var newValue = Math.max(Number(value) - Number(step), min);\n      newValue = precisionRound(newValue, _this._precision);\n      return String(newValue);\n    };\n    /**\n     * This is used when validating text entry in the input on blur or when enter key is pressed\n     * (not when changed via the buttons).\n     * @param event - the event that fired\n     */\n    _this._validate = function (event) {\n      if (_this.value !== undefined && _this._valueToValidate !== undefined && _this._valueToValidate !== _this._lastValidValue) {\n        var newValue = _this._onValidate(_this._valueToValidate, event);\n        // Done validating this value, so clear it\n        _this._valueToValidate = undefined;\n        if (newValue !== undefined) {\n          _this._lastValidValue = newValue;\n          _this.setState({\n            value: newValue\n          });\n        } else {\n          // Value was invalid. Reset state to last valid value.\n          _this.setState({\n            value: _this._lastValidValue\n          });\n        }\n      }\n    };\n    /**\n     * The method is needed to ensure we are updating the actual input value.\n     * without this our value will never change (and validation will not have the correct number)\n     * @param event - the event that was fired\n     */\n    _this._onInputChange = function (event) {\n      var element = event.target;\n      var value = element.value;\n      _this._valueToValidate = value;\n      _this.setState({\n        value: value\n      });\n    };\n    /**\n     * Update the value with the given stepFunction\n     * @param shouldSpin - should we fire off another updateValue when we are done here? This should be true\n     * when spinning in response to a mouseDown\n     * @param stepFunction - function to use to step by\n     * @param event - The event that triggered the updateValue\n     */\n    _this._updateValue = function (shouldSpin, stepDelay, stepFunction, event) {\n      var newValue = stepFunction(_this.value || '', event);\n      if (newValue !== undefined) {\n        _this._lastValidValue = newValue;\n        _this.setState({\n          value: newValue\n        });\n      }\n      if (_this._spinningByMouse !== shouldSpin) {\n        _this._spinningByMouse = shouldSpin;\n      }\n      if (shouldSpin) {\n        _this._currentStepFunctionHandle = _this._async.setTimeout(function () {\n          _this._updateValue(shouldSpin, _this._stepDelay, stepFunction, event);\n        }, stepDelay);\n      }\n    };\n    /**\n     * Stop spinning (clear any currently pending update and set spinning to false)\n     */\n    _this._stop = function () {\n      if (_this._currentStepFunctionHandle >= 0) {\n        _this._async.clearTimeout(_this._currentStepFunctionHandle);\n        _this._currentStepFunctionHandle = -1;\n      }\n      if (_this._spinningByMouse || _this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n        _this._spinningByMouse = false;\n        _this.setState({\n          keyboardSpinDirection: KeyboardSpinDirection.notSpinning\n        });\n      }\n    };\n    /**\n     * Handle keydown on the text field. We need to update\n     * the value when up or down arrow are depressed\n     * @param event - the keyboardEvent that was fired\n     */\n    _this._handleKeyDown = function (event) {\n      // eat the up and down arrow keys to keep focus in the spinButton\n      // (especially when a spinButton is inside of a FocusZone)\n      if (event.which === KeyCodes.up || event.which === KeyCodes.down || event.which === KeyCodes.enter) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      if (_this.props.disabled) {\n        _this._stop();\n        return;\n      }\n      var spinDirection = KeyboardSpinDirection.notSpinning;\n      switch (event.which) {\n        case KeyCodes.up:\n          spinDirection = KeyboardSpinDirection.up;\n          _this._updateValue(false /* shouldSpin */, _this._initialStepDelay, _this._onIncrement, event);\n          break;\n        case KeyCodes.down:\n          spinDirection = KeyboardSpinDirection.down;\n          _this._updateValue(false /* shouldSpin */, _this._initialStepDelay, _this._onDecrement, event);\n          break;\n        case KeyCodes.enter:\n          _this._validate(event);\n          break;\n        case KeyCodes.escape:\n          if (_this.value !== _this._lastValidValue) {\n            _this.setState({\n              value: _this._lastValidValue\n            });\n          }\n          break;\n        default:\n          break;\n      }\n      // style the increment/decrement button to look active\n      // when the corresponding up/down arrow keys trigger a step\n      if (_this.state.keyboardSpinDirection !== spinDirection) {\n        _this.setState({\n          keyboardSpinDirection: spinDirection\n        });\n      }\n    };\n    /**\n     * Make sure that we have stopped spinning on keyUp\n     * if the up or down arrow fired this event\n     * @param event - keyboard event\n     */\n    _this._handleKeyUp = function (event) {\n      if (_this.props.disabled || event.which === KeyCodes.up || event.which === KeyCodes.down) {\n        _this._stop();\n        return;\n      }\n    };\n    _this._onIncrementMouseDown = function (event) {\n      _this._updateValue(true /* shouldSpin */, _this._initialStepDelay, _this._onIncrement, event);\n    };\n    _this._onDecrementMouseDown = function (event) {\n      _this._updateValue(true /* shouldSpin */, _this._initialStepDelay, _this._onDecrement, event);\n    };\n    initializeComponentRef(_this);\n    warnMutuallyExclusive('SpinButton', props, {\n      value: 'defaultValue'\n    });\n    // Don't use || here because it won't handle empty strings properly\n    var _a = props.value,\n      value = _a === void 0 ? props.defaultValue : _a;\n    if (value === undefined) {\n      value = typeof props.min === 'number' ? String(props.min) : '0';\n    }\n    _this._lastValidValue = value;\n    // Ensure that the autocalculated precision is not negative.\n    _this._precision = _this._calculatePrecision(props);\n    _this.state = {\n      isFocused: false,\n      value: value,\n      keyboardSpinDirection: KeyboardSpinDirection.notSpinning\n    };\n    _this._async = new Async(_this);\n    _this._currentStepFunctionHandle = -1;\n    _this._labelId = getId('Label');\n    _this._inputId = getId('input');\n    _this._spinningByMouse = false;\n    _this._valueToValidate = undefined;\n    return _this;\n  }\n  SpinButton.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n  };\n  /**\n   * Invoked when a component is receiving new props. This method is not called for the initial render.\n   */\n  SpinButton.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    if (newProps.value !== undefined) {\n      // Value from props is considered pre-validated\n      this._lastValidValue = newProps.value;\n      this.setState({\n        value: newProps.value\n      });\n    }\n    this._precision = this._calculatePrecision(newProps);\n  };\n  SpinButton.prototype.render = function () {\n    var _this = this;\n    var _a = this.props,\n      disabled = _a.disabled,\n      label = _a.label,\n      min = _a.min,\n      max = _a.max,\n      labelPosition = _a.labelPosition,\n      iconProps = _a.iconProps,\n      incrementButtonIcon = _a.incrementButtonIcon,\n      incrementButtonAriaLabel = _a.incrementButtonAriaLabel,\n      decrementButtonIcon = _a.decrementButtonIcon,\n      decrementButtonAriaLabel = _a.decrementButtonAriaLabel,\n      ariaLabel = _a.ariaLabel,\n      ariaDescribedBy = _a.ariaDescribedBy,\n      customStyles = _a.styles,\n      customUpArrowButtonStyles = _a.upArrowButtonStyles,\n      customDownArrowButtonStyles = _a.downArrowButtonStyles,\n      theme = _a.theme,\n      ariaPositionInSet = _a.ariaPositionInSet,\n      ariaSetSize = _a.ariaSetSize,\n      ariaValueNow = _a.ariaValueNow,\n      ariaValueText = _a.ariaValueText,\n      keytipProps = _a.keytipProps,\n      className = _a.className,\n      inputProps = _a.inputProps,\n      iconButtonProps = _a.iconButtonProps;\n    var _b = this.state,\n      isFocused = _b.isFocused,\n      keyboardSpinDirection = _b.keyboardSpinDirection;\n    var value = this.value;\n    var classNames = this.props.getClassNames ? this.props.getClassNames(theme, disabled, isFocused, keyboardSpinDirection, labelPosition, className) : getClassNames(getStyles(theme, customStyles), disabled, isFocused, keyboardSpinDirection, labelPosition, className);\n    var nativeProps = getNativeProps(this.props, divProperties, ['onBlur', 'onFocus', 'className']);\n    return React.createElement(\"div\", {\n      className: classNames.root\n    }, labelPosition !== Position.bottom && (iconProps || label) && React.createElement(\"div\", {\n      className: classNames.labelWrapper\n    }, iconProps && React.createElement(Icon, __assign({}, iconProps, {\n      className: classNames.icon,\n      \"aria-hidden\": \"true\"\n    })), label && React.createElement(Label, {\n      id: this._labelId,\n      htmlFor: this._inputId,\n      className: classNames.label,\n      disabled: disabled\n    }, label)), React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return React.createElement(\"div\", __assign({}, nativeProps, {\n        className: classNames.spinButtonWrapper,\n        \"aria-label\": ariaLabel && ariaLabel,\n        \"aria-posinset\": ariaPositionInSet,\n        \"aria-setsize\": ariaSetSize,\n        \"data-ktp-target\": keytipAttributes['data-ktp-target']\n      }), React.createElement(\"input\", __assign({\n        value: value,\n        id: _this._inputId,\n        onChange: _this._onChange,\n        onInput: _this._onInputChange,\n        className: classNames.input,\n        type: \"text\",\n        autoComplete: \"off\",\n        role: \"spinbutton\",\n        \"aria-labelledby\": label && _this._labelId,\n        \"aria-valuenow\": typeof ariaValueNow === 'number' ? ariaValueNow : value && !isNaN(Number(value)) // Number('') is 0 which may not be desirable\n        ? Number(value) : undefined,\n        \"aria-valuetext\": typeof ariaValueText === 'string' ? ariaValueText : !value || isNaN(Number(value)) // Number('') is 0 which may not be desirable\n        ? value : undefined,\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"aria-describedby\": mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby']),\n        onBlur: _this._onBlur,\n        ref: _this._input,\n        onFocus: _this._onFocus,\n        onKeyDown: _this._handleKeyDown,\n        onKeyUp: _this._handleKeyUp,\n        disabled: disabled,\n        \"aria-disabled\": disabled,\n        \"data-lpignore\": true,\n        \"data-ktp-execute-target\": keytipAttributes['data-ktp-execute-target']\n      }, inputProps)), React.createElement(\"span\", {\n        className: classNames.arrowBox\n      }, React.createElement(IconButton, __assign({\n        styles: getArrowButtonStyles(theme, true, customUpArrowButtonStyles),\n        className: 'ms-UpButton',\n        checked: keyboardSpinDirection === KeyboardSpinDirection.up,\n        disabled: disabled,\n        iconProps: incrementButtonIcon,\n        onMouseDown: _this._onIncrementMouseDown,\n        onMouseLeave: _this._stop,\n        onMouseUp: _this._stop,\n        tabIndex: -1,\n        ariaLabel: incrementButtonAriaLabel,\n        \"data-is-focusable\": false\n      }, iconButtonProps)), React.createElement(IconButton, __assign({\n        styles: getArrowButtonStyles(theme, false, customDownArrowButtonStyles),\n        className: 'ms-DownButton',\n        checked: keyboardSpinDirection === KeyboardSpinDirection.down,\n        disabled: disabled,\n        iconProps: decrementButtonIcon,\n        onMouseDown: _this._onDecrementMouseDown,\n        onMouseLeave: _this._stop,\n        onMouseUp: _this._stop,\n        tabIndex: -1,\n        ariaLabel: decrementButtonAriaLabel,\n        \"data-is-focusable\": false\n      }, iconButtonProps))));\n    }), labelPosition === Position.bottom && (iconProps || label) && React.createElement(\"div\", {\n      className: classNames.labelWrapper\n    }, iconProps && React.createElement(Icon, {\n      iconName: iconProps.iconName,\n      className: classNames.icon,\n      \"aria-hidden\": \"true\"\n    }), label && React.createElement(Label, {\n      id: this._labelId,\n      htmlFor: this._inputId,\n      className: classNames.label,\n      disabled: disabled\n    }, label)));\n  };\n  SpinButton.prototype.focus = function () {\n    if (this._input.current) {\n      this._input.current.focus();\n    }\n  };\n  Object.defineProperty(SpinButton.prototype, \"value\", {\n    /**\n     * Gets the value of the spin button.\n     */\n    get: function () {\n      // TODO (version 8): value from props should ALWAYS override value from state.\n      // In a class component the code should be:\n      // const { value = this.state.value } = this.props;\n      // return value;\n      return this.state.value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  SpinButton.prototype._onChange = function () {\n    /**\n     * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n     * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n     * The no-op onChange handler was still needed because React gives console errors if an input\n     * doesn't have onChange.\n     *\n     * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n     * ours or 3rd-party, which simulate entering text in a SpinButton)\n     */\n  };\n  SpinButton.defaultProps = {\n    step: 1,\n    min: 0,\n    max: 100,\n    disabled: false,\n    labelPosition: Position.start,\n    label: '',\n    incrementButtonIcon: {\n      iconName: 'ChevronUpSmall'\n    },\n    decrementButtonIcon: {\n      iconName: 'ChevronDownSmall'\n    }\n  };\n  SpinButton = __decorate([customizable('SpinButton', ['theme', 'styles'], true)], SpinButton);\n  return SpinButton;\n}(React.Component);\nexport { SpinButton };","map":{"version":3,"sources":["components/SpinButton/SpinButton.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAK,MAAM,OAAO;AAC9B,SAAS,UAAU,QAAQ,cAAc;AACzC,SAAS,KAAK,QAAQ,aAAa;AACnC,SAAS,IAAI,QAAQ,YAAY;AACjC,SACE,sBAAsB,EACtB,qBAAqB,EACrB,KAAK,EACL,KAAK,EACL,QAAQ,EACR,YAAY,EACZ,kBAAkB,EAClB,cAAc,EACd,wBAAwB,EACxB,cAAc,EACd,aAAa,QACR,iBAAiB;AAExB,SAAS,QAAQ,QAAQ,6BAA6B;AACtD,SAAS,SAAS,EAAE,oBAAoB,QAAQ,qBAAqB;AACrE,SAAS,aAAa,QAAQ,yBAAyB;AACvD,SAAS,UAAU,QAAQ,kBAAkB;AAE7C,OAAA,IAAY,qBAIX;AAJD,CAAA,UAAY,qBAAqB,EAAA;EAC/B,qBAAA,CAAA,qBAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,CAAA,GAAA,MAAS;EACT,qBAAA,CAAA,qBAAA,CAAA,aAAA,CAAA,GAAA,CAAA,CAAA,GAAA,aAAe;EACf,qBAAA,CAAA,qBAAA,CAAA,IAAA,CAAA,GAAA,CAAA,CAAA,GAAA,IAAM;AACR,CAAC,EAJW,qBAAqB,KAArB,qBAAqB,GAAA,CAAA,CAAA,CAAA,CAAA;AAoCjC,IAAA,UAAA,GAAA,aAAA,UAAA,MAAA,EAAA;EAAgC,SAAA,CAAA,UAAA,EAAA,MAAA,CAAA;EAyB9B,SAAA,UAAA,CAAY,KAAuB,EAAA;IAAnC,IAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAK,CAAC,IAAA,IAAA;IAbN,KAAA,CAAA,MAAM,GAAG,KAAK,CAAC,SAAS,CAAA,CAAoB;IAS5C,KAAA,CAAA,iBAAiB,GAAG,GAAG;IACvB,KAAA,CAAA,UAAU,GAAG,EAAE;IA+Nf,KAAA,CAAA,QAAQ,GAAG,UAAC,EAAsC,EAAA;MACxD;MACA,IAAI,CAAC,KAAI,CAAC,MAAM,CAAC,OAAO,EAAE;QACxB;MACD;MAED,IAAI,KAAI,CAAC,gBAAgB,IAAI,KAAI,CAAC,KAAK,CAAC,qBAAqB,KAAK,qBAAqB,CAAC,WAAW,EAAE;QACnG,KAAI,CAAC,KAAK,CAAA,CAAE;MACb;MAED,KAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAA,CAAE;MAE5B,KAAI,CAAC,QAAQ,CAAC;QAAE,SAAS,EAAE;MAAI,CAAE,CAAC;MAElC,IAAI,KAAI,CAAC,KAAK,CAAC,OAAO,EAAE;QACtB,KAAI,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC;MACvB;IACH,CAAC;IAEO,KAAA,CAAA,OAAO,GAAG,UAAC,EAAsC,EAAA;MACvD,KAAI,CAAC,SAAS,CAAC,EAAE,CAAC;MAClB,KAAI,CAAC,QAAQ,CAAC;QAAE,SAAS,EAAE;MAAK,CAAE,CAAC;MACnC,IAAI,KAAI,CAAC,KAAK,CAAC,MAAM,EAAE;QACrB,KAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC;MACtB;IACH,CAAC;IAEO,KAAA,CAAA,WAAW,GAAG,UAAC,KAAa,EAAE,KAAyC,EAAA;MAC7E,IAAI,KAAI,CAAC,KAAK,CAAC,UAAU,EAAE;QACzB,OAAO,KAAI,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,EAAE,KAAK,CAAC;OAC3C,MAAM;QACL,OAAO,KAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC;MACtC;IACH,CAAC;IAEO,KAAA,CAAA,mBAAmB,GAAG,UAAC,KAAsC,EAAA;MAC3D,IAAA,EAAA,GAAA,KAAA,CAAA,SAAuD;QAAvD,SAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,IAAA,CAAA,GAAA,CAAA,kBAAA,CAAA,KAAA,CAAA,IAAA,CAAA,EAAA,CAAA,CAAA,GAAA,EAAuD;MAC/D,OAAO,SAAS;IAClB,CAAC;IAED;;AAEG;IACK,KAAA,CAAA,kBAAkB,GAAG,UAAC,KAAa,EAAA;MACzC,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,CAAC,IAAI,CAAA,CAAE,CAAC,MAAM,KAAK,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE;QACvE,OAAO,KAAI,CAAC,eAAe;MAC5B;MACD,IAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,KAAI,CAAC,KAAK,CAAC,GAAa,EAAE,IAAI,CAAC,GAAG,CAAC,KAAI,CAAC,KAAK,CAAC,GAAa,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;MACtG,OAAO,MAAM,CAAC,QAAQ,CAAC;IACzB,CAAC;IAEO,KAAA,CAAA,YAAY,GAAG,UACrB,KAAa,EACb,KAAwE,EAAA;MAExE,IAAI,KAAI,CAAC,KAAK,CAAC,WAAW,EAAE;QAC1B,OAAO,KAAI,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,EAAE,KAAK,CAAC;OAC5C,MAAM;QACL,OAAO,KAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC;MACvC;IACH,CAAC;IAED;;AAEG;IACK,KAAA,CAAA,mBAAmB,GAAG,UAAC,KAAa,EAAA;MACpC,IAAA,EAAA,GAAA,KAAA,CAAA,KAAsD;QAApD,GAAA,GAAA,EAAA,CAAA,GAAG;QAAE,IAAA,GAAA,EAAA,CAAA,IAA+C;MAC5D,IAAI,QAAQ,GAAW,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC;MAClE,QAAQ,GAAG,cAAc,CAAC,QAAQ,EAAE,KAAI,CAAC,UAAU,CAAC;MACpD,OAAO,MAAM,CAAC,QAAQ,CAAC;IACzB,CAAC;IAEO,KAAA,CAAA,YAAY,GAAG,UACrB,KAAa,EACb,KAAwE,EAAA;MAExE,IAAI,KAAI,CAAC,KAAK,CAAC,WAAW,EAAE;QAC1B,OAAO,KAAI,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,EAAE,KAAK,CAAC;OAC5C,MAAM;QACL,OAAO,KAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC;MACvC;IACH,CAAC;IAED;;AAEG;IACK,KAAA,CAAA,mBAAmB,GAAG,UAAC,KAAa,EAAA;MACpC,IAAA,EAAA,GAAA,KAAA,CAAA,KAAsD;QAApD,GAAA,GAAA,EAAA,CAAA,GAAG;QAAE,IAAA,GAAA,EAAA,CAAA,IAA+C;MAC5D,IAAI,QAAQ,GAAW,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC;MAClE,QAAQ,GAAG,cAAc,CAAC,QAAQ,EAAE,KAAI,CAAC,UAAU,CAAC;MACpD,OAAO,MAAM,CAAC,QAAQ,CAAC;IACzB,CAAC;IAcD;;;;AAIG;IACK,KAAA,CAAA,SAAS,GAAG,UAAC,KAAiF,EAAA;MACpG,IACE,KAAI,CAAC,KAAK,KAAK,SAAS,IACxB,KAAI,CAAC,gBAAgB,KAAK,SAAS,IACnC,KAAI,CAAC,gBAAgB,KAAK,KAAI,CAAC,eAAe,EAC9C;QACA,IAAM,QAAQ,GAAG,KAAI,CAAC,WAAY,CAAC,KAAI,CAAC,gBAAgB,EAAE,KAAK,CAAC;QAChE;QACA,KAAI,CAAC,gBAAgB,GAAG,SAAS;QAEjC,IAAI,QAAQ,KAAK,SAAS,EAAE;UAC1B,KAAI,CAAC,eAAe,GAAG,QAAQ;UAC/B,KAAI,CAAC,QAAQ,CAAC;YAAE,KAAK,EAAE;UAAQ,CAAE,CAAC;SACnC,MAAM;UACL;UACA,KAAI,CAAC,QAAQ,CAAC;YAAE,KAAK,EAAE,KAAI,CAAC;UAAe,CAAE,CAAC;QAC/C;MACF;IACH,CAAC;IAED;;;;AAIG;IACK,KAAA,CAAA,cAAc,GAAG,UAAC,KAA8D,EAAA;MACtF,IAAM,OAAO,GAAqB,KAAK,CAAC,MAA0B;MAClE,IAAM,KAAK,GAAW,OAAO,CAAC,KAAK;MACnC,KAAI,CAAC,gBAAgB,GAAG,KAAK;MAC7B,KAAI,CAAC,QAAQ,CAAC;QACZ,KAAK,EAAE;OACR,CAAC;IACJ,CAAC;IAED;;;;;;AAMG;IACK,KAAA,CAAA,YAAY,GAAG,UACrB,UAAmB,EACnB,SAAiB,EACjB,YAGkB,EAClB,KAAwE,EAAA;MAExE,IAAM,QAAQ,GAAkB,YAAY,CAAC,KAAI,CAAC,KAAK,IAAI,EAAE,EAAE,KAAK,CAAC;MACrE,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,KAAI,CAAC,eAAe,GAAG,QAAQ;QAC/B,KAAI,CAAC,QAAQ,CAAC;UAAE,KAAK,EAAE;QAAQ,CAAE,CAAC;MACnC;MAED,IAAI,KAAI,CAAC,gBAAgB,KAAK,UAAU,EAAE;QACxC,KAAI,CAAC,gBAAgB,GAAG,UAAU;MACnC;MAED,IAAI,UAAU,EAAE;QACd,KAAI,CAAC,0BAA0B,GAAG,KAAI,CAAC,MAAM,CAAC,UAAU,CAAC,YAAA;UACvD,KAAI,CAAC,YAAY,CAAC,UAAU,EAAE,KAAI,CAAC,UAAU,EAAE,YAAY,EAAE,KAAK,CAAC;QACrE,CAAC,EAAE,SAAS,CAAC;MACd;IACH,CAAC;IAED;;AAEG;IACK,KAAA,CAAA,KAAK,GAAG,YAAA;MACd,IAAI,KAAI,CAAC,0BAA0B,IAAI,CAAC,EAAE;QACxC,KAAI,CAAC,MAAM,CAAC,YAAY,CAAC,KAAI,CAAC,0BAA0B,CAAC;QACzD,KAAI,CAAC,0BAA0B,GAAG,CAAC,CAAC;MACrC;MAED,IAAI,KAAI,CAAC,gBAAgB,IAAI,KAAI,CAAC,KAAK,CAAC,qBAAqB,KAAK,qBAAqB,CAAC,WAAW,EAAE;QACnG,KAAI,CAAC,gBAAgB,GAAG,KAAK;QAC7B,KAAI,CAAC,QAAQ,CAAC;UAAE,qBAAqB,EAAE,qBAAqB,CAAC;QAAW,CAAE,CAAC;MAC5E;IACH,CAAC;IAED;;;;AAIG;IACK,KAAA,CAAA,cAAc,GAAG,UAAC,KAA4C,EAAA;MACpE;MACA;MACA,IAAI,KAAK,CAAC,KAAK,KAAK,QAAQ,CAAC,EAAE,IAAI,KAAK,CAAC,KAAK,KAAK,QAAQ,CAAC,IAAI,IAAI,KAAK,CAAC,KAAK,KAAK,QAAQ,CAAC,KAAK,EAAE;QAClG,KAAK,CAAC,cAAc,CAAA,CAAE;QACtB,KAAK,CAAC,eAAe,CAAA,CAAE;MACxB;MAED,IAAI,KAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;QACvB,KAAI,CAAC,KAAK,CAAA,CAAE;QACZ;MACD;MAED,IAAI,aAAa,GAAG,qBAAqB,CAAC,WAAW;MAErD,QAAQ,KAAK,CAAC,KAAK;QACjB,KAAK,QAAQ,CAAC,EAAE;UACd,aAAa,GAAG,qBAAqB,CAAC,EAAE;UACxC,KAAI,CAAC,YAAY,CAAC,KAAK,CAAC,kBAAkB,KAAI,CAAC,iBAAiB,EAAE,KAAI,CAAC,YAAa,EAAE,KAAK,CAAC;UAC5F;QACF,KAAK,QAAQ,CAAC,IAAI;UAChB,aAAa,GAAG,qBAAqB,CAAC,IAAI;UAC1C,KAAI,CAAC,YAAY,CAAC,KAAK,CAAC,kBAAkB,KAAI,CAAC,iBAAiB,EAAE,KAAI,CAAC,YAAa,EAAE,KAAK,CAAC;UAC5F;QACF,KAAK,QAAQ,CAAC,KAAK;UACjB,KAAI,CAAC,SAAS,CAAC,KAAK,CAAC;UACrB;QACF,KAAK,QAAQ,CAAC,MAAM;UAClB,IAAI,KAAI,CAAC,KAAK,KAAK,KAAI,CAAC,eAAe,EAAE;YACvC,KAAI,CAAC,QAAQ,CAAC;cAAE,KAAK,EAAE,KAAI,CAAC;YAAe,CAAE,CAAC;UAC/C;UACD;QACF;UACE;MACH;MAED;MACA;MACA,IAAI,KAAI,CAAC,KAAK,CAAC,qBAAqB,KAAK,aAAa,EAAE;QACtD,KAAI,CAAC,QAAQ,CAAC;UAAE,qBAAqB,EAAE;QAAa,CAAE,CAAC;MACxD;IACH,CAAC;IAED;;;;AAIG;IACK,KAAA,CAAA,YAAY,GAAG,UAAC,KAAuC,EAAA;MAC7D,IAAI,KAAI,CAAC,KAAK,CAAC,QAAQ,IAAI,KAAK,CAAC,KAAK,KAAK,QAAQ,CAAC,EAAE,IAAI,KAAK,CAAC,KAAK,KAAK,QAAQ,CAAC,IAAI,EAAE;QACvF,KAAI,CAAC,KAAK,CAAA,CAAE;QACZ;MACD;IACH,CAAC;IAEO,KAAA,CAAA,qBAAqB,GAAG,UAAC,KAAoC,EAAA;MACnE,KAAI,CAAC,YAAY,CAAC,IAAI,CAAC,kBAAkB,KAAI,CAAC,iBAAiB,EAAE,KAAI,CAAC,YAAa,EAAE,KAAK,CAAC;IAC7F,CAAC;IAEO,KAAA,CAAA,qBAAqB,GAAG,UAAC,KAAoC,EAAA;MACnE,KAAI,CAAC,YAAY,CAAC,IAAI,CAAC,kBAAkB,KAAI,CAAC,iBAAiB,EAAE,KAAI,CAAC,YAAa,EAAE,KAAK,CAAC;IAC7F,CAAC;IA5dC,sBAAsB,CAAC,KAAI,CAAC;IAE5B,qBAAqB,CAAC,YAAY,EAAE,KAAK,EAAE;MACzC,KAAK,EAAE;KACR,CAAC;IAEF;IACM,IAAA,EAAA,GAAA,KAAA,CAAA,KAA0B;MAA1B,KAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,YAAA,GAAA,EAA0B;IAChC,IAAI,KAAK,KAAK,SAAS,EAAE;MACvB,KAAK,GAAG,OAAO,KAAK,CAAC,GAAG,KAAK,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,GAAG;IAChE;IACD,KAAI,CAAC,eAAe,GAAG,KAAK;IAE5B;IACA,KAAI,CAAC,UAAU,GAAG,KAAI,CAAC,mBAAmB,CAAC,KAAiC,CAAC;IAE7E,KAAI,CAAC,KAAK,GAAG;MACX,SAAS,EAAE,KAAK;MAChB,KAAK,EAAA,KAAA;MACL,qBAAqB,EAAE,qBAAqB,CAAC;KAC9C;IAED,KAAI,CAAC,MAAM,GAAG,IAAI,KAAK,CAAC,KAAI,CAAC;IAC7B,KAAI,CAAC,0BAA0B,GAAG,CAAC,CAAC;IACpC,KAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC;IAC9B,KAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC;IAC9B,KAAI,CAAC,gBAAgB,GAAG,KAAK;IAC7B,KAAI,CAAC,gBAAgB,GAAG,SAAS;;EACnC;EAEO,UAAA,CAAA,SAAA,CAAA,oBAAoB,GAA3B,YAAA;IACE,IAAI,CAAC,MAAM,CAAC,OAAO,CAAA,CAAE;EACvB,CAAC;EAED;;AAEG;EACI,UAAA,CAAA,SAAA,CAAA,gCAAgC,GAAvC,UAAwC,QAA0B,EAAA;IAChE,IAAI,QAAQ,CAAC,KAAK,KAAK,SAAS,EAAE;MAChC;MACA,IAAI,CAAC,eAAe,GAAG,QAAQ,CAAC,KAAK;MACrC,IAAI,CAAC,QAAQ,CAAC;QAAE,KAAK,EAAE,QAAQ,CAAC;MAAK,CAAE,CAAC;IACzC;IACD,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,mBAAmB,CAAC,QAA2C,CAAC;EACzF,CAAC;EAEM,UAAA,CAAA,SAAA,CAAA,MAAM,GAAb,YAAA;IAAA,IAAA,KAAA,GAAA,IAAA;IACQ,IAAA,EAAA,GAAA,IAAA,CAAA,KAyBoC;MAxBxC,QAAA,GAAA,EAAA,CAAA,QAAQ;MACR,KAAA,GAAA,EAAA,CAAA,KAAK;MACL,GAAA,GAAA,EAAA,CAAA,GAAG;MACH,GAAA,GAAA,EAAA,CAAA,GAAG;MACH,aAAA,GAAA,EAAA,CAAA,aAAa;MACb,SAAA,GAAA,EAAA,CAAA,SAAS;MACT,mBAAA,GAAA,EAAA,CAAA,mBAAmB;MACnB,wBAAA,GAAA,EAAA,CAAA,wBAAwB;MACxB,mBAAA,GAAA,EAAA,CAAA,mBAAmB;MACnB,wBAAA,GAAA,EAAA,CAAA,wBAAwB;MACxB,SAAA,GAAA,EAAA,CAAA,SAAS;MACT,eAAA,GAAA,EAAA,CAAA,eAAe;MACf,YAAA,GAAA,EAAA,CAAA,MAAoB;MACpB,yBAAA,GAAA,EAAA,CAAA,mBAA8C;MAC9C,2BAAA,GAAA,EAAA,CAAA,qBAAkD;MAClD,KAAA,GAAA,EAAA,CAAA,KAAK;MACL,iBAAA,GAAA,EAAA,CAAA,iBAAiB;MACjB,WAAA,GAAA,EAAA,CAAA,WAAW;MACX,YAAA,GAAA,EAAA,CAAA,YAAY;MACZ,aAAA,GAAA,EAAA,CAAA,aAAa;MACb,WAAA,GAAA,EAAA,CAAA,WAAW;MACX,SAAA,GAAA,EAAA,CAAA,SAAS;MACT,UAAA,GAAA,EAAA,CAAA,UAAU;MACV,eAAA,GAAA,EAAA,CAAA,eACwC;IAEpC,IAAA,EAAA,GAAA,IAAA,CAAA,KAAiD;MAA/C,SAAA,GAAA,EAAA,CAAA,SAAS;MAAE,qBAAA,GAAA,EAAA,CAAA,qBAAoC;IACvD,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK;IAExB,IAAM,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa,GACvC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,KAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,qBAAqB,EAAE,aAAa,EAAE,SAAS,CAAC,GACtG,aAAa,CACX,SAAS,CAAC,KAAM,EAAE,YAAY,CAAC,EAC/B,QAAQ,EACR,SAAS,EACT,qBAAqB,EACrB,aAAa,EACb,SAAS,CACV;IAEL,IAAM,WAAW,GAAG,cAAc,CAAuC,IAAI,CAAC,KAAK,EAAE,aAAa,EAAE,CAClG,QAAQ,EACR,SAAS,EACT,WAAW,CACZ,CAAC;IAEF,OACE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;MAAK,SAAS,EAAE,UAAU,CAAC;IAAI,CAAA,EAC5B,aAAa,KAAK,QAAQ,CAAC,MAAM,KAAK,SAAS,IAAI,KAAK,CAAC,IACxD,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;MAAK,SAAS,EAAE,UAAU,CAAC;IAAY,CAAA,EACpC,SAAS,IAAI,KAAA,CAAA,aAAA,CAAC,IAAI,EAAA,QAAA,CAAA,CAAA,CAAA,EAAK,SAAS,EAAA;MAAE,SAAS,EAAE,UAAU,CAAC,IAAI;MAAA,aAAA,EAAc;IAAM,CAAA,CAAA,CAAG,EACnF,KAAK,IACJ,KAAA,CAAA,aAAA,CAAC,KAAK,EAAA;MAAC,EAAE,EAAE,IAAI,CAAC,QAAQ;MAAE,OAAO,EAAE,IAAI,CAAC,QAAQ;MAAE,SAAS,EAAE,UAAU,CAAC,KAAK;MAAE,QAAQ,EAAE;IAAQ,CAAA,EAC9F,KAAK,CAET,CAEJ,EACD,KAAA,CAAA,aAAA,CAAC,UAAU,EAAA;MAAC,WAAW,EAAE,WAAW;MAAE,QAAQ,EAAE;IAAQ,CAAA,EACrD,UAAC,gBAAqB,EAAA;MAAkB,OACvC,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA,QAAA,CAAA,CAAA,CAAA,EACM,WAAW,EAAA;QACf,SAAS,EAAE,UAAU,CAAC,iBAAiB;QAAA,YAAA,EAC3B,SAAS,IAAI,SAAS;QAAA,eAAA,EACnB,iBAAiB;QAAA,cAAA,EAClB,WAAW;QAAA,iBAAA,EACR,gBAAgB,CAAC,iBAAiB;MAAC,CAAA,CAAA,EAEpD,KAAA,CAAA,aAAA,CAAA,OAAA,EAAA,QAAA,CAAA;QACE,KAAK,EAAE,KAAK;QACZ,EAAE,EAAE,KAAI,CAAC,QAAQ;QACjB,QAAQ,EAAE,KAAI,CAAC,SAAS;QACxB,OAAO,EAAE,KAAI,CAAC,cAAc;QAC5B,SAAS,EAAE,UAAU,CAAC,KAAK;QAC3B,IAAI,EAAC,MAAM;QACX,YAAY,EAAC,KAAK;QAClB,IAAI,EAAC,YAAY;QAAA,iBAAA,EACA,KAAK,IAAI,KAAI,CAAC,QAAQ;QAAA,eAAA,EAErC,OAAO,YAAY,KAAK,QAAQ,GAC5B,YAAY,GACZ,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;QAAA,EAC/B,MAAM,CAAC,KAAK,CAAC,GACb,SAAS;QAAA,gBAAA,EAGb,OAAO,aAAa,KAAK,QAAQ,GAC7B,aAAa,GACb,CAAC,KAAK,IAAI,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;QAAA,EAC/B,KAAK,GACL,SAAS;QAAA,eAAA,EAEA,GAAG;QAAA,eAAA,EACH,GAAG;QAAA,kBAAA,EACA,wBAAwB,CAAC,eAAe,EAAE,gBAAgB,CAAC,kBAAkB,CAAC,CAAC;QACjG,MAAM,EAAE,KAAI,CAAC,OAAO;QACpB,GAAG,EAAE,KAAI,CAAC,MAAM;QAChB,OAAO,EAAE,KAAI,CAAC,QAAQ;QACtB,SAAS,EAAE,KAAI,CAAC,cAAc;QAC9B,OAAO,EAAE,KAAI,CAAC,YAAY;QAC1B,QAAQ,EAAE,QAAQ;QAAA,eAAA,EACH,QAAQ;QAAA,eAAA,EACR,IAAI;QAAA,yBAAA,EACM,gBAAgB,CAAC,yBAAyB;MAAC,CAAA,EAChE,UAAU,CAAA,CACd,EACF,KAAA,CAAA,aAAA,CAAA,MAAA,EAAA;QAAM,SAAS,EAAE,UAAU,CAAC;MAAQ,CAAA,EAClC,KAAA,CAAA,aAAA,CAAC,UAAU,EAAA,QAAA,CAAA;QACT,MAAM,EAAE,oBAAoB,CAAC,KAAM,EAAE,IAAI,EAAE,yBAAyB,CAAC;QACrE,SAAS,EAAE,aAAa;QACxB,OAAO,EAAE,qBAAqB,KAAK,qBAAqB,CAAC,EAAE;QAC3D,QAAQ,EAAE,QAAQ;QAClB,SAAS,EAAE,mBAAmB;QAC9B,WAAW,EAAE,KAAI,CAAC,qBAAqB;QACvC,YAAY,EAAE,KAAI,CAAC,KAAK;QACxB,SAAS,EAAE,KAAI,CAAC,KAAK;QACrB,QAAQ,EAAE,CAAC,CAAC;QACZ,SAAS,EAAE,wBAAwB;QAAA,mBAAA,EAChB;MAAK,CAAA,EACpB,eAAe,CAAA,CACnB,EACF,KAAA,CAAA,aAAA,CAAC,UAAU,EAAA,QAAA,CAAA;QACT,MAAM,EAAE,oBAAoB,CAAC,KAAM,EAAE,KAAK,EAAE,2BAA2B,CAAC;QACxE,SAAS,EAAE,eAAe;QAC1B,OAAO,EAAE,qBAAqB,KAAK,qBAAqB,CAAC,IAAI;QAC7D,QAAQ,EAAE,QAAQ;QAClB,SAAS,EAAE,mBAAmB;QAC9B,WAAW,EAAE,KAAI,CAAC,qBAAqB;QACvC,YAAY,EAAE,KAAI,CAAC,KAAK;QACxB,SAAS,EAAE,KAAI,CAAC,KAAK;QACrB,QAAQ,EAAE,CAAC,CAAC;QACZ,SAAS,EAAE,wBAAwB;QAAA,mBAAA,EAChB;MAAK,CAAA,EACpB,eAAe,CAAA,CACnB,CACG,CACH;IA7EiC,CA8ExC,CACU,EACZ,aAAa,KAAK,QAAQ,CAAC,MAAM,KAAK,SAAS,IAAI,KAAK,CAAC,IACxD,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;MAAK,SAAS,EAAE,UAAU,CAAC;IAAY,CAAA,EACpC,SAAS,IAAI,KAAA,CAAA,aAAA,CAAC,IAAI,EAAA;MAAC,QAAQ,EAAE,SAAS,CAAC,QAAQ;MAAE,SAAS,EAAE,UAAU,CAAC,IAAI;MAAA,aAAA,EAAc;IAAM,CAAA,CAAG,EAClG,KAAK,IACJ,KAAA,CAAA,aAAA,CAAC,KAAK,EAAA;MAAC,EAAE,EAAE,IAAI,CAAC,QAAQ;MAAE,OAAO,EAAE,IAAI,CAAC,QAAQ;MAAE,SAAS,EAAE,UAAU,CAAC,KAAK;MAAE,QAAQ,EAAE;IAAQ,CAAA,EAC9F,KAAK,CAET,CAEJ,CACG;EAEV,CAAC;EAEM,UAAA,CAAA,SAAA,CAAA,KAAK,GAAZ,YAAA;IACE,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE;MACvB,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAA,CAAE;IAC5B;EACH,CAAC;EAKD,MAAA,CAAA,cAAA,CAAW,UAAA,CAAA,SAAA,EAAA,OAAK,EAAA;IAHhB;;AAEG;SACH,SAAA,CAAA,EAAA;MACE;MACA;MACA;MACA;MACA,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK;IACzB,CAAC;;;IAAA;EA+FO,UAAA,CAAA,SAAA,CAAA,SAAS,GAAjB,YAAA;IACE;;;;;;;;AAQG;EARH,CASD;EA5Va,UAAA,CAAA,YAAY,GAAiB;IACzC,IAAI,EAAE,CAAC;IACP,GAAG,EAAE,CAAC;IACN,GAAG,EAAE,GAAG;IACR,QAAQ,EAAE,KAAK;IACf,aAAa,EAAE,QAAQ,CAAC,KAAK;IAC7B,KAAK,EAAE,EAAE;IACT,mBAAmB,EAAE;MAAE,QAAQ,EAAE;IAAgB,CAAE;IACnD,mBAAmB,EAAE;MAAE,QAAQ,EAAE;IAAkB;GACpD;EAVU,UAAU,GAAA,UAAA,CAAA,CADtB,YAAY,CAAC,YAAY,EAAE,CAAC,OAAO,EAAE,QAAQ,CAAC,EAAE,IAAI,CAAC,C,EACzC,UAAU,CAyftB;EAAD,OAAA,UAAC;CAAA,CAzf+B,KAAK,CAAC,SAAS,CAAA;SAAlC,UAAU","sourcesContent":["import * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport {\n  initializeComponentRef,\n  warnMutuallyExclusive,\n  Async,\n  getId,\n  KeyCodes,\n  customizable,\n  calculatePrecision,\n  precisionRound,\n  mergeAriaAttributeValues,\n  getNativeProps,\n  divProperties,\n} from '../../Utilities';\nimport { ISpinButton, ISpinButtonProps } from './SpinButton.types';\nimport { Position } from '../../utilities/positioning';\nimport { getStyles, getArrowButtonStyles } from './SpinButton.styles';\nimport { getClassNames } from './SpinButton.classNames';\nimport { KeytipData } from '../../KeytipData';\n\nexport enum KeyboardSpinDirection {\n  down = -1,\n  notSpinning = 0,\n  up = 1,\n}\n\nexport interface ISpinButtonState {\n  /**\n   * Is true when the control has focus.\n   */\n  isFocused: boolean;\n\n  /**\n   * the value of the spin button\n   */\n  value: string;\n\n  /**\n   * keyboard spin direction, used to style the up or down button\n   * as active when up/down arrow is pressed\n   */\n  keyboardSpinDirection: KeyboardSpinDirection;\n}\n\n// TODO (Fabric Next): remove default min/max values (issue #11358).\nexport type DefaultProps = Required<\n  Pick<\n    ISpinButtonProps,\n    'step' | 'min' | 'max' | 'disabled' | 'labelPosition' | 'label' | 'incrementButtonIcon' | 'decrementButtonIcon'\n  >\n>;\n\n/** Internal only props */\ntype ISpinButtonInternalProps = ISpinButtonProps & DefaultProps;\n\n@customizable('SpinButton', ['theme', 'styles'], true)\nexport class SpinButton extends React.Component<ISpinButtonProps, ISpinButtonState> implements ISpinButton {\n  public static defaultProps: DefaultProps = {\n    step: 1,\n    min: 0,\n    max: 100,\n    disabled: false,\n    labelPosition: Position.start,\n    label: '',\n    incrementButtonIcon: { iconName: 'ChevronUpSmall' },\n    decrementButtonIcon: { iconName: 'ChevronDownSmall' },\n  };\n\n  private _async: Async;\n  private _input = React.createRef<HTMLInputElement>();\n  private _inputId: string;\n  private _labelId: string;\n  private _lastValidValue: string;\n  private _spinningByMouse: boolean;\n  private _valueToValidate: string | undefined; // To avoid duplicate validations/submissions\n  private _precision: number;\n\n  private _currentStepFunctionHandle: number;\n  private _initialStepDelay = 400;\n  private _stepDelay = 75;\n\n  constructor(props: ISpinButtonProps) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    warnMutuallyExclusive('SpinButton', props, {\n      value: 'defaultValue',\n    });\n\n    // Don't use || here because it won't handle empty strings properly\n    let { value = props.defaultValue } = props;\n    if (value === undefined) {\n      value = typeof props.min === 'number' ? String(props.min) : '0';\n    }\n    this._lastValidValue = value;\n\n    // Ensure that the autocalculated precision is not negative.\n    this._precision = this._calculatePrecision(props as ISpinButtonInternalProps);\n\n    this.state = {\n      isFocused: false,\n      value,\n      keyboardSpinDirection: KeyboardSpinDirection.notSpinning,\n    };\n\n    this._async = new Async(this);\n    this._currentStepFunctionHandle = -1;\n    this._labelId = getId('Label');\n    this._inputId = getId('input');\n    this._spinningByMouse = false;\n    this._valueToValidate = undefined;\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n  }\n\n  /**\n   * Invoked when a component is receiving new props. This method is not called for the initial render.\n   */\n  public UNSAFE_componentWillReceiveProps(newProps: ISpinButtonProps): void {\n    if (newProps.value !== undefined) {\n      // Value from props is considered pre-validated\n      this._lastValidValue = newProps.value;\n      this.setState({ value: newProps.value });\n    }\n    this._precision = this._calculatePrecision(newProps as ISpinButtonProps & DefaultProps);\n  }\n\n  public render(): JSX.Element {\n    const {\n      disabled,\n      label,\n      min,\n      max,\n      labelPosition,\n      iconProps,\n      incrementButtonIcon,\n      incrementButtonAriaLabel,\n      decrementButtonIcon,\n      decrementButtonAriaLabel,\n      ariaLabel,\n      ariaDescribedBy,\n      styles: customStyles,\n      upArrowButtonStyles: customUpArrowButtonStyles,\n      downArrowButtonStyles: customDownArrowButtonStyles,\n      theme,\n      ariaPositionInSet,\n      ariaSetSize,\n      ariaValueNow,\n      ariaValueText,\n      keytipProps,\n      className,\n      inputProps,\n      iconButtonProps,\n    } = this.props as ISpinButtonInternalProps;\n\n    const { isFocused, keyboardSpinDirection } = this.state;\n    const value = this.value;\n\n    const classNames = this.props.getClassNames\n      ? this.props.getClassNames(theme!, disabled, isFocused, keyboardSpinDirection, labelPosition, className)\n      : getClassNames(\n          getStyles(theme!, customStyles),\n          disabled,\n          isFocused,\n          keyboardSpinDirection,\n          labelPosition,\n          className,\n        );\n\n    const nativeProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties, [\n      'onBlur',\n      'onFocus',\n      'className',\n    ]);\n\n    return (\n      <div className={classNames.root}>\n        {labelPosition !== Position.bottom && (iconProps || label) && (\n          <div className={classNames.labelWrapper}>\n            {iconProps && <Icon {...iconProps} className={classNames.icon} aria-hidden=\"true\" />}\n            {label && (\n              <Label id={this._labelId} htmlFor={this._inputId} className={classNames.label} disabled={disabled}>\n                {label}\n              </Label>\n            )}\n          </div>\n        )}\n        <KeytipData keytipProps={keytipProps} disabled={disabled}>\n          {(keytipAttributes: any): JSX.Element => (\n            <div\n              {...nativeProps}\n              className={classNames.spinButtonWrapper}\n              aria-label={ariaLabel && ariaLabel}\n              aria-posinset={ariaPositionInSet}\n              aria-setsize={ariaSetSize}\n              data-ktp-target={keytipAttributes['data-ktp-target']}\n            >\n              <input\n                value={value}\n                id={this._inputId}\n                onChange={this._onChange}\n                onInput={this._onInputChange}\n                className={classNames.input}\n                type=\"text\"\n                autoComplete=\"off\"\n                role=\"spinbutton\"\n                aria-labelledby={label && this._labelId}\n                aria-valuenow={\n                  typeof ariaValueNow === 'number'\n                    ? ariaValueNow\n                    : value && !isNaN(Number(value)) // Number('') is 0 which may not be desirable\n                    ? Number(value)\n                    : undefined\n                }\n                aria-valuetext={\n                  typeof ariaValueText === 'string'\n                    ? ariaValueText\n                    : !value || isNaN(Number(value)) // Number('') is 0 which may not be desirable\n                    ? value\n                    : undefined\n                }\n                aria-valuemin={min}\n                aria-valuemax={max}\n                aria-describedby={mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby'])}\n                onBlur={this._onBlur}\n                ref={this._input}\n                onFocus={this._onFocus}\n                onKeyDown={this._handleKeyDown}\n                onKeyUp={this._handleKeyUp}\n                disabled={disabled}\n                aria-disabled={disabled}\n                data-lpignore={true}\n                data-ktp-execute-target={keytipAttributes['data-ktp-execute-target']}\n                {...inputProps}\n              />\n              <span className={classNames.arrowBox}>\n                <IconButton\n                  styles={getArrowButtonStyles(theme!, true, customUpArrowButtonStyles)}\n                  className={'ms-UpButton'}\n                  checked={keyboardSpinDirection === KeyboardSpinDirection.up}\n                  disabled={disabled}\n                  iconProps={incrementButtonIcon}\n                  onMouseDown={this._onIncrementMouseDown}\n                  onMouseLeave={this._stop}\n                  onMouseUp={this._stop}\n                  tabIndex={-1}\n                  ariaLabel={incrementButtonAriaLabel}\n                  data-is-focusable={false}\n                  {...iconButtonProps}\n                />\n                <IconButton\n                  styles={getArrowButtonStyles(theme!, false, customDownArrowButtonStyles)}\n                  className={'ms-DownButton'}\n                  checked={keyboardSpinDirection === KeyboardSpinDirection.down}\n                  disabled={disabled}\n                  iconProps={decrementButtonIcon}\n                  onMouseDown={this._onDecrementMouseDown}\n                  onMouseLeave={this._stop}\n                  onMouseUp={this._stop}\n                  tabIndex={-1}\n                  ariaLabel={decrementButtonAriaLabel}\n                  data-is-focusable={false}\n                  {...iconButtonProps}\n                />\n              </span>\n            </div>\n          )}\n        </KeytipData>\n        {labelPosition === Position.bottom && (iconProps || label) && (\n          <div className={classNames.labelWrapper}>\n            {iconProps && <Icon iconName={iconProps.iconName} className={classNames.icon} aria-hidden=\"true\" />}\n            {label && (\n              <Label id={this._labelId} htmlFor={this._inputId} className={classNames.label} disabled={disabled}>\n                {label}\n              </Label>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  public focus(): void {\n    if (this._input.current) {\n      this._input.current.focus();\n    }\n  }\n\n  /**\n   * Gets the value of the spin button.\n   */\n  public get value(): string | undefined {\n    // TODO (version 8): value from props should ALWAYS override value from state.\n    // In a class component the code should be:\n    // const { value = this.state.value } = this.props;\n    // return value;\n    return this.state.value;\n  }\n\n  private _onFocus = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    // We can't set focus on a non-existing element\n    if (!this._input.current) {\n      return;\n    }\n\n    if (this._spinningByMouse || this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      this._stop();\n    }\n\n    this._input.current.select();\n\n    this.setState({ isFocused: true });\n\n    if (this.props.onFocus) {\n      this.props.onFocus(ev);\n    }\n  };\n\n  private _onBlur = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    this._validate(ev);\n    this.setState({ isFocused: false });\n    if (this.props.onBlur) {\n      this.props.onBlur(ev);\n    }\n  };\n\n  private _onValidate = (value: string, event?: React.SyntheticEvent<HTMLElement>): string | void => {\n    if (this.props.onValidate) {\n      return this.props.onValidate(value, event);\n    } else {\n      return this._defaultOnValidate(value);\n    }\n  };\n\n  private _calculatePrecision = (props: ISpinButtonProps & DefaultProps) => {\n    const { precision = Math.max(calculatePrecision(props.step), 0) } = props;\n    return precision;\n  };\n\n  /**\n   * Validate function to use if one is not passed in\n   */\n  private _defaultOnValidate = (value: string) => {\n    if (value === null || value.trim().length === 0 || isNaN(Number(value))) {\n      return this._lastValidValue;\n    }\n    const newValue = Math.min(this.props.max as number, Math.max(this.props.min as number, Number(value)));\n    return String(newValue);\n  };\n\n  private _onIncrement = (\n    value: string,\n    event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): string | void => {\n    if (this.props.onIncrement) {\n      return this.props.onIncrement(value, event);\n    } else {\n      return this._defaultOnIncrement(value);\n    }\n  };\n\n  /**\n   * Increment function to use if one is not passed in\n   */\n  private _defaultOnIncrement = (value: string): string | void => {\n    const { max, step } = this.props as ISpinButtonInternalProps;\n    let newValue: number = Math.min(Number(value) + Number(step), max);\n    newValue = precisionRound(newValue, this._precision);\n    return String(newValue);\n  };\n\n  private _onDecrement = (\n    value: string,\n    event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): string | void => {\n    if (this.props.onDecrement) {\n      return this.props.onDecrement(value, event);\n    } else {\n      return this._defaultOnDecrement(value);\n    }\n  };\n\n  /**\n   * Increment function to use if one is not passed in\n   */\n  private _defaultOnDecrement = (value: string): string | void => {\n    const { min, step } = this.props as ISpinButtonInternalProps;\n    let newValue: number = Math.max(Number(value) - Number(step), min);\n    newValue = precisionRound(newValue, this._precision);\n    return String(newValue);\n  };\n\n  private _onChange(): void {\n    /**\n     * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n     * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n     * The no-op onChange handler was still needed because React gives console errors if an input\n     * doesn't have onChange.\n     *\n     * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n     * ours or 3rd-party, which simulate entering text in a SpinButton)\n     */\n  }\n\n  /**\n   * This is used when validating text entry in the input on blur or when enter key is pressed\n   * (not when changed via the buttons).\n   * @param event - the event that fired\n   */\n  private _validate = (event: React.FocusEvent<HTMLInputElement> | React.KeyboardEvent<HTMLInputElement>): void => {\n    if (\n      this.value !== undefined &&\n      this._valueToValidate !== undefined &&\n      this._valueToValidate !== this._lastValidValue\n    ) {\n      const newValue = this._onValidate!(this._valueToValidate, event);\n      // Done validating this value, so clear it\n      this._valueToValidate = undefined;\n\n      if (newValue !== undefined) {\n        this._lastValidValue = newValue;\n        this.setState({ value: newValue });\n      } else {\n        // Value was invalid. Reset state to last valid value.\n        this.setState({ value: this._lastValidValue });\n      }\n    }\n  };\n\n  /**\n   * The method is needed to ensure we are updating the actual input value.\n   * without this our value will never change (and validation will not have the correct number)\n   * @param event - the event that was fired\n   */\n  private _onInputChange = (event: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>): void => {\n    const element: HTMLInputElement = event.target as HTMLInputElement;\n    const value: string = element.value;\n    this._valueToValidate = value;\n    this.setState({\n      value: value,\n    });\n  };\n\n  /**\n   * Update the value with the given stepFunction\n   * @param shouldSpin - should we fire off another updateValue when we are done here? This should be true\n   * when spinning in response to a mouseDown\n   * @param stepFunction - function to use to step by\n   * @param event - The event that triggered the updateValue\n   */\n  private _updateValue = (\n    shouldSpin: boolean,\n    stepDelay: number,\n    stepFunction: (\n      value: string,\n      event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    ) => string | void,\n    event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    const newValue: string | void = stepFunction(this.value || '', event);\n    if (newValue !== undefined) {\n      this._lastValidValue = newValue;\n      this.setState({ value: newValue });\n    }\n\n    if (this._spinningByMouse !== shouldSpin) {\n      this._spinningByMouse = shouldSpin;\n    }\n\n    if (shouldSpin) {\n      this._currentStepFunctionHandle = this._async.setTimeout(() => {\n        this._updateValue(shouldSpin, this._stepDelay, stepFunction, event);\n      }, stepDelay);\n    }\n  };\n\n  /**\n   * Stop spinning (clear any currently pending update and set spinning to false)\n   */\n  private _stop = (): void => {\n    if (this._currentStepFunctionHandle >= 0) {\n      this._async.clearTimeout(this._currentStepFunctionHandle);\n      this._currentStepFunctionHandle = -1;\n    }\n\n    if (this._spinningByMouse || this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      this._spinningByMouse = false;\n      this.setState({ keyboardSpinDirection: KeyboardSpinDirection.notSpinning });\n    }\n  };\n\n  /**\n   * Handle keydown on the text field. We need to update\n   * the value when up or down arrow are depressed\n   * @param event - the keyboardEvent that was fired\n   */\n  private _handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>): void => {\n    // eat the up and down arrow keys to keep focus in the spinButton\n    // (especially when a spinButton is inside of a FocusZone)\n    if (event.which === KeyCodes.up || event.which === KeyCodes.down || event.which === KeyCodes.enter) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (this.props.disabled) {\n      this._stop();\n      return;\n    }\n\n    let spinDirection = KeyboardSpinDirection.notSpinning;\n\n    switch (event.which) {\n      case KeyCodes.up:\n        spinDirection = KeyboardSpinDirection.up;\n        this._updateValue(false /* shouldSpin */, this._initialStepDelay, this._onIncrement!, event);\n        break;\n      case KeyCodes.down:\n        spinDirection = KeyboardSpinDirection.down;\n        this._updateValue(false /* shouldSpin */, this._initialStepDelay, this._onDecrement!, event);\n        break;\n      case KeyCodes.enter:\n        this._validate(event);\n        break;\n      case KeyCodes.escape:\n        if (this.value !== this._lastValidValue) {\n          this.setState({ value: this._lastValidValue });\n        }\n        break;\n      default:\n        break;\n    }\n\n    // style the increment/decrement button to look active\n    // when the corresponding up/down arrow keys trigger a step\n    if (this.state.keyboardSpinDirection !== spinDirection) {\n      this.setState({ keyboardSpinDirection: spinDirection });\n    }\n  };\n\n  /**\n   * Make sure that we have stopped spinning on keyUp\n   * if the up or down arrow fired this event\n   * @param event - keyboard event\n   */\n  private _handleKeyUp = (event: React.KeyboardEvent<HTMLElement>): void => {\n    if (this.props.disabled || event.which === KeyCodes.up || event.which === KeyCodes.down) {\n      this._stop();\n      return;\n    }\n  };\n\n  private _onIncrementMouseDown = (event: React.MouseEvent<HTMLElement>): void => {\n    this._updateValue(true /* shouldSpin */, this._initialStepDelay, this._onIncrement!, event);\n  };\n\n  private _onDecrementMouseDown = (event: React.MouseEvent<HTMLElement>): void => {\n    this._updateValue(true /* shouldSpin */, this._initialStepDelay, this._onDecrement!, event);\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}