{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { hiddenContentStyle } from '../../Styling';\nimport { initializeComponentRef, Async, divProperties, getNativeProps, getId, assign, hasOverflow, portalContainsElement, classNamesFunction, KeyCodes } from '../../Utilities';\nimport { TooltipOverflowMode } from './TooltipHost.types';\nimport { Tooltip } from './Tooltip';\nimport { TooltipDelay } from './Tooltip.types';\nvar getClassNames = classNamesFunction();\nvar TooltipHostBase = /** @class */function (_super) {\n  __extends(TooltipHostBase, _super);\n  // Constructor\n  function TooltipHostBase(props) {\n    var _this = _super.call(this, props) || this;\n    // The wrapping div that gets the hover events\n    _this._tooltipHost = React.createRef();\n    _this._defaultTooltipId = getId('tooltip');\n    _this.show = function () {\n      _this._toggleTooltip(true);\n    };\n    _this.dismiss = function () {\n      _this._hideTooltip();\n    };\n    _this._getTargetElement = function () {\n      if (!_this._tooltipHost.current) {\n        return undefined;\n      }\n      var overflowMode = _this.props.overflowMode;\n      // Select target element based on overflow mode. For parent mode, you want to position the tooltip relative\n      // to the parent element, otherwise it might look off.\n      if (overflowMode !== undefined) {\n        switch (overflowMode) {\n          case TooltipOverflowMode.Parent:\n            return _this._tooltipHost.current.parentElement;\n          case TooltipOverflowMode.Self:\n            return _this._tooltipHost.current;\n        }\n      }\n      return _this._tooltipHost.current;\n    };\n    // Show Tooltip\n    _this._onTooltipMouseEnter = function (ev) {\n      var _a = _this.props,\n        overflowMode = _a.overflowMode,\n        delay = _a.delay;\n      if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip !== _this) {\n        TooltipHostBase._currentVisibleTooltip.dismiss();\n      }\n      TooltipHostBase._currentVisibleTooltip = _this;\n      if (overflowMode !== undefined) {\n        var overflowElement = _this._getTargetElement();\n        if (overflowElement && !hasOverflow(overflowElement)) {\n          return;\n        }\n      }\n      if (ev.target && portalContainsElement(ev.target, _this._getTargetElement())) {\n        // Do not show tooltip when target is inside a portal relative to TooltipHost.\n        return;\n      }\n      _this._clearDismissTimer();\n      _this._clearOpenTimer();\n      if (delay !== TooltipDelay.zero) {\n        _this.setState({\n          isAriaPlaceholderRendered: true\n        });\n        var delayTime = _this._getDelayTime(delay); // non-null assertion because we set it in `defaultProps`\n        _this._openTimerId = _this._async.setTimeout(function () {\n          _this._toggleTooltip(true);\n        }, delayTime);\n      } else {\n        _this._toggleTooltip(true);\n      }\n    };\n    // Hide Tooltip\n    _this._onTooltipMouseLeave = function (ev) {\n      var closeDelay = _this.props.closeDelay;\n      _this._clearDismissTimer();\n      _this._clearOpenTimer();\n      if (closeDelay) {\n        _this._dismissTimerId = _this._async.setTimeout(function () {\n          _this._toggleTooltip(false);\n        }, closeDelay);\n      } else {\n        _this._toggleTooltip(false);\n      }\n      if (TooltipHostBase._currentVisibleTooltip === _this) {\n        TooltipHostBase._currentVisibleTooltip = undefined;\n      }\n    };\n    _this._onTooltipKeyDown = function (ev) {\n      if ((ev.which === KeyCodes.escape || ev.ctrlKey) && _this.state.isTooltipVisible) {\n        _this._hideTooltip();\n        ev.stopPropagation();\n      }\n    };\n    _this._clearDismissTimer = function () {\n      _this._async.clearTimeout(_this._dismissTimerId);\n    };\n    _this._clearOpenTimer = function () {\n      _this._async.clearTimeout(_this._openTimerId);\n    };\n    // Hide Tooltip\n    _this._hideTooltip = function () {\n      _this._clearOpenTimer();\n      _this._clearDismissTimer();\n      _this._toggleTooltip(false);\n    };\n    _this._toggleTooltip = function (isTooltipVisible) {\n      if (_this.state.isTooltipVisible !== isTooltipVisible) {\n        _this.setState({\n          isAriaPlaceholderRendered: false,\n          isTooltipVisible: isTooltipVisible\n        }, function () {\n          return _this.props.onTooltipToggle && _this.props.onTooltipToggle(isTooltipVisible);\n        });\n      }\n    };\n    _this._getDelayTime = function (delay) {\n      switch (delay) {\n        case TooltipDelay.medium:\n          return 300;\n        case TooltipDelay.long:\n          return 500;\n        default:\n          return 0;\n      }\n    };\n    initializeComponentRef(_this);\n    _this.state = {\n      isAriaPlaceholderRendered: false,\n      isTooltipVisible: false\n    };\n    _this._async = new Async(_this);\n    return _this;\n  }\n  // Render\n  TooltipHostBase.prototype.render = function () {\n    var _a = this.props,\n      calloutProps = _a.calloutProps,\n      children = _a.children,\n      content = _a.content,\n      directionalHint = _a.directionalHint,\n      directionalHintForRTL = _a.directionalHintForRTL,\n      className = _a.hostClassName,\n      id = _a.id,\n      _b = _a.setAriaDescribedBy,\n      setAriaDescribedBy = _b === void 0 ? true : _b,\n      tooltipProps = _a.tooltipProps,\n      styles = _a.styles,\n      theme = _a.theme;\n    this._classNames = getClassNames(styles, {\n      theme: theme,\n      className: className\n    });\n    var _c = this.state,\n      isAriaPlaceholderRendered = _c.isAriaPlaceholderRendered,\n      isTooltipVisible = _c.isTooltipVisible;\n    var tooltipId = id || this._defaultTooltipId;\n    var isContentPresent = !!(content || tooltipProps && tooltipProps.onRenderContent && tooltipProps.onRenderContent());\n    var showTooltip = isTooltipVisible && isContentPresent;\n    var ariaDescribedBy = setAriaDescribedBy && isTooltipVisible && isContentPresent ? tooltipId : undefined;\n    return React.createElement(\"div\", __assign({\n      className: this._classNames.root,\n      ref: this._tooltipHost\n    }, {\n      onFocusCapture: this._onTooltipMouseEnter\n    }, {\n      onBlurCapture: this._hideTooltip\n    }, {\n      onMouseEnter: this._onTooltipMouseEnter,\n      onMouseLeave: this._onTooltipMouseLeave,\n      onKeyDown: this._onTooltipKeyDown,\n      \"aria-describedby\": ariaDescribedBy\n    }), children, showTooltip && React.createElement(Tooltip, __assign({\n      id: tooltipId,\n      content: content,\n      targetElement: this._getTargetElement(),\n      directionalHint: directionalHint,\n      directionalHintForRTL: directionalHintForRTL,\n      calloutProps: assign({}, calloutProps, {\n        onDismiss: this._hideTooltip,\n        onMouseEnter: this._onTooltipMouseEnter,\n        onMouseLeave: this._onTooltipMouseLeave\n      }),\n      onMouseEnter: this._onTooltipMouseEnter,\n      onMouseLeave: this._onTooltipMouseLeave\n    }, getNativeProps(this.props, divProperties), tooltipProps)), isAriaPlaceholderRendered && React.createElement(\"div\", {\n      id: tooltipId,\n      style: hiddenContentStyle\n    }, content));\n  };\n  TooltipHostBase.prototype.componentWillUnmount = function () {\n    if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip === this) {\n      TooltipHostBase._currentVisibleTooltip = undefined;\n    }\n    this._async.dispose();\n  };\n  TooltipHostBase.defaultProps = {\n    delay: TooltipDelay.medium\n  };\n  return TooltipHostBase;\n}(React.Component);\nexport { TooltipHostBase };","map":{"version":3,"sources":["components/Tooltip/TooltipHost.base.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAK,MAAM,OAAO;AAC9B,SAAS,kBAAkB,QAAQ,eAAe;AAClD,SACE,sBAAsB,EACtB,KAAK,EACL,aAAa,EACb,cAAc,EACd,KAAK,EACL,MAAM,EACN,WAAW,EACX,qBAAqB,EACrB,kBAAkB,EAClB,QAAQ,QACH,iBAAiB;AACxB,SAEE,mBAAmB,QAId,qBAAqB;AAC5B,SAAS,OAAO,QAAQ,WAAW;AACnC,SAAS,YAAY,QAAQ,iBAAiB;AAO9C,IAAM,aAAa,GAAG,kBAAkB,CAAA,CAA8C;AAEtF,IAAA,eAAA,GAAA,aAAA,UAAA,MAAA,EAAA;EAAqC,SAAA,CAAA,eAAA,EAAA,MAAA,CAAA;EAgBnC;EACA,SAAA,eAAA,CAAY,KAAwB,EAAA;IAApC,IAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAK,CAAC,IAAA,IAAA;IAXd;IACQ,KAAA,CAAA,YAAY,GAAG,KAAK,CAAC,SAAS,CAAA,CAAkB;IAMhD,KAAA,CAAA,iBAAiB,GAAG,KAAK,CAAC,SAAS,CAAC;IA6FrC,KAAA,CAAA,IAAI,GAAG,YAAA;MACZ,KAAI,CAAC,cAAc,CAAC,IAAI,CAAC;IAC3B,CAAC;IAEM,KAAA,CAAA,OAAO,GAAG,YAAA;MACf,KAAI,CAAC,YAAY,CAAA,CAAE;IACrB,CAAC;IAEO,KAAA,CAAA,iBAAiB,GAAG,YAAA;MAC1B,IAAI,CAAC,KAAI,CAAC,YAAY,CAAC,OAAO,EAAE;QAC9B,OAAO,SAAS;MACjB;MAEO,IAAA,YAAA,GAAA,KAAA,CAAA,KAAA,CAAA,YAAY;MAEpB;MACA;MACA,IAAI,YAAY,KAAK,SAAS,EAAE;QAC9B,QAAQ,YAAY;UAClB,KAAK,mBAAmB,CAAC,MAAM;YAC7B,OAAO,KAAI,CAAC,YAAY,CAAC,OAAO,CAAC,aAAc;UAEjD,KAAK,mBAAmB,CAAC,IAAI;YAC3B,OAAO,KAAI,CAAC,YAAY,CAAC,OAAO;QACnC;MACF;MAED,OAAO,KAAI,CAAC,YAAY,CAAC,OAAO;IAClC,CAAC;IAED;IACQ,KAAA,CAAA,oBAAoB,GAAG,UAAC,EAAO,EAAA;MAC/B,IAAA,EAAA,GAAA,KAAA,CAAA,KAAoC;QAAlC,YAAA,GAAA,EAAA,CAAA,YAAY;QAAE,KAAA,GAAA,EAAA,CAAA,KAAoB;MAE1C,IAAI,eAAe,CAAC,sBAAsB,IAAI,eAAe,CAAC,sBAAsB,KAAK,KAAI,EAAE;QAC7F,eAAe,CAAC,sBAAsB,CAAC,OAAO,CAAA,CAAE;MACjD;MACD,eAAe,CAAC,sBAAsB,GAAG,KAAI;MAE7C,IAAI,YAAY,KAAK,SAAS,EAAE;QAC9B,IAAM,eAAe,GAAG,KAAI,CAAC,iBAAiB,CAAA,CAAE;QAChD,IAAI,eAAe,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,EAAE;UACpD;QACD;MACF;MAED,IAAI,EAAE,CAAC,MAAM,IAAI,qBAAqB,CAAC,EAAE,CAAC,MAAqB,EAAE,KAAI,CAAC,iBAAiB,CAAA,CAAE,CAAC,EAAE;QAC1F;QACA;MACD;MAED,KAAI,CAAC,kBAAkB,CAAA,CAAE;MACzB,KAAI,CAAC,eAAe,CAAA,CAAE;MAEtB,IAAI,KAAK,KAAK,YAAY,CAAC,IAAI,EAAE;QAC/B,KAAI,CAAC,QAAQ,CAAC;UAAE,yBAAyB,EAAE;QAAI,CAAE,CAAC;QAClD,IAAM,SAAS,GAAG,KAAI,CAAC,aAAa,CAAC,KAAM,CAAC,CAAC,CAAC;QAE9C,KAAI,CAAC,YAAY,GAAG,KAAI,CAAC,MAAM,CAAC,UAAU,CAAC,YAAA;UACzC,KAAI,CAAC,cAAc,CAAC,IAAI,CAAC;QAC3B,CAAC,EAAE,SAAS,CAAC;OACd,MAAM;QACL,KAAI,CAAC,cAAc,CAAC,IAAI,CAAC;MAC1B;IACH,CAAC;IAED;IACQ,KAAA,CAAA,oBAAoB,GAAG,UAAC,EAAO,EAAA;MAC7B,IAAA,UAAA,GAAA,KAAA,CAAA,KAAA,CAAA,UAAU;MAElB,KAAI,CAAC,kBAAkB,CAAA,CAAE;MACzB,KAAI,CAAC,eAAe,CAAA,CAAE;MAEtB,IAAI,UAAU,EAAE;QACd,KAAI,CAAC,eAAe,GAAG,KAAI,CAAC,MAAM,CAAC,UAAU,CAAC,YAAA;UAC5C,KAAI,CAAC,cAAc,CAAC,KAAK,CAAC;QAC5B,CAAC,EAAE,UAAU,CAAC;OACf,MAAM;QACL,KAAI,CAAC,cAAc,CAAC,KAAK,CAAC;MAC3B;MAED,IAAI,eAAe,CAAC,sBAAsB,KAAK,KAAI,EAAE;QACnD,eAAe,CAAC,sBAAsB,GAAG,SAAS;MACnD;IACH,CAAC;IAEO,KAAA,CAAA,iBAAiB,GAAG,UAAC,EAAoC,EAAA;MAC/D,IAAI,CAAC,EAAE,CAAC,KAAK,KAAK,QAAQ,CAAC,MAAM,IAAI,EAAE,CAAC,OAAO,KAAK,KAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE;QAC/E,KAAI,CAAC,YAAY,CAAA,CAAE;QACnB,EAAE,CAAC,eAAe,CAAA,CAAE;MACrB;IACH,CAAC;IAEO,KAAA,CAAA,kBAAkB,GAAG,YAAA;MAC3B,KAAI,CAAC,MAAM,CAAC,YAAY,CAAC,KAAI,CAAC,eAAe,CAAC;IAChD,CAAC;IAEO,KAAA,CAAA,eAAe,GAAG,YAAA;MACxB,KAAI,CAAC,MAAM,CAAC,YAAY,CAAC,KAAI,CAAC,YAAY,CAAC;IAC7C,CAAC;IAED;IACQ,KAAA,CAAA,YAAY,GAAG,YAAA;MACrB,KAAI,CAAC,eAAe,CAAA,CAAE;MACtB,KAAI,CAAC,kBAAkB,CAAA,CAAE;MACzB,KAAI,CAAC,cAAc,CAAC,KAAK,CAAC;IAC5B,CAAC;IAEO,KAAA,CAAA,cAAc,GAAG,UAAC,gBAAyB,EAAA;MACjD,IAAI,KAAI,CAAC,KAAK,CAAC,gBAAgB,KAAK,gBAAgB,EAAE;QACpD,KAAI,CAAC,QAAQ,CACX;UAAE,yBAAyB,EAAE,KAAK;UAAE,gBAAgB,EAAA;QAAA,CAAE,EACtD,YAAA;UAAM,OAAA,KAAI,CAAC,KAAK,CAAC,eAAe,IAAI,KAAI,CAAC,KAAK,CAAC,eAAe,CAAC,gBAAgB,CAAC;QAA1E,CAA0E,CACjF;MACF;IACH,CAAC;IAEO,KAAA,CAAA,aAAa,GAAG,UAAC,KAAmB,EAAA;MAC1C,QAAQ,KAAK;QACX,KAAK,YAAY,CAAC,MAAM;UACtB,OAAO,GAAG;QACZ,KAAK,YAAY,CAAC,IAAI;UACpB,OAAO,GAAG;QACZ;UACE,OAAO,CAAC;MACX;IACH,CAAC;IArNC,sBAAsB,CAAC,KAAI,CAAC;IAE5B,KAAI,CAAC,KAAK,GAAG;MACX,yBAAyB,EAAE,KAAK;MAChC,gBAAgB,EAAE;KACnB;IAED,KAAI,CAAC,MAAM,GAAG,IAAI,KAAK,CAAC,KAAI,CAAC;;EAC/B;EAEA;EACO,eAAA,CAAA,SAAA,CAAA,MAAM,GAAb,YAAA;IACQ,IAAA,EAAA,GAAA,IAAA,CAAA,KAYQ;MAXZ,YAAA,GAAA,EAAA,CAAA,YAAY;MACZ,QAAA,GAAA,EAAA,CAAA,QAAQ;MACR,OAAA,GAAA,EAAA,CAAA,OAAO;MACP,eAAA,GAAA,EAAA,CAAA,eAAe;MACf,qBAAA,GAAA,EAAA,CAAA,qBAAqB;MACrB,SAAA,GAAA,EAAA,CAAA,aAAwB;MACxB,EAAA,GAAA,EAAA,CAAA,EAAE;MACF,EAAA,GAAA,EAAA,CAAA,kBAAyB;MAAzB,kBAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,IAAA,GAAA,EAAyB;MACzB,YAAA,GAAA,EAAA,CAAA,YAAY;MACZ,MAAA,GAAA,EAAA,CAAA,MAAM;MACN,KAAA,GAAA,EAAA,CAAA,KACY;IAEd,IAAI,CAAC,WAAW,GAAG,aAAa,CAAC,MAAO,EAAE;MACxC,KAAK,EAAE,KAAM;MACb,SAAS,EAAA;KACV,CAAC;IAEI,IAAA,EAAA,GAAA,IAAA,CAAA,KAA4D;MAA1D,yBAAA,GAAA,EAAA,CAAA,yBAAyB;MAAE,gBAAA,GAAA,EAAA,CAAA,gBAA+B;IAClE,IAAM,SAAS,GAAG,EAAE,IAAI,IAAI,CAAC,iBAAiB;IAC9C,IAAM,gBAAgB,GAAG,CAAC,EACxB,OAAO,IACN,YAAY,IAAI,YAAY,CAAC,eAAe,IAAI,YAAY,CAAC,eAAe,CAAA,CAAG,CACjF;IACD,IAAM,WAAW,GAAG,gBAAgB,IAAI,gBAAgB;IACxD,IAAM,eAAe,GAAG,kBAAkB,IAAI,gBAAgB,IAAI,gBAAgB,GAAG,SAAS,GAAG,SAAS;IAE1G,OACE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA,QAAA,CAAA;MACE,SAAS,EAAE,IAAI,CAAC,WAAW,CAAC,IAAI;MAChC,GAAG,EAAE,IAAI,CAAC;IAAY,CAAA,EAClB;MAAE,cAAc,EAAE,IAAI,CAAC;IAAoB,CAAE,EAC7C;MAAE,aAAa,EAAE,IAAI,CAAC;IAAY,CAAE,EAAA;MACxC,YAAY,EAAE,IAAI,CAAC,oBAAoB;MACvC,YAAY,EAAE,IAAI,CAAC,oBAAoB;MACvC,SAAS,EAAE,IAAI,CAAC,iBAAiB;MAAA,kBAAA,EACf;IAAe,CAAA,CAAA,EAEhC,QAAQ,EACR,WAAW,IACV,KAAA,CAAA,aAAA,CAAC,OAAO,EAAA,QAAA,CAAA;MACN,EAAE,EAAE,SAAS;MACb,OAAO,EAAE,OAAO;MAChB,aAAa,EAAE,IAAI,CAAC,iBAAiB,CAAA,CAAE;MACvC,eAAe,EAAE,eAAe;MAChC,qBAAqB,EAAE,qBAAqB;MAC5C,YAAY,EAAE,MAAM,CAAC,CAAA,CAAE,EAAE,YAAY,EAAE;QACrC,SAAS,EAAE,IAAI,CAAC,YAAY;QAC5B,YAAY,EAAE,IAAI,CAAC,oBAAoB;QACvC,YAAY,EAAE,IAAI,CAAC;OACpB,CAAC;MACF,YAAY,EAAE,IAAI,CAAC,oBAAoB;MACvC,YAAY,EAAE,IAAI,CAAC;IAAoB,CAAA,EACnC,cAAc,CAAC,IAAI,CAAC,KAAK,EAAE,aAAa,CAAC,EACzC,YAAY,CAAA,CAEnB,EACA,yBAAyB,IACxB,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;MAAK,EAAE,EAAE,SAAS;MAAE,KAAK,EAAE;IAAyC,CAAA,EACjE,OAAO,CAEX,CACG;EAEV,CAAC;EAEM,eAAA,CAAA,SAAA,CAAA,oBAAoB,GAA3B,YAAA;IACE,IAAI,eAAe,CAAC,sBAAsB,IAAI,eAAe,CAAC,sBAAsB,KAAK,IAAI,EAAE;MAC7F,eAAe,CAAC,sBAAsB,GAAG,SAAS;IACnD;IAED,IAAI,CAAC,MAAM,CAAC,OAAO,CAAA,CAAE;EACvB,CAAC;EAxGa,eAAA,CAAA,YAAY,GAAG;IAC3B,KAAK,EAAE,YAAY,CAAC;GACrB;EAuOH,OAAA,eAAC;CAAA,CA1OoC,KAAK,CAAC,SAAS,CAAA;SAAvC,eAAe","sourcesContent":["import * as React from 'react';\nimport { hiddenContentStyle } from '../../Styling';\nimport {\n  initializeComponentRef,\n  Async,\n  divProperties,\n  getNativeProps,\n  getId,\n  assign,\n  hasOverflow,\n  portalContainsElement,\n  classNamesFunction,\n  KeyCodes,\n} from '../../Utilities';\nimport {\n  ITooltipHostProps,\n  TooltipOverflowMode,\n  ITooltipHostStyles,\n  ITooltipHostStyleProps,\n  ITooltipHost,\n} from './TooltipHost.types';\nimport { Tooltip } from './Tooltip';\nimport { TooltipDelay } from './Tooltip.types';\n\nexport interface ITooltipHostState {\n  isAriaPlaceholderRendered: boolean;\n  isTooltipVisible: boolean;\n}\n\nconst getClassNames = classNamesFunction<ITooltipHostStyleProps, ITooltipHostStyles>();\n\nexport class TooltipHostBase extends React.Component<ITooltipHostProps, ITooltipHostState> implements ITooltipHost {\n  public static defaultProps = {\n    delay: TooltipDelay.medium,\n  };\n\n  private static _currentVisibleTooltip: ITooltipHost | undefined;\n\n  // The wrapping div that gets the hover events\n  private _tooltipHost = React.createRef<HTMLDivElement>();\n\n  private _classNames: { [key in keyof ITooltipHostStyles]: string };\n  private _async: Async;\n  private _dismissTimerId: number;\n  private _openTimerId: number;\n  private _defaultTooltipId = getId('tooltip');\n\n  // Constructor\n  constructor(props: ITooltipHostProps) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    this.state = {\n      isAriaPlaceholderRendered: false,\n      isTooltipVisible: false,\n    };\n\n    this._async = new Async(this);\n  }\n\n  // Render\n  public render(): JSX.Element {\n    const {\n      calloutProps,\n      children,\n      content,\n      directionalHint,\n      directionalHintForRTL,\n      hostClassName: className,\n      id,\n      setAriaDescribedBy = true,\n      tooltipProps,\n      styles,\n      theme,\n    } = this.props;\n\n    this._classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n    });\n\n    const { isAriaPlaceholderRendered, isTooltipVisible } = this.state;\n    const tooltipId = id || this._defaultTooltipId;\n    const isContentPresent = !!(\n      content ||\n      (tooltipProps && tooltipProps.onRenderContent && tooltipProps.onRenderContent())\n    );\n    const showTooltip = isTooltipVisible && isContentPresent;\n    const ariaDescribedBy = setAriaDescribedBy && isTooltipVisible && isContentPresent ? tooltipId : undefined;\n\n    return (\n      <div\n        className={this._classNames.root}\n        ref={this._tooltipHost}\n        {...{ onFocusCapture: this._onTooltipMouseEnter }}\n        {...{ onBlurCapture: this._hideTooltip }}\n        onMouseEnter={this._onTooltipMouseEnter}\n        onMouseLeave={this._onTooltipMouseLeave}\n        onKeyDown={this._onTooltipKeyDown}\n        aria-describedby={ariaDescribedBy}\n      >\n        {children}\n        {showTooltip && (\n          <Tooltip\n            id={tooltipId}\n            content={content}\n            targetElement={this._getTargetElement()}\n            directionalHint={directionalHint}\n            directionalHintForRTL={directionalHintForRTL}\n            calloutProps={assign({}, calloutProps, {\n              onDismiss: this._hideTooltip,\n              onMouseEnter: this._onTooltipMouseEnter,\n              onMouseLeave: this._onTooltipMouseLeave,\n            })}\n            onMouseEnter={this._onTooltipMouseEnter}\n            onMouseLeave={this._onTooltipMouseLeave}\n            {...getNativeProps(this.props, divProperties)}\n            {...tooltipProps}\n          />\n        )}\n        {isAriaPlaceholderRendered && (\n          <div id={tooltipId} style={hiddenContentStyle as React.CSSProperties}>\n            {content}\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  public componentWillUnmount(): void {\n    if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip === this) {\n      TooltipHostBase._currentVisibleTooltip = undefined;\n    }\n\n    this._async.dispose();\n  }\n\n  public show = (): void => {\n    this._toggleTooltip(true);\n  };\n\n  public dismiss = (): void => {\n    this._hideTooltip();\n  };\n\n  private _getTargetElement = (): HTMLElement | undefined => {\n    if (!this._tooltipHost.current) {\n      return undefined;\n    }\n\n    const { overflowMode } = this.props;\n\n    // Select target element based on overflow mode. For parent mode, you want to position the tooltip relative\n    // to the parent element, otherwise it might look off.\n    if (overflowMode !== undefined) {\n      switch (overflowMode) {\n        case TooltipOverflowMode.Parent:\n          return this._tooltipHost.current.parentElement!;\n\n        case TooltipOverflowMode.Self:\n          return this._tooltipHost.current;\n      }\n    }\n\n    return this._tooltipHost.current;\n  };\n\n  // Show Tooltip\n  private _onTooltipMouseEnter = (ev: any): void => {\n    const { overflowMode, delay } = this.props;\n\n    if (TooltipHostBase._currentVisibleTooltip && TooltipHostBase._currentVisibleTooltip !== this) {\n      TooltipHostBase._currentVisibleTooltip.dismiss();\n    }\n    TooltipHostBase._currentVisibleTooltip = this;\n\n    if (overflowMode !== undefined) {\n      const overflowElement = this._getTargetElement();\n      if (overflowElement && !hasOverflow(overflowElement)) {\n        return;\n      }\n    }\n\n    if (ev.target && portalContainsElement(ev.target as HTMLElement, this._getTargetElement())) {\n      // Do not show tooltip when target is inside a portal relative to TooltipHost.\n      return;\n    }\n\n    this._clearDismissTimer();\n    this._clearOpenTimer();\n\n    if (delay !== TooltipDelay.zero) {\n      this.setState({ isAriaPlaceholderRendered: true });\n      const delayTime = this._getDelayTime(delay!); // non-null assertion because we set it in `defaultProps`\n\n      this._openTimerId = this._async.setTimeout(() => {\n        this._toggleTooltip(true);\n      }, delayTime);\n    } else {\n      this._toggleTooltip(true);\n    }\n  };\n\n  // Hide Tooltip\n  private _onTooltipMouseLeave = (ev: any): void => {\n    const { closeDelay } = this.props;\n\n    this._clearDismissTimer();\n    this._clearOpenTimer();\n\n    if (closeDelay) {\n      this._dismissTimerId = this._async.setTimeout(() => {\n        this._toggleTooltip(false);\n      }, closeDelay);\n    } else {\n      this._toggleTooltip(false);\n    }\n\n    if (TooltipHostBase._currentVisibleTooltip === this) {\n      TooltipHostBase._currentVisibleTooltip = undefined;\n    }\n  };\n\n  private _onTooltipKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    if ((ev.which === KeyCodes.escape || ev.ctrlKey) && this.state.isTooltipVisible) {\n      this._hideTooltip();\n      ev.stopPropagation();\n    }\n  };\n\n  private _clearDismissTimer = (): void => {\n    this._async.clearTimeout(this._dismissTimerId);\n  };\n\n  private _clearOpenTimer = (): void => {\n    this._async.clearTimeout(this._openTimerId);\n  };\n\n  // Hide Tooltip\n  private _hideTooltip = (): void => {\n    this._clearOpenTimer();\n    this._clearDismissTimer();\n    this._toggleTooltip(false);\n  };\n\n  private _toggleTooltip = (isTooltipVisible: boolean): void => {\n    if (this.state.isTooltipVisible !== isTooltipVisible) {\n      this.setState(\n        { isAriaPlaceholderRendered: false, isTooltipVisible },\n        () => this.props.onTooltipToggle && this.props.onTooltipToggle(isTooltipVisible),\n      );\n    }\n  };\n\n  private _getDelayTime = (delay: TooltipDelay): number => {\n    switch (delay) {\n      case TooltipDelay.medium:\n        return 300;\n      case TooltipDelay.long:\n        return 500;\n      default:\n        return 0;\n    }\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}