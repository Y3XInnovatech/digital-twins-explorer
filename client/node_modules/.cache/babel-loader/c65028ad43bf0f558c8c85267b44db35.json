{"ast":null,"code":"import { __assign } from \"tslib\";\nexport var InjectionMode = {\n  /**\n   * Avoids style injection, use getRules() to read the styles.\n   */\n  none: 0,\n  /**\n   * Inserts rules using the insertRule api.\n   */\n  insertNode: 1,\n  /**\n   * Appends rules using appendChild.\n   */\n  appendChild: 2\n};\nvar STYLESHEET_SETTING = '__stylesheet__';\n/**\n * MSIE 11 doesn't cascade styles based on DOM ordering, but rather on the order that each style node\n * is created. As such, to maintain consistent priority, IE11 should reuse a single style node.\n */\nvar REUSE_STYLE_NODE = typeof navigator !== 'undefined' && /rv:11.0/.test(navigator.userAgent);\nvar _global = {};\n// Grab window.\ntry {\n  _global = window;\n} catch (_a) {\n  /* leave as blank object */\n}\nvar _stylesheet;\n/**\n * Represents the state of styles registered in the page. Abstracts\n * the surface for adding styles to the stylesheet, exposes helpers\n * for reading the styles registered in server rendered scenarios.\n *\n * @public\n */\nvar Stylesheet = /** @class */function () {\n  function Stylesheet(config) {\n    this._rules = [];\n    this._preservedRules = [];\n    this._rulesToInsert = [];\n    this._counter = 0;\n    this._keyToClassName = {};\n    this._onResetCallbacks = [];\n    this._classNameToArgs = {};\n    this._config = __assign({\n      injectionMode: InjectionMode.insertNode,\n      defaultPrefix: 'css',\n      namespace: undefined,\n      cspSettings: undefined\n    }, config);\n    this._keyToClassName = this._config.classNameCache || {};\n  }\n  /**\n   * Gets the singleton instance.\n   */\n  Stylesheet.getInstance = function () {\n    var _a;\n    _stylesheet = _global[STYLESHEET_SETTING];\n    if (!_stylesheet || _stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== document) {\n      var fabricConfig = ((_a = _global) === null || _a === void 0 ? void 0 : _a.FabricConfig) || {};\n      _stylesheet = _global[STYLESHEET_SETTING] = new Stylesheet(fabricConfig.mergeStyles);\n    }\n    return _stylesheet;\n  };\n  /**\n   * Configures the stylesheet.\n   */\n  Stylesheet.prototype.setConfig = function (config) {\n    this._config = __assign(__assign({}, this._config), config);\n  };\n  /**\n   * Configures a reset callback.\n   *\n   * @param callback - A callback which will be called when the Stylesheet is reset.\n   */\n  Stylesheet.prototype.onReset = function (callback) {\n    this._onResetCallbacks.push(callback);\n  };\n  /**\n   * Generates a unique classname.\n   *\n   * @param displayName - Optional value to use as a prefix.\n   */\n  Stylesheet.prototype.getClassName = function (displayName) {\n    var namespace = this._config.namespace;\n    var prefix = displayName || this._config.defaultPrefix;\n    return \"\" + (namespace ? namespace + '-' : '') + prefix + \"-\" + this._counter++;\n  };\n  /**\n   * Used internally to cache information about a class which was\n   * registered with the stylesheet.\n   */\n  Stylesheet.prototype.cacheClassName = function (className, key, args, rules) {\n    this._keyToClassName[key] = className;\n    this._classNameToArgs[className] = {\n      args: args,\n      rules: rules\n    };\n  };\n  /**\n   * Gets the appropriate classname given a key which was previously\n   * registered using cacheClassName.\n   */\n  Stylesheet.prototype.classNameFromKey = function (key) {\n    return this._keyToClassName[key];\n  };\n  /**\n   * Gets all classnames cache with the stylesheet.\n   */\n  Stylesheet.prototype.getClassNameCache = function () {\n    return this._keyToClassName;\n  };\n  /**\n   * Gets the arguments associated with a given classname which was\n   * previously registered using cacheClassName.\n   */\n  Stylesheet.prototype.argsFromClassName = function (className) {\n    var entry = this._classNameToArgs[className];\n    return entry && entry.args;\n  };\n  /**\n   * Gets the arguments associated with a given classname which was\n   * previously registered using cacheClassName.\n   */\n  Stylesheet.prototype.insertedRulesFromClassName = function (className) {\n    var entry = this._classNameToArgs[className];\n    return entry && entry.rules;\n  };\n  /**\n   * Inserts a css rule into the stylesheet.\n   * @param preserve - Preserves the rule beyond a reset boundary.\n   */\n  Stylesheet.prototype.insertRule = function (rule, preserve) {\n    var injectionMode = this._config.injectionMode;\n    var element = injectionMode !== InjectionMode.none ? this._getStyleElement() : undefined;\n    if (preserve) {\n      this._preservedRules.push(rule);\n    }\n    if (element) {\n      switch (this._config.injectionMode) {\n        case InjectionMode.insertNode:\n          var sheet = element.sheet;\n          try {\n            sheet.insertRule(rule, sheet.cssRules.length);\n          } catch (e) {\n            // The browser will throw exceptions on unsupported rules (such as a moz prefix in webkit.)\n            // We need to swallow the exceptions for this scenario, otherwise we'd need to filter\n            // which could be slower and bulkier.\n          }\n          break;\n        case InjectionMode.appendChild:\n          element.appendChild(document.createTextNode(rule));\n          break;\n      }\n    } else {\n      this._rules.push(rule);\n    }\n    if (this._config.onInsertRule) {\n      this._config.onInsertRule(rule);\n    }\n  };\n  /**\n   * Gets all rules registered with the stylesheet; only valid when\n   * using InsertionMode.none.\n   */\n  Stylesheet.prototype.getRules = function (includePreservedRules) {\n    return (includePreservedRules ? this._preservedRules.join('') : '') + this._rules.join('') + this._rulesToInsert.join('');\n  };\n  /**\n   * Resets the internal state of the stylesheet. Only used in server\n   * rendered scenarios where we're using InsertionMode.none.\n   */\n  Stylesheet.prototype.reset = function () {\n    this._rules = [];\n    this._rulesToInsert = [];\n    this._counter = 0;\n    this._classNameToArgs = {};\n    this._keyToClassName = {};\n    this._onResetCallbacks.forEach(function (callback) {\n      return callback();\n    });\n  };\n  // Forces the regeneration of incoming styles without totally resetting the stylesheet.\n  Stylesheet.prototype.resetKeys = function () {\n    this._keyToClassName = {};\n  };\n  Stylesheet.prototype._getStyleElement = function () {\n    var _this = this;\n    if (!this._styleElement && typeof document !== 'undefined') {\n      this._styleElement = this._createStyleElement();\n      if (!REUSE_STYLE_NODE) {\n        // Reset the style element on the next frame.\n        window.requestAnimationFrame(function () {\n          _this._styleElement = undefined;\n        });\n      }\n    }\n    return this._styleElement;\n  };\n  Stylesheet.prototype._createStyleElement = function () {\n    var head = document.head;\n    var styleElement = document.createElement('style');\n    styleElement.setAttribute('data-merge-styles', 'true');\n    var cspSettings = this._config.cspSettings;\n    if (cspSettings) {\n      if (cspSettings.nonce) {\n        styleElement.setAttribute('nonce', cspSettings.nonce);\n      }\n    }\n    if (this._lastStyleElement) {\n      // If the `nextElementSibling` is null, then the insertBefore will act as a regular append.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore#Syntax\n      head.insertBefore(styleElement, this._lastStyleElement.nextElementSibling);\n    } else {\n      var placeholderStyleTag = this._findPlaceholderStyleTag();\n      if (placeholderStyleTag) {\n        head.insertBefore(styleElement, placeholderStyleTag.nextElementSibling);\n      } else {\n        head.insertBefore(styleElement, head.childNodes[0]);\n      }\n    }\n    this._lastStyleElement = styleElement;\n    return styleElement;\n  };\n  Stylesheet.prototype._findPlaceholderStyleTag = function () {\n    var head = document.head;\n    if (head) {\n      return head.querySelector('style[data-merge-styles]');\n    }\n    return null;\n  };\n  return Stylesheet;\n}();\nexport { Stylesheet };","map":{"version":3,"sources":["Stylesheet.ts"],"names":[],"mappings":"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","sourcesContent":["import { IStyle } from './IStyle';\n\nexport const InjectionMode = {\n  /**\n   * Avoids style injection, use getRules() to read the styles.\n   */\n  none: 0 as 0,\n\n  /**\n   * Inserts rules using the insertRule api.\n   */\n  insertNode: 1 as 1,\n\n  /**\n   * Appends rules using appendChild.\n   */\n  appendChild: 2 as 2,\n};\n\nexport type InjectionMode = typeof InjectionMode[keyof typeof InjectionMode];\n\n/**\n * CSP settings for the stylesheet\n */\nexport interface ICSPSettings {\n  /**\n   * Nonce to inject into script tag\n   */\n  nonce?: string;\n}\n\n/**\n * Stylesheet config.\n *\n * @public\n */\nexport interface IStyleSheetConfig {\n  /**\n   * Injection mode for how rules are inserted.\n   */\n  injectionMode?: InjectionMode;\n\n  /**\n   * Default 'displayName' to use for a className.\n   * @defaultvalue 'css'\n   */\n  defaultPrefix?: string;\n\n  /**\n   * Defines the default direction of rules for auto-rtlifying things.\n   * While typically this is represented as a DIR attribute in the markup,\n   * the DIR is not enough to control whether padding goes on the left or\n   * right. Use this to set the default direction when rules are registered.\n   */\n  rtl?: boolean;\n\n  /**\n   * Default 'namespace' to attach before the className.\n   */\n  namespace?: string;\n\n  /**\n   * CSP settings\n   */\n  cspSettings?: ICSPSettings;\n\n  /**\n   * Callback executed when a rule is inserted.\n   */\n  onInsertRule?: (rule: string) => void;\n\n  /**\n   * Initial value for classnames cache. Key is serialized css rules associated with a classname.\n   */\n  classNameCache?: { [key: string]: string };\n}\n\nconst STYLESHEET_SETTING = '__stylesheet__';\n/**\n * MSIE 11 doesn't cascade styles based on DOM ordering, but rather on the order that each style node\n * is created. As such, to maintain consistent priority, IE11 should reuse a single style node.\n */\nconst REUSE_STYLE_NODE = typeof navigator !== 'undefined' && /rv:11.0/.test(navigator.userAgent);\n\nlet _global: { [key: string]: any } = {};\n\n// Grab window.\ntry {\n  _global = window;\n} catch {\n  /* leave as blank object */\n}\n\nlet _stylesheet: Stylesheet;\n\n/**\n * Represents the state of styles registered in the page. Abstracts\n * the surface for adding styles to the stylesheet, exposes helpers\n * for reading the styles registered in server rendered scenarios.\n *\n * @public\n */\nexport class Stylesheet {\n  private _lastStyleElement?: HTMLStyleElement;\n  private _styleElement?: HTMLStyleElement;\n  private _rules: string[] = [];\n  private _preservedRules: string[] = [];\n  private _config: IStyleSheetConfig;\n  private _rulesToInsert: string[] = [];\n  private _counter = 0;\n  private _keyToClassName: { [key: string]: string } = {};\n  private _onResetCallbacks: (() => void)[] = [];\n\n  private _classNameToArgs: { [key: string]: { args: any; rules: string[] } } = {};\n\n  /**\n   * Gets the singleton instance.\n   */\n  public static getInstance(): Stylesheet {\n    _stylesheet = _global[STYLESHEET_SETTING] as Stylesheet;\n\n    if (!_stylesheet || (_stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== document)) {\n      const fabricConfig = _global?.FabricConfig || {};\n\n      _stylesheet = _global[STYLESHEET_SETTING] = new Stylesheet(fabricConfig.mergeStyles);\n    }\n\n    return _stylesheet;\n  }\n\n  constructor(config?: IStyleSheetConfig) {\n    this._config = {\n      injectionMode: InjectionMode.insertNode,\n      defaultPrefix: 'css',\n      namespace: undefined,\n      cspSettings: undefined,\n      ...config,\n    };\n\n    this._keyToClassName = this._config.classNameCache || {};\n  }\n\n  /**\n   * Configures the stylesheet.\n   */\n  public setConfig(config?: IStyleSheetConfig): void {\n    this._config = {\n      ...this._config,\n      ...config,\n    };\n  }\n\n  /**\n   * Configures a reset callback.\n   *\n   * @param callback - A callback which will be called when the Stylesheet is reset.\n   */\n  public onReset(callback: () => void): void {\n    this._onResetCallbacks.push(callback);\n  }\n\n  /**\n   * Generates a unique classname.\n   *\n   * @param displayName - Optional value to use as a prefix.\n   */\n  public getClassName(displayName?: string): string {\n    const { namespace } = this._config;\n    const prefix = displayName || this._config.defaultPrefix;\n\n    return `${namespace ? namespace + '-' : ''}${prefix}-${this._counter++}`;\n  }\n\n  /**\n   * Used internally to cache information about a class which was\n   * registered with the stylesheet.\n   */\n  public cacheClassName(className: string, key: string, args: IStyle[], rules: string[]): void {\n    this._keyToClassName[key] = className;\n    this._classNameToArgs[className] = {\n      args,\n      rules,\n    };\n  }\n\n  /**\n   * Gets the appropriate classname given a key which was previously\n   * registered using cacheClassName.\n   */\n  public classNameFromKey(key: string): string | undefined {\n    return this._keyToClassName[key];\n  }\n\n  /**\n   * Gets all classnames cache with the stylesheet.\n   */\n  public getClassNameCache(): { [key: string]: string } {\n    return this._keyToClassName;\n  }\n\n  /**\n   * Gets the arguments associated with a given classname which was\n   * previously registered using cacheClassName.\n   */\n  public argsFromClassName(className: string): IStyle[] | undefined {\n    const entry = this._classNameToArgs[className];\n\n    return entry && entry.args;\n  }\n\n  /**\n   * Gets the arguments associated with a given classname which was\n   * previously registered using cacheClassName.\n   */\n  public insertedRulesFromClassName(className: string): string[] | undefined {\n    const entry = this._classNameToArgs[className];\n\n    return entry && entry.rules;\n  }\n\n  /**\n   * Inserts a css rule into the stylesheet.\n   * @param preserve - Preserves the rule beyond a reset boundary.\n   */\n  public insertRule(rule: string, preserve?: boolean): void {\n    const { injectionMode } = this._config;\n    const element = injectionMode !== InjectionMode.none ? this._getStyleElement() : undefined;\n\n    if (preserve) {\n      this._preservedRules.push(rule);\n    }\n\n    if (element) {\n      switch (this._config.injectionMode) {\n        case InjectionMode.insertNode:\n          const { sheet } = element!;\n\n          try {\n            (sheet as CSSStyleSheet).insertRule(rule, (sheet as CSSStyleSheet).cssRules.length);\n          } catch (e) {\n            // The browser will throw exceptions on unsupported rules (such as a moz prefix in webkit.)\n            // We need to swallow the exceptions for this scenario, otherwise we'd need to filter\n            // which could be slower and bulkier.\n          }\n          break;\n\n        case InjectionMode.appendChild:\n          element.appendChild(document.createTextNode(rule));\n          break;\n      }\n    } else {\n      this._rules.push(rule);\n    }\n\n    if (this._config.onInsertRule) {\n      this._config.onInsertRule(rule);\n    }\n  }\n\n  /**\n   * Gets all rules registered with the stylesheet; only valid when\n   * using InsertionMode.none.\n   */\n  public getRules(includePreservedRules?: boolean): string {\n    return (\n      (includePreservedRules ? this._preservedRules.join('') : '') + this._rules.join('') + this._rulesToInsert.join('')\n    );\n  }\n\n  /**\n   * Resets the internal state of the stylesheet. Only used in server\n   * rendered scenarios where we're using InsertionMode.none.\n   */\n  public reset(): void {\n    this._rules = [];\n    this._rulesToInsert = [];\n    this._counter = 0;\n    this._classNameToArgs = {};\n    this._keyToClassName = {};\n\n    this._onResetCallbacks.forEach((callback: () => void) => callback());\n  }\n\n  // Forces the regeneration of incoming styles without totally resetting the stylesheet.\n  public resetKeys(): void {\n    this._keyToClassName = {};\n  }\n\n  private _getStyleElement(): HTMLStyleElement | undefined {\n    if (!this._styleElement && typeof document !== 'undefined') {\n      this._styleElement = this._createStyleElement();\n\n      if (!REUSE_STYLE_NODE) {\n        // Reset the style element on the next frame.\n        window.requestAnimationFrame(() => {\n          this._styleElement = undefined;\n        });\n      }\n    }\n    return this._styleElement;\n  }\n\n  private _createStyleElement(): HTMLStyleElement {\n    const head: HTMLHeadElement = document.head;\n    const styleElement = document.createElement('style');\n\n    styleElement.setAttribute('data-merge-styles', 'true');\n\n    const { cspSettings } = this._config;\n    if (cspSettings) {\n      if (cspSettings.nonce) {\n        styleElement.setAttribute('nonce', cspSettings.nonce);\n      }\n    }\n    if (this._lastStyleElement) {\n      // If the `nextElementSibling` is null, then the insertBefore will act as a regular append.\n      // https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore#Syntax\n      head!.insertBefore(styleElement, this._lastStyleElement.nextElementSibling);\n    } else {\n      const placeholderStyleTag: Element | null = this._findPlaceholderStyleTag();\n\n      if (placeholderStyleTag) {\n        head!.insertBefore(styleElement, placeholderStyleTag.nextElementSibling);\n      } else {\n        head!.insertBefore(styleElement, head.childNodes[0]);\n      }\n    }\n    this._lastStyleElement = styleElement;\n\n    return styleElement;\n  }\n\n  private _findPlaceholderStyleTag(): Element | null {\n    const head: HTMLHeadElement = document.head;\n    if (head) {\n      return head.querySelector('style[data-merge-styles]');\n    }\n    return null;\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}