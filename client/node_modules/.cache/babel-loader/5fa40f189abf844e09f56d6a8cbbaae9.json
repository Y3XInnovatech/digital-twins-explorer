{"ast":null,"code":"var _a;\nimport { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { Async, css, divProperties, elementContains, focusFirstChild, getDocument, getNativeProps, getWindow, on, shallowCompare } from '../../Utilities';\nimport { positionCallout, getMaxHeight, RectangleEdge, positionCard, getBoundsFromTargetWindow } from '../../utilities/positioning';\nimport { Popup } from '../../Popup';\nimport { classNamesFunction } from '../../Utilities';\nimport { AnimationClassNames } from '../../Styling';\nvar ANIMATIONS = (_a = {}, _a[RectangleEdge.top] = AnimationClassNames.slideUpIn10, _a[RectangleEdge.bottom] = AnimationClassNames.slideDownIn10, _a[RectangleEdge.left] = AnimationClassNames.slideLeftIn10, _a[RectangleEdge.right] = AnimationClassNames.slideRightIn10, _a);\nvar getClassNames = classNamesFunction({\n  disableCaching: true\n});\nvar BEAK_ORIGIN_POSITION = {\n  top: 0,\n  left: 0\n};\n// Microsoft Edge will overwrite inline styles if there is an animation pertaining to that style.\n// To help ensure that edge will respect the offscreen style opacity\n// filter needs to be added as an additional way to set opacity.\n// Also set pointer-events: none so that the callout will not occlude the element it is\n// going to be positioned against\nvar OFF_SCREEN_STYLE = {\n  opacity: 0,\n  filter: 'opacity(0)',\n  pointerEvents: 'none'\n};\n// role and role description go hand-in-hand. Both would be included by spreading getNativeProps for a basic element\n// This constant array can be used to filter these out of native props spread on callout root and apply them together on\n// calloutMain (the Popup component within the callout)\nvar ARIA_ROLE_ATTRIBUTES = ['role', 'aria-roledescription'];\nvar CalloutContentBase = /** @class */function (_super) {\n  __extends(CalloutContentBase, _super);\n  function CalloutContentBase(props) {\n    var _this = _super.call(this, props) || this;\n    _this._hostElement = React.createRef();\n    _this._calloutElement = React.createRef();\n    _this._hasListeners = false;\n    _this._disposables = [];\n    _this.dismiss = function (ev) {\n      var onDismiss = _this.props.onDismiss;\n      if (onDismiss) {\n        onDismiss(ev);\n      }\n    };\n    _this._dismissOnScroll = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      var _a = _this.props,\n        preventDismissOnEvent = _a.preventDismissOnEvent,\n        preventDismissOnScroll = _a.preventDismissOnScroll;\n      if (_this.state.positions && (preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnScroll)) {\n        _this._dismissOnClickOrScroll(ev);\n      }\n    };\n    _this._dismissOnResize = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      var _a = _this.props,\n        preventDismissOnEvent = _a.preventDismissOnEvent,\n        preventDismissOnResize = _a.preventDismissOnResize;\n      if (preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnResize) {\n        _this.dismiss(ev);\n      }\n    };\n    _this._dismissOnLostFocus = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      var _a = _this.props,\n        preventDismissOnEvent = _a.preventDismissOnEvent,\n        preventDismissOnLostFocus = _a.preventDismissOnLostFocus;\n      if (preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnLostFocus) {\n        _this._dismissOnClickOrScroll(ev);\n      }\n    };\n    _this._setInitialFocus = function () {\n      if (_this.props.setInitialFocus && !_this._didSetInitialFocus && _this.state.positions && _this._calloutElement.current) {\n        _this._didSetInitialFocus = true;\n        _this._async.requestAnimationFrame(function () {\n          return focusFirstChild(_this._calloutElement.current);\n        }, _this._calloutElement.current);\n      }\n    };\n    _this._onComponentDidMount = function () {\n      _this._addListeners();\n      if (_this.props.onLayerMounted) {\n        _this.props.onLayerMounted();\n      }\n      _this._updateAsyncPosition();\n      _this._setHeightOffsetEveryFrame();\n    };\n    _this._dismissOnTargetWindowBlur = function (ev) {\n      // eslint-disable-next-line deprecation/deprecation\n      var _a = _this.props,\n        preventDismissOnEvent = _a.preventDismissOnEvent,\n        preventDismissOnLostFocus = _a.preventDismissOnLostFocus,\n        shouldDismissOnWindowFocus = _a.shouldDismissOnWindowFocus;\n      // Do nothing\n      if (!shouldDismissOnWindowFocus) {\n        return;\n      }\n      if ((preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnLostFocus) && !_this._targetWindow.document.hasFocus() && ev.relatedTarget === null) {\n        _this.dismiss(ev);\n      }\n    };\n    _this._mouseDownOnPopup = function () {\n      _this._isMouseDownOnPopup = true;\n    };\n    _this._mouseUpOnPopup = function () {\n      _this._isMouseDownOnPopup = false;\n    };\n    _this._async = new Async(_this);\n    _this._didSetInitialFocus = false;\n    _this.state = {\n      positions: undefined,\n      slideDirectionalClassName: undefined,\n      // @TODO it looks like this is not even being used anymore.\n      calloutElementRect: undefined,\n      heightOffset: 0\n    };\n    _this._positionAttempts = 0;\n    return _this;\n  }\n  CalloutContentBase.prototype.componentDidUpdate = function () {\n    if (!this.props.hidden) {\n      this._setInitialFocus();\n      if (!this._hasListeners) {\n        this._addListeners();\n      }\n      this._updateAsyncPosition();\n    } else {\n      if (this._hasListeners) {\n        this._removeListeners();\n      }\n    }\n  };\n  CalloutContentBase.prototype.shouldComponentUpdate = function (newProps, newState) {\n    if (!newProps.shouldUpdateWhenHidden && this.props.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return false;\n    }\n    return !shallowCompare(this.props, newProps) || !shallowCompare(this.state, newState);\n  };\n  CalloutContentBase.prototype.UNSAFE_componentWillMount = function () {\n    this._setTargetWindowAndElement(this._getTarget());\n  };\n  CalloutContentBase.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n    this._disposables.forEach(function (dispose) {\n      return dispose();\n    });\n  };\n  CalloutContentBase.prototype.UNSAFE_componentWillUpdate = function (newProps) {\n    // If the target element changed, find the new one. If we are tracking target with class name, always find element\n    // because we do not know if fabric has rendered a new element and disposed the old element.\n    var newTarget = this._getTarget(newProps);\n    var oldTarget = this._getTarget();\n    if ((newTarget !== oldTarget || typeof newTarget === 'string' || newTarget instanceof String) && !this._blockResetHeight) {\n      this._maxHeight = undefined;\n      this._setTargetWindowAndElement(newTarget);\n    }\n    if (newProps.gapSpace !== this.props.gapSpace || this.props.beakWidth !== newProps.beakWidth) {\n      this._maxHeight = undefined;\n    }\n    if (newProps.finalHeight !== this.props.finalHeight) {\n      this._setHeightOffsetEveryFrame();\n    }\n    // Ensure positioning is recalculated when we are about to show a persisted menu.\n    if (this._didPositionPropsChange(newProps, this.props)) {\n      this._maxHeight = undefined;\n      // Target might have been updated while hidden.\n      this._setTargetWindowAndElement(newTarget);\n      this.setState({\n        positions: undefined\n      });\n      this._didSetInitialFocus = false;\n      this._bounds = undefined;\n    }\n    this._blockResetHeight = false;\n  };\n  CalloutContentBase.prototype.componentDidMount = function () {\n    if (!this.props.hidden) {\n      this._onComponentDidMount();\n    }\n  };\n  CalloutContentBase.prototype.render = function () {\n    // If there is no target window then we are likely in server side rendering and we should not render anything.\n    if (!this._targetWindow) {\n      return null;\n    }\n    var target = this.props.target;\n    var _a = this.props,\n      styles = _a.styles,\n      style = _a.style,\n      ariaLabel = _a.ariaLabel,\n      ariaDescribedBy = _a.ariaDescribedBy,\n      ariaLabelledBy = _a.ariaLabelledBy,\n      className = _a.className,\n      isBeakVisible = _a.isBeakVisible,\n      children = _a.children,\n      beakWidth = _a.beakWidth,\n      calloutWidth = _a.calloutWidth,\n      calloutMaxWidth = _a.calloutMaxWidth,\n      calloutMinWidth = _a.calloutMinWidth,\n      finalHeight = _a.finalHeight,\n      _b = _a.hideOverflow,\n      hideOverflow = _b === void 0 ? !!finalHeight : _b,\n      backgroundColor = _a.backgroundColor,\n      calloutMaxHeight = _a.calloutMaxHeight,\n      onScroll = _a.onScroll,\n      // eslint-disable-next-line deprecation/deprecation\n      _c = _a.shouldRestoreFocus,\n      // eslint-disable-next-line deprecation/deprecation\n      shouldRestoreFocus = _c === void 0 ? true : _c;\n    target = this._getTarget();\n    var positions = this.state.positions;\n    var getContentMaxHeight = this._getMaxHeight() ? this._getMaxHeight() + this.state.heightOffset : undefined;\n    var contentMaxHeight = calloutMaxHeight && getContentMaxHeight && calloutMaxHeight < getContentMaxHeight ? calloutMaxHeight : getContentMaxHeight;\n    var overflowYHidden = hideOverflow;\n    var beakVisible = isBeakVisible && !!target;\n    this._classNames = getClassNames(styles, {\n      theme: this.props.theme,\n      className: className,\n      overflowYHidden: overflowYHidden,\n      calloutWidth: calloutWidth,\n      positions: positions,\n      beakWidth: beakWidth,\n      backgroundColor: backgroundColor,\n      calloutMinWidth: calloutMinWidth,\n      calloutMaxWidth: calloutMaxWidth\n    });\n    var overflowStyle = __assign(__assign(__assign({}, style), {\n      maxHeight: contentMaxHeight\n    }), overflowYHidden && {\n      overflowY: 'hidden'\n    });\n    var visibilityStyle = this.props.hidden ? {\n      visibility: 'hidden'\n    } : undefined;\n    // React.CSSProperties does not understand IRawStyle, so the inline animations will need to be cast as any for now.\n    var content = React.createElement(\"div\", {\n      ref: this._hostElement,\n      className: this._classNames.container,\n      style: visibilityStyle\n    }, React.createElement(\"div\", __assign({}, getNativeProps(this.props, divProperties, ARIA_ROLE_ATTRIBUTES), {\n      className: css(this._classNames.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge]),\n      style: positions ? positions.elementPosition : OFF_SCREEN_STYLE,\n      // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n      // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n      tabIndex: -1,\n      ref: this._calloutElement\n    }), beakVisible && React.createElement(\"div\", {\n      className: this._classNames.beak,\n      style: this._getBeakPosition()\n    }), beakVisible && React.createElement(\"div\", {\n      className: this._classNames.beakCurtain\n    }), React.createElement(Popup, __assign({}, getNativeProps(this.props, ARIA_ROLE_ATTRIBUTES), {\n      ariaLabel: ariaLabel,\n      onRestoreFocus: this.props.onRestoreFocus,\n      ariaDescribedBy: ariaDescribedBy,\n      ariaLabelledBy: ariaLabelledBy,\n      className: this._classNames.calloutMain,\n      onDismiss: this.dismiss,\n      onScroll: onScroll,\n      shouldRestoreFocus: shouldRestoreFocus,\n      style: overflowStyle,\n      onMouseDown: this._mouseDownOnPopup,\n      onMouseUp: this._mouseUpOnPopup\n    }), children)));\n    return content;\n  };\n  CalloutContentBase.prototype._dismissOnClickOrScroll = function (ev) {\n    var target = ev.target;\n    var isEventTargetOutsideCallout = this._hostElement.current && !elementContains(this._hostElement.current, target);\n    // If mouse is pressed down on callout but moved outside then released, don't dismiss the callout.\n    if (isEventTargetOutsideCallout && this._isMouseDownOnPopup) {\n      this._isMouseDownOnPopup = false;\n      return;\n    }\n    if (!this._target && isEventTargetOutsideCallout || ev.target !== this._targetWindow && isEventTargetOutsideCallout && (this._target.stopPropagation || !this._target || this.props.dismissOnTargetClick || target !== this._target && !elementContains(this._target, target))) {\n      this.dismiss(ev);\n    }\n  };\n  CalloutContentBase.prototype._addListeners = function () {\n    var _this = this;\n    // This is added so the callout will dismiss when the window is scrolled\n    // but not when something inside the callout is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the callout.\n    this._async.setTimeout(function () {\n      _this._disposables.push(on(_this._targetWindow, 'scroll', _this._dismissOnScroll, true), on(_this._targetWindow, 'resize', _this._dismissOnResize, true), on(_this._targetWindow.document.documentElement, 'focus', _this._dismissOnLostFocus, true), on(_this._targetWindow.document.documentElement, 'click', _this._dismissOnLostFocus, true), on(_this._targetWindow, 'blur', _this._dismissOnTargetWindowBlur, true));\n      _this._hasListeners = true;\n    }, 0);\n  };\n  CalloutContentBase.prototype._removeListeners = function () {\n    this._disposables.forEach(function (dispose) {\n      return dispose();\n    });\n    this._disposables = [];\n    this._hasListeners = false;\n  };\n  CalloutContentBase.prototype._updateAsyncPosition = function () {\n    var _this = this;\n    this._async.requestAnimationFrame(function () {\n      return _this._updatePosition();\n    }, this._calloutElement.current);\n  };\n  CalloutContentBase.prototype._getBeakPosition = function () {\n    var positions = this.state.positions;\n    var beakPostionStyle = __assign({}, positions && positions.beakPosition ? positions.beakPosition.elementPosition : null);\n    if (!beakPostionStyle.top && !beakPostionStyle.bottom && !beakPostionStyle.left && !beakPostionStyle.right) {\n      beakPostionStyle.left = BEAK_ORIGIN_POSITION.left;\n      beakPostionStyle.top = BEAK_ORIGIN_POSITION.top;\n    }\n    return beakPostionStyle;\n  };\n  CalloutContentBase.prototype._updatePosition = function () {\n    // Try to update the target, page might have changed\n    this._setTargetWindowAndElement(this._getTarget());\n    var positions = this.state.positions;\n    var hostElement = this._hostElement.current;\n    var calloutElement = this._calloutElement.current;\n    // If we expect a target element to position against, we need to wait until `this._target` is resolved. Otherwise\n    // we can try to position.\n    var expectsTarget = !!this.props.target;\n    if (hostElement && calloutElement && (!expectsTarget || this._target)) {\n      var currentProps = __assign({}, this.props);\n      currentProps.bounds = this._getBounds();\n      currentProps.target = this._target;\n      // If there is a finalHeight given then we assume that the user knows and will handle\n      // additional positioning adjustments so we should call positionCard\n      var newPositions = this.props.finalHeight ? positionCard(currentProps, hostElement, calloutElement, positions) : positionCallout(currentProps, hostElement, calloutElement, positions);\n      // Set the new position only when the positions are not exists or one of the new callout positions are different.\n      // The position should not change if the position is within 2 decimal places.\n      if (!positions && newPositions || positions && newPositions && !this._arePositionsEqual(positions, newPositions) && this._positionAttempts < 5) {\n        // We should not reposition the callout more than a few times, if it is then the content is likely resizing\n        // and we should stop trying to reposition to prevent a stack overflow.\n        this._positionAttempts++;\n        this.setState({\n          positions: newPositions\n        });\n      } else if (this._positionAttempts > 0) {\n        // Only call the onPositioned callback if the callout has been re-positioned at least once.\n        this._positionAttempts = 0;\n        if (this.props.onPositioned) {\n          this.props.onPositioned(this.state.positions);\n        }\n      }\n    }\n  };\n  CalloutContentBase.prototype._getBounds = function () {\n    if (!this._bounds) {\n      var bounds = this.props.bounds;\n      var currentBounds = typeof bounds === 'function' ? bounds(this.props.target, this._targetWindow) : bounds;\n      if (!currentBounds) {\n        currentBounds = getBoundsFromTargetWindow(this._target, this._targetWindow);\n        currentBounds = {\n          top: currentBounds.top + this.props.minPagePadding,\n          left: currentBounds.left + this.props.minPagePadding,\n          right: currentBounds.right - this.props.minPagePadding,\n          bottom: currentBounds.bottom - this.props.minPagePadding,\n          width: currentBounds.width - this.props.minPagePadding * 2,\n          height: currentBounds.height - this.props.minPagePadding * 2\n        };\n      }\n      this._bounds = currentBounds;\n    }\n    return this._bounds;\n  };\n  // Max height should remain as synchronous as possible, which is why it is not done using set state.\n  // It needs to be synchronous since it will impact the ultimate position of the callout.\n  CalloutContentBase.prototype._getMaxHeight = function () {\n    var _this = this;\n    if (!this._maxHeight) {\n      if (this.props.directionalHintFixed && this._target) {\n        var beakWidth = this.props.isBeakVisible ? this.props.beakWidth : 0;\n        var gapSpace = this.props.gapSpace ? this.props.gapSpace : 0;\n        // Since the callout cannot measure it's border size it must be taken into account here. Otherwise it will\n        // overlap with the target.\n        var totalGap_1 = gapSpace + beakWidth;\n        this._async.requestAnimationFrame(function () {\n          if (_this._target) {\n            _this._maxHeight = getMaxHeight(_this._target, _this.props.directionalHint, totalGap_1, _this._getBounds(), _this.props.coverTarget);\n            _this._blockResetHeight = true;\n            _this.forceUpdate();\n          }\n        }, this._target);\n      } else {\n        this._maxHeight = this._getBounds().height;\n      }\n    }\n    return this._maxHeight;\n  };\n  CalloutContentBase.prototype._arePositionsEqual = function (positions, newPosition) {\n    return this._comparePositions(positions.elementPosition, newPosition.elementPosition) && this._comparePositions(positions.beakPosition.elementPosition, newPosition.beakPosition.elementPosition);\n  };\n  CalloutContentBase.prototype._comparePositions = function (oldPositions, newPositions) {\n    for (var key in newPositions) {\n      if (newPositions.hasOwnProperty(key)) {\n        var oldPositionEdge = oldPositions[key];\n        var newPositionEdge = newPositions[key];\n        if (oldPositionEdge !== undefined && newPositionEdge !== undefined) {\n          if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n  CalloutContentBase.prototype._setTargetWindowAndElement = function (target) {\n    var currentElement = this._calloutElement.current;\n    if (target) {\n      if (typeof target === 'string') {\n        var currentDoc = getDocument(currentElement);\n        this._target = currentDoc ? currentDoc.querySelector(target) : null;\n        this._targetWindow = getWindow(currentElement);\n        // Cast to any prevents error about stopPropagation always existing\n      } else if (target.stopPropagation) {\n        this._targetWindow = getWindow(target.target);\n        this._target = target;\n        // Same reason here\n      } else if (target.getBoundingClientRect) {\n        var targetElement = target;\n        this._targetWindow = getWindow(targetElement);\n        this._target = targetElement;\n      } else if (target.current !== undefined) {\n        this._target = target.current;\n        this._targetWindow = getWindow(this._target);\n        // HTMLImgElements can have x and y values. The check for it being a point must go last.\n      } else {\n        this._targetWindow = getWindow(currentElement);\n        this._target = target;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement);\n    }\n  };\n  CalloutContentBase.prototype._setHeightOffsetEveryFrame = function () {\n    var _this = this;\n    if (this._calloutElement.current && this.props.finalHeight) {\n      this._setHeightOffsetTimer = this._async.requestAnimationFrame(function () {\n        var calloutMainElem = _this._calloutElement.current && _this._calloutElement.current.lastChild;\n        if (!calloutMainElem) {\n          return;\n        }\n        var cardScrollHeight = calloutMainElem.scrollHeight;\n        var cardCurrHeight = calloutMainElem.offsetHeight;\n        var scrollDiff = cardScrollHeight - cardCurrHeight;\n        _this.setState({\n          heightOffset: _this.state.heightOffset + scrollDiff\n        });\n        if (calloutMainElem.offsetHeight < _this.props.finalHeight) {\n          _this._setHeightOffsetEveryFrame();\n        } else {\n          _this._async.cancelAnimationFrame(_this._setHeightOffsetTimer, _this._calloutElement.current);\n        }\n      }, this._calloutElement.current);\n    }\n  };\n  // Whether or not the current positions should be reset\n  CalloutContentBase.prototype._didPositionPropsChange = function (newProps, oldProps) {\n    return !newProps.hidden && newProps.hidden !== oldProps.hidden || newProps.directionalHint !== oldProps.directionalHint;\n  };\n  CalloutContentBase.prototype._getTarget = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n    var target = props.target;\n    return target;\n  };\n  CalloutContentBase.defaultProps = {\n    preventDismissOnLostFocus: false,\n    preventDismissOnScroll: false,\n    preventDismissOnResize: false,\n    isBeakVisible: true,\n    beakWidth: 16,\n    gapSpace: 0,\n    minPagePadding: 8,\n    directionalHint: DirectionalHint.bottomAutoEdge\n  };\n  return CalloutContentBase;\n}(React.Component);\nexport { CalloutContentBase };","map":{"version":3,"sources":["components/Callout/CalloutContent.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { ICalloutProps, ICalloutContentStyleProps, ICalloutContentStyles } from './Callout.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport {\n  Async,\n  Point,\n  IRectangle,\n  css,\n  divProperties,\n  elementContains,\n  focusFirstChild,\n  getDocument,\n  getNativeProps,\n  getWindow,\n  on,\n  shallowCompare,\n} from '../../Utilities';\nimport {\n  positionCallout,\n  ICalloutPositionedInfo,\n  IPositionProps,\n  getMaxHeight,\n  IPosition,\n  RectangleEdge,\n  positionCard,\n  getBoundsFromTargetWindow,\n} from '../../utilities/positioning';\nimport { Popup } from '../../Popup';\nimport { classNamesFunction } from '../../Utilities';\nimport { AnimationClassNames } from '../../Styling';\nimport { Target } from '@uifabric/react-hooks';\n\nconst ANIMATIONS: { [key: number]: string | undefined } = {\n  [RectangleEdge.top]: AnimationClassNames.slideUpIn10,\n  [RectangleEdge.bottom]: AnimationClassNames.slideDownIn10,\n  [RectangleEdge.left]: AnimationClassNames.slideLeftIn10,\n  [RectangleEdge.right]: AnimationClassNames.slideRightIn10,\n};\n\nconst getClassNames = classNamesFunction<ICalloutContentStyleProps, ICalloutContentStyles>({\n  disableCaching: true, // disabling caching because stylesProp.position mutates often\n});\n\nconst BEAK_ORIGIN_POSITION = { top: 0, left: 0 };\n// Microsoft Edge will overwrite inline styles if there is an animation pertaining to that style.\n// To help ensure that edge will respect the offscreen style opacity\n// filter needs to be added as an additional way to set opacity.\n// Also set pointer-events: none so that the callout will not occlude the element it is\n// going to be positioned against\nconst OFF_SCREEN_STYLE: React.CSSProperties = { opacity: 0, filter: 'opacity(0)', pointerEvents: 'none' };\n// role and role description go hand-in-hand. Both would be included by spreading getNativeProps for a basic element\n// This constant array can be used to filter these out of native props spread on callout root and apply them together on\n// calloutMain (the Popup component within the callout)\nconst ARIA_ROLE_ATTRIBUTES = ['role', 'aria-roledescription'];\n\nexport interface ICalloutState {\n  positions?: ICalloutPositionedInfo;\n  slideDirectionalClassName?: string;\n  calloutElementRect?: ClientRect;\n  heightOffset?: number;\n}\n\nexport class CalloutContentBase extends React.Component<ICalloutProps, ICalloutState> {\n  public static defaultProps = {\n    preventDismissOnLostFocus: false,\n    preventDismissOnScroll: false,\n    preventDismissOnResize: false,\n    isBeakVisible: true,\n    beakWidth: 16,\n    gapSpace: 0,\n    minPagePadding: 8,\n    directionalHint: DirectionalHint.bottomAutoEdge,\n  };\n\n  private _classNames: { [key in keyof ICalloutContentStyles]: string };\n  private _didSetInitialFocus: boolean;\n  private _hostElement = React.createRef<HTMLDivElement>();\n  private _calloutElement = React.createRef<HTMLDivElement>();\n  private _targetWindow: Window;\n  private _bounds: IRectangle | undefined;\n  private _positionAttempts: number;\n  private _target: Element | MouseEvent | Point | null;\n  private _setHeightOffsetTimer: number;\n  private _hasListeners = false;\n  private _maxHeight: number | undefined;\n  private _blockResetHeight: boolean;\n  private _isMouseDownOnPopup: boolean;\n\n  private _async: Async;\n  private _disposables: (() => void)[] = [];\n\n  constructor(props: ICalloutProps) {\n    super(props);\n\n    this._async = new Async(this);\n    this._didSetInitialFocus = false;\n    this.state = {\n      positions: undefined,\n      slideDirectionalClassName: undefined,\n      // @TODO it looks like this is not even being used anymore.\n      calloutElementRect: undefined,\n      heightOffset: 0,\n    };\n    this._positionAttempts = 0;\n  }\n\n  public componentDidUpdate() {\n    if (!this.props.hidden) {\n      this._setInitialFocus();\n      if (!this._hasListeners) {\n        this._addListeners();\n      }\n      this._updateAsyncPosition();\n    } else {\n      if (this._hasListeners) {\n        this._removeListeners();\n      }\n    }\n  }\n\n  public shouldComponentUpdate(newProps: ICalloutProps, newState: ICalloutState): boolean {\n    if (!newProps.shouldUpdateWhenHidden && this.props.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return false;\n    }\n\n    return !shallowCompare(this.props, newProps) || !shallowCompare(this.state, newState);\n  }\n\n  public UNSAFE_componentWillMount() {\n    this._setTargetWindowAndElement(this._getTarget());\n  }\n\n  public componentWillUnmount() {\n    this._async.dispose();\n    this._disposables.forEach((dispose: () => void) => dispose());\n  }\n\n  public UNSAFE_componentWillUpdate(newProps: ICalloutProps): void {\n    // If the target element changed, find the new one. If we are tracking target with class name, always find element\n    // because we do not know if fabric has rendered a new element and disposed the old element.\n    const newTarget = this._getTarget(newProps);\n    const oldTarget = this._getTarget();\n    if (\n      (newTarget !== oldTarget || typeof newTarget === 'string' || newTarget instanceof String) &&\n      !this._blockResetHeight\n    ) {\n      this._maxHeight = undefined;\n      this._setTargetWindowAndElement(newTarget!);\n    }\n    if (newProps.gapSpace !== this.props.gapSpace || this.props.beakWidth !== newProps.beakWidth) {\n      this._maxHeight = undefined;\n    }\n\n    if (newProps.finalHeight !== this.props.finalHeight) {\n      this._setHeightOffsetEveryFrame();\n    }\n\n    // Ensure positioning is recalculated when we are about to show a persisted menu.\n    if (this._didPositionPropsChange(newProps, this.props)) {\n      this._maxHeight = undefined;\n      // Target might have been updated while hidden.\n      this._setTargetWindowAndElement(newTarget);\n      this.setState({\n        positions: undefined,\n      });\n      this._didSetInitialFocus = false;\n      this._bounds = undefined;\n    }\n\n    this._blockResetHeight = false;\n  }\n\n  public componentDidMount(): void {\n    if (!this.props.hidden) {\n      this._onComponentDidMount();\n    }\n  }\n\n  public render(): JSX.Element | null {\n    // If there is no target window then we are likely in server side rendering and we should not render anything.\n    if (!this._targetWindow) {\n      return null;\n    }\n    let { target } = this.props;\n    const {\n      styles,\n      style,\n      ariaLabel,\n      ariaDescribedBy,\n      ariaLabelledBy,\n      className,\n      isBeakVisible,\n      children,\n      beakWidth,\n      calloutWidth,\n      calloutMaxWidth,\n      calloutMinWidth,\n      finalHeight,\n      hideOverflow = !!finalHeight,\n      backgroundColor,\n      calloutMaxHeight,\n      onScroll,\n      // eslint-disable-next-line deprecation/deprecation\n      shouldRestoreFocus = true,\n    } = this.props;\n    target = this._getTarget();\n    const { positions } = this.state;\n\n    const getContentMaxHeight: number | undefined = this._getMaxHeight()\n      ? this._getMaxHeight()! + this.state.heightOffset!\n      : undefined;\n    const contentMaxHeight: number | undefined =\n      calloutMaxHeight! && getContentMaxHeight && calloutMaxHeight! < getContentMaxHeight\n        ? calloutMaxHeight!\n        : getContentMaxHeight!;\n    const overflowYHidden = hideOverflow;\n\n    const beakVisible = isBeakVisible && !!target;\n    this._classNames = getClassNames(styles!, {\n      theme: this.props.theme!,\n      className,\n      overflowYHidden: overflowYHidden,\n      calloutWidth,\n      positions,\n      beakWidth,\n      backgroundColor,\n      calloutMinWidth,\n      calloutMaxWidth,\n    });\n\n    const overflowStyle: React.CSSProperties = {\n      ...style,\n      maxHeight: contentMaxHeight,\n      ...(overflowYHidden && { overflowY: 'hidden' }),\n    };\n\n    const visibilityStyle: React.CSSProperties | undefined = this.props.hidden ? { visibility: 'hidden' } : undefined;\n    // React.CSSProperties does not understand IRawStyle, so the inline animations will need to be cast as any for now.\n    const content = (\n      <div ref={this._hostElement} className={this._classNames.container} style={visibilityStyle}>\n        <div\n          {...getNativeProps(this.props, divProperties, ARIA_ROLE_ATTRIBUTES)}\n          className={css(this._classNames.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge!])}\n          style={positions ? positions.elementPosition : OFF_SCREEN_STYLE}\n          // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n          // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n          tabIndex={-1}\n          ref={this._calloutElement}\n        >\n          {beakVisible && <div className={this._classNames.beak} style={this._getBeakPosition()} />}\n          {beakVisible && <div className={this._classNames.beakCurtain} />}\n          <Popup\n            {...getNativeProps(this.props, ARIA_ROLE_ATTRIBUTES)}\n            ariaLabel={ariaLabel}\n            onRestoreFocus={this.props.onRestoreFocus}\n            ariaDescribedBy={ariaDescribedBy}\n            ariaLabelledBy={ariaLabelledBy}\n            className={this._classNames.calloutMain}\n            onDismiss={this.dismiss}\n            onScroll={onScroll}\n            shouldRestoreFocus={shouldRestoreFocus}\n            style={overflowStyle}\n            onMouseDown={this._mouseDownOnPopup}\n            onMouseUp={this._mouseUpOnPopup}\n          >\n            {children}\n          </Popup>\n        </div>\n      </div>\n    );\n\n    return content;\n  }\n\n  public dismiss = (ev?: Event | React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void => {\n    const { onDismiss } = this.props;\n\n    if (onDismiss) {\n      onDismiss(ev);\n    }\n  };\n\n  protected _dismissOnScroll = (ev: Event) => {\n    // eslint-disable-next-line deprecation/deprecation\n    const { preventDismissOnEvent, preventDismissOnScroll } = this.props;\n    if (\n      this.state.positions &&\n      ((preventDismissOnEvent && !preventDismissOnEvent(ev)) || (!preventDismissOnEvent && !preventDismissOnScroll))\n    ) {\n      this._dismissOnClickOrScroll(ev);\n    }\n  };\n\n  protected _dismissOnResize = (ev: Event) => {\n    // eslint-disable-next-line deprecation/deprecation\n    const { preventDismissOnEvent, preventDismissOnResize } = this.props;\n    if ((preventDismissOnEvent && !preventDismissOnEvent(ev)) || (!preventDismissOnEvent && !preventDismissOnResize)) {\n      this.dismiss(ev);\n    }\n  };\n\n  protected _dismissOnLostFocus = (ev: Event) => {\n    // eslint-disable-next-line deprecation/deprecation\n    const { preventDismissOnEvent, preventDismissOnLostFocus } = this.props;\n    if (\n      (preventDismissOnEvent && !preventDismissOnEvent(ev)) ||\n      (!preventDismissOnEvent && !preventDismissOnLostFocus)\n    ) {\n      this._dismissOnClickOrScroll(ev);\n    }\n  };\n\n  protected _setInitialFocus = (): void => {\n    if (\n      this.props.setInitialFocus &&\n      !this._didSetInitialFocus &&\n      this.state.positions &&\n      this._calloutElement.current\n    ) {\n      this._didSetInitialFocus = true;\n      this._async.requestAnimationFrame(\n        () => focusFirstChild(this._calloutElement.current!),\n        this._calloutElement.current,\n      );\n    }\n  };\n\n  protected _onComponentDidMount = (): void => {\n    this._addListeners();\n\n    if (this.props.onLayerMounted) {\n      this.props.onLayerMounted();\n    }\n\n    this._updateAsyncPosition();\n    this._setHeightOffsetEveryFrame();\n  };\n\n  private _dismissOnClickOrScroll(ev: Event) {\n    const target = ev.target as HTMLElement;\n    const isEventTargetOutsideCallout =\n      this._hostElement.current && !elementContains(this._hostElement.current, target);\n\n    // If mouse is pressed down on callout but moved outside then released, don't dismiss the callout.\n    if (isEventTargetOutsideCallout && this._isMouseDownOnPopup) {\n      this._isMouseDownOnPopup = false;\n      return;\n    }\n\n    if (\n      (!this._target && isEventTargetOutsideCallout) ||\n      (ev.target !== this._targetWindow &&\n        isEventTargetOutsideCallout &&\n        ((this._target as MouseEvent).stopPropagation ||\n          !this._target ||\n          this.props.dismissOnTargetClick ||\n          (target !== this._target && !elementContains(this._target as HTMLElement, target))))\n    ) {\n      this.dismiss(ev);\n    }\n  }\n\n  private _dismissOnTargetWindowBlur = (ev: FocusEvent) => {\n    // eslint-disable-next-line deprecation/deprecation\n    const { preventDismissOnEvent, preventDismissOnLostFocus, shouldDismissOnWindowFocus } = this.props;\n\n    // Do nothing\n    if (!shouldDismissOnWindowFocus) {\n      return;\n    }\n\n    if (\n      ((preventDismissOnEvent && !preventDismissOnEvent(ev)) ||\n        (!preventDismissOnEvent && !preventDismissOnLostFocus)) &&\n      !this._targetWindow.document.hasFocus() &&\n      ev.relatedTarget === null\n    ) {\n      this.dismiss(ev);\n    }\n  };\n\n  private _addListeners() {\n    // This is added so the callout will dismiss when the window is scrolled\n    // but not when something inside the callout is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the callout.\n    this._async.setTimeout(() => {\n      this._disposables.push(\n        on(this._targetWindow, 'scroll', this._dismissOnScroll, true),\n        on(this._targetWindow, 'resize', this._dismissOnResize, true),\n        on(this._targetWindow.document.documentElement, 'focus', this._dismissOnLostFocus, true),\n        on(this._targetWindow.document.documentElement, 'click', this._dismissOnLostFocus, true),\n        on(this._targetWindow, 'blur', this._dismissOnTargetWindowBlur, true),\n      );\n      this._hasListeners = true;\n    }, 0);\n  }\n\n  private _removeListeners() {\n    this._disposables.forEach((dispose: () => void) => dispose());\n    this._disposables = [];\n    this._hasListeners = false;\n  }\n\n  private _updateAsyncPosition(): void {\n    this._async.requestAnimationFrame(() => this._updatePosition(), this._calloutElement.current);\n  }\n\n  private _getBeakPosition(): React.CSSProperties {\n    const { positions } = this.state;\n    const beakPostionStyle: React.CSSProperties = {\n      ...(positions && positions.beakPosition ? positions.beakPosition.elementPosition : null),\n    };\n\n    if (!beakPostionStyle.top && !beakPostionStyle.bottom && !beakPostionStyle.left && !beakPostionStyle.right) {\n      beakPostionStyle.left = BEAK_ORIGIN_POSITION.left;\n      beakPostionStyle.top = BEAK_ORIGIN_POSITION.top;\n    }\n\n    return beakPostionStyle;\n  }\n\n  private _updatePosition(): void {\n    // Try to update the target, page might have changed\n    this._setTargetWindowAndElement(this._getTarget());\n\n    const { positions } = this.state;\n    const hostElement: HTMLElement | null = this._hostElement.current;\n    const calloutElement: HTMLElement | null = this._calloutElement.current;\n\n    // If we expect a target element to position against, we need to wait until `this._target` is resolved. Otherwise\n    // we can try to position.\n    const expectsTarget = !!this.props.target;\n\n    if (hostElement && calloutElement && (!expectsTarget || this._target)) {\n      const currentProps: IPositionProps = { ...(this.props as any) };\n      currentProps.bounds = this._getBounds();\n      currentProps.target = this._target!;\n      // If there is a finalHeight given then we assume that the user knows and will handle\n      // additional positioning adjustments so we should call positionCard\n      const newPositions: ICalloutPositionedInfo = this.props.finalHeight\n        ? positionCard(currentProps, hostElement, calloutElement, positions)\n        : positionCallout(currentProps, hostElement, calloutElement, positions);\n\n      // Set the new position only when the positions are not exists or one of the new callout positions are different.\n      // The position should not change if the position is within 2 decimal places.\n      if (\n        (!positions && newPositions) ||\n        (positions && newPositions && !this._arePositionsEqual(positions, newPositions) && this._positionAttempts < 5)\n      ) {\n        // We should not reposition the callout more than a few times, if it is then the content is likely resizing\n        // and we should stop trying to reposition to prevent a stack overflow.\n        this._positionAttempts++;\n        this.setState({\n          positions: newPositions,\n        });\n      } else if (this._positionAttempts > 0) {\n        // Only call the onPositioned callback if the callout has been re-positioned at least once.\n        this._positionAttempts = 0;\n        if (this.props.onPositioned) {\n          this.props.onPositioned(this.state.positions);\n        }\n      }\n    }\n  }\n\n  private _getBounds(): IRectangle {\n    if (!this._bounds) {\n      const bounds = this.props.bounds;\n      let currentBounds = typeof bounds === 'function' ? bounds(this.props.target, this._targetWindow) : bounds;\n\n      if (!currentBounds) {\n        currentBounds = getBoundsFromTargetWindow(this._target, this._targetWindow);\n        currentBounds = {\n          top: currentBounds.top + this.props.minPagePadding!,\n          left: currentBounds.left + this.props.minPagePadding!,\n          right: currentBounds.right! - this.props.minPagePadding!,\n          bottom: currentBounds.bottom! - this.props.minPagePadding!,\n          width: currentBounds.width - this.props.minPagePadding! * 2,\n          height: currentBounds.height - this.props.minPagePadding! * 2,\n        };\n      }\n      this._bounds = currentBounds;\n    }\n    return this._bounds;\n  }\n\n  // Max height should remain as synchronous as possible, which is why it is not done using set state.\n  // It needs to be synchronous since it will impact the ultimate position of the callout.\n  private _getMaxHeight(): number | undefined {\n    if (!this._maxHeight) {\n      if (this.props.directionalHintFixed && this._target) {\n        const beakWidth = this.props.isBeakVisible ? this.props.beakWidth : 0;\n        const gapSpace = this.props.gapSpace ? this.props.gapSpace : 0;\n        // Since the callout cannot measure it's border size it must be taken into account here. Otherwise it will\n        // overlap with the target.\n        const totalGap = gapSpace + beakWidth!;\n        this._async.requestAnimationFrame(() => {\n          if (this._target) {\n            this._maxHeight = getMaxHeight(\n              this._target,\n              this.props.directionalHint!,\n              totalGap,\n              this._getBounds(),\n              this.props.coverTarget,\n            );\n            this._blockResetHeight = true;\n            this.forceUpdate();\n          }\n        }, this._target as Element);\n      } else {\n        this._maxHeight = this._getBounds().height!;\n      }\n    }\n    return this._maxHeight!;\n  }\n\n  private _arePositionsEqual(positions: ICalloutPositionedInfo, newPosition: ICalloutPositionedInfo): boolean {\n    return (\n      this._comparePositions(positions.elementPosition, newPosition.elementPosition) &&\n      this._comparePositions(positions.beakPosition.elementPosition, newPosition.beakPosition.elementPosition)\n    );\n  }\n\n  private _comparePositions(oldPositions: IPosition, newPositions: IPosition): boolean {\n    for (const key in newPositions) {\n      if (newPositions.hasOwnProperty(key)) {\n        const oldPositionEdge = oldPositions[key];\n        const newPositionEdge = newPositions[key];\n\n        if (oldPositionEdge !== undefined && newPositionEdge !== undefined) {\n          if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  private _setTargetWindowAndElement(target: Target): void {\n    const currentElement = this._calloutElement.current;\n\n    if (target) {\n      if (typeof target === 'string') {\n        const currentDoc: Document = getDocument(currentElement)!;\n        this._target = currentDoc ? (currentDoc.querySelector(target) as Element) : null;\n        this._targetWindow = getWindow(currentElement)!;\n        // Cast to any prevents error about stopPropagation always existing\n      } else if ((target as any).stopPropagation) {\n        this._targetWindow = getWindow((target as MouseEvent).target as HTMLElement)!;\n        this._target = target as MouseEvent;\n        // Same reason here\n      } else if ((target as any).getBoundingClientRect) {\n        const targetElement: Element = target as Element;\n        this._targetWindow = getWindow(targetElement)!;\n        this._target = targetElement;\n      } else if ((target as React.RefObject<Element>).current !== undefined) {\n        this._target = (target as React.RefObject<Element>).current;\n        this._targetWindow = getWindow(this._target)!;\n        // HTMLImgElements can have x and y values. The check for it being a point must go last.\n      } else {\n        this._targetWindow = getWindow(currentElement)!;\n        this._target = target as Point;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement)!;\n    }\n  }\n\n  private _setHeightOffsetEveryFrame(): void {\n    if (this._calloutElement.current && this.props.finalHeight) {\n      this._setHeightOffsetTimer = this._async.requestAnimationFrame(() => {\n        const calloutMainElem = this._calloutElement.current && (this._calloutElement.current.lastChild as HTMLElement);\n\n        if (!calloutMainElem) {\n          return;\n        }\n\n        const cardScrollHeight: number = calloutMainElem.scrollHeight;\n        const cardCurrHeight: number = calloutMainElem.offsetHeight;\n        const scrollDiff: number = cardScrollHeight - cardCurrHeight;\n\n        this.setState({\n          heightOffset: this.state.heightOffset! + scrollDiff,\n        });\n\n        if (calloutMainElem.offsetHeight < this.props.finalHeight!) {\n          this._setHeightOffsetEveryFrame();\n        } else {\n          this._async.cancelAnimationFrame(this._setHeightOffsetTimer, this._calloutElement.current);\n        }\n      }, this._calloutElement.current);\n    }\n  }\n\n  // Whether or not the current positions should be reset\n  private _didPositionPropsChange(newProps: ICalloutProps, oldProps: ICalloutProps): boolean {\n    return (\n      (!newProps.hidden && newProps.hidden !== oldProps.hidden) || newProps.directionalHint !== oldProps.directionalHint\n    );\n  }\n\n  private _getTarget(props: ICalloutProps = this.props): Target {\n    const { target } = props;\n    return target!;\n  }\n\n  private _mouseDownOnPopup = () => {\n    this._isMouseDownOnPopup = true;\n  };\n\n  private _mouseUpOnPopup = () => {\n    this._isMouseDownOnPopup = false;\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}