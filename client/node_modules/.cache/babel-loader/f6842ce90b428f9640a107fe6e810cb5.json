{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\nconst events_1 = require(\"events\");\nconst jsiterable_1 = __importDefault(require(\"jsiterable\"));\nconst constants_1 = require(\"./constants\");\nconst errors_1 = __importDefault(require(\"./errors\"));\nconst identityMap_1 = __importDefault(require(\"./identityMap\"));\nconst iri_1 = __importDefault(require(\"./iri\"));\nconst jsonldProcessor_1 = __importDefault(require(\"./jsonldProcessor\"));\n/**\n * @description Node in an index.\n * @export\n * @class IndexNode\n */\nclass IndexNode {\n  /**\n   * @description Creates an instance of IndexNode.\n   * @param {string} id The id of the node.\n   * @param {GraphIndex} The index the node belongs to.\n   * @param {GraphIndex} index The index containing this node.\n   * @memberof IndexNode\n   */\n  constructor(id, index) {\n    this._attributes = new Map();\n    /**\n     * @description Metadata object for tracking.\n     * @memberof IndexNode\n     */\n    this.metadata = {};\n    if (!id) {\n      throw new ReferenceError(`Invalid id. id is ${id}`);\n    }\n    if (!index) {\n      throw new ReferenceError(`Invalid index. index is ${index}`);\n    }\n    this._nodeId = id;\n    this._index = index;\n  }\n  /**\n   * @description Gets the id of the node.\n   * @readonly\n   * @memberof IndexNode\n   */\n  get id() {\n    return this._index.iri.compact(this._nodeId);\n  }\n  /**\n   * @description Sets the id of the node.\n   * @memberof IndexNode\n   */\n  set id(id) {\n    if (!id) {\n      throw new ReferenceError(`Invalid newId. newId is ${id}`);\n    }\n    const expandedId = this._index.iri.expand(id);\n    if (this._index.iri.equal(this._nodeId, expandedId)) {\n      return;\n    }\n    if (this._index.hasNode(expandedId)) {\n      throw new errors_1.default.IndexNodeDuplicateError(id);\n    }\n    // Change the id of the node and re-add it to the index with the new id.\n    const previousId = this._nodeId;\n    const outgoingEdges = [...this._index.getNodeOutgoing(this._nodeId)];\n    const incomingEdges = [...this._index.getNodeIncoming(this._nodeId)];\n    this._index.removeNode(this);\n    this._nodeId = expandedId;\n    this._index.addNode(this);\n    // Recreate the outgoing edges from the new node.\n    for (const {\n      edge\n    } of outgoingEdges) {\n      this._index.createEdge(edge.label, this._nodeId, edge.toNodeId);\n    }\n    // Recreate incoming edges to the new node.\n    for (const {\n      edge\n    } of incomingEdges) {\n      this._index.createEdge(edge.label, edge.fromNodeId, this._nodeId);\n    }\n    this._index.emit('nodeIdChanged', this, previousId);\n  }\n  /**\n   * @description Gets the @index attribute of this node.\n   * @memberof IndexNode\n   */\n  get index() {\n    return this._nodeIndex;\n  }\n  /**\n   * @description Sets the @index attribute of this node.\n   * @memberof IndexNode\n   */\n  set index(value) {\n    this._nodeIndex = value;\n  }\n  /**\n   * @description Gets all the attributes defined on the node.\n   * @readonly\n   * @type {Iterable<[string, any]>}\n   * @memberof IndexNode\n   */\n  get attributes() {\n    return new jsiterable_1.default(this._attributes.entries()).map(([key, val]) => {\n      return [this._index.iri.compact(key), val.map(x => {\n        return {\n          value: x['@value'],\n          language: x['@language']\n        };\n      })];\n    });\n  }\n  /**\n   * @description Adds an attribute value.\n   * @param {string} name The name of the attribute.\n   * @param {*} value The value to add\n   * @returns {this}\n   * @memberof IndexNode\n   */\n  addAttributeValue(name, value, language) {\n    if (!name) {\n      throw new ReferenceError(`Invalid name. name is ${name}`);\n    }\n    if (value === null || value === undefined) {\n      throw new ReferenceError(`Invalid value. value is ${value}`);\n    }\n    if (language && typeof value !== 'string') {\n      throw new TypeError(`Invalid argument type. Language attribute values must be strings, but instead found ${typeof value}`);\n    }\n    const normalizedName = this._index.iri.expand(name);\n    if (this._attributes.has(normalizedName)) {\n      const values = this._attributes.get(normalizedName);\n      if (language) {\n        // If an existing value for the specified language is already set, then replace the value, else add a new one.\n        const existing = values.find(x => x['@language'] === language);\n        if (existing) {\n          existing['@value'] = value;\n        } else {\n          values.push({\n            '@language': language,\n            '@value': value\n          });\n        }\n      } else {\n        values.push({\n          '@value': value\n        });\n      }\n    } else {\n      if (language) {\n        this._attributes.set(normalizedName, [{\n          '@language': language,\n          '@value': value\n        }]);\n      } else {\n        this._attributes.set(normalizedName, [{\n          '@value': value\n        }]);\n      }\n    }\n    return this;\n  }\n  /**\n   * @description Deletes a attribute and its value.\n   * @param {string} name The name of the attribute to delete.\n   * @param {string} [language] The optional language whose value should be deleted.\n   * @returns {this}\n   * @memberof IndexNode\n   */\n  deleteAttribute(name, language) {\n    if (!name) {\n      throw new ReferenceError(`Invalid name. name is ${name}`);\n    }\n    const normalizedName = this._index.iri.expand(name);\n    if (language) {\n      const currentValues = this._attributes.get(normalizedName);\n      if (currentValues) {\n        const valueIndex = currentValues.findIndex(x => x['@language'] === language);\n        if (valueIndex >= 0) {\n          currentValues.splice(valueIndex, 1);\n        }\n      }\n    } else {\n      this._attributes.delete(this._index.iri.expand(name));\n    }\n    return this;\n  }\n  /**\n   * @description Gets an attribute value.\n   * @template T\n   * @param {string} name The name of the attribute value to get.\n   * @returns {T}\n   * @memberof IndexNode\n   */\n  getAttributeValues(name) {\n    if (!name) {\n      throw new ReferenceError(`Invalid name. name is ${name}`);\n    }\n    const normalizedName = this._index.iri.expand(name);\n    const values = this._attributes.get(normalizedName);\n    if (!values) {\n      return [];\n    }\n    return values.map(x => {\n      return {\n        value: x['@value'],\n        language: x['@language']\n      };\n    });\n  }\n  /**\n   * @description Checks if an attribute has been defined on the node.\n   * @param {string} name The name of the attribute to check.\n   * @returns {boolean} True if the attribute has been defined, else false.\n   * @memberof IndexNode\n   */\n  hasAttribute(name) {\n    if (!name) {\n      throw new ReferenceError(`Invalid name. name is ${name}`);\n    }\n    return this._attributes.has(this._index.iri.expand(name));\n  }\n  /**\n   * @description Checks if an attribute has been defined and has the specified value.\n   * @param {string} name The name of the attribute to check.\n   * @param {*} value The value of the attribute to check.\n   * @param {string} [language] Optional language.\n   * @returns {boolean} True if the attribute has been defined and has the specified value.\n   * @memberof IndexNode\n   */\n  hasAttributeValue(name, value, language) {\n    if (!name) {\n      throw new ReferenceError(`Invalid name. name is '${name}'`);\n    }\n    if (!value) {\n      throw new ReferenceError(`Invalid value. value is '${value}'`);\n    }\n    if (language && typeof value !== 'string') {\n      throw new TypeError(`Invalid argument type. Language attribute values must be strings, but instead found ${typeof value}`);\n    }\n    const normalizedName = this._index.iri.expand(name);\n    const values = this._attributes.get(normalizedName);\n    if (values) {\n      return language ? values.some(x => x['@language'] === language && x['@value'] === value) : values.some(x => x['@value'] === value);\n    } else {\n      return false;\n    }\n  }\n  /**\n   * @description Removes an attribute value.\n   * @param {string} name The name of the attribute whose value should be removed.\n   * @param {string} value The value to remove.\n   * @param {string} [language] Optional language to remove the value from.\n   * @returns {this}\n   * @memberof IndexNode\n   */\n  removeAttributeValue(name, value) {\n    if (!name) {\n      throw new ReferenceError(`Invalid name. name is '${name}'`);\n    }\n    if (!value) {\n      throw new ReferenceError(`Invalid value. value is '${value}'`);\n    }\n    const normalizedName = this._index.iri.expand(name);\n    if (!this._attributes.has(normalizedName)) {\n      return;\n    }\n    const currentValues = this._attributes.get(normalizedName);\n    if (!currentValues) {\n      return this;\n    }\n    let valueIndex = currentValues.findIndex(x => x['@value'] === value);\n    while (valueIndex >= 0) {\n      currentValues.splice(valueIndex, 1);\n      valueIndex = currentValues.findIndex(x => x['@value'] === value);\n    }\n    if (currentValues.length === 0) {\n      // Removal of all values of an attribute equals deletion of the attribute.\n      this._attributes.delete(normalizedName);\n    }\n    return this;\n  }\n  /**\n   * @description Sets an attribute value, replacing any existing value.\n   * @param {string} name The name of the attribute to set.\n   * @param {*} value The value to set.\n   * @param {string} [language] Optional language to set the value for.\n   * @returns {this}\n   * @memberof IndexNode\n   */\n  setAttributeValue(name, value, language) {\n    if (!name) {\n      throw new ReferenceError(`Invalid label. label is ${name}`);\n    }\n    if (value === null || value === undefined) {\n      throw new ReferenceError(`Invalid value. value is ${value}`);\n    }\n    if (language && typeof value !== 'string') {\n      throw new TypeError(`Invalid argument type. Language attribute values must be strings, but instead found ${typeof value}`);\n    }\n    const normalizedName = this._index.iri.expand(name);\n    if (language) {\n      // If an existing value for the specified language is already set, then replace the value, else add a new one.\n      const values = this._attributes.get(normalizedName) || [];\n      const existing = values.find(x => x['@language'] === language);\n      if (existing) {\n        existing['@value'] = value;\n      } else {\n        values.push({\n          '@language': language,\n          '@value': value\n        });\n      }\n    } else {\n      this._attributes.set(normalizedName, [{\n        '@value': value\n      }]);\n    }\n    return this;\n  }\n  /**\n   * @description Returns a JSON representation of the node.\n   * @param {JsonFormatOptions} [options={}] Formatting options for the node.\n   * @returns {Promise<any>}\n   * @memberof IndexNode\n   */\n  toJson(options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      options.frame = Object.assign(options.frame || {}, {\n        [constants_1.JsonldKeywords.id]: this._nodeId\n      });\n      const json = yield this._index.toJson(options);\n      return json['@graph'][0];\n    });\n  }\n  /**\n   * @description Converts the vertex into a triple form.\n   * @returns {*} JSON object containing the triple\n   * @memberof IndexNode\n   */\n  toTriple() {\n    const triple = {\n      [constants_1.JsonldKeywords.id]: this._nodeId\n    };\n    for (const [attributeName, values] of this._attributes) {\n      triple[this._index.iri.expand(attributeName)] = values;\n    }\n    for (const {\n      edge,\n      node\n    } of this._index.getNodeOutgoing(this._nodeId)) {\n      const edgeLabelId = this._index.iri.expand(edge.label);\n      const edgeNodeId = node._nodeId;\n      if (!triple[edgeLabelId]) {\n        triple[edgeLabelId] = [];\n      }\n      if (edgeLabelId === constants_1.JsonldKeywords.type) {\n        triple[edgeLabelId].push(edgeNodeId);\n      } else {\n        triple[edgeLabelId].push({\n          [constants_1.JsonldKeywords.id]: edgeNodeId\n        });\n      }\n    }\n    return triple;\n  }\n}\nexports.IndexNode = IndexNode;\n/**\n * @description Edge in an index.\n * @export\n * @class IndexEdge\n */\nclass IndexEdge {\n  /**\n   *Creates an instance of IndexEdge.\n   * @param {string} label The edge label.\n   * @param {string} fromNodeId The outgoing node id.\n   * @param {string} toNodeId The incoming node id.\n   * @param {GraphIndex} index The index containing this edge.\n   * @memberof IndexEdge\n   */\n  constructor(label, fromNodeId, toNodeId, index) {\n    if (!label) {\n      throw new ReferenceError(`Invalid label. label is ${label}`);\n    }\n    if (!fromNodeId) {\n      throw new ReferenceError(`Invalid fromNodeId. fromNodeId is ${fromNodeId}`);\n    }\n    if (!toNodeId) {\n      throw new ReferenceError(`Invalid toNodeId. toNodeId is ${toNodeId}`);\n    }\n    if (!index) {\n      throw new ReferenceError(`Invalid index. index is ${index}`);\n    }\n    this._label = label;\n    this._fromNodeId = fromNodeId;\n    this._toNodeId = toNodeId;\n    this._index = index;\n  }\n  /**\n   * @description Gets the id of the index.\n   * @readonly\n   * @type {string}\n   * @memberof IndexEdge\n   */\n  get id() {\n    return IndexEdge.toId(this._label, this._fromNodeId, this._toNodeId);\n  }\n  /**\n   * @description Gets the label of the edge.\n   * @readonly\n   * @type {string}\n   * @memberof IndexEdge\n   */\n  get label() {\n    return this._index.iri.compact(this._label);\n  }\n  /**\n   * @description Gets the outgoing node id of the edge.\n   * @readonly\n   * @type {string}\n   * @memberof IndexEdge\n   */\n  get fromNodeId() {\n    return this._index.iri.compact(this._fromNodeId);\n  }\n  /**\n   * @description Gets the incoming node id of the edge.\n   * @readonly\n   * @type {string}\n   * @memberof IndexEdge\n   */\n  get toNodeId() {\n    return this._index.iri.compact(this._toNodeId);\n  }\n  /**\n   * @description Generates a deterministic id for an edge.\n   * @static\n   * @param {string} label The label of the edge.\n   * @param {string} fromNodeId The outgoing node id of the edge.\n   * @param {string} toNodeId The incoming node id of the edge.\n   * @returns\n   * @memberof IndexEdge\n   */\n  static toId(label, fromNodeId, toNodeId) {\n    if (!label) {\n      throw new ReferenceError(`Invalid label. label is ${label}`);\n    }\n    if (!fromNodeId) {\n      throw new ReferenceError(`Invalid fromNodeId. fromNodeId is ${fromNodeId}`);\n    }\n    if (!toNodeId) {\n      throw new ReferenceError(`Invalid toNodeId. toNodeId is ${toNodeId}`);\n    }\n    return `${fromNodeId}->${label}->${toNodeId}`;\n  }\n}\nexports.IndexEdge = IndexEdge;\n/**\n * @description Index store for graph nodes and edges.\n * @export\n * @class GraphIndex\n */\nclass GraphIndex extends events_1.EventEmitter {\n  constructor() {\n    super();\n    this.iri = new iri_1.default();\n    this._edges = new Map();\n    this._index = new Map();\n    this._nodes = new Map();\n    this._processor = new jsonldProcessor_1.default({\n      remoteContexts: false\n    });\n  }\n  /**\n   * @description Gets the contexts registered with the index.\n   * @readonly\n   * @type {Iterable<[string, any]>}\n   * @memberof GraphIndex\n   */\n  get contexts() {\n    return this._processor.contexts;\n  }\n  /**\n   * @description Gets the count of nodes in the index.\n   * @readonly\n   * @type {number}\n   * @memberof GraphIndex\n   */\n  get nodeCount() {\n    return this._nodes.size;\n  }\n  /**\n   * @description Gets the count of edges in the index.\n   * @readonly\n   * @type {number}\n   * @memberof GraphIndex\n   */\n  get edgeCount() {\n    return this._index.size;\n  }\n  /**\n   * @description Adds a context to the index.\n   * @param {string} id The id of the context to add.\n   * @param {value} context The context to add.\n   * @memberof GraphIndex\n   */\n  addContext(id, context) {\n    this._processor.addContext(id, context);\n  }\n  /**\n   * @description Adds a prefix for a canonical URI\n   * @param {string} prefix The prefix to add.\n   * @param {string} uri The uri the prefix maps to.\n   * @memberof GraphIndex\n   */\n  addPrefix(prefix, uri) {\n    this.iri.addPrefix(prefix, uri);\n  }\n  /**\n   * @description Adds a new node to the index.\n   * @param {IndexNode} node The node instance to add.\n   * @memberof GraphIndex\n   */\n  addNode(node) {\n    if (!node) {\n      throw new ReferenceError(`Invalid node. node is ${node}`);\n    }\n    if (this._nodes.has(node.id)) {\n      throw new errors_1.default.IndexNodeDuplicateError(node.id);\n    }\n    this._nodes.set(node.id, node);\n  }\n  /**\n   * @description Creates a new edge in the index.\n   * @param {string} label The label of the edge to create.\n   * @param {string} fromNodeId The edge outgoing node id.\n   * @param {string} toNodeId The edge incoming node id.\n   * @memberof GraphIndex\n   */\n  createEdge(label, fromNodeId, toNodeId) {\n    if (!label) {\n      throw new ReferenceError(`Invalid label. label is ${label}`);\n    }\n    if (!fromNodeId) {\n      throw new ReferenceError(`Invalid fromNodeId. fromNodeId is ${fromNodeId}`);\n    }\n    if (!toNodeId) {\n      throw new ReferenceError(`Invalid toNodeId. toNodeId is ${toNodeId}`);\n    }\n    const expandedLabel = this.iri.expand(label);\n    const expandedFromId = this.iri.expand(fromNodeId);\n    const expandedToId = this.iri.expand(toNodeId);\n    if (!this._nodes.has(expandedFromId)) {\n      throw new errors_1.default.IndexEdgeNodeNotFoundError(label, fromNodeId, 'outgoing');\n    }\n    if (!this._nodes.has(expandedToId)) {\n      throw new errors_1.default.IndexEdgeNodeNotFoundError(label, toNodeId, 'incoming');\n    }\n    if (expandedFromId === expandedToId) {\n      throw new errors_1.default.IndexEdgeCyclicalError(label, toNodeId);\n    }\n    const edgeId = IndexEdge.toId(expandedLabel, expandedFromId, expandedToId);\n    if (this._edges.has(edgeId)) {\n      return this._edges.get(edgeId);\n    }\n    const edge = new IndexEdge(expandedLabel, expandedFromId, expandedToId, this);\n    this._edges.set(edge.id, edge);\n    this._indexEdge(expandedLabel, expandedFromId, expandedToId);\n    this.emit('edgeCreated', edge);\n    return edge;\n  }\n  /**\n   * @description Creates a new node in the index.\n   * @param {string} id The id of the node to create.\n   * @returns {IndexNode}\n   * @memberof GraphIndex\n   */\n  createNode(id) {\n    if (!id) {\n      throw new ReferenceError(`Invalid id. id is ${id}`);\n    }\n    const expandedId = this.iri.expand(id);\n    if (this._nodes.has(expandedId)) {\n      throw new errors_1.default.IndexNodeDuplicateError(id);\n    }\n    const node = new IndexNode(expandedId, this);\n    this._nodes.set(expandedId, node);\n    this.emit('nodeCreated', node);\n    return node;\n  }\n  /**\n   * @description Gets an edge in the index.\n   * @param {string} label The label of the edge ot get.\n   * @param {string} fromNodeId The edge outgoing node id.\n   * @param {string} toNodeId The edge incoming node id.\n   * @returns {IndexEdge}\n   * @memberof GraphIndex\n   */\n  getEdge(label, fromNodeId, toNodeId) {\n    if (!label) {\n      throw new ReferenceError(`Invalid label. label is ${label}`);\n    }\n    if (!fromNodeId) {\n      throw new ReferenceError(`Invalid fromNodeId. fromNodeId is ${fromNodeId}`);\n    }\n    if (!toNodeId) {\n      throw new ReferenceError(`Invalid toNodeId. toNodeId is ${toNodeId}`);\n    }\n    return this._edges.get(IndexEdge.toId(this.iri.expand(label), this.iri.expand(fromNodeId), this.iri.expand(toNodeId)));\n  }\n  /**\n   * @description Gets edges in the index.\n   * @param {string} [label] Optional label filter used to only return edges with the matching label.\n   * @returns {IterableIterator<IndexEdge>}\n   * @memberof GraphIndex\n   */\n  *getEdges(label) {\n    if (!label) {\n      for (const [, edge] of this._edges) {\n        yield edge;\n      }\n    } else {\n      const indexKey = GraphIndex.IX_EDGES_KEY(this.iri.expand(label));\n      if (!this._index.has(indexKey)) {\n        return;\n      }\n      for (const edgeId of this._index.get(indexKey)) {\n        yield this._edges.get(edgeId);\n      }\n    }\n  }\n  /**\n   * @description Gets all nodes that have an incoming edge with the specified label.\n   * @param {string} label The incoming edge label.\n   * @returns {IterableIterator<IndexNode>}\n   * @memberof GraphIndex\n   */\n  *getEdgeIncoming(label) {\n    if (!label) {\n      throw new ReferenceError(`Invalid label. label is ${label}`);\n    }\n    const indexKey = GraphIndex.IX_EDGE_INCOMING_KEY(this.iri.expand(label));\n    if (!this._index.has(indexKey)) {\n      return;\n    }\n    const visited = new Set();\n    for (const edgeId of this._index.get(indexKey)) {\n      const edge = this._edges.get(edgeId);\n      if (!visited.has(edge.toNodeId)) {\n        visited.add(edge.toNodeId);\n        yield this._nodes.get(edge.toNodeId);\n      }\n    }\n  }\n  /**\n   * @description Gets all nodes that haven an outgoing edge with the specified label.\n   * @param {string} label The outgoing edge label.\n   * @returns {IterableIterator<IndexNode>}\n   * @memberof GraphIndex\n   */\n  *getEdgeOutgoing(label) {\n    if (!label) {\n      throw new ReferenceError(`Invalid label. label is ${label}`);\n    }\n    const indexKey = GraphIndex.IX_EDGE_OUTGOING_KEY(this.iri.expand(label));\n    if (!this._index.has(indexKey)) {\n      return;\n    }\n    const visited = new Set();\n    for (const edgeId of this._index.get(indexKey)) {\n      const edge = this._edges.get(edgeId);\n      if (!visited.has(edge.fromNodeId)) {\n        visited.add(edge.fromNodeId);\n        yield this._nodes.get(edge.fromNodeId);\n      }\n    }\n  }\n  /**\n   * @description Gets a specific node in the index.\n   * @param {string} id The id of the node to get.\n   * @returns {IndexNode}\n   * @memberof GraphIndex\n   */\n  getNode(id) {\n    if (!id) {\n      throw new ReferenceError(`Invalid id. id is ${id}`);\n    }\n    return this._nodes.get(this.iri.expand(id));\n  }\n  /**\n   * @description Gets all nodes in the index.\n   * @returns {IterableIterator<IndexNode>}\n   * @memberof GraphIndex\n   */\n  *getNodes() {\n    for (const [, node] of this._nodes) {\n      yield node;\n    }\n  }\n  /**\n   * @description Gets a node's incoming edges, along with the incoming node.\n   * @param {string} id The node whose incoming edges and nodes are to be retrieved.\n   * @param {string} [label] Optional label to filter only those incoming edges that match the specified label.\n   * @returns {IterableIterator<{ edge: IndexEdge, node: IndexNode }>}\n   * @memberof GraphIndex\n   */\n  *getNodeIncoming(id, label) {\n    if (!id) {\n      throw new ReferenceError(`id is invalid. id is ${id}`);\n    }\n    let indexKey;\n    if (!label) {\n      indexKey = GraphIndex.IX_NODE_INCOMING_ALL_KEY(this.iri.expand(id));\n    } else {\n      indexKey = GraphIndex.IX_NODE_INCOMING_EDGES(this.iri.expand(id), this.iri.expand(label));\n    }\n    if (!this._index.has(indexKey)) {\n      return;\n    }\n    for (const edgeId of this._index.get(indexKey)) {\n      const edge = this._edges.get(edgeId);\n      const node = this._nodes.get(this.iri.expand(edge.fromNodeId));\n      yield {\n        edge,\n        node\n      };\n    }\n  }\n  /**\n   * @description Gets a node's outgoing edges, along with the outgoing node.\n   * @param {string} id The node whose outgoing edges and nodes are to be retrieved.\n   * @param {string} [label] Optional label to filter only those outgoing edges that match the specified label.\n   * @returns {IterableIterator<{ edge: IndexEdge, node: IndexNode }>}\n   * @memberof GraphIndex\n   */\n  *getNodeOutgoing(id, label) {\n    let indexKey;\n    if (!label) {\n      indexKey = GraphIndex.IX_NODE_OUTGOING_ALL(this.iri.expand(id));\n    } else {\n      indexKey = GraphIndex.IX_NODE_OUTGOING_EDGES(this.iri.expand(id), this.iri.expand(label));\n    }\n    if (!this._index.has(indexKey)) {\n      return;\n    }\n    for (const edgeId of this._index.get(indexKey)) {\n      const edge = this._edges.get(edgeId);\n      const node = this._nodes.get(this.iri.expand(edge.toNodeId));\n      yield {\n        edge,\n        node\n      };\n    }\n  }\n  /**\n   * @description Checks if a specific edge exists.\n   * @param {string} label The label of the edge.\n   * @param {string} fromNodeId The edge outgoing node id.\n   * @param {string} toNodeId The edge incoming node id.\n   * @returns {boolean} True if the edge exists, else false.\n   * @memberof GraphIndex\n   */\n  hasEdge(label, fromNodeId, toNodeId) {\n    if (!label) {\n      throw new ReferenceError(`Invalid label. label is ${label}`);\n    }\n    if (!fromNodeId) {\n      throw new ReferenceError(`Invalid fromNodeId. fromNodeId is ${fromNodeId}`);\n    }\n    if (!toNodeId) {\n      throw new ReferenceError(`Invalid toNodeId. toNodeId is ${toNodeId}`);\n    }\n    return this._edges.has(IndexEdge.toId(this.iri.expand(label), this.iri.expand(fromNodeId), this.iri.expand(toNodeId)));\n  }\n  /**\n   * @description Checks if a specific node exists.\n   * @param {string} id The id of the node to check for.\n   * @returns {boolean} True if the node exists, else false.\n   * @memberof GraphIndex\n   */\n  hasNode(id) {\n    if (!id) {\n      throw new ReferenceError(`Invalid nodeId. nodeId is ${id}`);\n    }\n    return this._nodes.has(this.iri.expand(id));\n  }\n  /**\n   * @description Loads a set of input JSON-LD documents into the index.\n   * @param {(any | any[])} inputs The inputs to load.\n   * @param {string|string[]|object|object[]} [contexts] The contexts to load.\n   * @param {string} [base] The base IRI of the context.\n   * @returns {Promise<Set<string>>}\n   * @memberof GraphIndex\n   */\n  load(inputs, contexts, base) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!inputs) {\n        throw new ReferenceError(`Invalid inputs. inputs is ${inputs}`);\n      }\n      const vertexTracker = new Set();\n      const documents = inputs instanceof Array ? inputs : [inputs];\n      for (const document of documents) {\n        try {\n          const triples = yield this._processor.flatten(document, contexts, base);\n          this._loadTriples(triples, vertexTracker, false);\n        } catch (err) {\n          throw new errors_1.default.DocumentParseError(err);\n        }\n      }\n      return vertexTracker;\n    });\n  }\n  /**\n   * @description Loads and merges a set of input JSON-LD documents into the index.\n   * @param {(any | any[])} inputs The inputs to merge.\n   * @param {string|string[]|object|object[]} [contexts] The contexts to merge.\n   * @param {string} [base] The base IRI of inputs.\n   * @returns {Promise<Set<string>>}\n   * @memberof GraphIndex\n   */\n  merge(inputs, contexts, base) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!inputs) {\n        throw new ReferenceError(`Invalid inputs. inputs is ${inputs}`);\n      }\n      const vertexTracker = new Set();\n      const documents = inputs instanceof Array ? inputs : [inputs];\n      for (const document of documents) {\n        try {\n          const triples = yield this._processor.flatten(document, contexts, base);\n          this._loadTriples(triples, vertexTracker, true);\n        } catch (err) {\n          throw new errors_1.default.DocumentParseError(err);\n        }\n      }\n      return vertexTracker;\n    });\n  }\n  /**\n   * @description Removes a context.\n   * @param {string} uri The uri of the context to remove.\n   * @memberof GraphIndex\n   */\n  removeContext(uri) {\n    this._processor.removeContext(uri);\n  }\n  /**\n   * @description Removes an edge from the index.\n   * @param {(string | IndexEdge)} edge The id or edge instance to remove from the index.\n   * @returns {void}\n   * @memberof GraphIndex\n   */\n  removeEdge(edge) {\n    if (!edge) {\n      throw new ReferenceError(`Invalid edge. edge is ${edge}`);\n    }\n    let indexEdge = edge;\n    if (typeof edge === 'string') {\n      indexEdge = this._edges.get(this.iri.expand(edge));\n      if (!indexEdge) {\n        return;\n      }\n    }\n    this._deleteEdgeIndex(this.iri.expand(indexEdge.label), this.iri.expand(indexEdge.fromNodeId), this.iri.expand(indexEdge.toNodeId));\n    if (this._edges.delete(indexEdge.id)) {\n      this.emit('edgeDeleted', indexEdge);\n    }\n  }\n  /**\n   * @description Removes a node from the index.\n   * @param {(string | IndexNode)} node The id or node instance to remove from the index.\n   * @returns {void}\n   * @memberof GraphIndex\n   */\n  removeNode(node) {\n    if (!node) {\n      throw new ReferenceError(`Invalid node. node is ${node}`);\n    }\n    let indexNode = node;\n    if (typeof node === 'string') {\n      indexNode = this._nodes.get(this.iri.expand(node));\n      if (!indexNode) {\n        return;\n      }\n    }\n    const incomingEdgesKey = GraphIndex.IX_NODE_INCOMING_ALL_KEY(this.iri.expand(indexNode.id));\n    const outgoingEdgesKey = GraphIndex.IX_NODE_OUTGOING_ALL(this.iri.expand(indexNode.id));\n    if (this._index.has(incomingEdgesKey)) {\n      for (const edgeId of this._index.get(incomingEdgesKey)) {\n        this.removeEdge(edgeId);\n      }\n      this._index.delete(incomingEdgesKey);\n    }\n    if (this._index.has(outgoingEdgesKey)) {\n      for (const edgeId of this._index.get(outgoingEdgesKey)) {\n        this.removeEdge(edgeId);\n      }\n      this._index.delete(outgoingEdgesKey);\n    }\n    this._nodes.delete(this.iri.expand(indexNode.id));\n    this.emit('nodeDeleted', indexNode);\n  }\n  /**\n   * @description Removes a prefix from the index.\n   * @param {string} prefix The prefix string to remove.\n   * @memberof GraphIndex\n   */\n  removePrefix(prefix) {\n    this.iri.removePrefix(prefix);\n  }\n  /**\n   * @description Gets a JSON representation of the index.\n   * @param {frame} [any] Optional frame instruction.\n   * @returns {Promise<any>}\n   * @memberof GraphIndex\n   */\n  toJson(options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const document = {\n        [constants_1.JsonldKeywords.graph]: []\n      };\n      for (const node of this.getNodes()) {\n        document[constants_1.JsonldKeywords.graph].push(node.toTriple());\n      }\n      const formatOptions = lodash_clonedeep_1.default(options);\n      if (formatOptions.frame) {\n        this._expandIdReferences(formatOptions.frame);\n        if (formatOptions.context && !formatOptions.frame[constants_1.JsonldKeywords.container]) {\n          formatOptions.frame[constants_1.JsonldKeywords.context] = options.context;\n        }\n        return this._processor.frame(document, formatOptions.frame, [], options.base);\n      } else if (options.context) {\n        const expanded = yield this._processor.expand(document, formatOptions.context, options.base);\n        return this._processor.compact(expanded, formatOptions.context);\n      } else {\n        return document;\n      }\n    });\n  }\n  _createEdgeIndexKeys(label, fromNodeId, toNodeId) {\n    return [GraphIndex.IX_EDGES_KEY(label), GraphIndex.IX_EDGE_INCOMING_KEY(label), GraphIndex.IX_EDGE_OUTGOING_KEY(label), GraphIndex.IX_NODE_INCOMING_ALL_KEY(toNodeId), GraphIndex.IX_NODE_INCOMING_EDGES(toNodeId, label), GraphIndex.IX_NODE_OUTGOING_ALL(fromNodeId), GraphIndex.IX_NODE_OUTGOING_EDGES(fromNodeId, label)];\n  }\n  _deleteEdgeIndex(label, fromNodeId, toNodeId) {\n    const edgeId = IndexEdge.toId(label, fromNodeId, toNodeId);\n    const indexKeys = this._createEdgeIndexKeys(label, fromNodeId, toNodeId);\n    for (const key of indexKeys) {\n      if (this._index.has(key)) {\n        this._index.get(key).delete(edgeId);\n        if (this._index.get(key).size === 0) {\n          this._index.delete(key);\n        }\n      }\n    }\n  }\n  _expandIdReferences(source) {\n    // This function is primarily looking for objects with @id keys and processing the identity references.\n    // 1. Start by only accepting Array or object types.\n    // 2. If source is an array, loop over elements in the array and recursively call self.\n    // 3. If source is an object\n    // 4. Get all own property keys. Loop through each key.\n    // 4.a.Key is @id, process the value\n    // 4.a @id value can either b a string or an array. If string replace the id with expanded id value. If an array then go through and expand each element.\n    if (source instanceof Array) {\n      for (const element of source) {\n        this._expandIdReferences(element);\n      }\n    } else if (typeof source === 'object') {\n      const keys = Object.getOwnPropertyNames(source);\n      for (const key of keys) {\n        if (key === constants_1.JsonldKeywords.id) {\n          if (source[key] instanceof Array) {\n            const elements = [...source[key]];\n            for (const element of elements) {\n              if (typeof element === 'string') {\n                source[key].splice(source[key].indexOf(element), 1, this.iri.expand(element));\n              }\n            }\n          } else if (typeof source[key] === 'string') {\n            source[key] = this.iri.expand(source[key]);\n          }\n        } else if (source[key] instanceof Array || typeof source[key] === 'object') {\n          this._expandIdReferences(source[key]);\n        }\n      }\n    }\n  }\n  _indexEdge(label, fromNodeId, toNodeId) {\n    const edgeId = IndexEdge.toId(label, fromNodeId, toNodeId);\n    for (const key of this._createEdgeIndexKeys(label, fromNodeId, toNodeId)) {\n      if (!this._index.has(key)) {\n        this._index.set(key, new Set());\n      }\n      this._index.get(key).add(edgeId);\n    }\n  }\n  _loadTriples(triples, vertexTracker, mergeAttributes = false) {\n    const identityMap = new identityMap_1.default();\n    for (const triple of triples) {\n      const id = identityMap.get(triple);\n      const types = triple[constants_1.JsonldKeywords.type] || [];\n      let subjectNode;\n      if (this.hasNode(id)) {\n        subjectNode = this.getNode(id);\n      } else {\n        subjectNode = this.createNode(id);\n        vertexTracker.add(this.iri.compact(id));\n      }\n      // Add outgoing edges to type nodes.\n      for (const typeId of types) {\n        if (!this.hasNode(typeId)) {\n          this.createNode(typeId);\n        }\n        this.createEdge(constants_1.JsonldKeywords.type, subjectNode.id, typeId);\n      }\n      // Process each predicate for the object.\n      for (const predicate of Object.keys(triple)) {\n        this._loadPredicate(identityMap, subjectNode, predicate, triple[predicate], vertexTracker, mergeAttributes);\n      }\n    }\n  }\n  _loadPredicate(identityMap, subjectNode, predicate, objects, vertexTracker, mergeAttributes) {\n    for (const obj of objects) {\n      if (obj[constants_1.JsonldKeywords.list]) {\n        // Predicate object is a @list container, Load individual items in the @list array.\n        return this._loadPredicate(identityMap, subjectNode, predicate, obj[constants_1.JsonldKeywords.list], vertexTracker, mergeAttributes);\n      }\n      if (obj[constants_1.JsonldKeywords.id]) {\n        // Predicate object is a reference to another entity, create an edge to model the relationship.\n        const objectId = identityMap.get(obj);\n        if (!this.hasNode(objectId)) {\n          this.createNode(objectId);\n        }\n        vertexTracker.add(this.iri.compact(objectId));\n        this.createEdge(predicate, subjectNode.id, objectId);\n      }\n      if (obj[constants_1.JsonldKeywords.value] !== null && obj[constants_1.JsonldKeywords.value] !== undefined) {\n        // Predicate object is a value. Inline the value as a attribute of the subject vertex.\n        if (mergeAttributes) {\n          subjectNode.setAttributeValue(predicate, obj[constants_1.JsonldKeywords.value], obj[constants_1.JsonldKeywords.language]);\n        } else {\n          subjectNode.addAttributeValue(predicate, obj[constants_1.JsonldKeywords.value], obj[constants_1.JsonldKeywords.language]);\n        }\n      }\n    }\n  }\n}\nexports.GraphIndex = GraphIndex;\nGraphIndex.IX_EDGES_KEY = label => `[e]::${label}`;\nGraphIndex.IX_EDGE_INCOMING_KEY = label => `[e]::${label}_[in]`;\nGraphIndex.IX_EDGE_OUTGOING_KEY = label => `[e]::${label}_[out]`;\nGraphIndex.IX_NODE_INCOMING_ALL_KEY = id => `[v]::${id}_[in]`;\nGraphIndex.IX_NODE_INCOMING_EDGES = (id, label) => `[v]::${id}_[in]_[e]::${label}`;\nGraphIndex.IX_NODE_OUTGOING_ALL = id => `[v]::${id}_[out]`;\nGraphIndex.IX_NODE_OUTGOING_EDGES = (id, label) => `[v]::${id}_[out]_[e]::${label}`;\nexports.default = GraphIndex;","map":{"version":3,"sources":["../src/graphIndex.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\nconst events_1 = require(\"events\");\nconst jsiterable_1 = __importDefault(require(\"jsiterable\"));\nconst constants_1 = require(\"./constants\");\nconst errors_1 = __importDefault(require(\"./errors\"));\nconst identityMap_1 = __importDefault(require(\"./identityMap\"));\nconst iri_1 = __importDefault(require(\"./iri\"));\nconst jsonldProcessor_1 = __importDefault(require(\"./jsonldProcessor\"));\n/**\n * @description Node in an index.\n * @export\n * @class IndexNode\n */\nclass IndexNode {\n    /**\n     * @description Creates an instance of IndexNode.\n     * @param {string} id The id of the node.\n     * @param {GraphIndex} The index the node belongs to.\n     * @param {GraphIndex} index The index containing this node.\n     * @memberof IndexNode\n     */\n    constructor(id, index) {\n        this._attributes = new Map();\n        /**\n         * @description Metadata object for tracking.\n         * @memberof IndexNode\n         */\n        this.metadata = {};\n        if (!id) {\n            throw new ReferenceError(`Invalid id. id is ${id}`);\n        }\n        if (!index) {\n            throw new ReferenceError(`Invalid index. index is ${index}`);\n        }\n        this._nodeId = id;\n        this._index = index;\n    }\n    /**\n     * @description Gets the id of the node.\n     * @readonly\n     * @memberof IndexNode\n     */\n    get id() {\n        return this._index.iri.compact(this._nodeId);\n    }\n    /**\n     * @description Sets the id of the node.\n     * @memberof IndexNode\n     */\n    set id(id) {\n        if (!id) {\n            throw new ReferenceError(`Invalid newId. newId is ${id}`);\n        }\n        const expandedId = this._index.iri.expand(id);\n        if (this._index.iri.equal(this._nodeId, expandedId)) {\n            return;\n        }\n        if (this._index.hasNode(expandedId)) {\n            throw new errors_1.default.IndexNodeDuplicateError(id);\n        }\n        // Change the id of the node and re-add it to the index with the new id.\n        const previousId = this._nodeId;\n        const outgoingEdges = [...this._index.getNodeOutgoing(this._nodeId)];\n        const incomingEdges = [...this._index.getNodeIncoming(this._nodeId)];\n        this._index.removeNode(this);\n        this._nodeId = expandedId;\n        this._index.addNode(this);\n        // Recreate the outgoing edges from the new node.\n        for (const { edge } of outgoingEdges) {\n            this._index.createEdge(edge.label, this._nodeId, edge.toNodeId);\n        }\n        // Recreate incoming edges to the new node.\n        for (const { edge } of incomingEdges) {\n            this._index.createEdge(edge.label, edge.fromNodeId, this._nodeId);\n        }\n        this._index.emit('nodeIdChanged', this, previousId);\n    }\n    /**\n     * @description Gets the @index attribute of this node.\n     * @memberof IndexNode\n     */\n    get index() {\n        return this._nodeIndex;\n    }\n    /**\n     * @description Sets the @index attribute of this node.\n     * @memberof IndexNode\n     */\n    set index(value) {\n        this._nodeIndex = value;\n    }\n    /**\n     * @description Gets all the attributes defined on the node.\n     * @readonly\n     * @type {Iterable<[string, any]>}\n     * @memberof IndexNode\n     */\n    get attributes() {\n        return new jsiterable_1.default(this._attributes.entries()).map(([key, val]) => {\n            return [\n                this._index.iri.compact(key),\n                val.map(x => {\n                    return {\n                        value: x['@value'],\n                        language: x['@language']\n                    };\n                })\n            ];\n        });\n    }\n    /**\n     * @description Adds an attribute value.\n     * @param {string} name The name of the attribute.\n     * @param {*} value The value to add\n     * @returns {this}\n     * @memberof IndexNode\n     */\n    addAttributeValue(name, value, language) {\n        if (!name) {\n            throw new ReferenceError(`Invalid name. name is ${name}`);\n        }\n        if (value === null || value === undefined) {\n            throw new ReferenceError(`Invalid value. value is ${value}`);\n        }\n        if (language && typeof value !== 'string') {\n            throw new TypeError(`Invalid argument type. Language attribute values must be strings, but instead found ${typeof value}`);\n        }\n        const normalizedName = this._index.iri.expand(name);\n        if (this._attributes.has(normalizedName)) {\n            const values = this._attributes.get(normalizedName);\n            if (language) {\n                // If an existing value for the specified language is already set, then replace the value, else add a new one.\n                const existing = values.find(x => x['@language'] === language);\n                if (existing) {\n                    existing['@value'] = value;\n                }\n                else {\n                    values.push({ '@language': language, '@value': value });\n                }\n            }\n            else {\n                values.push({ '@value': value });\n            }\n        }\n        else {\n            if (language) {\n                this._attributes.set(normalizedName, [\n                    {\n                        '@language': language,\n                        '@value': value\n                    }\n                ]);\n            }\n            else {\n                this._attributes.set(normalizedName, [\n                    {\n                        '@value': value\n                    }\n                ]);\n            }\n        }\n        return this;\n    }\n    /**\n     * @description Deletes a attribute and its value.\n     * @param {string} name The name of the attribute to delete.\n     * @param {string} [language] The optional language whose value should be deleted.\n     * @returns {this}\n     * @memberof IndexNode\n     */\n    deleteAttribute(name, language) {\n        if (!name) {\n            throw new ReferenceError(`Invalid name. name is ${name}`);\n        }\n        const normalizedName = this._index.iri.expand(name);\n        if (language) {\n            const currentValues = this._attributes.get(normalizedName);\n            if (currentValues) {\n                const valueIndex = currentValues.findIndex(x => x['@language'] === language);\n                if (valueIndex >= 0) {\n                    currentValues.splice(valueIndex, 1);\n                }\n            }\n        }\n        else {\n            this._attributes.delete(this._index.iri.expand(name));\n        }\n        return this;\n    }\n    /**\n     * @description Gets an attribute value.\n     * @template T\n     * @param {string} name The name of the attribute value to get.\n     * @returns {T}\n     * @memberof IndexNode\n     */\n    getAttributeValues(name) {\n        if (!name) {\n            throw new ReferenceError(`Invalid name. name is ${name}`);\n        }\n        const normalizedName = this._index.iri.expand(name);\n        const values = this._attributes.get(normalizedName);\n        if (!values) {\n            return [];\n        }\n        return values.map(x => {\n            return {\n                value: x['@value'],\n                language: x['@language']\n            };\n        });\n    }\n    /**\n     * @description Checks if an attribute has been defined on the node.\n     * @param {string} name The name of the attribute to check.\n     * @returns {boolean} True if the attribute has been defined, else false.\n     * @memberof IndexNode\n     */\n    hasAttribute(name) {\n        if (!name) {\n            throw new ReferenceError(`Invalid name. name is ${name}`);\n        }\n        return this._attributes.has(this._index.iri.expand(name));\n    }\n    /**\n     * @description Checks if an attribute has been defined and has the specified value.\n     * @param {string} name The name of the attribute to check.\n     * @param {*} value The value of the attribute to check.\n     * @param {string} [language] Optional language.\n     * @returns {boolean} True if the attribute has been defined and has the specified value.\n     * @memberof IndexNode\n     */\n    hasAttributeValue(name, value, language) {\n        if (!name) {\n            throw new ReferenceError(`Invalid name. name is '${name}'`);\n        }\n        if (!value) {\n            throw new ReferenceError(`Invalid value. value is '${value}'`);\n        }\n        if (language && typeof value !== 'string') {\n            throw new TypeError(`Invalid argument type. Language attribute values must be strings, but instead found ${typeof value}`);\n        }\n        const normalizedName = this._index.iri.expand(name);\n        const values = this._attributes.get(normalizedName);\n        if (values) {\n            return language\n                ? values.some(x => x['@language'] === language && x['@value'] === value)\n                : values.some(x => x['@value'] === value);\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * @description Removes an attribute value.\n     * @param {string} name The name of the attribute whose value should be removed.\n     * @param {string} value The value to remove.\n     * @param {string} [language] Optional language to remove the value from.\n     * @returns {this}\n     * @memberof IndexNode\n     */\n    removeAttributeValue(name, value) {\n        if (!name) {\n            throw new ReferenceError(`Invalid name. name is '${name}'`);\n        }\n        if (!value) {\n            throw new ReferenceError(`Invalid value. value is '${value}'`);\n        }\n        const normalizedName = this._index.iri.expand(name);\n        if (!this._attributes.has(normalizedName)) {\n            return;\n        }\n        const currentValues = this._attributes.get(normalizedName);\n        if (!currentValues) {\n            return this;\n        }\n        let valueIndex = currentValues.findIndex(x => x['@value'] === value);\n        while (valueIndex >= 0) {\n            currentValues.splice(valueIndex, 1);\n            valueIndex = currentValues.findIndex(x => x['@value'] === value);\n        }\n        if (currentValues.length === 0) {\n            // Removal of all values of an attribute equals deletion of the attribute.\n            this._attributes.delete(normalizedName);\n        }\n        return this;\n    }\n    /**\n     * @description Sets an attribute value, replacing any existing value.\n     * @param {string} name The name of the attribute to set.\n     * @param {*} value The value to set.\n     * @param {string} [language] Optional language to set the value for.\n     * @returns {this}\n     * @memberof IndexNode\n     */\n    setAttributeValue(name, value, language) {\n        if (!name) {\n            throw new ReferenceError(`Invalid label. label is ${name}`);\n        }\n        if (value === null || value === undefined) {\n            throw new ReferenceError(`Invalid value. value is ${value}`);\n        }\n        if (language && typeof value !== 'string') {\n            throw new TypeError(`Invalid argument type. Language attribute values must be strings, but instead found ${typeof value}`);\n        }\n        const normalizedName = this._index.iri.expand(name);\n        if (language) {\n            // If an existing value for the specified language is already set, then replace the value, else add a new one.\n            const values = this._attributes.get(normalizedName) || [];\n            const existing = values.find(x => x['@language'] === language);\n            if (existing) {\n                existing['@value'] = value;\n            }\n            else {\n                values.push({ '@language': language, '@value': value });\n            }\n        }\n        else {\n            this._attributes.set(normalizedName, [{ '@value': value }]);\n        }\n        return this;\n    }\n    /**\n     * @description Returns a JSON representation of the node.\n     * @param {JsonFormatOptions} [options={}] Formatting options for the node.\n     * @returns {Promise<any>}\n     * @memberof IndexNode\n     */\n    toJson(options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            options.frame = Object.assign(options.frame || {}, {\n                [constants_1.JsonldKeywords.id]: this._nodeId\n            });\n            const json = yield this._index.toJson(options);\n            return json['@graph'][0];\n        });\n    }\n    /**\n     * @description Converts the vertex into a triple form.\n     * @returns {*} JSON object containing the triple\n     * @memberof IndexNode\n     */\n    toTriple() {\n        const triple = {\n            [constants_1.JsonldKeywords.id]: this._nodeId\n        };\n        for (const [attributeName, values] of this._attributes) {\n            triple[this._index.iri.expand(attributeName)] = values;\n        }\n        for (const { edge, node } of this._index.getNodeOutgoing(this._nodeId)) {\n            const edgeLabelId = this._index.iri.expand(edge.label);\n            const edgeNodeId = node._nodeId;\n            if (!triple[edgeLabelId]) {\n                triple[edgeLabelId] = [];\n            }\n            if (edgeLabelId === constants_1.JsonldKeywords.type) {\n                triple[edgeLabelId].push(edgeNodeId);\n            }\n            else {\n                triple[edgeLabelId].push({\n                    [constants_1.JsonldKeywords.id]: edgeNodeId\n                });\n            }\n        }\n        return triple;\n    }\n}\nexports.IndexNode = IndexNode;\n/**\n * @description Edge in an index.\n * @export\n * @class IndexEdge\n */\nclass IndexEdge {\n    /**\n     *Creates an instance of IndexEdge.\n     * @param {string} label The edge label.\n     * @param {string} fromNodeId The outgoing node id.\n     * @param {string} toNodeId The incoming node id.\n     * @param {GraphIndex} index The index containing this edge.\n     * @memberof IndexEdge\n     */\n    constructor(label, fromNodeId, toNodeId, index) {\n        if (!label) {\n            throw new ReferenceError(`Invalid label. label is ${label}`);\n        }\n        if (!fromNodeId) {\n            throw new ReferenceError(`Invalid fromNodeId. fromNodeId is ${fromNodeId}`);\n        }\n        if (!toNodeId) {\n            throw new ReferenceError(`Invalid toNodeId. toNodeId is ${toNodeId}`);\n        }\n        if (!index) {\n            throw new ReferenceError(`Invalid index. index is ${index}`);\n        }\n        this._label = label;\n        this._fromNodeId = fromNodeId;\n        this._toNodeId = toNodeId;\n        this._index = index;\n    }\n    /**\n     * @description Gets the id of the index.\n     * @readonly\n     * @type {string}\n     * @memberof IndexEdge\n     */\n    get id() {\n        return IndexEdge.toId(this._label, this._fromNodeId, this._toNodeId);\n    }\n    /**\n     * @description Gets the label of the edge.\n     * @readonly\n     * @type {string}\n     * @memberof IndexEdge\n     */\n    get label() {\n        return this._index.iri.compact(this._label);\n    }\n    /**\n     * @description Gets the outgoing node id of the edge.\n     * @readonly\n     * @type {string}\n     * @memberof IndexEdge\n     */\n    get fromNodeId() {\n        return this._index.iri.compact(this._fromNodeId);\n    }\n    /**\n     * @description Gets the incoming node id of the edge.\n     * @readonly\n     * @type {string}\n     * @memberof IndexEdge\n     */\n    get toNodeId() {\n        return this._index.iri.compact(this._toNodeId);\n    }\n    /**\n     * @description Generates a deterministic id for an edge.\n     * @static\n     * @param {string} label The label of the edge.\n     * @param {string} fromNodeId The outgoing node id of the edge.\n     * @param {string} toNodeId The incoming node id of the edge.\n     * @returns\n     * @memberof IndexEdge\n     */\n    static toId(label, fromNodeId, toNodeId) {\n        if (!label) {\n            throw new ReferenceError(`Invalid label. label is ${label}`);\n        }\n        if (!fromNodeId) {\n            throw new ReferenceError(`Invalid fromNodeId. fromNodeId is ${fromNodeId}`);\n        }\n        if (!toNodeId) {\n            throw new ReferenceError(`Invalid toNodeId. toNodeId is ${toNodeId}`);\n        }\n        return `${fromNodeId}->${label}->${toNodeId}`;\n    }\n}\nexports.IndexEdge = IndexEdge;\n/**\n * @description Index store for graph nodes and edges.\n * @export\n * @class GraphIndex\n */\nclass GraphIndex extends events_1.EventEmitter {\n    constructor() {\n        super();\n        this.iri = new iri_1.default();\n        this._edges = new Map();\n        this._index = new Map();\n        this._nodes = new Map();\n        this._processor = new jsonldProcessor_1.default({ remoteContexts: false });\n    }\n    /**\n     * @description Gets the contexts registered with the index.\n     * @readonly\n     * @type {Iterable<[string, any]>}\n     * @memberof GraphIndex\n     */\n    get contexts() {\n        return this._processor.contexts;\n    }\n    /**\n     * @description Gets the count of nodes in the index.\n     * @readonly\n     * @type {number}\n     * @memberof GraphIndex\n     */\n    get nodeCount() {\n        return this._nodes.size;\n    }\n    /**\n     * @description Gets the count of edges in the index.\n     * @readonly\n     * @type {number}\n     * @memberof GraphIndex\n     */\n    get edgeCount() {\n        return this._index.size;\n    }\n    /**\n     * @description Adds a context to the index.\n     * @param {string} id The id of the context to add.\n     * @param {value} context The context to add.\n     * @memberof GraphIndex\n     */\n    addContext(id, context) {\n        this._processor.addContext(id, context);\n    }\n    /**\n     * @description Adds a prefix for a canonical URI\n     * @param {string} prefix The prefix to add.\n     * @param {string} uri The uri the prefix maps to.\n     * @memberof GraphIndex\n     */\n    addPrefix(prefix, uri) {\n        this.iri.addPrefix(prefix, uri);\n    }\n    /**\n     * @description Adds a new node to the index.\n     * @param {IndexNode} node The node instance to add.\n     * @memberof GraphIndex\n     */\n    addNode(node) {\n        if (!node) {\n            throw new ReferenceError(`Invalid node. node is ${node}`);\n        }\n        if (this._nodes.has(node.id)) {\n            throw new errors_1.default.IndexNodeDuplicateError(node.id);\n        }\n        this._nodes.set(node.id, node);\n    }\n    /**\n     * @description Creates a new edge in the index.\n     * @param {string} label The label of the edge to create.\n     * @param {string} fromNodeId The edge outgoing node id.\n     * @param {string} toNodeId The edge incoming node id.\n     * @memberof GraphIndex\n     */\n    createEdge(label, fromNodeId, toNodeId) {\n        if (!label) {\n            throw new ReferenceError(`Invalid label. label is ${label}`);\n        }\n        if (!fromNodeId) {\n            throw new ReferenceError(`Invalid fromNodeId. fromNodeId is ${fromNodeId}`);\n        }\n        if (!toNodeId) {\n            throw new ReferenceError(`Invalid toNodeId. toNodeId is ${toNodeId}`);\n        }\n        const expandedLabel = this.iri.expand(label);\n        const expandedFromId = this.iri.expand(fromNodeId);\n        const expandedToId = this.iri.expand(toNodeId);\n        if (!this._nodes.has(expandedFromId)) {\n            throw new errors_1.default.IndexEdgeNodeNotFoundError(label, fromNodeId, 'outgoing');\n        }\n        if (!this._nodes.has(expandedToId)) {\n            throw new errors_1.default.IndexEdgeNodeNotFoundError(label, toNodeId, 'incoming');\n        }\n        if (expandedFromId === expandedToId) {\n            throw new errors_1.default.IndexEdgeCyclicalError(label, toNodeId);\n        }\n        const edgeId = IndexEdge.toId(expandedLabel, expandedFromId, expandedToId);\n        if (this._edges.has(edgeId)) {\n            return this._edges.get(edgeId);\n        }\n        const edge = new IndexEdge(expandedLabel, expandedFromId, expandedToId, this);\n        this._edges.set(edge.id, edge);\n        this._indexEdge(expandedLabel, expandedFromId, expandedToId);\n        this.emit('edgeCreated', edge);\n        return edge;\n    }\n    /**\n     * @description Creates a new node in the index.\n     * @param {string} id The id of the node to create.\n     * @returns {IndexNode}\n     * @memberof GraphIndex\n     */\n    createNode(id) {\n        if (!id) {\n            throw new ReferenceError(`Invalid id. id is ${id}`);\n        }\n        const expandedId = this.iri.expand(id);\n        if (this._nodes.has(expandedId)) {\n            throw new errors_1.default.IndexNodeDuplicateError(id);\n        }\n        const node = new IndexNode(expandedId, this);\n        this._nodes.set(expandedId, node);\n        this.emit('nodeCreated', node);\n        return node;\n    }\n    /**\n     * @description Gets an edge in the index.\n     * @param {string} label The label of the edge ot get.\n     * @param {string} fromNodeId The edge outgoing node id.\n     * @param {string} toNodeId The edge incoming node id.\n     * @returns {IndexEdge}\n     * @memberof GraphIndex\n     */\n    getEdge(label, fromNodeId, toNodeId) {\n        if (!label) {\n            throw new ReferenceError(`Invalid label. label is ${label}`);\n        }\n        if (!fromNodeId) {\n            throw new ReferenceError(`Invalid fromNodeId. fromNodeId is ${fromNodeId}`);\n        }\n        if (!toNodeId) {\n            throw new ReferenceError(`Invalid toNodeId. toNodeId is ${toNodeId}`);\n        }\n        return this._edges.get(IndexEdge.toId(this.iri.expand(label), this.iri.expand(fromNodeId), this.iri.expand(toNodeId)));\n    }\n    /**\n     * @description Gets edges in the index.\n     * @param {string} [label] Optional label filter used to only return edges with the matching label.\n     * @returns {IterableIterator<IndexEdge>}\n     * @memberof GraphIndex\n     */\n    *getEdges(label) {\n        if (!label) {\n            for (const [, edge] of this._edges) {\n                yield edge;\n            }\n        }\n        else {\n            const indexKey = GraphIndex.IX_EDGES_KEY(this.iri.expand(label));\n            if (!this._index.has(indexKey)) {\n                return;\n            }\n            for (const edgeId of this._index.get(indexKey)) {\n                yield this._edges.get(edgeId);\n            }\n        }\n    }\n    /**\n     * @description Gets all nodes that have an incoming edge with the specified label.\n     * @param {string} label The incoming edge label.\n     * @returns {IterableIterator<IndexNode>}\n     * @memberof GraphIndex\n     */\n    *getEdgeIncoming(label) {\n        if (!label) {\n            throw new ReferenceError(`Invalid label. label is ${label}`);\n        }\n        const indexKey = GraphIndex.IX_EDGE_INCOMING_KEY(this.iri.expand(label));\n        if (!this._index.has(indexKey)) {\n            return;\n        }\n        const visited = new Set();\n        for (const edgeId of this._index.get(indexKey)) {\n            const edge = this._edges.get(edgeId);\n            if (!visited.has(edge.toNodeId)) {\n                visited.add(edge.toNodeId);\n                yield this._nodes.get(edge.toNodeId);\n            }\n        }\n    }\n    /**\n     * @description Gets all nodes that haven an outgoing edge with the specified label.\n     * @param {string} label The outgoing edge label.\n     * @returns {IterableIterator<IndexNode>}\n     * @memberof GraphIndex\n     */\n    *getEdgeOutgoing(label) {\n        if (!label) {\n            throw new ReferenceError(`Invalid label. label is ${label}`);\n        }\n        const indexKey = GraphIndex.IX_EDGE_OUTGOING_KEY(this.iri.expand(label));\n        if (!this._index.has(indexKey)) {\n            return;\n        }\n        const visited = new Set();\n        for (const edgeId of this._index.get(indexKey)) {\n            const edge = this._edges.get(edgeId);\n            if (!visited.has(edge.fromNodeId)) {\n                visited.add(edge.fromNodeId);\n                yield this._nodes.get(edge.fromNodeId);\n            }\n        }\n    }\n    /**\n     * @description Gets a specific node in the index.\n     * @param {string} id The id of the node to get.\n     * @returns {IndexNode}\n     * @memberof GraphIndex\n     */\n    getNode(id) {\n        if (!id) {\n            throw new ReferenceError(`Invalid id. id is ${id}`);\n        }\n        return this._nodes.get(this.iri.expand(id));\n    }\n    /**\n     * @description Gets all nodes in the index.\n     * @returns {IterableIterator<IndexNode>}\n     * @memberof GraphIndex\n     */\n    *getNodes() {\n        for (const [, node] of this._nodes) {\n            yield node;\n        }\n    }\n    /**\n     * @description Gets a node's incoming edges, along with the incoming node.\n     * @param {string} id The node whose incoming edges and nodes are to be retrieved.\n     * @param {string} [label] Optional label to filter only those incoming edges that match the specified label.\n     * @returns {IterableIterator<{ edge: IndexEdge, node: IndexNode }>}\n     * @memberof GraphIndex\n     */\n    *getNodeIncoming(id, label) {\n        if (!id) {\n            throw new ReferenceError(`id is invalid. id is ${id}`);\n        }\n        let indexKey;\n        if (!label) {\n            indexKey = GraphIndex.IX_NODE_INCOMING_ALL_KEY(this.iri.expand(id));\n        }\n        else {\n            indexKey = GraphIndex.IX_NODE_INCOMING_EDGES(this.iri.expand(id), this.iri.expand(label));\n        }\n        if (!this._index.has(indexKey)) {\n            return;\n        }\n        for (const edgeId of this._index.get(indexKey)) {\n            const edge = this._edges.get(edgeId);\n            const node = this._nodes.get(this.iri.expand(edge.fromNodeId));\n            yield { edge, node };\n        }\n    }\n    /**\n     * @description Gets a node's outgoing edges, along with the outgoing node.\n     * @param {string} id The node whose outgoing edges and nodes are to be retrieved.\n     * @param {string} [label] Optional label to filter only those outgoing edges that match the specified label.\n     * @returns {IterableIterator<{ edge: IndexEdge, node: IndexNode }>}\n     * @memberof GraphIndex\n     */\n    *getNodeOutgoing(id, label) {\n        let indexKey;\n        if (!label) {\n            indexKey = GraphIndex.IX_NODE_OUTGOING_ALL(this.iri.expand(id));\n        }\n        else {\n            indexKey = GraphIndex.IX_NODE_OUTGOING_EDGES(this.iri.expand(id), this.iri.expand(label));\n        }\n        if (!this._index.has(indexKey)) {\n            return;\n        }\n        for (const edgeId of this._index.get(indexKey)) {\n            const edge = this._edges.get(edgeId);\n            const node = this._nodes.get(this.iri.expand(edge.toNodeId));\n            yield { edge, node };\n        }\n    }\n    /**\n     * @description Checks if a specific edge exists.\n     * @param {string} label The label of the edge.\n     * @param {string} fromNodeId The edge outgoing node id.\n     * @param {string} toNodeId The edge incoming node id.\n     * @returns {boolean} True if the edge exists, else false.\n     * @memberof GraphIndex\n     */\n    hasEdge(label, fromNodeId, toNodeId) {\n        if (!label) {\n            throw new ReferenceError(`Invalid label. label is ${label}`);\n        }\n        if (!fromNodeId) {\n            throw new ReferenceError(`Invalid fromNodeId. fromNodeId is ${fromNodeId}`);\n        }\n        if (!toNodeId) {\n            throw new ReferenceError(`Invalid toNodeId. toNodeId is ${toNodeId}`);\n        }\n        return this._edges.has(IndexEdge.toId(this.iri.expand(label), this.iri.expand(fromNodeId), this.iri.expand(toNodeId)));\n    }\n    /**\n     * @description Checks if a specific node exists.\n     * @param {string} id The id of the node to check for.\n     * @returns {boolean} True if the node exists, else false.\n     * @memberof GraphIndex\n     */\n    hasNode(id) {\n        if (!id) {\n            throw new ReferenceError(`Invalid nodeId. nodeId is ${id}`);\n        }\n        return this._nodes.has(this.iri.expand(id));\n    }\n    /**\n     * @description Loads a set of input JSON-LD documents into the index.\n     * @param {(any | any[])} inputs The inputs to load.\n     * @param {string|string[]|object|object[]} [contexts] The contexts to load.\n     * @param {string} [base] The base IRI of the context.\n     * @returns {Promise<Set<string>>}\n     * @memberof GraphIndex\n     */\n    load(inputs, contexts, base) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!inputs) {\n                throw new ReferenceError(`Invalid inputs. inputs is ${inputs}`);\n            }\n            const vertexTracker = new Set();\n            const documents = inputs instanceof Array ? inputs : [inputs];\n            for (const document of documents) {\n                try {\n                    const triples = yield this._processor.flatten(document, contexts, base);\n                    this._loadTriples(triples, vertexTracker, false);\n                }\n                catch (err) {\n                    throw new errors_1.default.DocumentParseError(err);\n                }\n            }\n            return vertexTracker;\n        });\n    }\n    /**\n     * @description Loads and merges a set of input JSON-LD documents into the index.\n     * @param {(any | any[])} inputs The inputs to merge.\n     * @param {string|string[]|object|object[]} [contexts] The contexts to merge.\n     * @param {string} [base] The base IRI of inputs.\n     * @returns {Promise<Set<string>>}\n     * @memberof GraphIndex\n     */\n    merge(inputs, contexts, base) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!inputs) {\n                throw new ReferenceError(`Invalid inputs. inputs is ${inputs}`);\n            }\n            const vertexTracker = new Set();\n            const documents = inputs instanceof Array ? inputs : [inputs];\n            for (const document of documents) {\n                try {\n                    const triples = yield this._processor.flatten(document, contexts, base);\n                    this._loadTriples(triples, vertexTracker, true);\n                }\n                catch (err) {\n                    throw new errors_1.default.DocumentParseError(err);\n                }\n            }\n            return vertexTracker;\n        });\n    }\n    /**\n     * @description Removes a context.\n     * @param {string} uri The uri of the context to remove.\n     * @memberof GraphIndex\n     */\n    removeContext(uri) {\n        this._processor.removeContext(uri);\n    }\n    /**\n     * @description Removes an edge from the index.\n     * @param {(string | IndexEdge)} edge The id or edge instance to remove from the index.\n     * @returns {void}\n     * @memberof GraphIndex\n     */\n    removeEdge(edge) {\n        if (!edge) {\n            throw new ReferenceError(`Invalid edge. edge is ${edge}`);\n        }\n        let indexEdge = edge;\n        if (typeof edge === 'string') {\n            indexEdge = this._edges.get(this.iri.expand(edge));\n            if (!indexEdge) {\n                return;\n            }\n        }\n        this._deleteEdgeIndex(this.iri.expand(indexEdge.label), this.iri.expand(indexEdge.fromNodeId), this.iri.expand(indexEdge.toNodeId));\n        if (this._edges.delete(indexEdge.id)) {\n            this.emit('edgeDeleted', indexEdge);\n        }\n    }\n    /**\n     * @description Removes a node from the index.\n     * @param {(string | IndexNode)} node The id or node instance to remove from the index.\n     * @returns {void}\n     * @memberof GraphIndex\n     */\n    removeNode(node) {\n        if (!node) {\n            throw new ReferenceError(`Invalid node. node is ${node}`);\n        }\n        let indexNode = node;\n        if (typeof node === 'string') {\n            indexNode = this._nodes.get(this.iri.expand(node));\n            if (!indexNode) {\n                return;\n            }\n        }\n        const incomingEdgesKey = GraphIndex.IX_NODE_INCOMING_ALL_KEY(this.iri.expand(indexNode.id));\n        const outgoingEdgesKey = GraphIndex.IX_NODE_OUTGOING_ALL(this.iri.expand(indexNode.id));\n        if (this._index.has(incomingEdgesKey)) {\n            for (const edgeId of this._index.get(incomingEdgesKey)) {\n                this.removeEdge(edgeId);\n            }\n            this._index.delete(incomingEdgesKey);\n        }\n        if (this._index.has(outgoingEdgesKey)) {\n            for (const edgeId of this._index.get(outgoingEdgesKey)) {\n                this.removeEdge(edgeId);\n            }\n            this._index.delete(outgoingEdgesKey);\n        }\n        this._nodes.delete(this.iri.expand(indexNode.id));\n        this.emit('nodeDeleted', indexNode);\n    }\n    /**\n     * @description Removes a prefix from the index.\n     * @param {string} prefix The prefix string to remove.\n     * @memberof GraphIndex\n     */\n    removePrefix(prefix) {\n        this.iri.removePrefix(prefix);\n    }\n    /**\n     * @description Gets a JSON representation of the index.\n     * @param {frame} [any] Optional frame instruction.\n     * @returns {Promise<any>}\n     * @memberof GraphIndex\n     */\n    toJson(options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const document = { [constants_1.JsonldKeywords.graph]: [] };\n            for (const node of this.getNodes()) {\n                document[constants_1.JsonldKeywords.graph].push(node.toTriple());\n            }\n            const formatOptions = lodash_clonedeep_1.default(options);\n            if (formatOptions.frame) {\n                this._expandIdReferences(formatOptions.frame);\n                if (formatOptions.context && !formatOptions.frame[constants_1.JsonldKeywords.container]) {\n                    formatOptions.frame[constants_1.JsonldKeywords.context] = options.context;\n                }\n                return this._processor.frame(document, formatOptions.frame, [], options.base);\n            }\n            else if (options.context) {\n                const expanded = yield this._processor.expand(document, formatOptions.context, options.base);\n                return this._processor.compact(expanded, formatOptions.context);\n            }\n            else {\n                return document;\n            }\n        });\n    }\n    _createEdgeIndexKeys(label, fromNodeId, toNodeId) {\n        return [\n            GraphIndex.IX_EDGES_KEY(label),\n            GraphIndex.IX_EDGE_INCOMING_KEY(label),\n            GraphIndex.IX_EDGE_OUTGOING_KEY(label),\n            GraphIndex.IX_NODE_INCOMING_ALL_KEY(toNodeId),\n            GraphIndex.IX_NODE_INCOMING_EDGES(toNodeId, label),\n            GraphIndex.IX_NODE_OUTGOING_ALL(fromNodeId),\n            GraphIndex.IX_NODE_OUTGOING_EDGES(fromNodeId, label)\n        ];\n    }\n    _deleteEdgeIndex(label, fromNodeId, toNodeId) {\n        const edgeId = IndexEdge.toId(label, fromNodeId, toNodeId);\n        const indexKeys = this._createEdgeIndexKeys(label, fromNodeId, toNodeId);\n        for (const key of indexKeys) {\n            if (this._index.has(key)) {\n                this._index.get(key).delete(edgeId);\n                if (this._index.get(key).size === 0) {\n                    this._index.delete(key);\n                }\n            }\n        }\n    }\n    _expandIdReferences(source) {\n        // This function is primarily looking for objects with @id keys and processing the identity references.\n        // 1. Start by only accepting Array or object types.\n        // 2. If source is an array, loop over elements in the array and recursively call self.\n        // 3. If source is an object\n        // 4. Get all own property keys. Loop through each key.\n        // 4.a.Key is @id, process the value\n        // 4.a @id value can either b a string or an array. If string replace the id with expanded id value. If an array then go through and expand each element.\n        if (source instanceof Array) {\n            for (const element of source) {\n                this._expandIdReferences(element);\n            }\n        }\n        else if (typeof source === 'object') {\n            const keys = Object.getOwnPropertyNames(source);\n            for (const key of keys) {\n                if (key === constants_1.JsonldKeywords.id) {\n                    if (source[key] instanceof Array) {\n                        const elements = [...source[key]];\n                        for (const element of elements) {\n                            if (typeof element === 'string') {\n                                source[key].splice(source[key].indexOf(element), 1, this.iri.expand(element));\n                            }\n                        }\n                    }\n                    else if (typeof source[key] === 'string') {\n                        source[key] = this.iri.expand(source[key]);\n                    }\n                }\n                else if (source[key] instanceof Array || typeof source[key] === 'object') {\n                    this._expandIdReferences(source[key]);\n                }\n            }\n        }\n    }\n    _indexEdge(label, fromNodeId, toNodeId) {\n        const edgeId = IndexEdge.toId(label, fromNodeId, toNodeId);\n        for (const key of this._createEdgeIndexKeys(label, fromNodeId, toNodeId)) {\n            if (!this._index.has(key)) {\n                this._index.set(key, new Set());\n            }\n            this._index.get(key).add(edgeId);\n        }\n    }\n    _loadTriples(triples, vertexTracker, mergeAttributes = false) {\n        const identityMap = new identityMap_1.default();\n        for (const triple of triples) {\n            const id = identityMap.get(triple);\n            const types = triple[constants_1.JsonldKeywords.type] || [];\n            let subjectNode;\n            if (this.hasNode(id)) {\n                subjectNode = this.getNode(id);\n            }\n            else {\n                subjectNode = this.createNode(id);\n                vertexTracker.add(this.iri.compact(id));\n            }\n            // Add outgoing edges to type nodes.\n            for (const typeId of types) {\n                if (!this.hasNode(typeId)) {\n                    this.createNode(typeId);\n                }\n                this.createEdge(constants_1.JsonldKeywords.type, subjectNode.id, typeId);\n            }\n            // Process each predicate for the object.\n            for (const predicate of Object.keys(triple)) {\n                this._loadPredicate(identityMap, subjectNode, predicate, triple[predicate], vertexTracker, mergeAttributes);\n            }\n        }\n    }\n    _loadPredicate(identityMap, subjectNode, predicate, objects, vertexTracker, mergeAttributes) {\n        for (const obj of objects) {\n            if (obj[constants_1.JsonldKeywords.list]) {\n                // Predicate object is a @list container, Load individual items in the @list array.\n                return this._loadPredicate(identityMap, subjectNode, predicate, obj[constants_1.JsonldKeywords.list], vertexTracker, mergeAttributes);\n            }\n            if (obj[constants_1.JsonldKeywords.id]) {\n                // Predicate object is a reference to another entity, create an edge to model the relationship.\n                const objectId = identityMap.get(obj);\n                if (!this.hasNode(objectId)) {\n                    this.createNode(objectId);\n                }\n                vertexTracker.add(this.iri.compact(objectId));\n                this.createEdge(predicate, subjectNode.id, objectId);\n            }\n            if (obj[constants_1.JsonldKeywords.value] !== null && obj[constants_1.JsonldKeywords.value] !== undefined) {\n                // Predicate object is a value. Inline the value as a attribute of the subject vertex.\n                if (mergeAttributes) {\n                    subjectNode.setAttributeValue(predicate, obj[constants_1.JsonldKeywords.value], obj[constants_1.JsonldKeywords.language]);\n                }\n                else {\n                    subjectNode.addAttributeValue(predicate, obj[constants_1.JsonldKeywords.value], obj[constants_1.JsonldKeywords.language]);\n                }\n            }\n        }\n    }\n}\nexports.GraphIndex = GraphIndex;\nGraphIndex.IX_EDGES_KEY = (label) => `[e]::${label}`;\nGraphIndex.IX_EDGE_INCOMING_KEY = (label) => `[e]::${label}_[in]`;\nGraphIndex.IX_EDGE_OUTGOING_KEY = (label) => `[e]::${label}_[out]`;\nGraphIndex.IX_NODE_INCOMING_ALL_KEY = (id) => `[v]::${id}_[in]`;\nGraphIndex.IX_NODE_INCOMING_EDGES = (id, label) => `[v]::${id}_[in]_[e]::${label}`;\nGraphIndex.IX_NODE_OUTGOING_ALL = (id) => `[v]::${id}_[out]`;\nGraphIndex.IX_NODE_OUTGOING_EDGES = (id, label) => `[v]::${id}_[out]_[e]::${label}`;\nexports.default = GraphIndex;\n//# sourceMappingURL=graphIndex.js.map"]},"metadata":{},"sourceType":"script"}