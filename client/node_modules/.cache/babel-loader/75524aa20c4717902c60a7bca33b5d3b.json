{"ast":null,"code":"var listenersMap = new WeakMap();\nvar abortedMap = new WeakMap();\n/**\n * An aborter instance implements AbortSignal interface, can abort HTTP requests.\n *\n * - Call AbortSignal.none to create a new AbortSignal instance that cannot be cancelled.\n * Use `AbortSignal.none` when you are required to pass a cancellation token but the operation\n * cannot or will not ever be cancelled.\n *\n * @example\n * // Abort without timeout\n * await doAsyncWork(AbortSignal.none);\n *\n * @export\n * @class AbortSignal\n * @implements {AbortSignalLike}\n */\nvar AbortSignal = /** @class */function () {\n  function AbortSignal() {\n    /**\n     * onabort event listener.\n     *\n     * @memberof AbortSignal\n     */\n    this.onabort = null;\n    listenersMap.set(this, []);\n    abortedMap.set(this, false);\n  }\n  Object.defineProperty(AbortSignal.prototype, \"aborted\", {\n    /**\n     * Status of whether aborted or not.\n     *\n     * @readonly\n     * @type {boolean}\n     * @memberof AbortSignal\n     */\n    get: function () {\n      if (!abortedMap.has(this)) {\n        throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n      }\n      return abortedMap.get(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AbortSignal, \"none\", {\n    /**\n     * Creates a new AbortSignal instance that will never be aborted.\n     *\n     * @readonly\n     * @static\n     * @type {AbortSignal}\n     * @memberof AbortSignal\n     */\n    get: function () {\n      return new AbortSignal();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Added new \"abort\" event listener, only support \"abort\" event.\n   *\n   * @param {\"abort\"} _type Only support \"abort\" event\n   * @param {(this: AbortSignalLike, ev: any) => any} listener\n   * @memberof AbortSignal\n   */\n  AbortSignal.prototype.addEventListener = function (\n  // tslint:disable-next-line:variable-name\n  _type, listener) {\n    if (!listenersMap.has(this)) {\n      throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n    }\n    var listeners = listenersMap.get(this);\n    listeners.push(listener);\n  };\n  /**\n   * Remove \"abort\" event listener, only support \"abort\" event.\n   *\n   * @param {\"abort\"} _type Only support \"abort\" event\n   * @param {(this: AbortSignalLike, ev: any) => any} listener\n   * @memberof AbortSignal\n   */\n  AbortSignal.prototype.removeEventListener = function (\n  // tslint:disable-next-line:variable-name\n  _type, listener) {\n    if (!listenersMap.has(this)) {\n      throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n    }\n    var listeners = listenersMap.get(this);\n    var index = listeners.indexOf(listener);\n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n  };\n  /**\n   * Dispatches a synthetic event to the AbortSignal.\n   */\n  AbortSignal.prototype.dispatchEvent = function (_event) {\n    throw new Error(\"This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.\");\n  };\n  return AbortSignal;\n}();\nexport { AbortSignal };\n/**\n * Helper to trigger an abort event immediately, the onabort and all abort event listeners will be triggered.\n * Will try to trigger abort event for all linked AbortSignal nodes.\n *\n * - If there is a timeout, the timer will be cancelled.\n * - If aborted is true, nothing will happen.\n *\n * @returns\n * @internal\n */\nexport function abortSignal(signal) {\n  if (signal.aborted) {\n    return;\n  }\n  if (signal.onabort) {\n    signal.onabort.call(signal);\n  }\n  var listeners = listenersMap.get(signal);\n  if (listeners) {\n    listeners.forEach(function (listener) {\n      listener.call(signal, {\n        type: \"abort\"\n      });\n    });\n  }\n  abortedMap.set(signal, true);\n}","map":{"version":3,"sources":["../../src/AbortSignal.ts"],"names":[],"mappings":"AAGA,IAAM,YAAY,GAAG,IAAI,OAAO,CAAA,CAAqC;AACrE,IAAM,UAAU,GAAG,IAAI,OAAO,CAAA,CAAwB;AA6BtD;;;;;;;;;;;;;;AAcG;AACH,IAAA,WAAA,GAAA,aAAA,YAAA;EACE,SAAA,WAAA,CAAA,EAAA;IAgCA;;;;AAIG;IACI,IAAA,CAAA,OAAO,GAAiC,IAAI;IApCjD,YAAY,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC;IAC1B,UAAU,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC;EAC7B;EASA,MAAA,CAAA,cAAA,CAAW,WAAA,CAAA,SAAA,EAAA,SAAO,EAAA;IAPlB;;;;;;AAMG;SACH,SAAA,CAAA,EAAA;MACE,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;QACzB,MAAM,IAAI,SAAS,CAAC,mDAAmD,CAAC;MACzE;MAED,OAAO,UAAU,CAAC,GAAG,CAAC,IAAI,CAAE;IAC9B,CAAC;;;IAAA;EAUD,MAAA,CAAA,cAAA,CAAkB,WAAA,EAAA,MAAI,EAAA;IARtB;;;;;;;AAOG;SACH,SAAA,CAAA,EAAA;MACE,OAAO,IAAI,WAAW,CAAA,CAAE;IAC1B,CAAC;;;IAAA;EASD;;;;;;AAMG;EACI,WAAA,CAAA,SAAA,CAAA,gBAAgB,GAAvB;EACE;EACA,KAAc,EACd,QAAiD,EAAA;IAEjD,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;MAC3B,MAAM,IAAI,SAAS,CAAC,mDAAmD,CAAC;IACzE;IAED,IAAM,SAAS,GAAG,YAAY,CAAC,GAAG,CAAC,IAAI,CAAE;IACzC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC;EAC1B,CAAC;EAED;;;;;;AAMG;EACI,WAAA,CAAA,SAAA,CAAA,mBAAmB,GAA1B;EACE;EACA,KAAc,EACd,QAAiD,EAAA;IAEjD,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;MAC3B,MAAM,IAAI,SAAS,CAAC,mDAAmD,CAAC;IACzE;IAED,IAAM,SAAS,GAAG,YAAY,CAAC,GAAG,CAAC,IAAI,CAAE;IAEzC,IAAM,KAAK,GAAG,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC;IACzC,IAAI,KAAK,GAAG,CAAC,CAAC,EAAE;MACd,SAAS,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC;IAC3B;EACH,CAAC;EAED;;AAEG;EACH,WAAA,CAAA,SAAA,CAAA,aAAa,GAAb,UAAc,MAAa,EAAA;IACzB,MAAM,IAAI,KAAK,CACb,kHAAkH,CACnH;EACH,CAAC;EACH,OAAA,WAAC;AAAD,CAAC,CAAA,CAAA;;AAED;;;;;;;;;AASG;AACH,OAAM,SAAU,WAAW,CAAC,MAAmB,EAAA;EAC7C,IAAI,MAAM,CAAC,OAAO,EAAE;IAClB;EACD;EAED,IAAI,MAAM,CAAC,OAAO,EAAE;IAClB,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC;EAC5B;EAED,IAAM,SAAS,GAAG,YAAY,CAAC,GAAG,CAAC,MAAM,CAAE;EAC3C,IAAI,SAAS,EAAE;IACb,SAAS,CAAC,OAAO,CAAC,UAAC,QAAQ,EAAA;MACzB,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE;QAAE,IAAI,EAAE;MAAO,CAAE,CAAC;IAC1C,CAAC,CAAC;EACH;EAED,UAAU,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC;AAC9B","sourceRoot":"","sourcesContent":["var listenersMap = new WeakMap();\nvar abortedMap = new WeakMap();\n/**\n * An aborter instance implements AbortSignal interface, can abort HTTP requests.\n *\n * - Call AbortSignal.none to create a new AbortSignal instance that cannot be cancelled.\n * Use `AbortSignal.none` when you are required to pass a cancellation token but the operation\n * cannot or will not ever be cancelled.\n *\n * @example\n * // Abort without timeout\n * await doAsyncWork(AbortSignal.none);\n *\n * @export\n * @class AbortSignal\n * @implements {AbortSignalLike}\n */\nvar AbortSignal = /** @class */ (function () {\n    function AbortSignal() {\n        /**\n         * onabort event listener.\n         *\n         * @memberof AbortSignal\n         */\n        this.onabort = null;\n        listenersMap.set(this, []);\n        abortedMap.set(this, false);\n    }\n    Object.defineProperty(AbortSignal.prototype, \"aborted\", {\n        /**\n         * Status of whether aborted or not.\n         *\n         * @readonly\n         * @type {boolean}\n         * @memberof AbortSignal\n         */\n        get: function () {\n            if (!abortedMap.has(this)) {\n                throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n            }\n            return abortedMap.get(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AbortSignal, \"none\", {\n        /**\n         * Creates a new AbortSignal instance that will never be aborted.\n         *\n         * @readonly\n         * @static\n         * @type {AbortSignal}\n         * @memberof AbortSignal\n         */\n        get: function () {\n            return new AbortSignal();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Added new \"abort\" event listener, only support \"abort\" event.\n     *\n     * @param {\"abort\"} _type Only support \"abort\" event\n     * @param {(this: AbortSignalLike, ev: any) => any} listener\n     * @memberof AbortSignal\n     */\n    AbortSignal.prototype.addEventListener = function (\n    // tslint:disable-next-line:variable-name\n    _type, listener) {\n        if (!listenersMap.has(this)) {\n            throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n        }\n        var listeners = listenersMap.get(this);\n        listeners.push(listener);\n    };\n    /**\n     * Remove \"abort\" event listener, only support \"abort\" event.\n     *\n     * @param {\"abort\"} _type Only support \"abort\" event\n     * @param {(this: AbortSignalLike, ev: any) => any} listener\n     * @memberof AbortSignal\n     */\n    AbortSignal.prototype.removeEventListener = function (\n    // tslint:disable-next-line:variable-name\n    _type, listener) {\n        if (!listenersMap.has(this)) {\n            throw new TypeError(\"Expected `this` to be an instance of AbortSignal.\");\n        }\n        var listeners = listenersMap.get(this);\n        var index = listeners.indexOf(listener);\n        if (index > -1) {\n            listeners.splice(index, 1);\n        }\n    };\n    /**\n     * Dispatches a synthetic event to the AbortSignal.\n     */\n    AbortSignal.prototype.dispatchEvent = function (_event) {\n        throw new Error(\"This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.\");\n    };\n    return AbortSignal;\n}());\nexport { AbortSignal };\n/**\n * Helper to trigger an abort event immediately, the onabort and all abort event listeners will be triggered.\n * Will try to trigger abort event for all linked AbortSignal nodes.\n *\n * - If there is a timeout, the timer will be cancelled.\n * - If aborted is true, nothing will happen.\n *\n * @returns\n * @internal\n */\nexport function abortSignal(signal) {\n    if (signal.aborted) {\n        return;\n    }\n    if (signal.onabort) {\n        signal.onabort.call(signal);\n    }\n    var listeners = listenersMap.get(signal);\n    if (listeners) {\n        listeners.forEach(function (listener) {\n            listener.call(signal, { type: \"abort\" });\n        });\n    }\n    abortedMap.set(signal, true);\n}\n//# sourceMappingURL=AbortSignal.js.map"]},"metadata":{},"sourceType":"module"}