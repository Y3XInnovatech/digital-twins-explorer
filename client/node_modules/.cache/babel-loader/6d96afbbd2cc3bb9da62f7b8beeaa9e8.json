{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./serializer.common\";\n// tslint:disable-next-line:no-null-keyword\nvar doc = document.implementation.createDocument(null, null, null);\nvar parser = new DOMParser();\nexport function parseXML(str, opts) {\n  var _a, _b, _c;\n  if (opts === void 0) {\n    opts = {};\n  }\n  try {\n    var updatedOptions = {\n      rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : \"\",\n      includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,\n      xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n    };\n    var dom = parser.parseFromString(str, \"application/xml\");\n    throwIfError(dom);\n    var obj = void 0;\n    if (updatedOptions.includeRoot) {\n      obj = domToObject(dom, updatedOptions);\n    } else {\n      obj = domToObject(dom.childNodes[0], updatedOptions);\n    }\n    return Promise.resolve(obj);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\nvar errorNS;\nfunction getErrorNamespace() {\n  var _a;\n  if (errorNS === undefined) {\n    try {\n      errorNS = (_a = parser.parseFromString(\"INVALID\", \"text/xml\").getElementsByTagName(\"parsererror\")[0].namespaceURI) !== null && _a !== void 0 ? _a : \"\";\n    } catch (ignored) {\n      // Most browsers will return a document containing <parsererror>, but IE will throw.\n      errorNS = \"\";\n    }\n  }\n  return errorNS;\n}\nfunction throwIfError(dom) {\n  var parserErrors = dom.getElementsByTagName(\"parsererror\");\n  if (parserErrors.length > 0 && getErrorNamespace()) {\n    for (var i = 0; i < parserErrors.length; i++) {\n      if (parserErrors[i].namespaceURI === errorNS) {\n        throw new Error(parserErrors[i].innerHTML);\n      }\n    }\n  }\n}\nfunction isElement(node) {\n  return !!node.attributes;\n}\n/**\n * Get the Element-typed version of the provided Node if the provided node is an element with\n * attributes. If it isn't, then undefined is returned.\n */\nfunction asElementWithAttributes(node) {\n  return isElement(node) && node.hasAttributes() ? node : undefined;\n}\nfunction domToObject(node, options) {\n  var result = {};\n  var childNodeCount = node.childNodes.length;\n  var firstChildNode = node.childNodes[0];\n  var onlyChildTextValue = firstChildNode && childNodeCount === 1 && firstChildNode.nodeType === Node.TEXT_NODE && firstChildNode.nodeValue || undefined;\n  var elementWithAttributes = asElementWithAttributes(node);\n  if (elementWithAttributes) {\n    result[XML_ATTRKEY] = {};\n    for (var i = 0; i < elementWithAttributes.attributes.length; i++) {\n      var attr = elementWithAttributes.attributes[i];\n      result[XML_ATTRKEY][attr.nodeName] = attr.nodeValue;\n    }\n    if (onlyChildTextValue) {\n      result[options.xmlCharKey] = onlyChildTextValue;\n    }\n  } else if (childNodeCount === 0) {\n    result = \"\";\n  } else if (onlyChildTextValue) {\n    result = onlyChildTextValue;\n  }\n  if (!onlyChildTextValue) {\n    for (var i = 0; i < childNodeCount; i++) {\n      var child = node.childNodes[i];\n      // Ignore leading/trailing whitespace nodes\n      if (child.nodeType !== Node.TEXT_NODE) {\n        var childObject = domToObject(child, options);\n        if (!result[child.nodeName]) {\n          result[child.nodeName] = childObject;\n        } else if (Array.isArray(result[child.nodeName])) {\n          result[child.nodeName].push(childObject);\n        } else {\n          result[child.nodeName] = [result[child.nodeName], childObject];\n        }\n      }\n    }\n  }\n  return result;\n}\nvar serializer = new XMLSerializer();\nexport function stringifyXML(content, opts) {\n  var _a, _b, _c;\n  if (opts === void 0) {\n    opts = {};\n  }\n  var updatedOptions = {\n    rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : \"root\",\n    includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,\n    xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n  };\n  var dom = buildNode(content, updatedOptions.rootName, updatedOptions)[0];\n  return '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' + serializer.serializeToString(dom);\n}\nfunction buildAttributes(attrs) {\n  var result = [];\n  for (var _i = 0, _a = Object.keys(attrs); _i < _a.length; _i++) {\n    var key = _a[_i];\n    var attr = doc.createAttribute(key);\n    attr.value = attrs[key].toString();\n    result.push(attr);\n  }\n  return result;\n}\nfunction buildNode(obj, elementName, options) {\n  if (obj === undefined || obj === null || typeof obj === \"string\" || typeof obj === \"number\" || typeof obj === \"boolean\") {\n    var elem = doc.createElement(elementName);\n    elem.textContent = obj === undefined || obj === null ? \"\" : obj.toString();\n    return [elem];\n  } else if (Array.isArray(obj)) {\n    var result = [];\n    for (var _i = 0, obj_1 = obj; _i < obj_1.length; _i++) {\n      var arrayElem = obj_1[_i];\n      for (var _a = 0, _b = buildNode(arrayElem, elementName, options); _a < _b.length; _a++) {\n        var child = _b[_a];\n        result.push(child);\n      }\n    }\n    return result;\n  } else if (typeof obj === \"object\") {\n    var elem = doc.createElement(elementName);\n    for (var _c = 0, _d = Object.keys(obj); _c < _d.length; _c++) {\n      var key = _d[_c];\n      if (key === XML_ATTRKEY) {\n        for (var _e = 0, _f = buildAttributes(obj[key]); _e < _f.length; _e++) {\n          var attr = _f[_e];\n          elem.attributes.setNamedItem(attr);\n        }\n      } else if (key === options.xmlCharKey) {\n        elem.textContent = obj[key].toString();\n      } else {\n        for (var _g = 0, _h = buildNode(obj[key], key, options); _g < _h.length; _g++) {\n          var child = _h[_g];\n          elem.appendChild(child);\n        }\n      }\n    }\n    return [elem];\n  } else {\n    throw new Error(\"Illegal value passed to buildObject: \" + obj);\n  }\n}","map":{"version":3,"sources":["../../../src/util/xml.browser.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { XML_ATTRKEY, XML_CHARKEY, SerializerOptions } from \"./serializer.common\";\n\n// tslint:disable-next-line:no-null-keyword\nconst doc = document.implementation.createDocument(null, null, null);\n\nconst parser = new DOMParser();\nexport function parseXML(str: string, opts: SerializerOptions = {}): Promise<any> {\n  try {\n    const updatedOptions: Required<SerializerOptions> = {\n      rootName: opts.rootName ?? \"\",\n      includeRoot: opts.includeRoot ?? false,\n      xmlCharKey: opts.xmlCharKey ?? XML_CHARKEY\n    };\n    const dom = parser.parseFromString(str, \"application/xml\");\n    throwIfError(dom);\n\n    let obj;\n    if (updatedOptions.includeRoot) {\n      obj = domToObject(dom, updatedOptions);\n    } else {\n      obj = domToObject(dom.childNodes[0], updatedOptions);\n    }\n\n    return Promise.resolve(obj);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\n\nlet errorNS: string | undefined;\n\nfunction getErrorNamespace(): string {\n  if (errorNS === undefined) {\n    try {\n      errorNS =\n        parser.parseFromString(\"INVALID\", \"text/xml\").getElementsByTagName(\"parsererror\")[0]\n          .namespaceURI! ?? \"\";\n    } catch (ignored) {\n      // Most browsers will return a document containing <parsererror>, but IE will throw.\n      errorNS = \"\";\n    }\n  }\n  return errorNS;\n}\n\nfunction throwIfError(dom: Document): void {\n  const parserErrors = dom.getElementsByTagName(\"parsererror\");\n  if (parserErrors.length > 0 && getErrorNamespace()) {\n    for (let i = 0; i < parserErrors.length; i++) {\n      if (parserErrors[i].namespaceURI === errorNS) {\n        throw new Error(parserErrors[i].innerHTML);\n      }\n    }\n  }\n}\n\nfunction isElement(node: Node): node is Element {\n  return !!(node as Element).attributes;\n}\n\n/**\n * Get the Element-typed version of the provided Node if the provided node is an element with\n * attributes. If it isn't, then undefined is returned.\n */\nfunction asElementWithAttributes(node: Node): Element | undefined {\n  return isElement(node) && node.hasAttributes() ? node : undefined;\n}\n\nfunction domToObject(node: Node, options: Required<SerializerOptions>): any {\n  let result: any = {};\n\n  const childNodeCount: number = node.childNodes.length;\n\n  const firstChildNode: Node = node.childNodes[0];\n  const onlyChildTextValue: string | undefined =\n    (firstChildNode &&\n      childNodeCount === 1 &&\n      firstChildNode.nodeType === Node.TEXT_NODE &&\n      firstChildNode.nodeValue) ||\n    undefined;\n\n  const elementWithAttributes: Element | undefined = asElementWithAttributes(node);\n  if (elementWithAttributes) {\n    result[XML_ATTRKEY] = {};\n\n    for (let i = 0; i < elementWithAttributes.attributes.length; i++) {\n      const attr = elementWithAttributes.attributes[i];\n      result[XML_ATTRKEY][attr.nodeName] = attr.nodeValue;\n    }\n\n    if (onlyChildTextValue) {\n      result[options.xmlCharKey] = onlyChildTextValue;\n    }\n  } else if (childNodeCount === 0) {\n    result = \"\";\n  } else if (onlyChildTextValue) {\n    result = onlyChildTextValue;\n  }\n\n  if (!onlyChildTextValue) {\n    for (let i = 0; i < childNodeCount; i++) {\n      const child = node.childNodes[i];\n      // Ignore leading/trailing whitespace nodes\n      if (child.nodeType !== Node.TEXT_NODE) {\n        const childObject: any = domToObject(child, options);\n        if (!result[child.nodeName]) {\n          result[child.nodeName] = childObject;\n        } else if (Array.isArray(result[child.nodeName])) {\n          result[child.nodeName].push(childObject);\n        } else {\n          result[child.nodeName] = [result[child.nodeName], childObject];\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nconst serializer = new XMLSerializer();\n\nexport function stringifyXML(content: unknown, opts: SerializerOptions = {}): string {\n  const updatedOptions: Required<SerializerOptions> = {\n    rootName: opts.rootName ?? \"root\",\n    includeRoot: opts.includeRoot ?? false,\n    xmlCharKey: opts.xmlCharKey ?? XML_CHARKEY\n  };\n  const dom = buildNode(content, updatedOptions.rootName, updatedOptions)[0];\n  return (\n    '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' + serializer.serializeToString(dom)\n  );\n}\n\nfunction buildAttributes(attrs: { [key: string]: { toString(): string } }): Attr[] {\n  const result = [];\n  for (const key of Object.keys(attrs)) {\n    const attr = doc.createAttribute(key);\n    attr.value = attrs[key].toString();\n    result.push(attr);\n  }\n  return result;\n}\n\nfunction buildNode(obj: any, elementName: string, options: Required<SerializerOptions>): Node[] {\n  if (\n    obj === undefined ||\n    obj === null ||\n    typeof obj === \"string\" ||\n    typeof obj === \"number\" ||\n    typeof obj === \"boolean\"\n  ) {\n    const elem = doc.createElement(elementName);\n    elem.textContent = obj === undefined || obj === null ? \"\" : obj.toString();\n    return [elem];\n  } else if (Array.isArray(obj)) {\n    const result = [];\n    for (const arrayElem of obj) {\n      for (const child of buildNode(arrayElem, elementName, options)) {\n        result.push(child);\n      }\n    }\n    return result;\n  } else if (typeof obj === \"object\") {\n    const elem = doc.createElement(elementName);\n    for (const key of Object.keys(obj)) {\n      if (key === XML_ATTRKEY) {\n        for (const attr of buildAttributes(obj[key])) {\n          elem.attributes.setNamedItem(attr);\n        }\n      } else if (key === options.xmlCharKey) {\n        elem.textContent = obj[key].toString();\n      } else {\n        for (const child of buildNode(obj[key], key, options)) {\n          elem.appendChild(child);\n        }\n      }\n    }\n    return [elem];\n  } else {\n    throw new Error(`Illegal value passed to buildObject: ${obj}`);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}