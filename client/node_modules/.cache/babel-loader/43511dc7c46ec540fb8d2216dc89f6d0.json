{"ast":null,"code":"import { __assign, __decorate, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, getId, allowScrollOnElement, allowOverscrollOnElement, KeyCodes, elementContains, warnDeprecations, Async, EventGroup } from '../../Utilities';\nimport { FocusTrapZone } from '../FocusTrapZone/index';\nimport { animationDuration } from './Modal.styles';\nimport { Overlay } from '../../Overlay';\nimport { Layer } from '../../Layer';\nimport { Popup } from '../Popup/index';\nimport { withResponsiveMode, ResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { DirectionalHint } from '../Callout/index';\nimport { Icon } from '../Icon/index';\nimport { DraggableZone } from '../../utilities/DraggableZone/index';\nimport { initializeComponentRef } from '@uifabric/utilities';\n// @TODO - need to change this to a panel whenever the breakpoint is under medium (verify the spec)\nvar DefaultLayerProps = {\n  eventBubblingEnabled: false\n};\nvar getClassNames = classNamesFunction();\nvar COMPONENT_NAME = 'Modal';\nvar ModalBase = /** @class */function (_super) {\n  __extends(ModalBase, _super);\n  function ModalBase(props) {\n    var _this = _super.call(this, props) || this;\n    _this._focusTrapZone = React.createRef();\n    _this._registerInitialModalPosition = function () {\n      var _a;\n      var dialogMain = document.querySelector(\"[data-id=\" + _this.state.id + \"]\");\n      if (dialogMain) {\n        var modalRectangle = dialogMain.getBoundingClientRect();\n        if (((_a = _this.props.dragOptions) === null || _a === void 0 ? void 0 : _a.keepInBounds) && !_this._minClampedPosition && !_this._maxClampedPosition) {\n          _this._minClampedPosition = {\n            x: -modalRectangle.x,\n            y: -modalRectangle.y\n          };\n          _this._maxClampedPosition = {\n            x: modalRectangle.x,\n            y: modalRectangle.y\n          };\n        }\n        _this.setState({\n          modalRectangleTop: modalRectangle.top\n        });\n      }\n    };\n    // Allow the user to scroll within the modal but not on the body\n    _this._allowScrollOnModal = function (elt) {\n      if (elt) {\n        if (_this._allowTouchBodyScroll) {\n          allowOverscrollOnElement(elt, _this._events);\n        } else {\n          allowScrollOnElement(elt, _this._events);\n        }\n      } else {\n        _this._events.off(_this._scrollableContent);\n      }\n      _this._scrollableContent = elt;\n    };\n    _this._onModalContextMenuClose = function () {\n      _this.setState({\n        isModalMenuOpen: false\n      });\n    };\n    _this._onModalClose = function () {\n      _this._lastSetX = 0;\n      _this._lastSetY = 0;\n      _this.setState({\n        isModalMenuOpen: false,\n        isInKeyboardMoveMode: false,\n        isOpen: false,\n        x: 0,\n        y: 0\n      });\n      if (_this.props.dragOptions && _this._hasRegisteredKeyUp) {\n        _this._events.off(window, 'keyup', _this._onKeyUp, true /* useCapture */);\n      }\n      // Call the onDismiss callback\n      if (_this.props.onDismissed) {\n        _this.props.onDismissed();\n      }\n    };\n    _this._onDragStart = function () {\n      _this.setState({\n        isModalMenuOpen: false,\n        isInKeyboardMoveMode: false\n      });\n    };\n    _this._onDrag = function (_, ui) {\n      var _a = _this.state,\n        x = _a.x,\n        y = _a.y;\n      _this.setState(_this._getClampedPosition({\n        x: x + ui.delta.x,\n        y: y + ui.delta.y\n      }));\n    };\n    _this._onDragStop = function () {\n      _this.focus();\n    };\n    _this._onKeyUp = function (event) {\n      // Need to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n      // Otherwise it would continue to fire a click even if the event was cancelled\n      // during mouseDown.\n      if (event.altKey && event.ctrlKey && event.keyCode === KeyCodes.space) {\n        // Since this is a global handler, we should make sure the target is within the dialog\n        // before opening the dropdown\n        if (elementContains(_this._scrollableContent, event.target)) {\n          _this.setState({\n            isModalMenuOpen: !_this.state.isModalMenuOpen\n          });\n          event.preventDefault();\n          event.stopPropagation();\n        }\n      }\n    };\n    // We need a global onKeyDown event when we are in the move mode so that we can\n    // handle the key presses and the components inside the modal do not get the events\n    _this._onKeyDown = function (event) {\n      if (event.altKey && event.ctrlKey && event.keyCode === KeyCodes.space) {\n        // CTRL + ALT + SPACE is handled during keyUp\n        event.preventDefault();\n        event.stopPropagation();\n        return;\n      }\n      if (_this.state.isModalMenuOpen && (event.altKey || event.keyCode === KeyCodes.escape)) {\n        _this.setState({\n          isModalMenuOpen: false\n        });\n      }\n      if (_this.state.isInKeyboardMoveMode && (event.keyCode === KeyCodes.escape || event.keyCode === KeyCodes.enter)) {\n        _this.setState({\n          isInKeyboardMoveMode: false\n        });\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      if (_this.state.isInKeyboardMoveMode) {\n        var handledEvent = true;\n        var delta = _this._getMoveDelta(event);\n        switch (event.keyCode) {\n          /* eslint-disable no-fallthrough */\n          case KeyCodes.escape:\n            _this.setState({\n              x: _this._lastSetX,\n              y: _this._lastSetY\n            });\n          case KeyCodes.enter:\n            {\n              // TODO: determine if fallthrough was intentional\n              /* eslint-enable no-fallthrough */\n              _this._lastSetX = 0;\n              _this._lastSetY = 0;\n              _this.setState({\n                isInKeyboardMoveMode: false\n              });\n              break;\n            }\n          case KeyCodes.up:\n            {\n              _this.setState({\n                y: _this._getClampedPositionY(_this.state.y - delta)\n              });\n              break;\n            }\n          case KeyCodes.down:\n            {\n              _this.setState({\n                y: _this._getClampedPositionY(_this.state.y + delta)\n              });\n              break;\n            }\n          case KeyCodes.left:\n            {\n              _this.setState({\n                x: _this._getClampedPositionX(_this.state.x - delta)\n              });\n              break;\n            }\n          case KeyCodes.right:\n            {\n              _this.setState({\n                x: _this._getClampedPositionX(_this.state.x + delta)\n              });\n              break;\n            }\n          default:\n            {\n              handledEvent = false;\n            }\n        }\n        if (handledEvent) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n      }\n    };\n    _this._onEnterKeyboardMoveMode = function () {\n      _this._lastSetX = _this.state.x;\n      _this._lastSetY = _this.state.y;\n      _this.setState({\n        isInKeyboardMoveMode: true,\n        isModalMenuOpen: false\n      });\n      _this._events.on(window, 'keydown', _this._onKeyDown, true /* useCapture */);\n    };\n    _this._onExitKeyboardMoveMode = function () {\n      _this._lastSetX = 0;\n      _this._lastSetY = 0;\n      _this.setState({\n        isInKeyboardMoveMode: false\n      });\n      _this._events.off(window, 'keydown', _this._onKeyDown, true /* useCapture */);\n    };\n    _this._registerForKeyUp = function () {\n      if (!_this._hasRegisteredKeyUp) {\n        _this._events.on(window, 'keyup', _this._onKeyUp, true /* useCapture */);\n        _this._hasRegisteredKeyUp = true;\n      }\n    };\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    initializeComponentRef(_this);\n    warnDeprecations(COMPONENT_NAME, props, {\n      onLayerDidMount: 'layerProps.onLayerDidMount'\n    });\n    _this.state = {\n      id: getId('Modal'),\n      isOpen: props.isOpen,\n      isVisible: props.isOpen,\n      hasBeenOpened: props.isOpen,\n      x: 0,\n      y: 0\n    };\n    _this._lastSetX = 0;\n    _this._lastSetY = 0;\n    var _a = _this.props.allowTouchBodyScroll,\n      allowTouchBodyScroll = _a === void 0 ? false : _a;\n    _this._allowTouchBodyScroll = allowTouchBodyScroll;\n    return _this;\n  }\n  ModalBase.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    clearTimeout(this._onModalCloseTimer);\n    // Opening the dialog\n    if (newProps.isOpen) {\n      if (!this.state.isOpen) {\n        // First Open\n        this.setState({\n          isOpen: true\n        });\n        // Add a keyUp handler for all key up events when the dialog is open\n        if (newProps.dragOptions) {\n          this._registerForKeyUp();\n        }\n      } else {\n        // Modal has been opened\n        // Reopen during closing\n        this.setState({\n          hasBeenOpened: true,\n          isVisible: true\n        });\n      }\n    }\n    // Closing the dialog\n    if (!newProps.isOpen && this.state.isOpen) {\n      this._onModalCloseTimer = this._async.setTimeout(this._onModalClose, parseFloat(animationDuration) * 1000);\n      this.setState({\n        isVisible: false\n      });\n    }\n  };\n  ModalBase.prototype.componentDidMount = function () {\n    var _this = this;\n    // Not all modals show just by updating their props. Some only render when they are mounted and pass in\n    // isOpen as true. We need to add the keyUp handler in componentDidMount if we are in that case.\n    if (this.state.isOpen && this.state.isVisible) {\n      this._registerForKeyUp();\n      requestAnimationFrame(function () {\n        return setTimeout(_this._registerInitialModalPosition, 0);\n      });\n    }\n  };\n  ModalBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _this = this;\n    if (!prevProps.isOpen && !prevState.isVisible) {\n      this.setState({\n        isVisible: true\n      });\n    }\n    if (!prevProps.isOpen && this.props.isOpen) {\n      requestAnimationFrame(function () {\n        return setTimeout(_this._registerInitialModalPosition, 0);\n      });\n    }\n  };\n  ModalBase.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n    this._events.dispose();\n  };\n  ModalBase.prototype.render = function () {\n    var _a = this.props,\n      className = _a.className,\n      containerClassName = _a.containerClassName,\n      scrollableContentClassName = _a.scrollableContentClassName,\n      elementToFocusOnDismiss = _a.elementToFocusOnDismiss,\n      firstFocusableSelector = _a.firstFocusableSelector,\n      forceFocusInsideTrap = _a.forceFocusInsideTrap,\n      ignoreExternalFocusing = _a.ignoreExternalFocusing,\n      isBlocking = _a.isBlocking,\n      isClickableOutsideFocusTrap = _a.isClickableOutsideFocusTrap,\n      isDarkOverlay = _a.isDarkOverlay,\n      onDismiss = _a.onDismiss,\n      layerProps = _a.layerProps,\n      overlay = _a.overlay,\n      responsiveMode = _a.responsiveMode,\n      titleAriaId = _a.titleAriaId,\n      styles = _a.styles,\n      subtitleAriaId = _a.subtitleAriaId,\n      theme = _a.theme,\n      topOffsetFixed = _a.topOffsetFixed,\n      // eslint-disable-next-line deprecation/deprecation\n      onLayerDidMount = _a.onLayerDidMount,\n      isModeless = _a.isModeless,\n      dragOptions = _a.dragOptions,\n      enableAriaHiddenSiblings = _a.enableAriaHiddenSiblings;\n    var _b = this.state,\n      isOpen = _b.isOpen,\n      isVisible = _b.isVisible,\n      hasBeenOpened = _b.hasBeenOpened,\n      modalRectangleTop = _b.modalRectangleTop,\n      x = _b.x,\n      y = _b.y,\n      isInKeyboardMoveMode = _b.isInKeyboardMoveMode;\n    if (!isOpen) {\n      return null;\n    }\n    var layerClassName = layerProps === undefined ? '' : layerProps.className;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      containerClassName: containerClassName,\n      scrollableContentClassName: scrollableContentClassName,\n      isOpen: isOpen,\n      isVisible: isVisible,\n      hasBeenOpened: hasBeenOpened,\n      modalRectangleTop: modalRectangleTop,\n      topOffsetFixed: topOffsetFixed,\n      isModeless: isModeless,\n      layerClassName: layerClassName,\n      isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector\n    });\n    var mergedLayerProps = __assign(__assign(__assign({}, DefaultLayerProps), this.props.layerProps), {\n      onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount,\n      insertFirst: isModeless,\n      className: classNames.layer\n    });\n    var modalContent = React.createElement(FocusTrapZone, {\n      \"data-id\": this.state.id,\n      componentRef: this._focusTrapZone,\n      className: classNames.main,\n      elementToFocusOnDismiss: elementToFocusOnDismiss,\n      isClickableOutsideFocusTrap: isModeless || isClickableOutsideFocusTrap || !isBlocking,\n      ignoreExternalFocusing: ignoreExternalFocusing,\n      forceFocusInsideTrap: isModeless ? !isModeless : forceFocusInsideTrap,\n      firstFocusableSelector: firstFocusableSelector,\n      focusPreviouslyFocusedInnerElement: true,\n      onBlur: isInKeyboardMoveMode ? this._onExitKeyboardMoveMode : undefined,\n      enableAriaHiddenSiblings: enableAriaHiddenSiblings\n    }, dragOptions && isInKeyboardMoveMode && React.createElement(\"div\", {\n      className: classNames.keyboardMoveIconContainer\n    }, dragOptions.keyboardMoveIconProps ? React.createElement(Icon, __assign({}, dragOptions.keyboardMoveIconProps)) : React.createElement(Icon, {\n      iconName: \"move\",\n      className: classNames.keyboardMoveIcon\n    })), React.createElement(\"div\", {\n      ref: this._allowScrollOnModal,\n      className: classNames.scrollableContent,\n      \"data-is-scrollable\": true\n    }, dragOptions && this.state.isModalMenuOpen && React.createElement(dragOptions.menu, {\n      items: [{\n        key: 'move',\n        text: dragOptions.moveMenuItemText,\n        onClick: this._onEnterKeyboardMoveMode\n      }, {\n        key: 'close',\n        text: dragOptions.closeMenuItemText,\n        onClick: this._onModalClose\n      }],\n      onDismiss: this._onModalContextMenuClose,\n      alignTargetEdge: true,\n      coverTarget: true,\n      directionalHint: DirectionalHint.topLeftEdge,\n      directionalHintFixed: true,\n      shouldFocusOnMount: true,\n      target: this._scrollableContent\n    }), this.props.children));\n    // @temp tuatology - Will adjust this to be a panel at certain breakpoints\n    if (responsiveMode >= ResponsiveMode.small) {\n      return React.createElement(Layer, __assign({}, mergedLayerProps), React.createElement(Popup, {\n        role: isModeless || !isBlocking ? 'dialog' : 'alertdialog',\n        \"aria-modal\": !isModeless,\n        ariaLabelledBy: titleAriaId,\n        ariaDescribedBy: subtitleAriaId,\n        onDismiss: onDismiss,\n        shouldRestoreFocus: !ignoreExternalFocusing\n      }, React.createElement(\"div\", {\n        className: classNames.root,\n        role: !isModeless ? 'document' : undefined\n      }, !isModeless && React.createElement(Overlay, __assign({\n        isDarkThemed: isDarkOverlay,\n        onClick: isBlocking ? undefined : onDismiss,\n        allowTouchBodyScroll: this._allowTouchBodyScroll\n      }, overlay)), dragOptions ? React.createElement(DraggableZone, {\n        handleSelector: dragOptions.dragHandleSelector || \".\" + classNames.main.split(' ')[0],\n        preventDragSelector: \"button\",\n        onStart: this._onDragStart,\n        onDragChange: this._onDrag,\n        onStop: this._onDragStop,\n        position: {\n          x: x,\n          y: y\n        }\n      }, modalContent) : modalContent)));\n    }\n    return null;\n  };\n  ModalBase.prototype.focus = function () {\n    if (this._focusTrapZone.current) {\n      this._focusTrapZone.current.focus();\n    }\n  };\n  /**\n   * Clamps the position coordinates to the maximum/minimum value specified in props\n   */\n  ModalBase.prototype._getClampedPosition = function (position) {\n    if (!this.props.dragOptions || !this.props.dragOptions.keepInBounds) {\n      return position;\n    }\n    return {\n      x: this._getClampedPositionX(position.x),\n      y: this._getClampedPositionY(position.y)\n    };\n  };\n  ModalBase.prototype._getClampedPositionY = function (y) {\n    var minPosition = this._minClampedPosition;\n    var maxPosition = this._maxClampedPosition;\n    if (minPosition) {\n      y = Math.max(minPosition.y, y);\n    }\n    if (maxPosition) {\n      y = Math.min(maxPosition.y, y);\n    }\n    return y;\n  };\n  ModalBase.prototype._getClampedPositionX = function (x) {\n    var minPosition = this._minClampedPosition;\n    var maxPosition = this._maxClampedPosition;\n    if (minPosition) {\n      x = Math.max(minPosition.x, x);\n    }\n    if (maxPosition) {\n      x = Math.min(maxPosition.x, x);\n    }\n    return x;\n  };\n  ModalBase.prototype._getMoveDelta = function (event) {\n    var delta = 10;\n    if (event.shiftKey) {\n      if (!event.ctrlKey) {\n        delta = 50;\n      }\n    } else if (event.ctrlKey) {\n      delta = 1;\n    }\n    return delta;\n  };\n  ModalBase.defaultProps = {\n    isOpen: false,\n    isDarkOverlay: true,\n    isBlocking: false,\n    className: '',\n    containerClassName: ''\n  };\n  ModalBase = __decorate([withResponsiveMode], ModalBase);\n  return ModalBase;\n}(React.Component);\nexport { ModalBase };","map":{"version":3,"sources":["components/Modal/Modal.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  classNamesFunction,\n  getId,\n  allowScrollOnElement,\n  allowOverscrollOnElement,\n  KeyCodes,\n  elementContains,\n  warnDeprecations,\n  Async,\n  EventGroup,\n} from '../../Utilities';\nimport { FocusTrapZone, IFocusTrapZone } from '../FocusTrapZone/index';\nimport { animationDuration } from './Modal.styles';\nimport { IModalProps, IModalStyleProps, IModalStyles, IModal } from './Modal.types';\nimport { Overlay } from '../../Overlay';\nimport { ILayerProps, Layer } from '../../Layer';\nimport { Popup } from '../Popup/index';\nimport { withResponsiveMode, ResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { DirectionalHint } from '../Callout/index';\nimport { Icon } from '../Icon/index';\nimport { DraggableZone, ICoordinates, IDragData } from '../../utilities/DraggableZone/index';\nimport { initializeComponentRef } from '@uifabric/utilities';\n\n// @TODO - need to change this to a panel whenever the breakpoint is under medium (verify the spec)\n\nconst DefaultLayerProps: ILayerProps = {\n  eventBubblingEnabled: false,\n};\n\nexport interface IDialogState {\n  isOpen?: boolean;\n  isVisible?: boolean;\n  isVisibleClose?: boolean;\n  id?: string;\n  hasBeenOpened?: boolean;\n  modalRectangleTop?: number;\n  isModalMenuOpen?: boolean;\n  isInKeyboardMoveMode?: boolean;\n  x: number;\n  y: number;\n}\n\nconst getClassNames = classNamesFunction<IModalStyleProps, IModalStyles>();\nconst COMPONENT_NAME = 'Modal';\n\n@withResponsiveMode\nexport class ModalBase extends React.Component<IModalProps, IDialogState> implements IModal {\n  public static defaultProps: IModalProps = {\n    isOpen: false,\n    isDarkOverlay: true,\n    isBlocking: false,\n    className: '',\n    containerClassName: '',\n  };\n\n  private _onModalCloseTimer: number;\n  private _focusTrapZone = React.createRef<IFocusTrapZone>();\n  private _scrollableContent: HTMLDivElement | null;\n  private _lastSetX: number;\n  private _lastSetY: number;\n  private _allowTouchBodyScroll: boolean;\n  private _hasRegisteredKeyUp: boolean;\n  private _async: Async;\n  private _events: EventGroup;\n  private _minClampedPosition: ICoordinates;\n  private _maxClampedPosition: ICoordinates;\n\n  constructor(props: IModalProps) {\n    super(props);\n\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n    initializeComponentRef(this);\n\n    warnDeprecations(COMPONENT_NAME, props, {\n      onLayerDidMount: 'layerProps.onLayerDidMount',\n    });\n\n    this.state = {\n      id: getId('Modal'),\n      isOpen: props.isOpen,\n      isVisible: props.isOpen,\n      hasBeenOpened: props.isOpen,\n      x: 0,\n      y: 0,\n    };\n\n    this._lastSetX = 0;\n    this._lastSetY = 0;\n\n    const { allowTouchBodyScroll = false } = this.props;\n    this._allowTouchBodyScroll = allowTouchBodyScroll;\n  }\n\n  public UNSAFE_componentWillReceiveProps(newProps: IModalProps): void {\n    clearTimeout(this._onModalCloseTimer);\n\n    // Opening the dialog\n    if (newProps.isOpen) {\n      if (!this.state.isOpen) {\n        // First Open\n        this.setState({\n          isOpen: true,\n        });\n        // Add a keyUp handler for all key up events when the dialog is open\n        if (newProps.dragOptions) {\n          this._registerForKeyUp();\n        }\n      } else {\n        // Modal has been opened\n        // Reopen during closing\n        this.setState({\n          hasBeenOpened: true,\n          isVisible: true,\n        });\n      }\n    }\n\n    // Closing the dialog\n    if (!newProps.isOpen && this.state.isOpen) {\n      this._onModalCloseTimer = this._async.setTimeout(this._onModalClose, parseFloat(animationDuration) * 1000);\n      this.setState({\n        isVisible: false,\n      });\n    }\n  }\n\n  public componentDidMount() {\n    // Not all modals show just by updating their props. Some only render when they are mounted and pass in\n    // isOpen as true. We need to add the keyUp handler in componentDidMount if we are in that case.\n    if (this.state.isOpen && this.state.isVisible) {\n      this._registerForKeyUp();\n      requestAnimationFrame(() => setTimeout(this._registerInitialModalPosition, 0));\n    }\n  }\n\n  public componentDidUpdate(prevProps: IModalProps, prevState: IDialogState) {\n    if (!prevProps.isOpen && !prevState.isVisible) {\n      this.setState({\n        isVisible: true,\n      });\n    }\n    if (!prevProps.isOpen && this.props.isOpen) {\n      requestAnimationFrame(() => setTimeout(this._registerInitialModalPosition, 0));\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  public render(): JSX.Element | null {\n    const {\n      className,\n      containerClassName,\n      scrollableContentClassName,\n      elementToFocusOnDismiss,\n      firstFocusableSelector,\n      forceFocusInsideTrap,\n      ignoreExternalFocusing,\n      isBlocking,\n      isClickableOutsideFocusTrap,\n      isDarkOverlay,\n      onDismiss,\n      layerProps,\n      overlay,\n      responsiveMode,\n      titleAriaId,\n      styles,\n      subtitleAriaId,\n      theme,\n      topOffsetFixed,\n      // eslint-disable-next-line deprecation/deprecation\n      onLayerDidMount,\n      isModeless,\n      dragOptions,\n      enableAriaHiddenSiblings,\n    } = this.props;\n    const { isOpen, isVisible, hasBeenOpened, modalRectangleTop, x, y, isInKeyboardMoveMode } = this.state;\n\n    if (!isOpen) {\n      return null;\n    }\n\n    const layerClassName = layerProps === undefined ? '' : layerProps.className;\n\n    const classNames = getClassNames(styles, {\n      theme: theme!,\n      className,\n      containerClassName,\n      scrollableContentClassName,\n      isOpen,\n      isVisible,\n      hasBeenOpened,\n      modalRectangleTop,\n      topOffsetFixed,\n      isModeless,\n      layerClassName,\n      isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector,\n    });\n\n    const mergedLayerProps = {\n      ...DefaultLayerProps,\n      ...this.props.layerProps,\n      onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount,\n      insertFirst: isModeless,\n      className: classNames.layer,\n    };\n    const modalContent = (\n      <FocusTrapZone\n        data-id={this.state.id}\n        componentRef={this._focusTrapZone}\n        className={classNames.main}\n        elementToFocusOnDismiss={elementToFocusOnDismiss}\n        isClickableOutsideFocusTrap={isModeless || isClickableOutsideFocusTrap || !isBlocking}\n        ignoreExternalFocusing={ignoreExternalFocusing}\n        forceFocusInsideTrap={isModeless ? !isModeless : forceFocusInsideTrap}\n        firstFocusableSelector={firstFocusableSelector}\n        focusPreviouslyFocusedInnerElement={true}\n        onBlur={isInKeyboardMoveMode ? this._onExitKeyboardMoveMode : undefined}\n        enableAriaHiddenSiblings={enableAriaHiddenSiblings}\n      >\n        {dragOptions && isInKeyboardMoveMode && (\n          <div className={classNames.keyboardMoveIconContainer}>\n            {dragOptions.keyboardMoveIconProps ? (\n              <Icon {...dragOptions.keyboardMoveIconProps} />\n            ) : (\n              <Icon iconName=\"move\" className={classNames.keyboardMoveIcon} />\n            )}\n          </div>\n        )}\n        <div ref={this._allowScrollOnModal} className={classNames.scrollableContent} data-is-scrollable={true}>\n          {dragOptions && this.state.isModalMenuOpen && (\n            <dragOptions.menu\n              items={[\n                { key: 'move', text: dragOptions.moveMenuItemText, onClick: this._onEnterKeyboardMoveMode },\n                { key: 'close', text: dragOptions.closeMenuItemText, onClick: this._onModalClose },\n              ]}\n              onDismiss={this._onModalContextMenuClose}\n              alignTargetEdge={true}\n              coverTarget={true}\n              directionalHint={DirectionalHint.topLeftEdge}\n              directionalHintFixed={true}\n              shouldFocusOnMount={true}\n              target={this._scrollableContent}\n            />\n          )}\n          {this.props.children}\n        </div>\n      </FocusTrapZone>\n    );\n\n    // @temp tuatology - Will adjust this to be a panel at certain breakpoints\n    if (responsiveMode! >= ResponsiveMode.small) {\n      return (\n        <Layer {...mergedLayerProps}>\n          <Popup\n            role={isModeless || !isBlocking ? 'dialog' : 'alertdialog'}\n            aria-modal={!isModeless}\n            ariaLabelledBy={titleAriaId}\n            ariaDescribedBy={subtitleAriaId}\n            onDismiss={onDismiss}\n            shouldRestoreFocus={!ignoreExternalFocusing}\n          >\n            <div className={classNames.root} role={!isModeless ? 'document' : undefined}>\n              {!isModeless && (\n                <Overlay\n                  isDarkThemed={isDarkOverlay}\n                  onClick={isBlocking ? undefined : (onDismiss as any)}\n                  allowTouchBodyScroll={this._allowTouchBodyScroll}\n                  {...overlay}\n                />\n              )}\n              {dragOptions ? (\n                <DraggableZone\n                  handleSelector={dragOptions.dragHandleSelector || `.${classNames.main.split(' ')[0]}`}\n                  preventDragSelector=\"button\"\n                  onStart={this._onDragStart}\n                  onDragChange={this._onDrag}\n                  onStop={this._onDragStop}\n                  position={{ x: x, y: y }}\n                >\n                  {modalContent}\n                </DraggableZone>\n              ) : (\n                modalContent\n              )}\n            </div>\n          </Popup>\n        </Layer>\n      );\n    }\n    return null;\n  }\n\n  public focus() {\n    if (this._focusTrapZone.current) {\n      this._focusTrapZone.current.focus();\n    }\n  }\n\n  private _registerInitialModalPosition = (): void => {\n    const dialogMain = document.querySelector(`[data-id=${this.state.id}]`);\n\n    if (dialogMain) {\n      const modalRectangle = dialogMain.getBoundingClientRect();\n      if (this.props.dragOptions?.keepInBounds && !this._minClampedPosition && !this._maxClampedPosition) {\n        this._minClampedPosition = { x: -modalRectangle.x, y: -modalRectangle.y };\n        this._maxClampedPosition = { x: modalRectangle.x, y: modalRectangle.y };\n      }\n\n      this.setState({\n        modalRectangleTop: modalRectangle.top,\n      });\n    }\n  };\n\n  /**\n   * Clamps the position coordinates to the maximum/minimum value specified in props\n   */\n  private _getClampedPosition(position: ICoordinates) {\n    if (!this.props.dragOptions || !this.props.dragOptions.keepInBounds) {\n      return position;\n    }\n    return { x: this._getClampedPositionX(position.x), y: this._getClampedPositionY(position.y) };\n  }\n\n  private _getClampedPositionY(y: number) {\n    const minPosition = this._minClampedPosition;\n    const maxPosition = this._maxClampedPosition;\n    if (minPosition) {\n      y = Math.max(minPosition.y, y);\n    }\n    if (maxPosition) {\n      y = Math.min(maxPosition.y, y);\n    }\n    return y;\n  }\n\n  private _getClampedPositionX(x: number) {\n    const minPosition = this._minClampedPosition;\n    const maxPosition = this._maxClampedPosition;\n    if (minPosition) {\n      x = Math.max(minPosition.x, x);\n    }\n    if (maxPosition) {\n      x = Math.min(maxPosition.x, x);\n    }\n    return x;\n  }\n\n  // Allow the user to scroll within the modal but not on the body\n  private _allowScrollOnModal = (elt: HTMLDivElement | null): void => {\n    if (elt) {\n      if (this._allowTouchBodyScroll) {\n        allowOverscrollOnElement(elt, this._events);\n      } else {\n        allowScrollOnElement(elt, this._events);\n      }\n    } else {\n      this._events.off(this._scrollableContent);\n    }\n    this._scrollableContent = elt;\n  };\n\n  private _onModalContextMenuClose = (): void => {\n    this.setState({ isModalMenuOpen: false });\n  };\n\n  private _onModalClose = (): void => {\n    this._lastSetX = 0;\n    this._lastSetY = 0;\n\n    this.setState({\n      isModalMenuOpen: false,\n      isInKeyboardMoveMode: false,\n      isOpen: false,\n      x: 0,\n      y: 0,\n    });\n\n    if (this.props.dragOptions && this._hasRegisteredKeyUp) {\n      this._events.off(window, 'keyup', this._onKeyUp, true /* useCapture */);\n    }\n\n    // Call the onDismiss callback\n    if (this.props.onDismissed) {\n      this.props.onDismissed();\n    }\n  };\n\n  private _onDragStart = (): void => {\n    this.setState({ isModalMenuOpen: false, isInKeyboardMoveMode: false });\n  };\n\n  private _onDrag = (_: React.MouseEvent<HTMLElement> & React.TouchEvent<HTMLElement>, ui: IDragData): void => {\n    const { x, y } = this.state;\n    this.setState(this._getClampedPosition({ x: x + ui.delta.x, y: y + ui.delta.y }));\n  };\n\n  private _onDragStop = (): void => {\n    this.focus();\n  };\n\n  private _onKeyUp = (event: React.KeyboardEvent<HTMLElement>): void => {\n    // Need to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n    // Otherwise it would continue to fire a click even if the event was cancelled\n    // during mouseDown.\n    if (event.altKey && event.ctrlKey && event.keyCode === KeyCodes.space) {\n      // Since this is a global handler, we should make sure the target is within the dialog\n      // before opening the dropdown\n      if (elementContains(this._scrollableContent, event.target as HTMLElement)) {\n        this.setState({ isModalMenuOpen: !this.state.isModalMenuOpen });\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n  };\n\n  // We need a global onKeyDown event when we are in the move mode so that we can\n  // handle the key presses and the components inside the modal do not get the events\n  private _onKeyDown = (event: React.KeyboardEvent<HTMLElement>): void => {\n    if (event.altKey && event.ctrlKey && event.keyCode === KeyCodes.space) {\n      // CTRL + ALT + SPACE is handled during keyUp\n      event.preventDefault();\n      event.stopPropagation();\n      return;\n    }\n\n    if (this.state.isModalMenuOpen && (event.altKey || event.keyCode === KeyCodes.escape)) {\n      this.setState({ isModalMenuOpen: false });\n    }\n\n    if (this.state.isInKeyboardMoveMode && (event.keyCode === KeyCodes.escape || event.keyCode === KeyCodes.enter)) {\n      this.setState({ isInKeyboardMoveMode: false });\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (this.state.isInKeyboardMoveMode) {\n      let handledEvent = true;\n      const delta = this._getMoveDelta(event);\n\n      switch (event.keyCode) {\n        /* eslint-disable no-fallthrough */\n        case KeyCodes.escape:\n          this.setState({ x: this._lastSetX, y: this._lastSetY });\n        case KeyCodes.enter: {\n          // TODO: determine if fallthrough was intentional\n          /* eslint-enable no-fallthrough */\n          this._lastSetX = 0;\n          this._lastSetY = 0;\n          this.setState({ isInKeyboardMoveMode: false });\n          break;\n        }\n        case KeyCodes.up: {\n          this.setState({\n            y: this._getClampedPositionY(this.state.y - delta),\n          });\n          break;\n        }\n        case KeyCodes.down: {\n          this.setState({\n            y: this._getClampedPositionY(this.state.y + delta),\n          });\n          break;\n        }\n        case KeyCodes.left: {\n          this.setState({\n            x: this._getClampedPositionX(this.state.x - delta),\n          });\n          break;\n        }\n        case KeyCodes.right: {\n          this.setState({\n            x: this._getClampedPositionX(this.state.x + delta),\n          });\n          break;\n        }\n        default: {\n          handledEvent = false;\n        }\n      }\n\n      if (handledEvent) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n  };\n\n  private _getMoveDelta(event: React.KeyboardEvent<HTMLElement>): number {\n    let delta = 10;\n    if (event.shiftKey) {\n      if (!event.ctrlKey) {\n        delta = 50;\n      }\n    } else if (event.ctrlKey) {\n      delta = 1;\n    }\n\n    return delta;\n  }\n\n  private _onEnterKeyboardMoveMode = () => {\n    this._lastSetX = this.state.x;\n    this._lastSetY = this.state.y;\n    this.setState({ isInKeyboardMoveMode: true, isModalMenuOpen: false });\n    this._events.on(window, 'keydown', this._onKeyDown, true /* useCapture */);\n  };\n\n  private _onExitKeyboardMoveMode = () => {\n    this._lastSetX = 0;\n    this._lastSetY = 0;\n    this.setState({ isInKeyboardMoveMode: false });\n    this._events.off(window, 'keydown', this._onKeyDown, true /* useCapture */);\n  };\n\n  private _registerForKeyUp = (): void => {\n    if (!this._hasRegisteredKeyUp) {\n      this._events.on(window, 'keyup', this._onKeyUp, true /* useCapture */);\n      this._hasRegisteredKeyUp = true;\n    }\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}