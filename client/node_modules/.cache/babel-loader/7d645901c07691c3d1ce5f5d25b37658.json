{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __assign, __awaiter, __generator, __spreadArrays } from \"tslib\";\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { logPolicy } from \"./policies/logPolicy\";\nimport { getPathStringFromParameter, getPathStringFromParameterPath } from \"./operationParameter\";\nimport { getStreamResponseStatusCodes } from \"./operationSpec\";\nimport { deserializationPolicy, DefaultDeserializationOptions } from \"./policies/deserializationPolicy\";\nimport { exponentialRetryPolicy, DefaultRetryOptions } from \"./policies/exponentialRetryPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport { userAgentPolicy, getDefaultUserAgentHeaderName, getDefaultUserAgentValue } from \"./policies/userAgentPolicy\";\nimport { redirectPolicy, DefaultRedirectOptions } from \"./policies/redirectPolicy\";\nimport { RequestPolicyOptions } from \"./policies/requestPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { MapperType } from \"./serializer\";\nimport { URLBuilder } from \"./url\";\nimport * as utils from \"./util/utils\";\nimport { stringifyXML } from \"./util/xml\";\nimport { WebResource, isWebResourceLike } from \"./webResource\";\nimport { isNode } from \"./util/utils\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { logger } from \"./log\";\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from \"./policies/keepAlivePolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\nimport { disableResponseDecompressionPolicy } from \"./policies/disableResponseDecompressionPolicy\";\nimport { ndJsonPolicy } from \"./policies/ndJsonPolicy\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\";\nimport { URL } from \"./url\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\n/**\n * ServiceClient sends service requests and receives responses.\n */\nvar ServiceClient = /** @class */function () {\n  /**\n   * The ServiceClient constructor\n   * @param credentials - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  function ServiceClient(credentials, /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n  options) {\n    var _this = this;\n    if (!options) {\n      options = {};\n    }\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n    var requestPolicyFactories;\n    if (Array.isArray(options.requestPolicyFactories)) {\n      logger.info(\"ServiceClient: using custom request policies\");\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      var authPolicyFactory = undefined;\n      if (isTokenCredential(credentials)) {\n        logger.info(\"ServiceClient: creating bearer token authentication policy from provided credentials\");\n        // Create a wrapped RequestPolicyFactory here so that we can provide the\n        // correct scope to the BearerTokenAuthenticationPolicy at the first time\n        // one is requested.  This is needed because generated ServiceClient\n        // implementations do not set baseUri until after ServiceClient's constructor\n        // is finished, leaving baseUri empty at the time when it is needed to\n        // build the correct scope name.\n        var wrappedPolicyFactory = function () {\n          var bearerTokenPolicyFactory = undefined;\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          var serviceClient = _this;\n          var serviceClientOptions = options;\n          return {\n            create: function (nextPolicy, createOptions) {\n              var credentialScopes = getCredentialScopes(serviceClientOptions, serviceClient.baseUri);\n              if (!credentialScopes) {\n                throw new Error(\"When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy\");\n              }\n              if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {\n                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(credentials, credentialScopes);\n              }\n              return bearerTokenPolicyFactory.create(nextPolicy, createOptions);\n            }\n          };\n        };\n        authPolicyFactory = wrappedPolicyFactory();\n      } else if (credentials && typeof credentials.signRequest === \"function\") {\n        logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n        authPolicyFactory = signingPolicy(credentials);\n      } else if (credentials !== undefined && credentials !== null) {\n        throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n      }\n      logger.info(\"ServiceClient: using default request policies\");\n      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n      if (options.requestPolicyFactories) {\n        // options.requestPolicyFactories can also be a function that manipulates\n        // the default requestPolicyFactories array\n        var newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n  ServiceClient.prototype.sendRequest = function (options) {\n    if (options === null || options === undefined || typeof options !== \"object\") {\n      throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n    }\n    var httpRequest;\n    try {\n      if (isWebResourceLike(options)) {\n        options.validateRequestProperties();\n        httpRequest = options;\n      } else {\n        httpRequest = new WebResource();\n        httpRequest = httpRequest.prepare(options);\n      }\n    } catch (error) {\n      return Promise.reject(error);\n    }\n    var httpPipeline = this._httpClient;\n    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n      for (var i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n        httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);\n      }\n    }\n    return httpPipeline.sendRequest(httpRequest);\n  };\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   * @param callback - The callback to call when the response is received.\n   */\n  ServiceClient.prototype.sendOperationRequest = function (operationArguments, operationSpec, callback) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var serializerOptions, httpRequest, result, baseUri, requestUrl, _i, _b, urlParameter, urlParameterValue, _c, _d, queryParameter, queryParameterValue, index, item, index, contentType, _e, _f, headerParameter, headerValue, headerCollectionPrefix, _g, _h, key, options, customHeaderName, rawResponse, sendRequestError, error_1, error_2, cb;\n      return __generator(this, function (_j) {\n        switch (_j.label) {\n          case 0:\n            if (typeof operationArguments.options === \"function\") {\n              callback = operationArguments.options;\n              operationArguments.options = undefined;\n            }\n            serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n            httpRequest = new WebResource();\n            _j.label = 1;\n          case 1:\n            _j.trys.push([1, 6,, 7]);\n            baseUri = operationSpec.baseUrl || this.baseUri;\n            if (!baseUri) {\n              throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\");\n            }\n            httpRequest.method = operationSpec.httpMethod;\n            httpRequest.operationSpec = operationSpec;\n            requestUrl = URLBuilder.parse(baseUri);\n            if (operationSpec.path) {\n              requestUrl.appendPath(operationSpec.path);\n            }\n            if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n              for (_i = 0, _b = operationSpec.urlParameters; _i < _b.length; _i++) {\n                urlParameter = _b[_i];\n                urlParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, urlParameter, operationSpec.serializer);\n                urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter(urlParameter), serializerOptions);\n                if (!urlParameter.skipEncoding) {\n                  urlParameterValue = encodeURIComponent(urlParameterValue);\n                }\n                requestUrl.replaceAll(\"{\" + (urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)) + \"}\", urlParameterValue);\n              }\n            }\n            if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {\n              for (_c = 0, _d = operationSpec.queryParameters; _c < _d.length; _c++) {\n                queryParameter = _d[_c];\n                queryParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, queryParameter, operationSpec.serializer);\n                if (queryParameterValue !== undefined && queryParameterValue !== null) {\n                  queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter), serializerOptions);\n                  if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null) {\n                    if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {\n                      if (queryParameterValue.length === 0) {\n                        // The collection is empty, no need to try serializing the current queryParam\n                        continue;\n                      } else {\n                        for (index in queryParameterValue) {\n                          item = queryParameterValue[index];\n                          queryParameterValue[index] = item === undefined || item === null ? \"\" : item.toString();\n                        }\n                      }\n                    } else if (queryParameter.collectionFormat === QueryCollectionFormat.Ssv || queryParameter.collectionFormat === QueryCollectionFormat.Tsv) {\n                      queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n                    }\n                  }\n                  if (!queryParameter.skipEncoding) {\n                    if (Array.isArray(queryParameterValue)) {\n                      for (index in queryParameterValue) {\n                        if (queryParameterValue[index] !== undefined && queryParameterValue[index] !== null) {\n                          queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);\n                        }\n                      }\n                    } else {\n                      queryParameterValue = encodeURIComponent(queryParameterValue);\n                    }\n                  }\n                  if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null && queryParameter.collectionFormat !== QueryCollectionFormat.Multi && queryParameter.collectionFormat !== QueryCollectionFormat.Ssv && queryParameter.collectionFormat !== QueryCollectionFormat.Tsv) {\n                    queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n                  }\n                  requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n                }\n              }\n            }\n            httpRequest.url = requestUrl.toString();\n            contentType = operationSpec.contentType || this.requestContentType;\n            if (contentType && operationSpec.requestBody) {\n              httpRequest.headers.set(\"Content-Type\", contentType);\n            }\n            if (operationSpec.headerParameters) {\n              for (_e = 0, _f = operationSpec.headerParameters; _e < _f.length; _e++) {\n                headerParameter = _f[_e];\n                headerValue = getOperationArgumentValueFromParameter(this, operationArguments, headerParameter, operationSpec.serializer);\n                if (headerValue !== undefined && headerValue !== null) {\n                  headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter), serializerOptions);\n                  headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;\n                  if (headerCollectionPrefix) {\n                    for (_g = 0, _h = Object.keys(headerValue); _g < _h.length; _g++) {\n                      key = _h[_g];\n                      httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n                    }\n                  } else {\n                    httpRequest.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n                  }\n                }\n              }\n            }\n            options = operationArguments.options;\n            if (options) {\n              if (options.customHeaders) {\n                for (customHeaderName in options.customHeaders) {\n                  httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n                }\n              }\n              if (options.abortSignal) {\n                httpRequest.abortSignal = options.abortSignal;\n              }\n              if (options.timeout) {\n                httpRequest.timeout = options.timeout;\n              }\n              if (options.onUploadProgress) {\n                httpRequest.onUploadProgress = options.onUploadProgress;\n              }\n              if (options.onDownloadProgress) {\n                httpRequest.onDownloadProgress = options.onDownloadProgress;\n              }\n              if (options.spanOptions) {\n                httpRequest.spanOptions = options.spanOptions;\n              }\n              if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {\n                httpRequest.shouldDeserialize = options.shouldDeserialize;\n              }\n            }\n            httpRequest.withCredentials = this._withCredentials;\n            serializeRequestBody(this, httpRequest, operationArguments, operationSpec);\n            if (httpRequest.streamResponseStatusCodes === undefined) {\n              httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);\n            }\n            rawResponse = void 0;\n            sendRequestError = void 0;\n            _j.label = 2;\n          case 2:\n            _j.trys.push([2, 4,, 5]);\n            return [4 /*yield*/, this.sendRequest(httpRequest)];\n          case 3:\n            rawResponse = _j.sent();\n            return [3 /*break*/, 5];\n          case 4:\n            error_1 = _j.sent();\n            sendRequestError = error_1;\n            return [3 /*break*/, 5];\n          case 5:\n            if (sendRequestError) {\n              if (sendRequestError.response) {\n                sendRequestError.details = flattenResponse(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] || operationSpec.responses[\"default\"]);\n              }\n              result = Promise.reject(sendRequestError);\n            } else {\n              result = Promise.resolve(flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]));\n            }\n            return [3 /*break*/, 7];\n          case 6:\n            error_2 = _j.sent();\n            result = Promise.reject(error_2);\n            return [3 /*break*/, 7];\n          case 7:\n            cb = callback;\n            if (cb) {\n              result.then(function (res) {\n                return cb(null, res._response.parsedBody, res._response.request, res._response);\n              }).catch(function (err) {\n                return cb(err);\n              });\n            }\n            return [2 /*return*/, result];\n        }\n      });\n    });\n  };\n  return ServiceClient;\n}();\nexport { ServiceClient };\nexport function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {\n  var _a, _b, _c, _d, _e, _f;\n  var serializerOptions = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions) !== null && _b !== void 0 ? _b : {};\n  var updatedOptions = {\n    rootName: (_c = serializerOptions.rootName) !== null && _c !== void 0 ? _c : \"\",\n    includeRoot: (_d = serializerOptions.includeRoot) !== null && _d !== void 0 ? _d : false,\n    xmlCharKey: (_e = serializerOptions.xmlCharKey) !== null && _e !== void 0 ? _e : XML_CHARKEY\n  };\n  var xmlCharKey = serializerOptions.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);\n    var bodyMapper = operationSpec.requestBody.mapper;\n    var required = bodyMapper.required,\n      xmlName = bodyMapper.xmlName,\n      xmlElementName = bodyMapper.xmlElementName,\n      serializedName = bodyMapper.serializedName,\n      xmlNamespace = bodyMapper.xmlNamespace,\n      xmlNamespacePrefix = bodyMapper.xmlNamespacePrefix;\n    var typeName = bodyMapper.type.name;\n    try {\n      if (httpRequest.body !== undefined && httpRequest.body !== null || required) {\n        var requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n        httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString, updatedOptions);\n        var isStream = typeName === MapperType.Stream;\n        if (operationSpec.isXML) {\n          var xmlnsKey = xmlNamespacePrefix ? \"xmlns:\" + xmlNamespacePrefix : \"xmlns\";\n          var value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, httpRequest.body, updatedOptions);\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(utils.prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {\n              rootName: xmlName || serializedName,\n              xmlCharKey: xmlCharKey\n            });\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey: xmlCharKey\n            });\n          }\n        } else if (typeName === MapperType.String && (((_f = operationSpec.contentType) === null || _f === void 0 ? void 0 : _f.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(\"Error \\\"\" + error.message + \"\\\" occurred in serializing the payload - \" + JSON.stringify(serializedName, undefined, \"  \") + \".\");\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n    for (var _i = 0, _g = operationSpec.formDataParameters; _i < _g.length; _i++) {\n      var formDataParameter = _g[_i];\n      var formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        var formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n      }\n    }\n  }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n  var _a;\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    var result = {};\n    result[options.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = (_a = {}, _a[xmlnsKey] = xmlNamespace, _a);\n    return result;\n  }\n  return serializedValue;\n}\nfunction getValueOrFunctionResult(value, defaultValueCreator) {\n  var result;\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n  return result;\n}\nfunction createDefaultRequestPolicyFactories(authPolicyFactory, options) {\n  var factories = [];\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n  if (authPolicyFactory) {\n    factories.push(authPolicyFactory);\n  }\n  var userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName);\n  var userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, getDefaultUserAgentValue);\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({\n      key: userAgentHeaderName,\n      value: userAgentHeaderValue\n    }));\n  }\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n  if (isNode) {\n    factories.push(proxyPolicy(options.proxySettings));\n  }\n  factories.push(logPolicy({\n    logger: logger.info\n  }));\n  return factories;\n}\nexport function createPipelineFromOptions(pipelineOptions, authPolicyFactory) {\n  var requestPolicyFactories = [];\n  if (pipelineOptions.sendStreamingJson) {\n    requestPolicyFactories.push(ndJsonPolicy());\n  }\n  var userAgentValue = undefined;\n  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n    var userAgentInfo = [];\n    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);\n    // Add the default user agent value if it isn't already specified\n    // by the userAgentPrefix option.\n    var defaultUserAgentInfo = getDefaultUserAgentValue();\n    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n      userAgentInfo.push(defaultUserAgentInfo);\n    }\n    userAgentValue = userAgentInfo.join(\" \");\n  }\n  var keepAliveOptions = __assign(__assign({}, DefaultKeepAliveOptions), pipelineOptions.keepAliveOptions);\n  var retryOptions = __assign(__assign({}, DefaultRetryOptions), pipelineOptions.retryOptions);\n  var redirectOptions = __assign(__assign({}, DefaultRedirectOptions), pipelineOptions.redirectOptions);\n  if (isNode) {\n    requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));\n  }\n  var deserializationOptions = __assign(__assign({}, DefaultDeserializationOptions), pipelineOptions.deserializationOptions);\n  var loggingOptions = __assign({}, pipelineOptions.loggingOptions);\n  requestPolicyFactories.push(tracingPolicy({\n    userAgent: userAgentValue\n  }), keepAlivePolicy(keepAliveOptions), userAgentPolicy({\n    value: userAgentValue\n  }), generateClientRequestIdPolicy(), deserializationPolicy(deserializationOptions.expectedContentTypes), throttlingRetryPolicy(), systemErrorRetryPolicy(), exponentialRetryPolicy(retryOptions.maxRetries, retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs));\n  if (redirectOptions.handleRedirects) {\n    requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));\n  }\n  if (authPolicyFactory) {\n    requestPolicyFactories.push(authPolicyFactory);\n  }\n  requestPolicyFactories.push(logPolicy(loggingOptions));\n  if (isNode && pipelineOptions.decompressResponse === false) {\n    requestPolicyFactories.push(disableResponseDecompressionPolicy());\n  }\n  return {\n    httpClient: pipelineOptions.httpClient,\n    requestPolicyFactories: requestPolicyFactories\n  };\n}\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\nexport function getPropertyParent(parent, propertyPath) {\n  if (parent && propertyPath) {\n    var propertyPathLength = propertyPath.length;\n    for (var i = 0; i < propertyPathLength - 1; ++i) {\n      var propertyName = propertyPath[i];\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n      parent = parent[propertyName];\n    }\n  }\n  return parent;\n}\nfunction getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer) {\n  return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer);\n}\nexport function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer) {\n  var _a;\n  var value;\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n  var serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        var propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n        var useDefaultValue = false;\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue = parameterMapper.required || parameterPath[0] === \"options\" && parameterPath.length === 2;\n        }\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      }\n      // Serialize just for validation purposes.\n      var parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);\n      serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n    for (var propertyName in parameterPath) {\n      var propertyMapper = parameterMapper.type.modelProperties[propertyName];\n      var propertyPath = parameterPath[propertyName];\n      var propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer);\n      // Serialize just for validation purposes.\n      var propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);\n      if (propertyValue !== undefined && propertyValue !== null) {\n        if (!value) {\n          value = {};\n        }\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n  return value;\n}\nfunction getPropertyFromParameterPath(parent, parameterPath) {\n  var result = {\n    propertyFound: false\n  };\n  var i = 0;\n  for (; i < parameterPath.length; ++i) {\n    var parameterPathPart = parameterPath[i];\n    // Make sure to check inherited properties too, so don't use hasOwnProperty().\n    if (parent !== undefined && parent !== null && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n  return result;\n}\nexport function flattenResponse(_response, responseSpec) {\n  var parsedHeaders = _response.parsedHeaders;\n  var bodyMapper = responseSpec && responseSpec.bodyMapper;\n  var addOperationResponse = function (obj) {\n    return Object.defineProperty(obj, \"_response\", {\n      value: _response\n    });\n  };\n  if (bodyMapper) {\n    var typeName = bodyMapper.type.name;\n    if (typeName === \"Stream\") {\n      return addOperationResponse(__assign(__assign({}, parsedHeaders), {\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody\n      }));\n    }\n    var modelProperties_1 = typeName === \"Composite\" && bodyMapper.type.modelProperties || {};\n    var isPageableResponse = Object.keys(modelProperties_1).some(function (k) {\n      return modelProperties_1[k].serializedName === \"\";\n    });\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      var arrayResponse = __spreadArrays(_response.parsedBody || []);\n      for (var _i = 0, _a = Object.keys(modelProperties_1); _i < _a.length; _i++) {\n        var key = _a[_i];\n        if (modelProperties_1[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n      if (parsedHeaders) {\n        for (var _b = 0, _c = Object.keys(parsedHeaders); _b < _c.length; _b++) {\n          var key = _c[_b];\n          arrayResponse[key] = parsedHeaders[key];\n        }\n      }\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse(__assign(__assign({}, parsedHeaders), _response.parsedBody));\n    }\n  }\n  if (bodyMapper || _response.request.method === \"HEAD\" || utils.isPrimitiveType(_response.parsedBody)) {\n    // primitive body types and HEAD booleans\n    return addOperationResponse(__assign(__assign({}, parsedHeaders), {\n      body: _response.parsedBody\n    }));\n  }\n  return addOperationResponse(__assign(__assign({}, parsedHeaders), _response.parsedBody));\n}\nfunction getCredentialScopes(options, baseUri) {\n  if (options === null || options === void 0 ? void 0 : options.credentialScopes) {\n    var scopes = options.credentialScopes;\n    return Array.isArray(scopes) ? scopes.map(function (scope) {\n      return new URL(scope).toString();\n    }) : new URL(scopes).toString();\n  }\n  if (baseUri) {\n    return baseUri + \"/.default\";\n  }\n  return undefined;\n}","map":{"version":3,"sources":["../../src/serviceClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { HttpClient } from \"./httpClient\";\nimport { HttpOperationResponse, RestResponse } from \"./httpOperationResponse\";\nimport { HttpPipelineLogger } from \"./httpPipelineLogger\";\nimport { logPolicy, LogPolicyOptions } from \"./policies/logPolicy\";\nimport { OperationArguments } from \"./operationArguments\";\nimport {\n  getPathStringFromParameter,\n  getPathStringFromParameterPath,\n  OperationParameter,\n  ParameterPath\n} from \"./operationParameter\";\nimport { getStreamResponseStatusCodes, OperationSpec } from \"./operationSpec\";\nimport {\n  deserializationPolicy,\n  DeserializationContentTypes,\n  DefaultDeserializationOptions\n} from \"./policies/deserializationPolicy\";\nimport { exponentialRetryPolicy, DefaultRetryOptions } from \"./policies/exponentialRetryPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport {\n  userAgentPolicy,\n  getDefaultUserAgentHeaderName,\n  getDefaultUserAgentValue\n} from \"./policies/userAgentPolicy\";\nimport { redirectPolicy, DefaultRedirectOptions } from \"./policies/redirectPolicy\";\nimport {\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./policies/requestPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { bearerTokenAuthenticationPolicy } from \"./policies/bearerTokenAuthenticationPolicy\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { CompositeMapper, DictionaryMapper, Mapper, MapperType, Serializer } from \"./serializer\";\nimport { URLBuilder } from \"./url\";\nimport * as utils from \"./util/utils\";\nimport { stringifyXML } from \"./util/xml\";\nimport {\n  RequestOptionsBase,\n  RequestPrepareOptions,\n  WebResource,\n  WebResourceLike,\n  isWebResourceLike\n} from \"./webResource\";\nimport { OperationResponse } from \"./operationResponse\";\nimport { ServiceCallback, isNode } from \"./util/utils\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { ServiceClientCredentials } from \"./credentials/serviceClientCredentials\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { logger } from \"./log\";\nimport { InternalPipelineOptions } from \"./pipelineOptions\";\nimport { DefaultKeepAliveOptions, keepAlivePolicy } from \"./policies/keepAlivePolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\nimport { disableResponseDecompressionPolicy } from \"./policies/disableResponseDecompressionPolicy\";\nimport { ndJsonPolicy } from \"./policies/ndJsonPolicy\";\nimport { XML_ATTRKEY, SerializerOptions, XML_CHARKEY } from \"./util/serializer.common\";\nimport { URL } from \"./url\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\n\n/**\n * Options to configure a proxy for outgoing requests (Node.js only).\n */\nexport interface ProxySettings {\n  /**\n   * The proxy's host address.\n   */\n  host: string;\n\n  /**\n   * The proxy host's port.\n   */\n  port: number;\n\n  /**\n   * The user name to authenticate with the proxy, if required.\n   */\n  username?: string;\n\n  /**\n   * The password to authenticate with the proxy, if required.\n   */\n  password?: string;\n}\n\nexport type ProxyOptions = ProxySettings; // Alias ProxySettings as ProxyOptions for future use.\n\n/**\n * Options to be provided while creating the client.\n */\nexport interface ServiceClientOptions {\n  /**\n   * An array of factories which get called to create the RequestPolicy pipeline used to send a HTTP\n   * request on the wire, or a function that takes in the defaultRequestPolicyFactories and returns\n   * the requestPolicyFactories that will be used.\n   */\n  requestPolicyFactories?:\n    | RequestPolicyFactory[]\n    | ((defaultRequestPolicyFactories: RequestPolicyFactory[]) => void | RequestPolicyFactory[]);\n  /**\n   * The HttpClient that will be used to send HTTP requests.\n   */\n  httpClient?: HttpClient;\n  /**\n   * The HttpPipelineLogger that can be used to debug RequestPolicies within the HTTP pipeline.\n   */\n  httpPipelineLogger?: HttpPipelineLogger;\n  /**\n   * If set to true, turn off the default retry policy.\n   */\n  noRetryPolicy?: boolean;\n  /**\n   * Gets or sets the retry timeout in seconds for AutomaticRPRegistration. Default value is 30.\n   */\n  rpRegistrationRetryTimeout?: number;\n  /**\n   * Whether or not to generate a client request ID header for each HTTP request.\n   */\n  generateClientRequestIdHeader?: boolean;\n  /**\n   * Whether to include credentials in CORS requests in the browser.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials for more information.\n   */\n  withCredentials?: boolean;\n  /**\n   * If specified, a GenerateRequestIdPolicy will be added to the HTTP pipeline that will add a\n   * header to all outgoing requests with this header name and a random UUID as the request ID.\n   */\n  clientRequestIdHeaderName?: string;\n  /**\n   * The content-types that will be associated with JSON or XML serialization.\n   */\n  deserializationContentTypes?: DeserializationContentTypes;\n  /**\n   * The header name to use for the telemetry header while sending the request. If this is not\n   * specified, then \"User-Agent\" will be used when running on Node.js and \"x-ms-useragent\" will\n   * be used when running in a browser.\n   */\n  userAgentHeaderName?: string | ((defaultUserAgentHeaderName: string) => string);\n  /**\n   * The string to be set to the telemetry header while sending the request, or a function that\n   * takes in the default user-agent string and returns the user-agent string that will be used.\n   */\n  userAgent?: string | ((defaultUserAgent: string) => string);\n  /**\n   * Proxy settings which will be used for every HTTP request (Node.js only).\n   */\n  proxySettings?: ProxySettings;\n  /**\n   * If specified, will be used to build the BearerTokenAuthenticationPolicy.\n   */\n  credentialScopes?: string | string[];\n}\n\n/**\n * ServiceClient sends service requests and receives responses.\n */\nexport class ServiceClient {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   */\n  protected baseUri?: string;\n\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  protected requestContentType?: string;\n\n  /**\n   * The HTTP client that will be used to send requests.\n   */\n  private readonly _httpClient: HttpClient;\n  private readonly _requestPolicyOptions: RequestPolicyOptions;\n\n  private readonly _requestPolicyFactories: RequestPolicyFactory[];\n  private readonly _withCredentials: boolean;\n\n  /**\n   * The ServiceClient constructor\n   * @param credentials - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(\n    credentials?: TokenCredential | ServiceClientCredentials,\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */\n    options?: ServiceClientOptions\n  ) {\n    if (!options) {\n      options = {};\n    }\n\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n\n    let requestPolicyFactories: RequestPolicyFactory[];\n    if (Array.isArray(options.requestPolicyFactories)) {\n      logger.info(\"ServiceClient: using custom request policies\");\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      let authPolicyFactory: RequestPolicyFactory | undefined = undefined;\n      if (isTokenCredential(credentials)) {\n        logger.info(\n          \"ServiceClient: creating bearer token authentication policy from provided credentials\"\n        );\n        // Create a wrapped RequestPolicyFactory here so that we can provide the\n        // correct scope to the BearerTokenAuthenticationPolicy at the first time\n        // one is requested.  This is needed because generated ServiceClient\n        // implementations do not set baseUri until after ServiceClient's constructor\n        // is finished, leaving baseUri empty at the time when it is needed to\n        // build the correct scope name.\n        const wrappedPolicyFactory: () => RequestPolicyFactory = () => {\n          let bearerTokenPolicyFactory: RequestPolicyFactory | undefined = undefined;\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const serviceClient = this;\n          const serviceClientOptions = options;\n          return {\n            create(nextPolicy: RequestPolicy, createOptions: RequestPolicyOptions): RequestPolicy {\n              const credentialScopes = getCredentialScopes(\n                serviceClientOptions,\n                serviceClient.baseUri\n              );\n\n              if (!credentialScopes) {\n                throw new Error(\n                  `When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy`\n                );\n              }\n\n              if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) {\n                bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(\n                  credentials,\n                  credentialScopes\n                );\n              }\n\n              return bearerTokenPolicyFactory.create(nextPolicy, createOptions);\n            }\n          };\n        };\n\n        authPolicyFactory = wrappedPolicyFactory();\n      } else if (credentials && typeof credentials.signRequest === \"function\") {\n        logger.info(\"ServiceClient: creating signing policy from provided credentials\");\n        authPolicyFactory = signingPolicy(credentials);\n      } else if (credentials !== undefined && credentials !== null) {\n        throw new Error(\"The credentials argument must implement the TokenCredential interface\");\n      }\n\n      logger.info(\"ServiceClient: using default request policies\");\n      requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);\n      if (options.requestPolicyFactories) {\n        // options.requestPolicyFactories can also be a function that manipulates\n        // the default requestPolicyFactories array\n        const newRequestPolicyFactories:\n          | void\n          | RequestPolicyFactory[] = options.requestPolicyFactories(requestPolicyFactories);\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n\n  /**\n   * Send the provided httpRequest.\n   */\n  sendRequest(options: RequestPrepareOptions | WebResourceLike): Promise<HttpOperationResponse> {\n    if (options === null || options === undefined || typeof options !== \"object\") {\n      throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n    }\n\n    let httpRequest: WebResourceLike;\n    try {\n      if (isWebResourceLike(options)) {\n        options.validateRequestProperties();\n        httpRequest = options;\n      } else {\n        httpRequest = new WebResource();\n        httpRequest = httpRequest.prepare(options);\n      }\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    let httpPipeline: RequestPolicy = this._httpClient;\n    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n      for (let i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n        httpPipeline = this._requestPolicyFactories[i].create(\n          httpPipeline,\n          this._requestPolicyOptions\n        );\n      }\n    }\n    return httpPipeline.sendRequest(httpRequest);\n  }\n\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   * @param callback - The callback to call when the response is received.\n   */\n  async sendOperationRequest(\n    operationArguments: OperationArguments,\n    operationSpec: OperationSpec,\n    callback?: ServiceCallback<any>\n  ): Promise<RestResponse> {\n    if (typeof operationArguments.options === \"function\") {\n      callback = operationArguments.options;\n      operationArguments.options = undefined;\n    }\n\n    const serializerOptions = operationArguments.options?.serializerOptions;\n    const httpRequest: WebResourceLike = new WebResource();\n\n    let result: Promise<RestResponse>;\n    try {\n      const baseUri: string | undefined = operationSpec.baseUrl || this.baseUri;\n      if (!baseUri) {\n        throw new Error(\n          \"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\"\n        );\n      }\n\n      httpRequest.method = operationSpec.httpMethod;\n      httpRequest.operationSpec = operationSpec;\n\n      const requestUrl: URLBuilder = URLBuilder.parse(baseUri);\n      if (operationSpec.path) {\n        requestUrl.appendPath(operationSpec.path);\n      }\n      if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n        for (const urlParameter of operationSpec.urlParameters) {\n          let urlParameterValue: string = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            urlParameter,\n            operationSpec.serializer\n          );\n          urlParameterValue = operationSpec.serializer.serialize(\n            urlParameter.mapper,\n            urlParameterValue,\n            getPathStringFromParameter(urlParameter),\n            serializerOptions\n          );\n          if (!urlParameter.skipEncoding) {\n            urlParameterValue = encodeURIComponent(urlParameterValue);\n          }\n          requestUrl.replaceAll(\n            `{${urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)}}`,\n            urlParameterValue\n          );\n        }\n      }\n      if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {\n        for (const queryParameter of operationSpec.queryParameters) {\n          let queryParameterValue: any = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            queryParameter,\n            operationSpec.serializer\n          );\n          if (queryParameterValue !== undefined && queryParameterValue !== null) {\n            queryParameterValue = operationSpec.serializer.serialize(\n              queryParameter.mapper,\n              queryParameterValue,\n              getPathStringFromParameter(queryParameter),\n              serializerOptions\n            );\n            if (\n              queryParameter.collectionFormat !== undefined &&\n              queryParameter.collectionFormat !== null\n            ) {\n              if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {\n                if (queryParameterValue.length === 0) {\n                  // The collection is empty, no need to try serializing the current queryParam\n                  continue;\n                } else {\n                  for (const index in queryParameterValue) {\n                    const item = queryParameterValue[index];\n                    queryParameterValue[index] =\n                      item === undefined || item === null ? \"\" : item.toString();\n                  }\n                }\n              } else if (\n                queryParameter.collectionFormat === QueryCollectionFormat.Ssv ||\n                queryParameter.collectionFormat === QueryCollectionFormat.Tsv\n              ) {\n                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n              }\n            }\n            if (!queryParameter.skipEncoding) {\n              if (Array.isArray(queryParameterValue)) {\n                for (const index in queryParameterValue) {\n                  if (\n                    queryParameterValue[index] !== undefined &&\n                    queryParameterValue[index] !== null\n                  ) {\n                    queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);\n                  }\n                }\n              } else {\n                queryParameterValue = encodeURIComponent(queryParameterValue);\n              }\n            }\n            if (\n              queryParameter.collectionFormat !== undefined &&\n              queryParameter.collectionFormat !== null &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Multi &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Ssv &&\n              queryParameter.collectionFormat !== QueryCollectionFormat.Tsv\n            ) {\n              queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n            }\n            requestUrl.setQueryParameter(\n              queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter),\n              queryParameterValue\n            );\n          }\n        }\n      }\n      httpRequest.url = requestUrl.toString();\n\n      const contentType = operationSpec.contentType || this.requestContentType;\n      if (contentType && operationSpec.requestBody) {\n        httpRequest.headers.set(\"Content-Type\", contentType);\n      }\n\n      if (operationSpec.headerParameters) {\n        for (const headerParameter of operationSpec.headerParameters) {\n          let headerValue: any = getOperationArgumentValueFromParameter(\n            this,\n            operationArguments,\n            headerParameter,\n            operationSpec.serializer\n          );\n          if (headerValue !== undefined && headerValue !== null) {\n            headerValue = operationSpec.serializer.serialize(\n              headerParameter.mapper,\n              headerValue,\n              getPathStringFromParameter(headerParameter),\n              serializerOptions\n            );\n            const headerCollectionPrefix = (headerParameter.mapper as DictionaryMapper)\n              .headerCollectionPrefix;\n            if (headerCollectionPrefix) {\n              for (const key of Object.keys(headerValue)) {\n                httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n              }\n            } else {\n              httpRequest.headers.set(\n                headerParameter.mapper.serializedName ||\n                  getPathStringFromParameter(headerParameter),\n                headerValue\n              );\n            }\n          }\n        }\n      }\n\n      const options: RequestOptionsBase | undefined = operationArguments.options;\n      if (options) {\n        if (options.customHeaders) {\n          for (const customHeaderName in options.customHeaders) {\n            httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n          }\n        }\n\n        if (options.abortSignal) {\n          httpRequest.abortSignal = options.abortSignal;\n        }\n\n        if (options.timeout) {\n          httpRequest.timeout = options.timeout;\n        }\n\n        if (options.onUploadProgress) {\n          httpRequest.onUploadProgress = options.onUploadProgress;\n        }\n\n        if (options.onDownloadProgress) {\n          httpRequest.onDownloadProgress = options.onDownloadProgress;\n        }\n\n        if (options.spanOptions) {\n          httpRequest.spanOptions = options.spanOptions;\n        }\n\n        if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) {\n          httpRequest.shouldDeserialize = options.shouldDeserialize;\n        }\n      }\n\n      httpRequest.withCredentials = this._withCredentials;\n\n      serializeRequestBody(this, httpRequest, operationArguments, operationSpec);\n\n      if (httpRequest.streamResponseStatusCodes === undefined) {\n        httpRequest.streamResponseStatusCodes = getStreamResponseStatusCodes(operationSpec);\n      }\n\n      let rawResponse: HttpOperationResponse;\n      let sendRequestError;\n      try {\n        rawResponse = await this.sendRequest(httpRequest);\n      } catch (error) {\n        sendRequestError = error;\n      }\n      if (sendRequestError) {\n        if (sendRequestError.response) {\n          sendRequestError.details = flattenResponse(\n            sendRequestError.response,\n            operationSpec.responses[sendRequestError.statusCode] ||\n              operationSpec.responses[\"default\"]\n          );\n        }\n        result = Promise.reject(sendRequestError);\n      } else {\n        result = Promise.resolve(\n          flattenResponse(rawResponse!, operationSpec.responses[rawResponse!.status])\n        );\n      }\n    } catch (error) {\n      result = Promise.reject(error);\n    }\n\n    const cb = callback;\n    if (cb) {\n      result\n        .then((res) => cb(null, res._response.parsedBody, res._response.request, res._response))\n        .catch((err) => cb(err));\n    }\n\n    return result;\n  }\n}\n\nexport function serializeRequestBody(\n  serviceClient: ServiceClient,\n  httpRequest: WebResourceLike,\n  operationArguments: OperationArguments,\n  operationSpec: OperationSpec\n): void {\n  const serializerOptions = operationArguments.options?.serializerOptions ?? {};\n  const updatedOptions: Required<SerializerOptions> = {\n    rootName: serializerOptions.rootName ?? \"\",\n    includeRoot: serializerOptions.includeRoot ?? false,\n    xmlCharKey: serializerOptions.xmlCharKey ?? XML_CHARKEY\n  };\n\n  const xmlCharKey = serializerOptions.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(\n      serviceClient,\n      operationArguments,\n      operationSpec.requestBody,\n      operationSpec.serializer\n    );\n\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const {\n      required,\n      xmlName,\n      xmlElementName,\n      serializedName,\n      xmlNamespace,\n      xmlNamespacePrefix\n    } = bodyMapper;\n    const typeName = bodyMapper.type.name;\n\n    try {\n      if ((httpRequest.body !== undefined && httpRequest.body !== null) || required) {\n        const requestBodyParameterPathString: string = getPathStringFromParameter(\n          operationSpec.requestBody\n        );\n        httpRequest.body = operationSpec.serializer.serialize(\n          bodyMapper,\n          httpRequest.body,\n          requestBodyParameterPathString,\n          updatedOptions\n        );\n\n        const isStream = typeName === MapperType.Stream;\n\n        if (operationSpec.isXML) {\n          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n          const value = getXmlValueWithNamespace(\n            xmlNamespace,\n            xmlnsKey,\n            typeName,\n            httpRequest.body,\n            updatedOptions\n          );\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(\n              utils.prepareXMLRootList(\n                value,\n                xmlElementName || xmlName || serializedName!,\n                xmlnsKey,\n                xmlNamespace\n              ),\n              {\n                rootName: xmlName || serializedName,\n                xmlCharKey\n              }\n            );\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey\n            });\n          }\n        } else if (\n          typeName === MapperType.String &&\n          (operationSpec.contentType?.match(\"text/plain\") || operationSpec.mediaType === \"text\")\n        ) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(\n        `Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(\n          serializedName,\n          undefined,\n          \"  \"\n        )}.`\n      );\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue: any = getOperationArgumentValueFromParameter(\n        serviceClient,\n        operationArguments,\n        formDataParameter,\n        operationSpec.serializer\n      );\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName: string =\n          formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(\n          formDataParameter.mapper,\n          formDataParameterValue,\n          getPathStringFromParameter(formDataParameter),\n          updatedOptions\n        );\n      }\n    }\n  }\n}\n\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(\n  xmlNamespace: string | undefined,\n  xmlnsKey: string,\n  typeName: string,\n  serializedValue: any,\n  options: Required<SerializerOptions>\n): any {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    const result: any = {};\n    result[options.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };\n    return result;\n  }\n\n  return serializedValue;\n}\n\nfunction getValueOrFunctionResult(\n  value: undefined | string | ((defaultValue: string) => string),\n  defaultValueCreator: () => string\n): string {\n  let result: string;\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n  return result;\n}\n\nfunction createDefaultRequestPolicyFactories(\n  authPolicyFactory: RequestPolicyFactory | undefined,\n  options: ServiceClientOptions\n): RequestPolicyFactory[] {\n  const factories: RequestPolicyFactory[] = [];\n\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n\n  if (authPolicyFactory) {\n    factories.push(authPolicyFactory);\n  }\n\n  const userAgentHeaderName: string = getValueOrFunctionResult(\n    options.userAgentHeaderName,\n    getDefaultUserAgentHeaderName\n  );\n  const userAgentHeaderValue: string = getValueOrFunctionResult(\n    options.userAgent,\n    getDefaultUserAgentValue\n  );\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({ key: userAgentHeaderName, value: userAgentHeaderValue }));\n  }\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n\n  if (isNode) {\n    factories.push(proxyPolicy(options.proxySettings));\n  }\n\n  factories.push(logPolicy({ logger: logger.info }));\n\n  return factories;\n}\n\nexport function createPipelineFromOptions(\n  pipelineOptions: InternalPipelineOptions,\n  authPolicyFactory?: RequestPolicyFactory\n): ServiceClientOptions {\n  const requestPolicyFactories: RequestPolicyFactory[] = [];\n\n  if (pipelineOptions.sendStreamingJson) {\n    requestPolicyFactories.push(ndJsonPolicy());\n  }\n\n  let userAgentValue = undefined;\n  if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {\n    const userAgentInfo: string[] = [];\n    userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);\n\n    // Add the default user agent value if it isn't already specified\n    // by the userAgentPrefix option.\n    const defaultUserAgentInfo = getDefaultUserAgentValue();\n    if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) {\n      userAgentInfo.push(defaultUserAgentInfo);\n    }\n\n    userAgentValue = userAgentInfo.join(\" \");\n  }\n\n  const keepAliveOptions = {\n    ...DefaultKeepAliveOptions,\n    ...pipelineOptions.keepAliveOptions\n  };\n\n  const retryOptions = {\n    ...DefaultRetryOptions,\n    ...pipelineOptions.retryOptions\n  };\n\n  const redirectOptions = {\n    ...DefaultRedirectOptions,\n    ...pipelineOptions.redirectOptions\n  };\n\n  if (isNode) {\n    requestPolicyFactories.push(proxyPolicy(pipelineOptions.proxyOptions));\n  }\n\n  const deserializationOptions = {\n    ...DefaultDeserializationOptions,\n    ...pipelineOptions.deserializationOptions\n  };\n\n  const loggingOptions: LogPolicyOptions = {\n    ...pipelineOptions.loggingOptions\n  };\n\n  requestPolicyFactories.push(\n    tracingPolicy({ userAgent: userAgentValue }),\n    keepAlivePolicy(keepAliveOptions),\n    userAgentPolicy({ value: userAgentValue }),\n    generateClientRequestIdPolicy(),\n    deserializationPolicy(deserializationOptions.expectedContentTypes),\n    throttlingRetryPolicy(),\n    systemErrorRetryPolicy(),\n    exponentialRetryPolicy(\n      retryOptions.maxRetries,\n      retryOptions.retryDelayInMs,\n      retryOptions.maxRetryDelayInMs\n    )\n  );\n\n  if (redirectOptions.handleRedirects) {\n    requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));\n  }\n\n  if (authPolicyFactory) {\n    requestPolicyFactories.push(authPolicyFactory);\n  }\n\n  requestPolicyFactories.push(logPolicy(loggingOptions));\n\n  if (isNode && pipelineOptions.decompressResponse === false) {\n    requestPolicyFactories.push(disableResponseDecompressionPolicy());\n  }\n\n  return {\n    httpClient: pipelineOptions.httpClient,\n    requestPolicyFactories\n  };\n}\n\nexport type PropertyParent = { [propertyName: string]: any };\n\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\nexport function getPropertyParent(parent: PropertyParent, propertyPath: string[]): PropertyParent {\n  if (parent && propertyPath) {\n    const propertyPathLength: number = propertyPath.length;\n    for (let i = 0; i < propertyPathLength - 1; ++i) {\n      const propertyName: string = propertyPath[i];\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n      parent = parent[propertyName];\n    }\n  }\n  return parent;\n}\n\nfunction getOperationArgumentValueFromParameter(\n  serviceClient: ServiceClient,\n  operationArguments: OperationArguments,\n  parameter: OperationParameter,\n  serializer: Serializer\n): any {\n  return getOperationArgumentValueFromParameterPath(\n    serviceClient,\n    operationArguments,\n    parameter.parameterPath,\n    parameter.mapper,\n    serializer\n  );\n}\n\nexport function getOperationArgumentValueFromParameterPath(\n  serviceClient: ServiceClient,\n  operationArguments: OperationArguments,\n  parameterPath: ParameterPath,\n  parameterMapper: Mapper,\n  serializer: Serializer\n): any {\n  let value: any;\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n  const serializerOptions = operationArguments.options?.serializerOptions;\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        let propertySearchResult: PropertySearchResult = getPropertyFromParameterPath(\n          operationArguments,\n          parameterPath\n        );\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n\n        let useDefaultValue = false;\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue =\n            parameterMapper.required ||\n            (parameterPath[0] === \"options\" && parameterPath.length === 2);\n        }\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      }\n\n      // Serialize just for validation purposes.\n      const parameterPathString: string = getPathStringFromParameterPath(\n        parameterPath,\n        parameterMapper\n      );\n      serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n\n    for (const propertyName in parameterPath) {\n      const propertyMapper: Mapper = (parameterMapper as CompositeMapper).type.modelProperties![\n        propertyName\n      ];\n      const propertyPath: ParameterPath = parameterPath[propertyName];\n      const propertyValue: any = getOperationArgumentValueFromParameterPath(\n        serviceClient,\n        operationArguments,\n        propertyPath,\n        propertyMapper,\n        serializer\n      );\n      // Serialize just for validation purposes.\n      const propertyPathString: string = getPathStringFromParameterPath(\n        propertyPath,\n        propertyMapper\n      );\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);\n      if (propertyValue !== undefined && propertyValue !== null) {\n        if (!value) {\n          value = {};\n        }\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n  return value;\n}\n\ninterface PropertySearchResult {\n  propertyValue?: any;\n  propertyFound: boolean;\n}\n\nfunction getPropertyFromParameterPath(\n  parent: { [parameterName: string]: any },\n  parameterPath: string[]\n): PropertySearchResult {\n  const result: PropertySearchResult = { propertyFound: false };\n  let i = 0;\n  for (; i < parameterPath.length; ++i) {\n    const parameterPathPart: string = parameterPath[i];\n    // Make sure to check inherited properties too, so don't use hasOwnProperty().\n    if (parent !== undefined && parent !== null && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n  return result;\n}\n\nexport function flattenResponse(\n  _response: HttpOperationResponse,\n  responseSpec: OperationResponse | undefined\n): RestResponse {\n  const parsedHeaders = _response.parsedHeaders;\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n\n  const addOperationResponse = (\n    obj: Record<string, unknown>\n  ): {\n    _response: HttpOperationResponse;\n  } => {\n    return Object.defineProperty(obj, \"_response\", {\n      value: _response\n    });\n  };\n\n  if (bodyMapper) {\n    const typeName = bodyMapper.type.name;\n    if (typeName === \"Stream\") {\n      return addOperationResponse({\n        ...parsedHeaders,\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody\n      });\n    }\n\n    const modelProperties =\n      (typeName === \"Composite\" && (bodyMapper as CompositeMapper).type.modelProperties) || {};\n    const isPageableResponse = Object.keys(modelProperties).some(\n      (k) => modelProperties[k].serializedName === \"\"\n    );\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      const arrayResponse = [...(_response.parsedBody || [])] as RestResponse & any[];\n\n      for (const key of Object.keys(modelProperties)) {\n        if (modelProperties[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n\n      if (parsedHeaders) {\n        for (const key of Object.keys(parsedHeaders)) {\n          arrayResponse[key] = parsedHeaders[key];\n        }\n      }\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse({\n        ...parsedHeaders,\n        ..._response.parsedBody\n      });\n    }\n  }\n\n  if (\n    bodyMapper ||\n    _response.request.method === \"HEAD\" ||\n    utils.isPrimitiveType(_response.parsedBody)\n  ) {\n    // primitive body types and HEAD booleans\n    return addOperationResponse({\n      ...parsedHeaders,\n      body: _response.parsedBody\n    });\n  }\n\n  return addOperationResponse({\n    ...parsedHeaders,\n    ..._response.parsedBody\n  });\n}\n\nfunction getCredentialScopes(\n  options?: ServiceClientOptions,\n  baseUri?: string\n): string | string[] | undefined {\n  if (options?.credentialScopes) {\n    const scopes = options.credentialScopes;\n    return Array.isArray(scopes)\n      ? scopes.map((scope) => new URL(scope).toString())\n      : new URL(scopes).toString();\n  }\n\n  if (baseUri) {\n    return `${baseUri}/.default`;\n  }\n  return undefined;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}