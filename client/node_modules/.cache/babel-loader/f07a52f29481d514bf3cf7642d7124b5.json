{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __awaiter, __extends, __generator } from \"tslib\";\nimport { BaseRequestPolicy } from \"../policies/requestPolicy\";\nimport { Constants } from \"../util/constants\";\nimport { HttpHeaders } from \"../httpHeaders\";\nimport { ExpiringAccessTokenCache } from \"../credentials/accessTokenCache\";\nimport { AccessTokenRefresher } from \"../credentials/accessTokenRefresher\";\n/**\n * The automated token refresh will only start to happen at the\n * expiration date minus the value of timeBetweenRefreshAttemptsInMs,\n * which is by default 30 seconds.\n */\nvar timeBetweenRefreshAttemptsInMs = 30000;\n/**\n * Creates a new BearerTokenAuthenticationPolicy factory.\n *\n * @param credential - The TokenCredential implementation that can supply the bearer token.\n * @param scopes - The scopes for which the bearer token applies.\n */\nexport function bearerTokenAuthenticationPolicy(credential, scopes) {\n  var tokenCache = new ExpiringAccessTokenCache();\n  var tokenRefresher = new AccessTokenRefresher(credential, scopes, timeBetweenRefreshAttemptsInMs);\n  return {\n    create: function (nextPolicy, options) {\n      return new BearerTokenAuthenticationPolicy(nextPolicy, options, tokenCache, tokenRefresher);\n    }\n  };\n}\n/**\n *\n * Provides a RequestPolicy that can request a token from a TokenCredential\n * implementation and then apply it to the Authorization header of a request\n * as a Bearer token.\n *\n */\nvar BearerTokenAuthenticationPolicy = /** @class */function (_super) {\n  __extends(BearerTokenAuthenticationPolicy, _super);\n  /**\n   * Creates a new BearerTokenAuthenticationPolicy object.\n   *\n   * @param nextPolicy - The next RequestPolicy in the request pipeline.\n   * @param options - Options for this RequestPolicy.\n   * @param credential - The TokenCredential implementation that can supply the bearer token.\n   * @param scopes - The scopes for which the bearer token applies.\n   * @param tokenCache - The cache for the most recent AccessToken returned from the TokenCredential.\n   */\n  function BearerTokenAuthenticationPolicy(nextPolicy, options, tokenCache, tokenRefresher) {\n    var _this = _super.call(this, nextPolicy, options) || this;\n    _this.tokenCache = tokenCache;\n    _this.tokenRefresher = tokenRefresher;\n    return _this;\n  }\n  /**\n   * Applies the Bearer token to the request through the Authorization header.\n   */\n  BearerTokenAuthenticationPolicy.prototype.sendRequest = function (webResource) {\n    return __awaiter(this, void 0, void 0, function () {\n      var token;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!webResource.headers) webResource.headers = new HttpHeaders();\n            return [4 /*yield*/, this.getToken({\n              abortSignal: webResource.abortSignal,\n              tracingOptions: {\n                spanOptions: webResource.spanOptions\n              }\n            })];\n          case 1:\n            token = _a.sent();\n            webResource.headers.set(Constants.HeaderConstants.AUTHORIZATION, \"Bearer \" + token);\n            return [2 /*return*/, this._nextPolicy.sendRequest(webResource)];\n        }\n      });\n    });\n  };\n  /**\n   * Attempts a token update if any other time related conditionals have been reached based on the tokenRefresher class.\n   */\n  BearerTokenAuthenticationPolicy.prototype.updateTokenIfNeeded = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var accessToken;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.tokenRefresher.isReady()) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.tokenRefresher.refresh(options)];\n          case 1:\n            accessToken = _a.sent();\n            this.tokenCache.setCachedToken(accessToken);\n            _a.label = 2;\n          case 2:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  BearerTokenAuthenticationPolicy.prototype.getToken = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var accessToken;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            accessToken = this.tokenCache.getCachedToken();\n            if (!(accessToken === undefined)) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.tokenRefresher.refresh(options)];\n          case 1:\n            // Waiting for the next refresh only if the cache is unable to retrieve the access token,\n            // which means that it has expired, or it has never been set.\n            accessToken = _a.sent();\n            this.tokenCache.setCachedToken(accessToken);\n            return [3 /*break*/, 3];\n          case 2:\n            // If we still have a cached access token,\n            // And any other time related conditionals have been reached based on the tokenRefresher class,\n            // then attempt to refresh without waiting.\n            this.updateTokenIfNeeded(options);\n            _a.label = 3;\n          case 3:\n            return [2 /*return*/, accessToken ? accessToken.token : undefined];\n        }\n      });\n    });\n  };\n  return BearerTokenAuthenticationPolicy;\n}(BaseRequestPolicy);\nexport { BearerTokenAuthenticationPolicy };","map":{"version":3,"sources":["../../../src/policies/bearerTokenAuthenticationPolicy.ts"],"names":[],"mappings":"AAAA;AACA;;AAGA,SACE,iBAAiB,QAIZ,2BAA2B;AAClC,SAAS,SAAS,QAAQ,mBAAmB;AAE7C,SAAS,WAAW,QAAQ,gBAAgB;AAE5C,SAA2B,wBAAwB,QAAQ,iCAAiC;AAC5F,SAAS,oBAAoB,QAAQ,qCAAqC;AAE1E;;;;AAIG;AACH,IAAM,8BAA8B,GAAG,KAAK;AAE5C;;;;;AAKG;AACH,OAAM,SAAU,+BAA+B,CAC7C,UAA2B,EAC3B,MAAyB,EAAA;EAEzB,IAAM,UAAU,GAAqB,IAAI,wBAAwB,CAAA,CAAE;EACnE,IAAM,cAAc,GAAG,IAAI,oBAAoB,CAC7C,UAAU,EACV,MAAM,EACN,8BAA8B,CAC/B;EAED,OAAO;IACL,MAAM,EAAE,SAAA,CAAC,UAAyB,EAAE,OAA6B,EAAA;MAC/D,OAAO,IAAI,+BAA+B,CAAC,UAAU,EAAE,OAAO,EAAE,UAAU,EAAE,cAAc,CAAC;IAC7F;GACD;AACH;AAEA;;;;;;AAMG;AACH,IAAA,+BAAA,GAAA,aAAA,UAAA,MAAA,EAAA;EAAqD,SAAA,CAAA,+BAAA,EAAA,MAAA,CAAA;EACnD;;;;;;;;AAQG;EACH,SAAA,+BAAA,CACE,UAAyB,EACzB,OAA6B,EACrB,UAA4B,EAC5B,cAAoC,EAAA;IAJ9C,IAAA,KAAA,GAME,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,UAAU,EAAE,OAAO,CAAC,IAAA,IAAA;IAHlB,KAAA,CAAA,UAAU,GAAV,UAAU;IACV,KAAA,CAAA,cAAc,GAAd,cAAc;;EAGxB;EAEA;;AAEG;EACU,+BAAA,CAAA,SAAA,CAAA,WAAW,GAAxB,UAAyB,WAA4B,EAAA;;;;;;YACnD,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,WAAW,CAAC,OAAO,GAAG,IAAI,WAAW,CAAA,CAAE;YACnD,OAAA,CAAA,CAAA,CAAA,WAAM,IAAI,CAAC,QAAQ,CAAC;cAChC,WAAW,EAAE,WAAW,CAAC,WAAW;cACpC,cAAc,EAAE;gBACd,WAAW,EAAE,WAAW,CAAC;cAC1B;aACF,CAAC,CAAA;;YALI,KAAK,GAAG,EAAA,CAAA,IAAA,CAAA,CAKZ;YACF,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,eAAe,CAAC,aAAa,EAAE,SAAA,GAAU,KAAO,CAAC;YACnF,OAAA,CAAA,CAAA,CAAA,YAAO,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,WAAW,CAAC,CAAA;;;;GACjD;EAED;;AAEG;EACW,+BAAA,CAAA,SAAA,CAAA,mBAAmB,GAAjC,UAAkC,OAAwB,EAAA;;;;;;iBACpD,IAAI,CAAC,cAAc,CAAC,OAAO,CAAA,CAAE,EAA7B,OAAA,CAAA,CAAA,CAAA,WAAA,CAAA,CAAA;YACkB,OAAA,CAAA,CAAA,CAAA,WAAM,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,OAAO,CAAC,CAAA;;YAAxD,WAAW,GAAG,EAAA,CAAA,IAAA,CAAA,CAA0C;YAC9D,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,WAAW,CAAC;;;;;;;GAE9C;EAEa,+BAAA,CAAA,SAAA,CAAA,QAAQ,GAAtB,UAAuB,OAAwB,EAAA;;;;;;YACzC,WAAW,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAA,CAAE;gBAC9C,EAAA,WAAW,KAAK,SAAS,CAAA,EAAzB,OAAA,CAAA,CAAA,CAAA,WAAA,CAAA,CAAA;YAGY,OAAA,CAAA,CAAA,CAAA,WAAM,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,OAAO,CAAC,CAAA;;YAFxD;YACA;YACA,WAAW,GAAG,EAAA,CAAA,IAAA,CAAA,CAA0C;YACxD,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,WAAW,CAAC;;;YAE3C;YACA;YACA;YACA,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC;;;YAGnC,OAAA,CAAA,CAAA,CAAA,YAAO,WAAW,GAAG,WAAW,CAAC,KAAK,GAAG,SAAS,CAAA;;;;GACnD;EACH,OAAA,+BAAC;AAAD,CAAC,CA5DoD,iBAAiB,CAAA","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TokenCredential, GetTokenOptions } from \"@azure/core-auth\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyOptions,\n  RequestPolicyFactory\n} from \"../policies/requestPolicy\";\nimport { Constants } from \"../util/constants\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { HttpHeaders } from \"../httpHeaders\";\nimport { WebResourceLike } from \"../webResource\";\nimport { AccessTokenCache, ExpiringAccessTokenCache } from \"../credentials/accessTokenCache\";\nimport { AccessTokenRefresher } from \"../credentials/accessTokenRefresher\";\n\n/**\n * The automated token refresh will only start to happen at the\n * expiration date minus the value of timeBetweenRefreshAttemptsInMs,\n * which is by default 30 seconds.\n */\nconst timeBetweenRefreshAttemptsInMs = 30000;\n\n/**\n * Creates a new BearerTokenAuthenticationPolicy factory.\n *\n * @param credential - The TokenCredential implementation that can supply the bearer token.\n * @param scopes - The scopes for which the bearer token applies.\n */\nexport function bearerTokenAuthenticationPolicy(\n  credential: TokenCredential,\n  scopes: string | string[]\n): RequestPolicyFactory {\n  const tokenCache: AccessTokenCache = new ExpiringAccessTokenCache();\n  const tokenRefresher = new AccessTokenRefresher(\n    credential,\n    scopes,\n    timeBetweenRefreshAttemptsInMs\n  );\n\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new BearerTokenAuthenticationPolicy(nextPolicy, options, tokenCache, tokenRefresher);\n    }\n  };\n}\n\n/**\n *\n * Provides a RequestPolicy that can request a token from a TokenCredential\n * implementation and then apply it to the Authorization header of a request\n * as a Bearer token.\n *\n */\nexport class BearerTokenAuthenticationPolicy extends BaseRequestPolicy {\n  /**\n   * Creates a new BearerTokenAuthenticationPolicy object.\n   *\n   * @param nextPolicy - The next RequestPolicy in the request pipeline.\n   * @param options - Options for this RequestPolicy.\n   * @param credential - The TokenCredential implementation that can supply the bearer token.\n   * @param scopes - The scopes for which the bearer token applies.\n   * @param tokenCache - The cache for the most recent AccessToken returned from the TokenCredential.\n   */\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    private tokenCache: AccessTokenCache,\n    private tokenRefresher: AccessTokenRefresher\n  ) {\n    super(nextPolicy, options);\n  }\n\n  /**\n   * Applies the Bearer token to the request through the Authorization header.\n   */\n  public async sendRequest(webResource: WebResourceLike): Promise<HttpOperationResponse> {\n    if (!webResource.headers) webResource.headers = new HttpHeaders();\n    const token = await this.getToken({\n      abortSignal: webResource.abortSignal,\n      tracingOptions: {\n        spanOptions: webResource.spanOptions\n      }\n    });\n    webResource.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${token}`);\n    return this._nextPolicy.sendRequest(webResource);\n  }\n\n  /**\n   * Attempts a token update if any other time related conditionals have been reached based on the tokenRefresher class.\n   */\n  private async updateTokenIfNeeded(options: GetTokenOptions): Promise<void> {\n    if (this.tokenRefresher.isReady()) {\n      const accessToken = await this.tokenRefresher.refresh(options);\n      this.tokenCache.setCachedToken(accessToken);\n    }\n  }\n\n  private async getToken(options: GetTokenOptions): Promise<string | undefined> {\n    let accessToken = this.tokenCache.getCachedToken();\n    if (accessToken === undefined) {\n      // Waiting for the next refresh only if the cache is unable to retrieve the access token,\n      // which means that it has expired, or it has never been set.\n      accessToken = await this.tokenRefresher.refresh(options);\n      this.tokenCache.setCachedToken(accessToken);\n    } else {\n      // If we still have a cached access token,\n      // And any other time related conditionals have been reached based on the tokenRefresher class,\n      // then attempt to refresh without waiting.\n      this.updateTokenIfNeeded(options);\n    }\n\n    return accessToken ? accessToken.token : undefined;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}