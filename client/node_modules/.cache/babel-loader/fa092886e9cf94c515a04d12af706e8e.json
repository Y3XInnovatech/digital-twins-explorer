{"ast":null,"code":"import * as React from 'react';\n/**\n * Creates a ref, and calls a callback whenever the ref changes to a non-null value. The callback can optionally return\n * a cleanup function that'll be called before the value changes, and when the ref is unmounted.\n *\n * This can be used to work around a limitation that useEffect cannot depend on `ref.current` (see\n * https://github.com/facebook/react/issues/14387#issuecomment-503616820).\n *\n * Usage example:\n * ```ts\n * const myRef = useRefEffect<HTMLElement>(element => {\n *  ...\n *  return () => { ... cleanup ... };\n * });\n * ```\n * ```jsx\n * <div ref={myRef} />\n * ```\n *\n * @param callback - Called whenever the ref's value changes to non-null. Can optionally return a cleanup function.\n * @param initial - (Optional) The initial value for the ref.\n *\n * @returns A function that should be called to set the ref's value. The object also has a `.current` member that can be\n * used to access the ref's value (like a normal RefObject). It can be hooked up to an element's `ref` property.\n */\nexport function useRefEffect(callback, initial) {\n  if (initial === void 0) {\n    initial = null;\n  }\n  var data = React.useRef({\n    ref: Object.assign(function (value) {\n      if (data.ref.current !== value) {\n        if (data.cleanup) {\n          data.cleanup();\n          data.cleanup = undefined;\n        }\n        data.ref.current = value;\n        if (value !== null) {\n          data.cleanup = data.callback(value);\n        }\n      }\n    }, {\n      current: initial\n    }),\n    callback: callback\n  }).current;\n  data.callback = callback;\n  return data.ref;\n}","map":{"version":3,"sources":["useRefEffect.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,MAAM,OAAO;AAO9B;;;;;;;;;;;;;;;;;;;;;;;AAuBG;AACH,OAAM,SAAU,YAAY,CAAI,QAA2C,EAAE,OAAwB,EAAA;EAAxB,IAAA,OAAA,KAAA,KAAA,CAAA,EAAA;IAAA,OAAA,GAAA,IAAwB;EAAA;EAOnG,IAAM,IAAI,GAAG,KAAK,CAAC,MAAM,CAAU;IACjC,GAAG,EAAE,MAAM,CAAC,MAAM,CAChB,UAAC,KAAe,EAAA;MACd,IAAI,IAAI,CAAC,GAAG,CAAC,OAAO,KAAK,KAAK,EAAE;QAC9B,IAAI,IAAI,CAAC,OAAO,EAAE;UAChB,IAAI,CAAC,OAAO,CAAA,CAAE;UACd,IAAI,CAAC,OAAO,GAAG,SAAS;QACzB;QAED,IAAI,CAAC,GAAG,CAAC,OAAO,GAAG,KAAK;QAExB,IAAI,KAAK,KAAK,IAAI,EAAE;UAClB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC;QACpC;MACF;IACH,CAAC,EACD;MACE,OAAO,EAAE;KACV,CACF;IACD,QAAQ,EAAA;GACT,CAAC,CAAC,OAAO;EAEV,IAAI,CAAC,QAAQ,GAAG,QAAQ;EAExB,OAAO,IAAI,CAAC,GAAG;AACjB","sourcesContent":["import * as React from 'react';\r\n\r\n/**\r\n * A callback ref function that also has a .current member for the ref's current value.\r\n */\r\nexport type RefCallback<T> = ((value: T | null) => void) & React.RefObject<T>;\r\n\r\n/**\r\n * Creates a ref, and calls a callback whenever the ref changes to a non-null value. The callback can optionally return\r\n * a cleanup function that'll be called before the value changes, and when the ref is unmounted.\r\n *\r\n * This can be used to work around a limitation that useEffect cannot depend on `ref.current` (see\r\n * https://github.com/facebook/react/issues/14387#issuecomment-503616820).\r\n *\r\n * Usage example:\r\n * ```ts\r\n * const myRef = useRefEffect<HTMLElement>(element => {\r\n *  ...\r\n *  return () => { ... cleanup ... };\r\n * });\r\n * ```\r\n * ```jsx\r\n * <div ref={myRef} />\r\n * ```\r\n *\r\n * @param callback - Called whenever the ref's value changes to non-null. Can optionally return a cleanup function.\r\n * @param initial - (Optional) The initial value for the ref.\r\n *\r\n * @returns A function that should be called to set the ref's value. The object also has a `.current` member that can be\r\n * used to access the ref's value (like a normal RefObject). It can be hooked up to an element's `ref` property.\r\n */\r\nexport function useRefEffect<T>(callback: (value: T) => (() => void) | void, initial: T | null = null): RefCallback<T> {\r\n  type RefData = {\r\n    ref: ((value: T | null) => void) & React.MutableRefObject<T | null>;\r\n    callback: (value: T) => (() => void) | void;\r\n    cleanup?: (() => void) | void;\r\n  };\r\n\r\n  const data = React.useRef<RefData>({\r\n    ref: Object.assign(\r\n      (value: T | null) => {\r\n        if (data.ref.current !== value) {\r\n          if (data.cleanup) {\r\n            data.cleanup();\r\n            data.cleanup = undefined;\r\n          }\r\n\r\n          data.ref.current = value;\r\n\r\n          if (value !== null) {\r\n            data.cleanup = data.callback(value);\r\n          }\r\n        }\r\n      },\r\n      {\r\n        current: initial,\r\n      },\r\n    ),\r\n    callback,\r\n  }).current;\r\n\r\n  data.callback = callback;\r\n\r\n  return data.ref;\r\n}\r\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}