{"ast":null,"code":"/**\n * Determines the distance between two points.\n *\n * @public\n */\n/* eslint-disable deprecation/deprecation */\nexport function getDistanceBetweenPoints(point1, point2) {\n  var left1 = point1.left || point1.x || 0;\n  var top1 = point1.top || point1.y || 0;\n  var left2 = point2.left || point2.x || 0;\n  var top2 = point2.top || point2.y || 0;\n  /* eslint-enable deprecation/deprecation */\n  var distance = Math.sqrt(Math.pow(left1 - left2, 2) + Math.pow(top1 - top2, 2));\n  return distance;\n}\n/**\n * Produces a proportionally-scaled version of an input content size when fit to a bounding size.\n * Given a `contentSize` and a `boundsSize`, this function scales `contentSize` proportionally\n * using either `contain` or `cover` fit behaviors.\n * Use this function to pre-calculate the layout for the CSS `object-fit` and `background-fit` behaviors.\n * With `contain`, the output size must be the largest it can be while completely within the `boundsSize`.\n * With `cover`, the output size must be the smallest it can be while completely around the `boundsSize`.\n * By default, there is a `maxScale` value of 1, which prevents the `contentSize` from being scaled larger.\n *\n * @param options - the options for the bounds fit operation\n */\nexport function fitContentToBounds(options) {\n  var contentSize = options.contentSize,\n    boundsSize = options.boundsSize,\n    _a = options.mode,\n    mode = _a === void 0 ? 'contain' : _a,\n    _b = options.maxScale,\n    maxScale = _b === void 0 ? 1 : _b;\n  var contentAspectRatio = contentSize.width / contentSize.height;\n  var boundsAspectRatio = boundsSize.width / boundsSize.height;\n  var scale;\n  if (mode === 'contain' ? contentAspectRatio > boundsAspectRatio : contentAspectRatio < boundsAspectRatio) {\n    scale = boundsSize.width / contentSize.width;\n  } else {\n    scale = boundsSize.height / contentSize.height;\n  }\n  var finalScale = Math.min(maxScale, scale);\n  return {\n    width: contentSize.width * finalScale,\n    height: contentSize.height * finalScale\n  };\n}\n/**\n * Calculates a number's precision based on the number of trailing\n * zeros if the number does not have a decimal indicated by a negative\n * precision. Otherwise, it calculates the number of digits after\n * the decimal point indicated by a positive precision.\n * @param value - the value to determine the precision of\n */\nexport function calculatePrecision(value) {\n  /**\n   * Group 1:\n   * [1-9]([0]+$) matches trailing zeros\n   * Group 2:\n   * \\.([0-9]*) matches all digits after a decimal point.\n   */\n  var groups = /[1-9]([0]+$)|\\.([0-9]*)/.exec(String(value));\n  if (!groups) {\n    return 0;\n  }\n  if (groups[1]) {\n    return -groups[1].length;\n  }\n  if (groups[2]) {\n    return groups[2].length;\n  }\n  return 0;\n}\n/**\n * Rounds a number to a certain level of precision. Accepts negative precision.\n * @param value - The value that is being rounded.\n * @param precision - The number of decimal places to round the number to\n */\nexport function precisionRound(value, precision, base) {\n  if (base === void 0) {\n    base = 10;\n  }\n  var exp = Math.pow(base, precision);\n  return Math.round(value * exp) / exp;\n}","map":{"version":3,"sources":["math.ts"],"names":[],"mappings":"AAGA;;;;AAIG;AACH;AACA,OAAM,SAAU,wBAAwB,CAAC,MAAa,EAAE,MAAa,EAAA;EACnE,IAAM,KAAK,GAAG,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC,CAAC,IAAI,CAAC;EAC1C,IAAM,IAAI,GAAG,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,CAAC,IAAI,CAAC;EACxC,IAAM,KAAK,GAAG,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC,CAAC,IAAI,CAAC;EAC1C,IAAM,IAAI,GAAG,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,CAAC,IAAI,CAAC;EACxC;EAEA,IAAI,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,KAAK,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,IAAI,EAAE,CAAC,CAAC,CAAC;EAE/E,OAAO,QAAQ;AACjB;AA+BA;;;;;;;;;;AAUG;AACH,OAAM,SAAU,kBAAkB,CAAC,OAAmC,EAAA;EAC5D,IAAA,WAAA,GAAA,OAAA,CAAA,WAAW;IAAE,UAAA,GAAA,OAAA,CAAA,UAAU;IAAE,EAAA,GAAA,OAAA,CAAA,IAAgB;IAAhB,IAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,SAAA,GAAA,EAAgB;IAAE,EAAA,GAAA,OAAA,CAAA,QAAY;IAAZ,QAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,CAAA,GAAA,EAAY;EAE/D,IAAM,kBAAkB,GAAG,WAAW,CAAC,KAAK,GAAG,WAAW,CAAC,MAAM;EACjE,IAAM,iBAAiB,GAAG,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,MAAM;EAE9D,IAAI,KAAa;EAEjB,IAAI,IAAI,KAAK,SAAS,GAAG,kBAAkB,GAAG,iBAAiB,GAAG,kBAAkB,GAAG,iBAAiB,EAAE;IACxG,KAAK,GAAG,UAAU,CAAC,KAAK,GAAG,WAAW,CAAC,KAAK;GAC7C,MAAM;IACL,KAAK,GAAG,UAAU,CAAC,MAAM,GAAG,WAAW,CAAC,MAAM;EAC/C;EAED,IAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,KAAK,CAAC;EAE5C,OAAO;IACL,KAAK,EAAE,WAAW,CAAC,KAAK,GAAG,UAAU;IACrC,MAAM,EAAE,WAAW,CAAC,MAAM,GAAG;GAC9B;AACH;AAEA;;;;;;AAMG;AACH,OAAM,SAAU,kBAAkB,CAAC,KAAsB,EAAA;EACvD;;;;;AAKG;EACH,IAAM,MAAM,GAAG,yBAAyB,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;EAC5D,IAAI,CAAC,MAAM,EAAE;IACX,OAAO,CAAC;EACT;EACD,IAAI,MAAM,CAAC,CAAC,CAAC,EAAE;IACb,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM;EACzB;EACD,IAAI,MAAM,CAAC,CAAC,CAAC,EAAE;IACb,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM;EACxB;EACD,OAAO,CAAC;AACV;AAEA;;;;AAIG;AACH,OAAM,SAAU,cAAc,CAAC,KAAa,EAAE,SAAiB,EAAE,IAAiB,EAAA;EAAjB,IAAA,IAAA,KAAA,KAAA,CAAA,EAAA;IAAA,IAAA,GAAA,EAAiB;EAAA;EAChF,IAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,SAAS,CAAC;EACrC,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,GAAG,CAAC,GAAG,GAAG;AACtC","sourcesContent":["import { Point } from './Point';\nimport { ISize } from './ISize';\n\n/**\n * Determines the distance between two points.\n *\n * @public\n */\n/* eslint-disable deprecation/deprecation */\nexport function getDistanceBetweenPoints(point1: Point, point2: Point): number {\n  const left1 = point1.left || point1.x || 0;\n  const top1 = point1.top || point1.y || 0;\n  const left2 = point2.left || point2.x || 0;\n  const top2 = point2.top || point2.y || 0;\n  /* eslint-enable deprecation/deprecation */\n\n  let distance = Math.sqrt(Math.pow(left1 - left2, 2) + Math.pow(top1 - top2, 2));\n\n  return distance;\n}\n\n/**\n * The available fit modes. These should match the fit modes for CSS.\n */\nexport type FitMode = 'contain' | 'cover';\n\n/**\n * Options for fitting content sizes into bounding sizes.\n */\nexport interface IFitContentToBoundsOptions {\n  /**\n   * The size of the content to fit to the bounds.\n   * The output will be proportional to this value.\n   */\n  contentSize: ISize;\n  /**\n   * The size of the bounds.\n   */\n  boundsSize: ISize;\n  /**\n   * The fit mode to apply, either 'contain' or 'cover'.\n   */\n  mode: FitMode;\n  /**\n   * An optional maximum scale factor to apply. The default is 1.\n   * Use Infinity for an unbounded resize.\n   */\n  maxScale?: number;\n}\n\n/**\n * Produces a proportionally-scaled version of an input content size when fit to a bounding size.\n * Given a `contentSize` and a `boundsSize`, this function scales `contentSize` proportionally\n * using either `contain` or `cover` fit behaviors.\n * Use this function to pre-calculate the layout for the CSS `object-fit` and `background-fit` behaviors.\n * With `contain`, the output size must be the largest it can be while completely within the `boundsSize`.\n * With `cover`, the output size must be the smallest it can be while completely around the `boundsSize`.\n * By default, there is a `maxScale` value of 1, which prevents the `contentSize` from being scaled larger.\n *\n * @param options - the options for the bounds fit operation\n */\nexport function fitContentToBounds(options: IFitContentToBoundsOptions): ISize {\n  const { contentSize, boundsSize, mode = 'contain', maxScale = 1 } = options;\n\n  const contentAspectRatio = contentSize.width / contentSize.height;\n  const boundsAspectRatio = boundsSize.width / boundsSize.height;\n\n  let scale: number;\n\n  if (mode === 'contain' ? contentAspectRatio > boundsAspectRatio : contentAspectRatio < boundsAspectRatio) {\n    scale = boundsSize.width / contentSize.width;\n  } else {\n    scale = boundsSize.height / contentSize.height;\n  }\n\n  const finalScale = Math.min(maxScale, scale);\n\n  return {\n    width: contentSize.width * finalScale,\n    height: contentSize.height * finalScale,\n  };\n}\n\n/**\n * Calculates a number's precision based on the number of trailing\n * zeros if the number does not have a decimal indicated by a negative\n * precision. Otherwise, it calculates the number of digits after\n * the decimal point indicated by a positive precision.\n * @param value - the value to determine the precision of\n */\nexport function calculatePrecision(value: number | string): number {\n  /**\n   * Group 1:\n   * [1-9]([0]+$) matches trailing zeros\n   * Group 2:\n   * \\.([0-9]*) matches all digits after a decimal point.\n   */\n  const groups = /[1-9]([0]+$)|\\.([0-9]*)/.exec(String(value));\n  if (!groups) {\n    return 0;\n  }\n  if (groups[1]) {\n    return -groups[1].length;\n  }\n  if (groups[2]) {\n    return groups[2].length;\n  }\n  return 0;\n}\n\n/**\n * Rounds a number to a certain level of precision. Accepts negative precision.\n * @param value - The value that is being rounded.\n * @param precision - The number of decimal places to round the number to\n */\nexport function precisionRound(value: number, precision: number, base: number = 10): number {\n  const exp = Math.pow(base, precision);\n  return Math.round(value * exp) / exp;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}