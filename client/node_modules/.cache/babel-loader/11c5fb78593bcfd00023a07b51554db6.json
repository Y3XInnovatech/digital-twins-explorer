{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, classNamesFunction, findIndex, KeyCodes, getId, warnMutuallyExclusive, warnConditionallyRequiredProps } from '../../Utilities';\nimport { ButtonGrid } from '../../utilities/ButtonGrid/ButtonGrid';\nimport { ColorPickerGridCell } from './ColorPickerGridCell';\nimport { memoizeFunction, warnDeprecations } from '@uifabric/utilities';\nvar getClassNames = classNamesFunction();\nvar COMPONENT_NAME = 'SwatchColorPicker';\nvar SwatchColorPickerBase = /** @class */function (_super) {\n  __extends(SwatchColorPickerBase, _super);\n  function SwatchColorPickerBase(props) {\n    var _this = _super.call(this, props) || this;\n    _this.navigationIdleDelay = 250 /* ms */;\n    // Add an index to each color cells. Memoizes this so that color cells do not re-render on every update.\n    _this._getItemsWithIndex = memoizeFunction(function (items) {\n      return items.map(function (item, index) {\n        return __assign(__assign({}, item), {\n          index: index\n        });\n      });\n    });\n    _this._onRenderItem = function (item, index) {\n      var _a = _this.props.onRenderColorCell,\n        onRenderColorCell = _a === void 0 ? _this._renderOption : _a;\n      return onRenderColorCell(item, _this._renderOption);\n    };\n    /**\n     * When the whole swatchColorPicker is blurred,\n     * make sure to clear the pending focused stated\n     */\n    _this._onSwatchColorPickerBlur = function () {\n      if (_this.props.onCellFocused) {\n        _this._cellFocused = false;\n        _this.props.onCellFocused();\n      }\n    };\n    /**\n     * Render a color cell\n     * @param item - The item to render\n     * @returns - Element representing the item\n     */\n    _this._renderOption = function (item) {\n      var props = _this.props;\n      var id = _this._id;\n      return React.createElement(ColorPickerGridCell, {\n        item: item,\n        idPrefix: id,\n        color: item.color,\n        styles: props.getColorGridCellStyles,\n        disabled: props.disabled,\n        onClick: _this._onCellClick,\n        onHover: _this._onGridCellHovered,\n        onFocus: _this._onGridCellFocused,\n        selected: _this.state.selectedIndex !== undefined && _this.state.selectedIndex === item.index,\n        circle: props.cellShape === 'circle',\n        label: item.label,\n        onMouseEnter: _this._onMouseEnter,\n        onMouseMove: _this._onMouseMove,\n        onMouseLeave: _this._onMouseLeave,\n        onWheel: _this._onWheel,\n        onKeyDown: _this._onKeyDown,\n        height: props.cellHeight,\n        width: props.cellWidth,\n        borderWidth: props.cellBorderWidth\n      });\n    };\n    /**\n     * Callback passed to the GridCell that will manage triggering the onCellHovered callback for mouseEnter\n     */\n    _this._onMouseEnter = function (ev) {\n      if (!_this.props.focusOnHover) {\n        return !_this.isNavigationIdle || !!_this.props.disabled;\n      }\n      if (_this.isNavigationIdle && !_this.props.disabled) {\n        ev.currentTarget.focus();\n      }\n      return true;\n    };\n    /**\n     * Callback passed to the GridCell that will manage Hover/Focus updates\n     */\n    _this._onMouseMove = function (ev) {\n      if (!_this.props.focusOnHover) {\n        return !_this.isNavigationIdle || !!_this.props.disabled;\n      }\n      var targetElement = ev.currentTarget;\n      // If navigation is idle and the targetElement is the focused element bail out\n      // if (!this.isNavigationIdle || (document && targetElement === (document.activeElement as HTMLElement))) {\n      if (_this.isNavigationIdle && !(document && targetElement === document.activeElement)) {\n        targetElement.focus();\n      }\n      return true;\n    };\n    /**\n     * Callback passed to the GridCell that will manage Hover/Focus updates\n     */\n    _this._onMouseLeave = function (ev) {\n      var parentSelector = _this.props.mouseLeaveParentSelector;\n      if (!_this.props.focusOnHover || !parentSelector || !_this.isNavigationIdle || _this.props.disabled) {\n        return;\n      }\n      // Get the elements that math the given selector\n      var elements = document.querySelectorAll(parentSelector);\n      // iterate over the elements return to make sure it is a parent of the target and focus it\n      for (var index = 0; index < elements.length; index += 1) {\n        if (elements[index].contains(ev.currentTarget)) {\n          /**\n           * IE11 focus() method forces parents to scroll to top of element.\n           * Edge and IE expose a setActive() function for focusable divs that\n           * sets the page focus but does not scroll the parent element.\n           */\n          if (elements[index].setActive) {\n            try {\n              elements[index].setActive();\n            } catch (e) {\n              /* no-op */\n            }\n          } else {\n            elements[index].focus();\n          }\n          break;\n        }\n      }\n    };\n    /**\n     * Callback to make sure we don't update the hovered element during mouse wheel\n     */\n    _this._onWheel = function () {\n      _this._setNavigationTimeout();\n    };\n    /**\n     * Callback that\n     */\n    _this._onKeyDown = function (ev) {\n      if (ev.which === KeyCodes.up || ev.which === KeyCodes.down || ev.which === KeyCodes.left || ev.which === KeyCodes.right) {\n        _this._setNavigationTimeout();\n      }\n    };\n    /**\n     * Sets a timeout so we won't process any mouse \"hover\" events\n     * while navigating (via mouseWheel or arrowKeys)\n     */\n    _this._setNavigationTimeout = function () {\n      if (!_this.isNavigationIdle && _this.navigationIdleTimeoutId !== undefined) {\n        _this.async.clearTimeout(_this.navigationIdleTimeoutId);\n        _this.navigationIdleTimeoutId = undefined;\n      } else {\n        _this.isNavigationIdle = false;\n      }\n      _this.navigationIdleTimeoutId = _this.async.setTimeout(function () {\n        _this.isNavigationIdle = true;\n      }, _this.navigationIdleDelay);\n    };\n    /**\n     * Callback passed to the GridCell class that will trigger the onCellHovered callback of the SwatchColorPicker\n     * NOTE: This will not be triggered if shouldFocusOnHover === true\n     */\n    _this._onGridCellHovered = function (item) {\n      var onCellHovered = _this.props.onCellHovered;\n      if (onCellHovered) {\n        return item ? onCellHovered(item.id, item.color) : onCellHovered();\n      }\n    };\n    /**\n     * Callback passed to the GridCell class that will trigger the onCellFocus callback of the SwatchColorPicker\n     */\n    _this._onGridCellFocused = function (item) {\n      var onCellFocused = _this.props.onCellFocused;\n      if (onCellFocused) {\n        if (item) {\n          _this._cellFocused = true;\n          return onCellFocused(item.id, item.color);\n        } else {\n          _this._cellFocused = false;\n          return onCellFocused();\n        }\n      }\n    };\n    /**\n     * Handle the click on a cell\n     * @param item - The cell that the click was fired against\n     */\n    _this._onCellClick = function (item) {\n      if (_this.props.disabled) {\n        return;\n      }\n      var index = item.index;\n      // If we have a valid index and it is not already\n      // selected, select it\n      if (index >= 0 && index !== _this.state.selectedIndex) {\n        if (_this.props.onCellFocused && _this._cellFocused) {\n          _this._cellFocused = false;\n          _this.props.onCellFocused();\n        }\n        if (_this.props.onColorChanged) {\n          _this.props.onColorChanged(item.id, item.color);\n        }\n        // Update internal state only if the component is uncontrolled\n        if (_this.props.isControlled !== true) {\n          _this.setState({\n            selectedIndex: index\n          });\n        }\n      }\n    };\n    _this._id = props.id || getId('swatchColorPicker');\n    if (process.env.NODE_ENV !== 'production') {\n      warnMutuallyExclusive(COMPONENT_NAME, props, {\n        focusOnHover: 'onHover'\n      });\n      warnConditionallyRequiredProps(COMPONENT_NAME, props, ['focusOnHover'], 'mouseLeaveParentSelector', !!props.mouseLeaveParentSelector);\n      warnDeprecations(COMPONENT_NAME, props, {\n        positionInSet: 'ariaPosInSet',\n        setSize: 'ariaSetSize'\n      });\n    }\n    _this.isNavigationIdle = true;\n    _this.async = new Async(_this);\n    var selectedIndex;\n    if (props.selectedId) {\n      selectedIndex = _getSelectedIndex(props.colorCells, props.selectedId);\n    }\n    _this.state = {\n      selectedIndex: selectedIndex\n    };\n    return _this;\n  }\n  SwatchColorPickerBase.getDerivedStateFromProps = function (newProps, state) {\n    var newSelectedIndex = newProps.selectedId ? _getSelectedIndex(newProps.colorCells, newProps.selectedId) : undefined;\n    // If not controlled, we do not want to allow updates to selectedIndex to be undefined\n    if (!newProps.isControlled && newSelectedIndex === undefined) {\n      return null;\n    }\n    if (newSelectedIndex !== state.selectedIndex) {\n      return {\n        selectedIndex: newSelectedIndex\n      };\n    }\n    return null;\n  };\n  SwatchColorPickerBase.prototype.componentWillUnmount = function () {\n    if (this.props.onCellFocused && this._cellFocused) {\n      this._cellFocused = false;\n      this.props.onCellFocused();\n    }\n    this.async.dispose();\n  };\n  SwatchColorPickerBase.prototype.render = function () {\n    var _a = this.props,\n      colorCells = _a.colorCells,\n      columnCount = _a.columnCount,\n      /* eslint-disable deprecation/deprecation */\n      _b = _a.ariaPosInSet,\n      /* eslint-disable deprecation/deprecation */\n      ariaPosInSet = _b === void 0 ? this.props.positionInSet : _b,\n      _c = _a.ariaSetSize,\n      ariaSetSize = _c === void 0 ? this.props.setSize : _c,\n      /* eslint-enable deprecation/deprecation */\n      shouldFocusCircularNavigate = _a.shouldFocusCircularNavigate,\n      className = _a.className,\n      doNotContainWithinFocusZone = _a.doNotContainWithinFocusZone,\n      styles = _a.styles,\n      cellMargin = _a.cellMargin;\n    var classNames = getClassNames(styles, {\n      theme: this.props.theme,\n      className: className,\n      cellMargin: cellMargin\n    });\n    if (colorCells.length < 1 || columnCount < 1) {\n      return null;\n    }\n    return React.createElement(ButtonGrid, __assign({}, this.props, {\n      id: this._id,\n      items: this._getItemsWithIndex(colorCells),\n      columnCount: columnCount,\n      onRenderItem: this._onRenderItem,\n      ariaPosInSet: ariaPosInSet,\n      ariaSetSize: ariaSetSize,\n      shouldFocusCircularNavigate: shouldFocusCircularNavigate,\n      doNotContainWithinFocusZone: doNotContainWithinFocusZone,\n      onBlur: this._onSwatchColorPickerBlur,\n      theme: this.props.theme,\n      styles: {\n        root: classNames.root,\n        tableCell: classNames.tableCell,\n        focusedContainer: classNames.focusedContainer\n      }\n    }));\n  };\n  SwatchColorPickerBase.defaultProps = {\n    cellShape: 'circle',\n    disabled: false,\n    shouldFocusCircularNavigate: true,\n    cellMargin: 10\n  };\n  return SwatchColorPickerBase;\n}(React.Component);\nexport { SwatchColorPickerBase };\n/**\n * Get the selected item's index\n * @param items - The items to search\n * @param selectedId - The selected item's id to find\n * @returns - The index of the selected item's id, -1 if there was no match\n */\nfunction _getSelectedIndex(items, selectedId) {\n  var selectedIndex = findIndex(items, function (item) {\n    return item.id === selectedId;\n  });\n  return selectedIndex >= 0 ? selectedIndex : undefined;\n}","map":{"version":3,"sources":["components/SwatchColorPicker/SwatchColorPicker.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  classNamesFunction,\n  findIndex,\n  KeyCodes,\n  getId,\n  warnMutuallyExclusive,\n  warnConditionallyRequiredProps,\n} from '../../Utilities';\nimport {\n  ISwatchColorPickerProps,\n  ISwatchColorPickerStyleProps,\n  ISwatchColorPickerStyles,\n} from './SwatchColorPicker.types';\nimport { ButtonGrid } from '../../utilities/ButtonGrid/ButtonGrid';\nimport { IColorCellProps } from './ColorPickerGridCell.types';\nimport { ColorPickerGridCell } from './ColorPickerGridCell';\nimport { memoizeFunction, warnDeprecations } from '@uifabric/utilities';\n\nexport interface ISwatchColorPickerState {\n  selectedIndex?: number;\n}\n\nconst getClassNames = classNamesFunction<ISwatchColorPickerStyleProps, ISwatchColorPickerStyles>();\n\nconst COMPONENT_NAME = 'SwatchColorPicker';\n\nexport class SwatchColorPickerBase extends React.Component<ISwatchColorPickerProps, ISwatchColorPickerState> {\n  public static defaultProps = {\n    cellShape: 'circle',\n    disabled: false,\n    shouldFocusCircularNavigate: true,\n    cellMargin: 10,\n  } as ISwatchColorPickerProps;\n\n  private _id: string;\n  private _cellFocused: boolean;\n\n  private navigationIdleTimeoutId: number | undefined;\n  private isNavigationIdle: boolean;\n  private readonly navigationIdleDelay: number = 250 /* ms */;\n  private async: Async;\n\n  // Add an index to each color cells. Memoizes this so that color cells do not re-render on every update.\n  private _getItemsWithIndex = memoizeFunction((items: IColorCellProps[]) => {\n    return items.map((item, index) => {\n      return { ...item, index: index };\n    });\n  });\n\n  public static getDerivedStateFromProps(newProps: ISwatchColorPickerProps, state: ISwatchColorPickerState) {\n    const newSelectedIndex = newProps.selectedId\n      ? _getSelectedIndex(newProps.colorCells, newProps.selectedId)\n      : undefined;\n\n    // If not controlled, we do not want to allow updates to selectedIndex to be undefined\n    if (!newProps.isControlled && newSelectedIndex === undefined) {\n      return null;\n    }\n\n    if (newSelectedIndex !== state.selectedIndex) {\n      return {\n        selectedIndex: newSelectedIndex,\n      };\n    }\n\n    return null;\n  }\n\n  constructor(props: ISwatchColorPickerProps) {\n    super(props);\n\n    this._id = props.id || getId('swatchColorPicker');\n\n    if (process.env.NODE_ENV !== 'production') {\n      warnMutuallyExclusive(COMPONENT_NAME, props, {\n        focusOnHover: 'onHover',\n      });\n\n      warnConditionallyRequiredProps(\n        COMPONENT_NAME,\n        props,\n        ['focusOnHover'],\n        'mouseLeaveParentSelector',\n        !!props.mouseLeaveParentSelector,\n      );\n\n      warnDeprecations(COMPONENT_NAME, props, {\n        positionInSet: 'ariaPosInSet',\n        setSize: 'ariaSetSize',\n      });\n    }\n\n    this.isNavigationIdle = true;\n    this.async = new Async(this);\n\n    let selectedIndex: number | undefined;\n    if (props.selectedId) {\n      selectedIndex = _getSelectedIndex(props.colorCells, props.selectedId);\n    }\n\n    this.state = {\n      selectedIndex,\n    };\n  }\n\n  public componentWillUnmount() {\n    if (this.props.onCellFocused && this._cellFocused) {\n      this._cellFocused = false;\n      this.props.onCellFocused();\n    }\n    this.async.dispose();\n  }\n\n  public render(): JSX.Element | null {\n    const {\n      colorCells,\n      columnCount,\n      /* eslint-disable deprecation/deprecation */\n      ariaPosInSet = this.props.positionInSet,\n      ariaSetSize = this.props.setSize,\n      /* eslint-enable deprecation/deprecation */\n      shouldFocusCircularNavigate,\n      className,\n      doNotContainWithinFocusZone,\n      styles,\n      cellMargin,\n    } = this.props;\n\n    const classNames = getClassNames(styles!, {\n      theme: this.props.theme!,\n      className,\n      cellMargin,\n    });\n\n    if (colorCells.length < 1 || columnCount < 1) {\n      return null;\n    }\n    return (\n      <ButtonGrid\n        {...this.props}\n        id={this._id}\n        items={this._getItemsWithIndex(colorCells)}\n        columnCount={columnCount}\n        onRenderItem={this._onRenderItem}\n        ariaPosInSet={ariaPosInSet}\n        ariaSetSize={ariaSetSize}\n        shouldFocusCircularNavigate={shouldFocusCircularNavigate}\n        doNotContainWithinFocusZone={doNotContainWithinFocusZone}\n        onBlur={this._onSwatchColorPickerBlur}\n        theme={this.props.theme!}\n        styles={{\n          root: classNames.root,\n          tableCell: classNames.tableCell,\n          focusedContainer: classNames.focusedContainer,\n        }}\n      />\n    );\n  }\n\n  private _onRenderItem = (item: IColorCellProps, index: number): JSX.Element => {\n    const { onRenderColorCell = this._renderOption } = this.props;\n    return onRenderColorCell(item, this._renderOption) as JSX.Element;\n  };\n\n  /**\n   * When the whole swatchColorPicker is blurred,\n   * make sure to clear the pending focused stated\n   */\n  private _onSwatchColorPickerBlur = (): void => {\n    if (this.props.onCellFocused) {\n      this._cellFocused = false;\n      this.props.onCellFocused();\n    }\n  };\n\n  /**\n   * Render a color cell\n   * @param item - The item to render\n   * @returns - Element representing the item\n   */\n  private _renderOption = (item: IColorCellProps): JSX.Element => {\n    const props = this.props;\n    const id = this._id;\n\n    return (\n      <ColorPickerGridCell\n        item={item}\n        idPrefix={id}\n        color={item.color}\n        styles={props.getColorGridCellStyles}\n        disabled={props.disabled}\n        onClick={this._onCellClick}\n        onHover={this._onGridCellHovered}\n        onFocus={this._onGridCellFocused}\n        selected={this.state.selectedIndex !== undefined && this.state.selectedIndex === item.index}\n        circle={props.cellShape === 'circle'}\n        label={item.label}\n        onMouseEnter={this._onMouseEnter}\n        onMouseMove={this._onMouseMove}\n        onMouseLeave={this._onMouseLeave}\n        onWheel={this._onWheel}\n        onKeyDown={this._onKeyDown}\n        height={props.cellHeight}\n        width={props.cellWidth}\n        borderWidth={props.cellBorderWidth}\n      />\n    );\n  };\n\n  /**\n   * Callback passed to the GridCell that will manage triggering the onCellHovered callback for mouseEnter\n   */\n  private _onMouseEnter = (ev: React.MouseEvent<HTMLButtonElement>): boolean => {\n    if (!this.props.focusOnHover) {\n      return !this.isNavigationIdle || !!this.props.disabled;\n    }\n\n    if (this.isNavigationIdle && !this.props.disabled) {\n      ev.currentTarget.focus();\n    }\n\n    return true;\n  };\n\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n  private _onMouseMove = (ev: React.MouseEvent<HTMLButtonElement>): boolean => {\n    if (!this.props.focusOnHover) {\n      return !this.isNavigationIdle || !!this.props.disabled;\n    }\n\n    const targetElement = ev.currentTarget as HTMLElement;\n\n    // If navigation is idle and the targetElement is the focused element bail out\n    // if (!this.isNavigationIdle || (document && targetElement === (document.activeElement as HTMLElement))) {\n    if (this.isNavigationIdle && !(document && targetElement === (document.activeElement as HTMLElement))) {\n      targetElement.focus();\n    }\n\n    return true;\n  };\n\n  /**\n   * Callback passed to the GridCell that will manage Hover/Focus updates\n   */\n  private _onMouseLeave = (ev: React.MouseEvent<HTMLButtonElement>): void => {\n    const parentSelector = this.props.mouseLeaveParentSelector;\n\n    if (!this.props.focusOnHover || !parentSelector || !this.isNavigationIdle || this.props.disabled) {\n      return;\n    }\n\n    // Get the elements that math the given selector\n    const elements = document.querySelectorAll(parentSelector);\n\n    // iterate over the elements return to make sure it is a parent of the target and focus it\n    for (let index = 0; index < elements.length; index += 1) {\n      if (elements[index].contains(ev.currentTarget)) {\n        /**\n         * IE11 focus() method forces parents to scroll to top of element.\n         * Edge and IE expose a setActive() function for focusable divs that\n         * sets the page focus but does not scroll the parent element.\n         */\n        if ((elements[index] as any).setActive) {\n          try {\n            (elements[index] as any).setActive();\n          } catch (e) {\n            /* no-op */\n          }\n        } else {\n          (elements[index] as HTMLElement).focus();\n        }\n\n        break;\n      }\n    }\n  };\n\n  /**\n   * Callback to make sure we don't update the hovered element during mouse wheel\n   */\n  private _onWheel = (): void => {\n    this._setNavigationTimeout();\n  };\n\n  /**\n   * Callback that\n   */\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLButtonElement>): void => {\n    if (\n      ev.which === KeyCodes.up ||\n      ev.which === KeyCodes.down ||\n      ev.which === KeyCodes.left ||\n      ev.which === KeyCodes.right\n    ) {\n      this._setNavigationTimeout();\n    }\n  };\n\n  /**\n   * Sets a timeout so we won't process any mouse \"hover\" events\n   * while navigating (via mouseWheel or arrowKeys)\n   */\n  private _setNavigationTimeout = () => {\n    if (!this.isNavigationIdle && this.navigationIdleTimeoutId !== undefined) {\n      this.async.clearTimeout(this.navigationIdleTimeoutId);\n      this.navigationIdleTimeoutId = undefined;\n    } else {\n      this.isNavigationIdle = false;\n    }\n\n    this.navigationIdleTimeoutId = this.async.setTimeout(() => {\n      this.isNavigationIdle = true;\n    }, this.navigationIdleDelay);\n  };\n\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellHovered callback of the SwatchColorPicker\n   * NOTE: This will not be triggered if shouldFocusOnHover === true\n   */\n  private _onGridCellHovered = (item?: IColorCellProps): void => {\n    const { onCellHovered } = this.props;\n\n    if (onCellHovered) {\n      return item ? onCellHovered(item.id, item.color) : onCellHovered();\n    }\n  };\n\n  /**\n   * Callback passed to the GridCell class that will trigger the onCellFocus callback of the SwatchColorPicker\n   */\n  private _onGridCellFocused = (item?: IColorCellProps): void => {\n    const { onCellFocused } = this.props;\n    if (onCellFocused) {\n      if (item) {\n        this._cellFocused = true;\n        return onCellFocused(item.id, item.color);\n      } else {\n        this._cellFocused = false;\n        return onCellFocused();\n      }\n    }\n  };\n\n  /**\n   * Handle the click on a cell\n   * @param item - The cell that the click was fired against\n   */\n  private _onCellClick = (item: IColorCellProps): void => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    const index = item.index as number;\n\n    // If we have a valid index and it is not already\n    // selected, select it\n    if (index >= 0 && index !== this.state.selectedIndex) {\n      if (this.props.onCellFocused && this._cellFocused) {\n        this._cellFocused = false;\n        this.props.onCellFocused();\n      }\n\n      if (this.props.onColorChanged) {\n        this.props.onColorChanged(item.id, item.color);\n      }\n\n      // Update internal state only if the component is uncontrolled\n      if (this.props.isControlled !== true) {\n        this.setState({\n          selectedIndex: index,\n        });\n      }\n    }\n  };\n}\n\n/**\n * Get the selected item's index\n * @param items - The items to search\n * @param selectedId - The selected item's id to find\n * @returns - The index of the selected item's id, -1 if there was no match\n */\nfunction _getSelectedIndex(items: IColorCellProps[], selectedId: string): number | undefined {\n  const selectedIndex = findIndex(items, item => item.id === selectedId);\n  return selectedIndex >= 0 ? selectedIndex : undefined;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}