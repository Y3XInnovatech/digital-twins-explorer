{"ast":null,"code":"var _a;\nimport { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { getClassNames } from './PositioningContainer.styles';\nimport { Layer } from '../../../Layer';\n// Utilites/Helpers\nimport { DirectionalHint } from '../../../common/DirectionalHint';\nimport { css, elementContains, focusFirstChild, getWindow, getDocument, initializeComponentRef, Async, EventGroup } from '../../../Utilities';\nimport { getMaxHeight, positionElement, RectangleEdge } from '../../../utilities/positioning';\nimport { AnimationClassNames, mergeStyles } from '../../../Styling';\nvar OFF_SCREEN_STYLE = {\n  opacity: 0\n};\n// In order for some of the max height logic to work\n// properly we need to set the border.\n// The value is abitrary.\nvar BORDER_WIDTH = 1;\nvar SLIDE_ANIMATIONS = (_a = {}, _a[RectangleEdge.top] = 'slideUpIn20', _a[RectangleEdge.bottom] = 'slideDownIn20', _a[RectangleEdge.left] = 'slideLeftIn20', _a[RectangleEdge.right] = 'slideRightIn20', _a);\nvar PositioningContainer = /** @class */function (_super) {\n  __extends(PositioningContainer, _super);\n  function PositioningContainer(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * The primary positioned div.\n     */\n    _this._positionedHost = React.createRef();\n    // @TODO rename to reflect the name of this class\n    _this._contentHost = React.createRef();\n    /**\n     * Deprecated, use `onResize` instead.\n     * @deprecated Use `onResize` instead.\n     */\n    _this.dismiss = function (ev) {\n      _this.onResize(ev);\n    };\n    _this.onResize = function (ev) {\n      var onDismiss = _this.props.onDismiss;\n      if (onDismiss) {\n        onDismiss(ev);\n      } else {\n        _this._updateAsyncPosition();\n      }\n    };\n    _this._setInitialFocus = function () {\n      if (_this._contentHost.current && _this.props.setInitialFocus && !_this._didSetInitialFocus && _this.state.positions) {\n        _this._didSetInitialFocus = true;\n        focusFirstChild(_this._contentHost.current);\n      }\n    };\n    _this._onComponentDidMount = function () {\n      // This is added so the positioningContainer will dismiss when the window is scrolled\n      // but not when something inside the positioningContainer is scrolled. The delay seems\n      // to be required to avoid React firing an async focus event in IE from\n      // the target changing focus quickly prior to rendering the positioningContainer.\n      _this._async.setTimeout(function () {\n        _this._events.on(_this._targetWindow, 'scroll', _this._async.throttle(_this._dismissOnScroll, 10), true);\n        _this._events.on(_this._targetWindow, 'resize', _this._async.throttle(_this.onResize, 10), true);\n        _this._events.on(_this._targetWindow.document.body, 'focus', _this._dismissOnLostFocus, true);\n        _this._events.on(_this._targetWindow.document.body, 'click', _this._dismissOnLostFocus, true);\n      }, 0);\n      if (_this.props.onLayerMounted) {\n        _this.props.onLayerMounted();\n      }\n      _this._updateAsyncPosition();\n      _this._setHeightOffsetEveryFrame();\n    };\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this._didSetInitialFocus = false;\n    _this.state = {\n      positions: undefined,\n      heightOffset: 0\n    };\n    _this._positionAttempts = 0;\n    return _this;\n  }\n  PositioningContainer.prototype.UNSAFE_componentWillMount = function () {\n    this._setTargetWindowAndElement(this._getTarget());\n  };\n  PositioningContainer.prototype.componentDidMount = function () {\n    this._onComponentDidMount();\n  };\n  PositioningContainer.prototype.componentDidUpdate = function () {\n    this._setInitialFocus();\n    this._updateAsyncPosition();\n  };\n  PositioningContainer.prototype.UNSAFE_componentWillUpdate = function (newProps) {\n    // If the target element changed, find the new one. If we are tracking\n    // target with class name, always find element because we do not know if\n    // fabric has rendered a new element and disposed the old element.\n    var newTarget = this._getTarget(newProps);\n    var oldTarget = this._getTarget();\n    if (newTarget !== oldTarget || typeof newTarget === 'string' || newTarget instanceof String) {\n      this._maxHeight = undefined;\n      this._setTargetWindowAndElement(newTarget);\n    }\n    if (newProps.offsetFromTarget !== this.props.offsetFromTarget) {\n      this._maxHeight = undefined;\n    }\n    if (newProps.finalHeight !== this.props.finalHeight) {\n      this._setHeightOffsetEveryFrame();\n    }\n  };\n  PositioningContainer.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n    this._events.dispose();\n  };\n  PositioningContainer.prototype.render = function () {\n    // If there is no target window then we are likely in server side rendering and we should not render anything.\n    if (!this._targetWindow) {\n      return null;\n    }\n    var _a = this.props,\n      className = _a.className,\n      positioningContainerWidth = _a.positioningContainerWidth,\n      positioningContainerMaxHeight = _a.positioningContainerMaxHeight,\n      children = _a.children;\n    var positions = this.state.positions;\n    var styles = getClassNames();\n    var directionalClassName = positions && positions.targetEdge ? AnimationClassNames[SLIDE_ANIMATIONS[positions.targetEdge]] : '';\n    var getContentMaxHeight = this._getMaxHeight() + this.state.heightOffset;\n    var contentMaxHeight = positioningContainerMaxHeight && positioningContainerMaxHeight > getContentMaxHeight ? getContentMaxHeight : positioningContainerMaxHeight;\n    var content = React.createElement(\"div\", {\n      ref: this._positionedHost,\n      className: css('ms-PositioningContainer', styles.container)\n    }, React.createElement(\"div\", {\n      className: mergeStyles('ms-PositioningContainer-layerHost', styles.root, className, directionalClassName, !!positioningContainerWidth && {\n        width: positioningContainerWidth\n      }),\n      style: positions ? positions.elementPosition : OFF_SCREEN_STYLE,\n      // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n      // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n      tabIndex: -1,\n      ref: this._contentHost\n    }, children,\n    // @TODO apply to the content container\n    contentMaxHeight));\n    return this.props.doNotLayer ? content : React.createElement(Layer, null, content);\n  };\n  PositioningContainer.prototype._dismissOnScroll = function (ev) {\n    var preventDismissOnScroll = this.props.preventDismissOnScroll;\n    if (this.state.positions && !preventDismissOnScroll) {\n      this._dismissOnLostFocus(ev);\n    }\n  };\n  PositioningContainer.prototype._dismissOnLostFocus = function (ev) {\n    var target = ev.target;\n    var clickedOutsideCallout = this._positionedHost.current && !elementContains(this._positionedHost.current, target);\n    if (!this._target && clickedOutsideCallout || ev.target !== this._targetWindow && clickedOutsideCallout && (this._target.stopPropagation || !this._target || target !== this._target && !elementContains(this._target, target))) {\n      this.onResize(ev);\n    }\n  };\n  PositioningContainer.prototype._updateAsyncPosition = function () {\n    var _this = this;\n    this._async.requestAnimationFrame(function () {\n      return _this._updatePosition();\n    });\n  };\n  PositioningContainer.prototype._updatePosition = function () {\n    var positions = this.state.positions;\n    var _a = this.props,\n      offsetFromTarget = _a.offsetFromTarget,\n      onPositioned = _a.onPositioned;\n    var hostElement = this._positionedHost.current;\n    var positioningContainerElement = this._contentHost.current;\n    if (hostElement && positioningContainerElement) {\n      var currentProps = __assign({}, this.props);\n      currentProps.bounds = this._getBounds();\n      currentProps.target = this._target;\n      if (document.body.contains(currentProps.target)) {\n        currentProps.gapSpace = offsetFromTarget;\n        var newPositions_1 = positionElement(currentProps, hostElement, positioningContainerElement);\n        // Set the new position only when the positions are not exists or one of the new positioningContainer positions\n        // are different. The position should not change if the position is within 2 decimal places.\n        if (!positions && newPositions_1 || positions && newPositions_1 && !this._arePositionsEqual(positions, newPositions_1) && this._positionAttempts < 5) {\n          // We should not reposition the positioningContainer more than a few times, if it is then the content is\n          // likely resizing and we should stop trying to reposition to prevent a stack overflow.\n          this._positionAttempts++;\n          this.setState({\n            positions: newPositions_1\n          }, function () {\n            if (onPositioned) {\n              onPositioned(newPositions_1);\n            }\n          });\n        } else {\n          this._positionAttempts = 0;\n          if (onPositioned) {\n            onPositioned(newPositions_1);\n          }\n        }\n      } else if (positions !== undefined) {\n        this.setState({\n          positions: undefined\n        });\n      }\n    }\n  };\n  PositioningContainer.prototype._getBounds = function () {\n    if (!this._positioningBounds) {\n      var currentBounds = this.props.bounds;\n      if (!currentBounds) {\n        currentBounds = {\n          top: 0 + this.props.minPagePadding,\n          left: 0 + this.props.minPagePadding,\n          right: this._targetWindow.innerWidth - this.props.minPagePadding,\n          bottom: this._targetWindow.innerHeight - this.props.minPagePadding,\n          width: this._targetWindow.innerWidth - this.props.minPagePadding * 2,\n          height: this._targetWindow.innerHeight - this.props.minPagePadding * 2\n        };\n      }\n      this._positioningBounds = currentBounds;\n    }\n    return this._positioningBounds;\n  };\n  /**\n   * Return the maximum height the container can grow to\n   * without going out of the specified bounds\n   */\n  PositioningContainer.prototype._getMaxHeight = function () {\n    var _a = this.props,\n      directionalHintFixed = _a.directionalHintFixed,\n      offsetFromTarget = _a.offsetFromTarget,\n      directionalHint = _a.directionalHint;\n    if (!this._maxHeight) {\n      if (directionalHintFixed && this._target) {\n        var gapSpace = offsetFromTarget ? offsetFromTarget : 0;\n        this._maxHeight = getMaxHeight(this._target, directionalHint, gapSpace, this._getBounds());\n      } else {\n        this._maxHeight = this._getBounds().height - BORDER_WIDTH * 2;\n      }\n    }\n    return this._maxHeight;\n  };\n  PositioningContainer.prototype._arePositionsEqual = function (positions, newPosition) {\n    return this._comparePositions(positions.elementPosition, newPosition.elementPosition);\n  };\n  PositioningContainer.prototype._comparePositions = function (oldPositions, newPositions) {\n    for (var key in newPositions) {\n      if (newPositions.hasOwnProperty(key)) {\n        var oldPositionEdge = oldPositions[key];\n        var newPositionEdge = newPositions[key];\n        if (oldPositionEdge && newPositionEdge) {\n          if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  };\n  PositioningContainer.prototype._setTargetWindowAndElement = function (target) {\n    var currentElement = this._positionedHost.current;\n    if (target) {\n      if (typeof target === 'string') {\n        var currentDoc = getDocument();\n        this._target = currentDoc ? currentDoc.querySelector(target) : null;\n        this._targetWindow = getWindow(currentElement);\n        // Cast to any prevents error about stopPropagation always existing\n      } else if (target.stopPropagation) {\n        this._targetWindow = getWindow(target.target);\n        this._target = target;\n      } else if (\n      // eslint-disable-next-line deprecation/deprecation\n      (target.left !== undefined || target.x !== undefined) && (\n      // eslint-disable-next-line deprecation/deprecation\n      target.top !== undefined || target.y !== undefined)) {\n        this._targetWindow = getWindow(currentElement);\n        this._target = target;\n      } else {\n        var targetElement = target;\n        this._targetWindow = getWindow(targetElement);\n        this._target = target;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement);\n    }\n  };\n  /**\n   * Animates the height if finalHeight was given.\n   */\n  PositioningContainer.prototype._setHeightOffsetEveryFrame = function () {\n    var _this = this;\n    if (this._contentHost && this.props.finalHeight) {\n      this._setHeightOffsetTimer = this._async.requestAnimationFrame(function () {\n        if (!_this._contentHost.current) {\n          return;\n        }\n        var positioningContainerMainElem = _this._contentHost.current.lastChild;\n        var cardScrollHeight = positioningContainerMainElem.scrollHeight;\n        var cardCurrHeight = positioningContainerMainElem.offsetHeight;\n        var scrollDiff = cardScrollHeight - cardCurrHeight;\n        _this.setState({\n          heightOffset: _this.state.heightOffset + scrollDiff\n        });\n        if (positioningContainerMainElem.offsetHeight < _this.props.finalHeight) {\n          _this._setHeightOffsetEveryFrame();\n        } else {\n          _this._async.cancelAnimationFrame(_this._setHeightOffsetTimer);\n        }\n      });\n    }\n  };\n  PositioningContainer.prototype._getTarget = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n    var target = props.target;\n    return target;\n  };\n  PositioningContainer.defaultProps = {\n    preventDismissOnScroll: false,\n    offsetFromTarget: 0,\n    minPagePadding: 8,\n    directionalHint: DirectionalHint.bottomAutoEdge\n  };\n  return PositioningContainer;\n}(React.Component);\nexport { PositioningContainer };","map":{"version":3,"sources":["components/Coachmark/PositioningContainer/PositioningContainer.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { IPositioningContainerProps } from './PositioningContainer.types';\nimport { getClassNames } from './PositioningContainer.styles';\nimport { Layer } from '../../../Layer';\n\n// Utilites/Helpers\nimport { DirectionalHint } from '../../../common/DirectionalHint';\nimport {\n  Point,\n  IRectangle,\n  css,\n  elementContains,\n  focusFirstChild,\n  getWindow,\n  getDocument,\n  initializeComponentRef,\n  Async,\n  EventGroup,\n} from '../../../Utilities';\n\nimport {\n  getMaxHeight,\n  positionElement,\n  IPositionedData,\n  IPositionProps,\n  IPosition,\n  RectangleEdge,\n} from '../../../utilities/positioning';\n\nimport { AnimationClassNames, mergeStyles } from '../../../Styling';\n\nconst OFF_SCREEN_STYLE = { opacity: 0 };\n\n// In order for some of the max height logic to work\n// properly we need to set the border.\n// The value is abitrary.\nconst BORDER_WIDTH = 1;\nconst SLIDE_ANIMATIONS: { [key: number]: string } = {\n  [RectangleEdge.top]: 'slideUpIn20',\n  [RectangleEdge.bottom]: 'slideDownIn20',\n  [RectangleEdge.left]: 'slideLeftIn20',\n  [RectangleEdge.right]: 'slideRightIn20',\n};\n\nexport interface IPositioningContainerState {\n  /**\n   * Current set of calcualted positions for the outermost parent container.\n   */\n  positions?: IPositionedData;\n\n  /**\n   * Tracks the current height offset and updates during\n   * the height animation when props.finalHeight is specified.\n   */\n  heightOffset?: number;\n}\n\nexport class PositioningContainer extends React.Component<IPositioningContainerProps, IPositioningContainerState>\n  implements PositioningContainer {\n  public static defaultProps: IPositioningContainerProps = {\n    preventDismissOnScroll: false,\n    offsetFromTarget: 0,\n    minPagePadding: 8,\n    directionalHint: DirectionalHint.bottomAutoEdge,\n  };\n\n  private _didSetInitialFocus: boolean;\n\n  /**\n   * The primary positioned div.\n   */\n  private _positionedHost = React.createRef<HTMLDivElement>();\n\n  // @TODO rename to reflect the name of this class\n  private _contentHost = React.createRef<HTMLDivElement>();\n\n  /**\n   * Stores an instance of Window, used to check\n   * for server side rendering and if focus was lost.\n   */\n  private _targetWindow: Window;\n\n  /**\n   * The bounds used when determing if and where the\n   * PositioningContainer should be placed.\n   */\n  private _positioningBounds: IRectangle;\n\n  /**\n   * The maximum height the PositioningContainer can grow to\n   * without going being the window or target bounds\n   */\n  private _maxHeight: number | undefined;\n  private _positionAttempts: number;\n  private _target: HTMLElement | MouseEvent | Point | null;\n  private _setHeightOffsetTimer: number;\n  private _async: Async;\n  private _events: EventGroup;\n\n  constructor(props: IPositioningContainerProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    this._didSetInitialFocus = false;\n    this.state = {\n      positions: undefined,\n      heightOffset: 0,\n    };\n    this._positionAttempts = 0;\n  }\n\n  public UNSAFE_componentWillMount(): void {\n    this._setTargetWindowAndElement(this._getTarget());\n  }\n\n  public componentDidMount(): void {\n    this._onComponentDidMount();\n  }\n\n  public componentDidUpdate(): void {\n    this._setInitialFocus();\n    this._updateAsyncPosition();\n  }\n\n  public UNSAFE_componentWillUpdate(newProps: IPositioningContainerProps): void {\n    // If the target element changed, find the new one. If we are tracking\n    // target with class name, always find element because we do not know if\n    // fabric has rendered a new element and disposed the old element.\n    const newTarget = this._getTarget(newProps);\n    const oldTarget = this._getTarget();\n    if (newTarget !== oldTarget || typeof newTarget === 'string' || newTarget instanceof String) {\n      this._maxHeight = undefined;\n      this._setTargetWindowAndElement(newTarget!);\n    }\n\n    if (newProps.offsetFromTarget !== this.props.offsetFromTarget) {\n      this._maxHeight = undefined;\n    }\n\n    if (newProps.finalHeight !== this.props.finalHeight) {\n      this._setHeightOffsetEveryFrame();\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  public render(): JSX.Element | null {\n    // If there is no target window then we are likely in server side rendering and we should not render anything.\n    if (!this._targetWindow) {\n      return null;\n    }\n\n    const { className, positioningContainerWidth, positioningContainerMaxHeight, children } = this.props;\n    const { positions } = this.state;\n\n    const styles = getClassNames();\n\n    const directionalClassName =\n      positions && positions.targetEdge ? (AnimationClassNames as any)[SLIDE_ANIMATIONS[positions.targetEdge]] : '';\n\n    const getContentMaxHeight: number = this._getMaxHeight() + this.state.heightOffset!;\n    const contentMaxHeight: number =\n      positioningContainerMaxHeight! && positioningContainerMaxHeight! > getContentMaxHeight\n        ? getContentMaxHeight\n        : positioningContainerMaxHeight!;\n    const content = (\n      <div ref={this._positionedHost} className={css('ms-PositioningContainer', styles.container)}>\n        <div\n          className={mergeStyles(\n            'ms-PositioningContainer-layerHost',\n            styles.root,\n            className,\n            directionalClassName,\n            !!positioningContainerWidth && { width: positioningContainerWidth },\n          )}\n          style={positions ? positions.elementPosition : OFF_SCREEN_STYLE}\n          // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n          // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n          tabIndex={-1}\n          ref={this._contentHost}\n        >\n          {children}\n          {\n            // @TODO apply to the content container\n            contentMaxHeight\n          }\n        </div>\n      </div>\n    );\n\n    return this.props.doNotLayer ? content : <Layer>{content}</Layer>;\n  }\n\n  /**\n   * Deprecated, use `onResize` instead.\n   * @deprecated Use `onResize` instead.\n   */\n  public dismiss = (ev?: Event | React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void => {\n    this.onResize(ev);\n  };\n\n  public onResize = (ev?: Event | React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void => {\n    const { onDismiss } = this.props;\n    if (onDismiss) {\n      onDismiss(ev);\n    } else {\n      this._updateAsyncPosition();\n    }\n  };\n\n  protected _dismissOnScroll(ev: Event): void {\n    const { preventDismissOnScroll } = this.props;\n    if (this.state.positions && !preventDismissOnScroll) {\n      this._dismissOnLostFocus(ev);\n    }\n  }\n\n  protected _dismissOnLostFocus(ev: Event): void {\n    const target = ev.target as HTMLElement;\n    const clickedOutsideCallout =\n      this._positionedHost.current && !elementContains(this._positionedHost.current, target);\n\n    if (\n      (!this._target && clickedOutsideCallout) ||\n      (ev.target !== this._targetWindow &&\n        clickedOutsideCallout &&\n        ((this._target as MouseEvent).stopPropagation ||\n          !this._target ||\n          (target !== this._target && !elementContains(this._target as HTMLElement, target))))\n    ) {\n      this.onResize(ev);\n    }\n  }\n\n  protected _setInitialFocus = (): void => {\n    if (this._contentHost.current && this.props.setInitialFocus && !this._didSetInitialFocus && this.state.positions) {\n      this._didSetInitialFocus = true;\n      focusFirstChild(this._contentHost.current);\n    }\n  };\n\n  protected _onComponentDidMount = (): void => {\n    // This is added so the positioningContainer will dismiss when the window is scrolled\n    // but not when something inside the positioningContainer is scrolled. The delay seems\n    // to be required to avoid React firing an async focus event in IE from\n    // the target changing focus quickly prior to rendering the positioningContainer.\n    this._async.setTimeout(() => {\n      this._events.on(this._targetWindow, 'scroll', this._async.throttle(this._dismissOnScroll, 10), true);\n      this._events.on(this._targetWindow, 'resize', this._async.throttle(this.onResize, 10), true);\n      this._events.on(this._targetWindow.document.body, 'focus', this._dismissOnLostFocus, true);\n      this._events.on(this._targetWindow.document.body, 'click', this._dismissOnLostFocus, true);\n    }, 0);\n\n    if (this.props.onLayerMounted) {\n      this.props.onLayerMounted();\n    }\n\n    this._updateAsyncPosition();\n    this._setHeightOffsetEveryFrame();\n  };\n\n  private _updateAsyncPosition(): void {\n    this._async.requestAnimationFrame(() => this._updatePosition());\n  }\n\n  private _updatePosition(): void {\n    const { positions } = this.state;\n    const { offsetFromTarget, onPositioned } = this.props;\n\n    const hostElement = this._positionedHost.current;\n    const positioningContainerElement = this._contentHost.current;\n\n    if (hostElement && positioningContainerElement) {\n      const currentProps: IPositionProps = { ...(this.props as any) };\n      currentProps.bounds = this._getBounds();\n      currentProps.target = this._target!;\n      if (document.body.contains(currentProps.target as Node)) {\n        currentProps.gapSpace = offsetFromTarget;\n        const newPositions: IPositionedData = positionElement(currentProps, hostElement, positioningContainerElement);\n        // Set the new position only when the positions are not exists or one of the new positioningContainer positions\n        // are different. The position should not change if the position is within 2 decimal places.\n        if (\n          (!positions && newPositions) ||\n          (positions && newPositions && !this._arePositionsEqual(positions, newPositions) && this._positionAttempts < 5)\n        ) {\n          // We should not reposition the positioningContainer more than a few times, if it is then the content is\n          // likely resizing and we should stop trying to reposition to prevent a stack overflow.\n          this._positionAttempts++;\n          this.setState(\n            {\n              positions: newPositions,\n            },\n            () => {\n              if (onPositioned) {\n                onPositioned(newPositions);\n              }\n            },\n          );\n        } else {\n          this._positionAttempts = 0;\n          if (onPositioned) {\n            onPositioned(newPositions);\n          }\n        }\n      } else if (positions !== undefined) {\n        this.setState({\n          positions: undefined,\n        });\n      }\n    }\n  }\n\n  private _getBounds(): IRectangle {\n    if (!this._positioningBounds) {\n      let currentBounds = this.props.bounds;\n\n      if (!currentBounds) {\n        currentBounds = {\n          top: 0 + this.props.minPagePadding!,\n          left: 0 + this.props.minPagePadding!,\n          right: this._targetWindow.innerWidth - this.props.minPagePadding!,\n          bottom: this._targetWindow.innerHeight - this.props.minPagePadding!,\n          width: this._targetWindow.innerWidth - this.props.minPagePadding! * 2,\n          height: this._targetWindow.innerHeight - this.props.minPagePadding! * 2,\n        };\n      }\n      this._positioningBounds = currentBounds;\n    }\n    return this._positioningBounds;\n  }\n\n  /**\n   * Return the maximum height the container can grow to\n   * without going out of the specified bounds\n   */\n  private _getMaxHeight(): number {\n    const { directionalHintFixed, offsetFromTarget, directionalHint } = this.props;\n\n    if (!this._maxHeight) {\n      if (directionalHintFixed && this._target) {\n        const gapSpace = offsetFromTarget ? offsetFromTarget : 0;\n        this._maxHeight = getMaxHeight(this._target, directionalHint!, gapSpace, this._getBounds());\n      } else {\n        this._maxHeight = this._getBounds().height! - BORDER_WIDTH * 2;\n      }\n    }\n    return this._maxHeight!;\n  }\n\n  private _arePositionsEqual(positions: IPositionedData, newPosition: IPositionedData): boolean {\n    return this._comparePositions(positions.elementPosition, newPosition.elementPosition);\n  }\n\n  private _comparePositions(oldPositions: IPosition, newPositions: IPosition): boolean {\n    for (const key in newPositions) {\n      if (newPositions.hasOwnProperty(key)) {\n        const oldPositionEdge = oldPositions[key];\n        const newPositionEdge = newPositions[key];\n\n        if (oldPositionEdge && newPositionEdge) {\n          if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  private _setTargetWindowAndElement(target: HTMLElement | string | MouseEvent | Point | null): void {\n    const currentElement = this._positionedHost.current;\n\n    if (target) {\n      if (typeof target === 'string') {\n        const currentDoc: Document = getDocument()!;\n        this._target = currentDoc ? (currentDoc.querySelector(target) as HTMLElement) : null;\n        this._targetWindow = getWindow(currentElement)!;\n        // Cast to any prevents error about stopPropagation always existing\n      } else if ((target as any).stopPropagation) {\n        this._targetWindow = getWindow((target as MouseEvent).target as HTMLElement)!;\n        this._target = target;\n      } else if (\n        // eslint-disable-next-line deprecation/deprecation\n        ((target as Point).left !== undefined || (target as Point).x !== undefined) &&\n        // eslint-disable-next-line deprecation/deprecation\n        ((target as Point).top !== undefined || (target as Point).y !== undefined)\n      ) {\n        this._targetWindow = getWindow(currentElement)!;\n        this._target = target;\n      } else {\n        const targetElement: HTMLElement = target as HTMLElement;\n        this._targetWindow = getWindow(targetElement)!;\n        this._target = target;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement)!;\n    }\n  }\n\n  /**\n   * Animates the height if finalHeight was given.\n   */\n  private _setHeightOffsetEveryFrame(): void {\n    if (this._contentHost && this.props.finalHeight) {\n      this._setHeightOffsetTimer = this._async.requestAnimationFrame(() => {\n        if (!this._contentHost.current) {\n          return;\n        }\n\n        const positioningContainerMainElem = this._contentHost.current.lastChild as HTMLElement;\n        const cardScrollHeight: number = positioningContainerMainElem.scrollHeight;\n        const cardCurrHeight: number = positioningContainerMainElem.offsetHeight;\n        const scrollDiff: number = cardScrollHeight - cardCurrHeight;\n\n        this.setState({\n          heightOffset: this.state.heightOffset! + scrollDiff,\n        });\n\n        if (positioningContainerMainElem.offsetHeight < this.props.finalHeight!) {\n          this._setHeightOffsetEveryFrame();\n        } else {\n          this._async.cancelAnimationFrame(this._setHeightOffsetTimer);\n        }\n      });\n    }\n  }\n\n  private _getTarget(props: IPositioningContainerProps = this.props): HTMLElement | string | MouseEvent | Point | null {\n    const { target } = props;\n    return target!;\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}