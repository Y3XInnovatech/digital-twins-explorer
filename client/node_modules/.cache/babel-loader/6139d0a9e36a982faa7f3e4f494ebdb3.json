{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, classNamesFunction, divProperties, getNativeProps, getRTL, initializeComponentRef } from '../../Utilities';\nimport { ScrollablePaneContext } from './ScrollablePane.types';\nvar getClassNames = classNamesFunction();\nvar ScrollablePaneBase = /** @class */function (_super) {\n  __extends(ScrollablePaneBase, _super);\n  function ScrollablePaneBase(props) {\n    var _this = _super.call(this, props) || this;\n    _this._root = React.createRef();\n    _this._stickyAboveRef = React.createRef();\n    _this._stickyBelowRef = React.createRef();\n    _this._contentContainer = React.createRef();\n    _this.subscribe = function (handler) {\n      _this._subscribers.add(handler);\n    };\n    _this.unsubscribe = function (handler) {\n      _this._subscribers.delete(handler);\n    };\n    _this.addSticky = function (sticky) {\n      _this._stickies.add(sticky);\n      // If ScrollablePane is mounted, then sort sticky in correct place\n      if (_this.contentContainer) {\n        sticky.setDistanceFromTop(_this.contentContainer);\n        _this.sortSticky(sticky);\n      }\n    };\n    _this.removeSticky = function (sticky) {\n      _this._stickies.delete(sticky);\n      _this._removeStickyFromContainers(sticky);\n      _this.notifySubscribers();\n    };\n    _this.sortSticky = function (sticky, sortAgain) {\n      if (_this.stickyAbove && _this.stickyBelow) {\n        if (sortAgain) {\n          _this._removeStickyFromContainers(sticky);\n        }\n        if (sticky.canStickyTop && sticky.stickyContentTop) {\n          _this._addToStickyContainer(sticky, _this.stickyAbove, sticky.stickyContentTop);\n        }\n        if (sticky.canStickyBottom && sticky.stickyContentBottom) {\n          _this._addToStickyContainer(sticky, _this.stickyBelow, sticky.stickyContentBottom);\n        }\n      }\n    };\n    _this.updateStickyRefHeights = function () {\n      var stickyItems = _this._stickies;\n      var stickyTopHeight = 0;\n      var stickyBottomHeight = 0;\n      stickyItems.forEach(function (sticky) {\n        var _a = sticky.state,\n          isStickyTop = _a.isStickyTop,\n          isStickyBottom = _a.isStickyBottom;\n        if (sticky.nonStickyContent) {\n          if (isStickyTop) {\n            stickyTopHeight += sticky.nonStickyContent.offsetHeight;\n          }\n          if (isStickyBottom) {\n            stickyBottomHeight += sticky.nonStickyContent.offsetHeight;\n          }\n          _this._checkStickyStatus(sticky);\n        }\n      });\n      _this.setState({\n        stickyTopHeight: stickyTopHeight,\n        stickyBottomHeight: stickyBottomHeight\n      });\n    };\n    _this.notifySubscribers = function () {\n      if (_this.contentContainer) {\n        _this._subscribers.forEach(function (handle) {\n          // this.stickyBelow is passed in for calculating distance to determine Sticky status\n          handle(_this.contentContainer, _this.stickyBelow);\n        });\n      }\n    };\n    _this.getScrollPosition = function () {\n      if (_this.contentContainer) {\n        return _this.contentContainer.scrollTop;\n      }\n      return 0;\n    };\n    _this.syncScrollSticky = function (sticky) {\n      if (sticky && _this.contentContainer) {\n        sticky.syncScroll(_this.contentContainer);\n      }\n    };\n    _this._getScrollablePaneContext = function () {\n      return {\n        scrollablePane: {\n          subscribe: _this.subscribe,\n          unsubscribe: _this.unsubscribe,\n          addSticky: _this.addSticky,\n          removeSticky: _this.removeSticky,\n          updateStickyRefHeights: _this.updateStickyRefHeights,\n          sortSticky: _this.sortSticky,\n          notifySubscribers: _this.notifySubscribers,\n          syncScrollSticky: _this.syncScrollSticky\n        }\n      };\n    };\n    _this._addToStickyContainer = function (sticky, stickyContainer, stickyContentToAdd) {\n      // If there's no children, append child to list, otherwise, sort though array and append at correct position\n      if (!stickyContainer.children.length) {\n        stickyContainer.appendChild(stickyContentToAdd);\n      } else {\n        // If stickyContentToAdd isn't a child element of target container, then append\n        if (!stickyContainer.contains(stickyContentToAdd)) {\n          var stickyChildrenElements_1 = [].slice.call(stickyContainer.children);\n          var stickyList_1 = [];\n          // Get stickies.  Filter by canStickyTop/Bottom, then sort by distance from top, and then\n          // filter by elements that are in the stickyContainer already.\n          _this._stickies.forEach(function (stickyItem) {\n            if (stickyContainer === _this.stickyAbove && sticky.canStickyTop) {\n              stickyList_1.push(stickyItem);\n            } else if (sticky.canStickyBottom) {\n              stickyList_1.push(stickyItem);\n            }\n          });\n          var stickyListSorted = stickyList_1.sort(function (a, b) {\n            return (a.state.distanceFromTop || 0) - (b.state.distanceFromTop || 0);\n          }).filter(function (item) {\n            var stickyContent = stickyContainer === _this.stickyAbove ? item.stickyContentTop : item.stickyContentBottom;\n            if (stickyContent) {\n              return stickyChildrenElements_1.indexOf(stickyContent) > -1;\n            }\n            return false;\n          });\n          // Get first element that has a distance from top that is further than our sticky that is being added\n          var targetStickyToAppendBefore = undefined;\n          for (var _i = 0, stickyListSorted_1 = stickyListSorted; _i < stickyListSorted_1.length; _i++) {\n            var stickyListItem = stickyListSorted_1[_i];\n            if ((stickyListItem.state.distanceFromTop || 0) >= (sticky.state.distanceFromTop || 0)) {\n              targetStickyToAppendBefore = stickyListItem;\n              break;\n            }\n          }\n          // If target element to append before is known, grab respective stickyContentTop/Bottom element\n          // and insert before\n          var targetContainer = null;\n          if (targetStickyToAppendBefore) {\n            targetContainer = stickyContainer === _this.stickyAbove ? targetStickyToAppendBefore.stickyContentTop : targetStickyToAppendBefore.stickyContentBottom;\n          }\n          stickyContainer.insertBefore(stickyContentToAdd, targetContainer);\n        }\n      }\n    };\n    _this._removeStickyFromContainers = function (sticky) {\n      if (_this.stickyAbove && sticky.stickyContentTop && _this.stickyAbove.contains(sticky.stickyContentTop)) {\n        _this.stickyAbove.removeChild(sticky.stickyContentTop);\n      }\n      if (_this.stickyBelow && sticky.stickyContentBottom && _this.stickyBelow.contains(sticky.stickyContentBottom)) {\n        _this.stickyBelow.removeChild(sticky.stickyContentBottom);\n      }\n    };\n    _this._onWindowResize = function () {\n      var scrollbarWidth = _this._getScrollbarWidth();\n      var scrollbarHeight = _this._getScrollbarHeight();\n      _this.setState({\n        scrollbarWidth: scrollbarWidth,\n        scrollbarHeight: scrollbarHeight\n      });\n      _this.notifySubscribers();\n    };\n    _this._getStickyContainerStyle = function (height, isTop) {\n      return __assign(__assign({\n        height: height\n      }, getRTL(_this.props.theme) ? {\n        right: '0',\n        left: (_this.state.scrollbarWidth || _this._getScrollbarWidth() || 0) + \"px\"\n      } : {\n        left: '0',\n        right: (_this.state.scrollbarWidth || _this._getScrollbarWidth() || 0) + \"px\"\n      }), isTop ? {\n        top: '0'\n      } : {\n        bottom: (_this.state.scrollbarHeight || _this._getScrollbarHeight() || 0) + \"px\"\n      });\n    };\n    _this._onScroll = function () {\n      var contentContainer = _this.contentContainer;\n      if (contentContainer) {\n        _this._stickies.forEach(function (sticky) {\n          sticky.syncScroll(contentContainer);\n        });\n      }\n      _this._notifyThrottled();\n    };\n    _this._subscribers = new Set();\n    _this._stickies = new Set();\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this.state = {\n      stickyTopHeight: 0,\n      stickyBottomHeight: 0,\n      scrollbarWidth: 0,\n      scrollbarHeight: 0\n    };\n    _this._notifyThrottled = _this._async.throttle(_this.notifySubscribers, 50);\n    return _this;\n  }\n  Object.defineProperty(ScrollablePaneBase.prototype, \"root\", {\n    get: function () {\n      return this._root.current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"stickyAbove\", {\n    get: function () {\n      return this._stickyAboveRef.current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"stickyBelow\", {\n    get: function () {\n      return this._stickyBelowRef.current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"contentContainer\", {\n    get: function () {\n      return this._contentContainer.current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  ScrollablePaneBase.prototype.componentDidMount = function () {\n    var _this = this;\n    var initialScrollPosition = this.props.initialScrollPosition;\n    this._events.on(this.contentContainer, 'scroll', this._onScroll);\n    this._events.on(window, 'resize', this._onWindowResize);\n    if (this.contentContainer && initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    }\n    // Set sticky distances from top property, then sort in correct order and notify subscribers\n    this.setStickiesDistanceFromTop();\n    this._stickies.forEach(function (sticky) {\n      _this.sortSticky(sticky);\n    });\n    this.notifySubscribers();\n    if ('MutationObserver' in window) {\n      this._mutationObserver = new MutationObserver(function (mutation) {\n        // Function to check if mutation is occuring in stickyAbove or stickyBelow\n        function checkIfMutationIsSticky(mutationRecord) {\n          if (this.stickyAbove !== null && this.stickyBelow !== null) {\n            return this.stickyAbove.contains(mutationRecord.target) || this.stickyBelow.contains(mutationRecord.target);\n          }\n          return false;\n        }\n        // Compute the scrollbar height, which might have changed if the content's width changed and caused overflow\n        var scrollbarHeight = _this._getScrollbarHeight();\n        // If the scrollbar height changed, update state so it's postioned correctly below sticky footer\n        if (scrollbarHeight !== _this.state.scrollbarHeight) {\n          _this.setState({\n            scrollbarHeight: scrollbarHeight\n          });\n        }\n        // Notify subscribers again to re-check whether Sticky should be Sticky'd or not\n        _this.notifySubscribers();\n        // If mutation occurs in sticky header or footer, then update sticky top/bottom heights\n        if (mutation.some(checkIfMutationIsSticky.bind(_this))) {\n          _this.updateStickyRefHeights();\n        } else {\n          // If mutation occurs in scrollable region, then find Sticky it belongs to and force update\n          var stickyList_2 = [];\n          _this._stickies.forEach(function (sticky) {\n            if (sticky.root && sticky.root.contains(mutation[0].target)) {\n              stickyList_2.push(sticky);\n            }\n          });\n          if (stickyList_2.length) {\n            stickyList_2.forEach(function (sticky) {\n              sticky.forceUpdate();\n            });\n          }\n        }\n      });\n      if (this.root) {\n        this._mutationObserver.observe(this.root, {\n          childList: true,\n          attributes: true,\n          subtree: true,\n          characterData: true\n        });\n      }\n    }\n  };\n  ScrollablePaneBase.prototype.componentWillUnmount = function () {\n    this._events.dispose();\n    this._async.dispose();\n    if (this._mutationObserver) {\n      this._mutationObserver.disconnect();\n    }\n  };\n  // Only updates if props/state change, just to prevent excessive setState with updateStickyRefHeights\n  ScrollablePaneBase.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    return this.props.children !== nextProps.children || this.props.initialScrollPosition !== nextProps.initialScrollPosition || this.props.className !== nextProps.className || this.state.stickyTopHeight !== nextState.stickyTopHeight || this.state.stickyBottomHeight !== nextState.stickyBottomHeight || this.state.scrollbarWidth !== nextState.scrollbarWidth || this.state.scrollbarHeight !== nextState.scrollbarHeight;\n  };\n  ScrollablePaneBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var initialScrollPosition = this.props.initialScrollPosition;\n    if (this.contentContainer && typeof initialScrollPosition === 'number' && prevProps.initialScrollPosition !== initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    }\n    // Update subscribers when stickyTopHeight/stickyBottomHeight changes\n    if (prevState.stickyTopHeight !== this.state.stickyTopHeight || prevState.stickyBottomHeight !== this.state.stickyBottomHeight) {\n      this.notifySubscribers();\n    }\n    this._async.setTimeout(this._onWindowResize, 0);\n  };\n  ScrollablePaneBase.prototype.render = function () {\n    var _a = this.props,\n      className = _a.className,\n      theme = _a.theme,\n      styles = _a.styles;\n    var _b = this.state,\n      stickyTopHeight = _b.stickyTopHeight,\n      stickyBottomHeight = _b.stickyBottomHeight;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      scrollbarVisibility: this.props.scrollbarVisibility\n    });\n    return React.createElement(\"div\", __assign({}, getNativeProps(this.props, divProperties), {\n      ref: this._root,\n      className: classNames.root\n    }), React.createElement(\"div\", {\n      ref: this._stickyAboveRef,\n      className: classNames.stickyAbove,\n      style: this._getStickyContainerStyle(stickyTopHeight, true)\n    }), React.createElement(\"div\", {\n      ref: this._contentContainer,\n      className: classNames.contentContainer,\n      \"data-is-scrollable\": true\n    }, React.createElement(ScrollablePaneContext.Provider, {\n      value: this._getScrollablePaneContext()\n    }, this.props.children)), React.createElement(\"div\", {\n      className: classNames.stickyBelow,\n      style: this._getStickyContainerStyle(stickyBottomHeight, false)\n    }, React.createElement(\"div\", {\n      ref: this._stickyBelowRef,\n      className: classNames.stickyBelowItems\n    })));\n  };\n  ScrollablePaneBase.prototype.setStickiesDistanceFromTop = function () {\n    var _this = this;\n    if (this.contentContainer) {\n      this._stickies.forEach(function (sticky) {\n        sticky.setDistanceFromTop(_this.contentContainer);\n      });\n    }\n  };\n  ScrollablePaneBase.prototype.forceLayoutUpdate = function () {\n    this._onWindowResize();\n  };\n  ScrollablePaneBase.prototype._checkStickyStatus = function (sticky) {\n    if (this.stickyAbove && this.stickyBelow && this.contentContainer && sticky.nonStickyContent) {\n      // If sticky is sticky, then append content to appropriate container\n      if (sticky.state.isStickyTop || sticky.state.isStickyBottom) {\n        if (sticky.state.isStickyTop && !this.stickyAbove.contains(sticky.nonStickyContent) && sticky.stickyContentTop) {\n          sticky.addSticky(sticky.stickyContentTop);\n        }\n        if (sticky.state.isStickyBottom && !this.stickyBelow.contains(sticky.nonStickyContent) && sticky.stickyContentBottom) {\n          sticky.addSticky(sticky.stickyContentBottom);\n        }\n      } else if (!this.contentContainer.contains(sticky.nonStickyContent)) {\n        // Reset sticky if it's not sticky and not in the contentContainer element\n        sticky.resetSticky();\n      }\n    }\n  };\n  ScrollablePaneBase.prototype._getScrollbarWidth = function () {\n    var contentContainer = this.contentContainer;\n    return contentContainer ? contentContainer.offsetWidth - contentContainer.clientWidth : 0;\n  };\n  ScrollablePaneBase.prototype._getScrollbarHeight = function () {\n    var contentContainer = this.contentContainer;\n    return contentContainer ? contentContainer.offsetHeight - contentContainer.clientHeight : 0;\n  };\n  return ScrollablePaneBase;\n}(React.Component);\nexport { ScrollablePaneBase };","map":{"version":3,"sources":["components/ScrollablePane/ScrollablePane.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  EventGroup,\n  classNamesFunction,\n  divProperties,\n  getNativeProps,\n  getRTL,\n  initializeComponentRef,\n} from '../../Utilities';\nimport {\n  IScrollablePane,\n  IScrollablePaneContext,\n  IScrollablePaneProps,\n  IScrollablePaneStyleProps,\n  IScrollablePaneStyles,\n  ScrollablePaneContext,\n} from './ScrollablePane.types';\nimport { Sticky } from '../../Sticky';\n\nexport interface IScrollablePaneState {\n  stickyTopHeight: number;\n  stickyBottomHeight: number;\n  scrollbarWidth: number;\n  scrollbarHeight: number;\n}\n\nconst getClassNames = classNamesFunction<IScrollablePaneStyleProps, IScrollablePaneStyles>();\n\nexport class ScrollablePaneBase extends React.Component<IScrollablePaneProps, IScrollablePaneState>\n  implements IScrollablePane {\n  private _root = React.createRef<HTMLDivElement>();\n  private _stickyAboveRef = React.createRef<HTMLDivElement>();\n  private _stickyBelowRef = React.createRef<HTMLDivElement>();\n  private _contentContainer = React.createRef<HTMLDivElement>();\n  private _subscribers: Set<Function>;\n  private _stickies: Set<Sticky>;\n  private _mutationObserver: MutationObserver;\n  private _notifyThrottled: () => void;\n  private _async: Async;\n  private _events: EventGroup;\n\n  constructor(props: IScrollablePaneProps) {\n    super(props);\n    this._subscribers = new Set<Function>();\n    this._stickies = new Set<Sticky>();\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    this.state = {\n      stickyTopHeight: 0,\n      stickyBottomHeight: 0,\n      scrollbarWidth: 0,\n      scrollbarHeight: 0,\n    };\n\n    this._notifyThrottled = this._async.throttle(this.notifySubscribers, 50);\n  }\n\n  public get root(): HTMLDivElement | null {\n    return this._root.current;\n  }\n\n  public get stickyAbove(): HTMLDivElement | null {\n    return this._stickyAboveRef.current;\n  }\n\n  public get stickyBelow(): HTMLDivElement | null {\n    return this._stickyBelowRef.current;\n  }\n\n  public get contentContainer(): HTMLDivElement | null {\n    return this._contentContainer.current;\n  }\n\n  public componentDidMount() {\n    const { initialScrollPosition } = this.props;\n    this._events.on(this.contentContainer, 'scroll', this._onScroll);\n    this._events.on(window, 'resize', this._onWindowResize);\n    if (this.contentContainer && initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    }\n\n    // Set sticky distances from top property, then sort in correct order and notify subscribers\n    this.setStickiesDistanceFromTop();\n    this._stickies.forEach(sticky => {\n      this.sortSticky(sticky);\n    });\n    this.notifySubscribers();\n\n    if ('MutationObserver' in window) {\n      this._mutationObserver = new MutationObserver(mutation => {\n        // Function to check if mutation is occuring in stickyAbove or stickyBelow\n        function checkIfMutationIsSticky(mutationRecord: MutationRecord): boolean {\n          if (this.stickyAbove !== null && this.stickyBelow !== null) {\n            return this.stickyAbove.contains(mutationRecord.target) || this.stickyBelow.contains(mutationRecord.target);\n          }\n          return false;\n        }\n\n        // Compute the scrollbar height, which might have changed if the content's width changed and caused overflow\n        const scrollbarHeight = this._getScrollbarHeight();\n        // If the scrollbar height changed, update state so it's postioned correctly below sticky footer\n        if (scrollbarHeight !== this.state.scrollbarHeight) {\n          this.setState({\n            scrollbarHeight: scrollbarHeight,\n          });\n        }\n\n        // Notify subscribers again to re-check whether Sticky should be Sticky'd or not\n        this.notifySubscribers();\n\n        // If mutation occurs in sticky header or footer, then update sticky top/bottom heights\n        if (mutation.some(checkIfMutationIsSticky.bind(this))) {\n          this.updateStickyRefHeights();\n        } else {\n          // If mutation occurs in scrollable region, then find Sticky it belongs to and force update\n          const stickyList: Sticky[] = [];\n          this._stickies.forEach(sticky => {\n            if (sticky.root && sticky.root.contains(mutation[0].target)) {\n              stickyList.push(sticky);\n            }\n          });\n          if (stickyList.length) {\n            stickyList.forEach(sticky => {\n              sticky.forceUpdate();\n            });\n          }\n        }\n      });\n\n      if (this.root) {\n        this._mutationObserver.observe(this.root, {\n          childList: true,\n          attributes: true,\n          subtree: true,\n          characterData: true,\n        });\n      }\n    }\n  }\n\n  public componentWillUnmount() {\n    this._events.dispose();\n    this._async.dispose();\n\n    if (this._mutationObserver) {\n      this._mutationObserver.disconnect();\n    }\n  }\n\n  // Only updates if props/state change, just to prevent excessive setState with updateStickyRefHeights\n  public shouldComponentUpdate(nextProps: IScrollablePaneProps, nextState: IScrollablePaneState): boolean {\n    return (\n      this.props.children !== nextProps.children ||\n      this.props.initialScrollPosition !== nextProps.initialScrollPosition ||\n      this.props.className !== nextProps.className ||\n      this.state.stickyTopHeight !== nextState.stickyTopHeight ||\n      this.state.stickyBottomHeight !== nextState.stickyBottomHeight ||\n      this.state.scrollbarWidth !== nextState.scrollbarWidth ||\n      this.state.scrollbarHeight !== nextState.scrollbarHeight\n    );\n  }\n\n  public componentDidUpdate(prevProps: IScrollablePaneProps, prevState: IScrollablePaneState) {\n    const initialScrollPosition = this.props.initialScrollPosition;\n    if (\n      this.contentContainer &&\n      typeof initialScrollPosition === 'number' &&\n      prevProps.initialScrollPosition !== initialScrollPosition\n    ) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    }\n\n    // Update subscribers when stickyTopHeight/stickyBottomHeight changes\n    if (\n      prevState.stickyTopHeight !== this.state.stickyTopHeight ||\n      prevState.stickyBottomHeight !== this.state.stickyBottomHeight\n    ) {\n      this.notifySubscribers();\n    }\n\n    this._async.setTimeout(this._onWindowResize, 0);\n  }\n\n  public render(): JSX.Element {\n    const { className, theme, styles } = this.props;\n    const { stickyTopHeight, stickyBottomHeight } = this.state;\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      scrollbarVisibility: this.props.scrollbarVisibility,\n    });\n\n    return (\n      <div {...getNativeProps(this.props, divProperties)} ref={this._root} className={classNames.root}>\n        <div\n          ref={this._stickyAboveRef}\n          className={classNames.stickyAbove}\n          style={this._getStickyContainerStyle(stickyTopHeight, true)}\n        />\n        <div ref={this._contentContainer} className={classNames.contentContainer} data-is-scrollable={true}>\n          <ScrollablePaneContext.Provider value={this._getScrollablePaneContext()}>\n            {this.props.children}\n          </ScrollablePaneContext.Provider>\n        </div>\n        <div className={classNames.stickyBelow} style={this._getStickyContainerStyle(stickyBottomHeight, false)}>\n          <div ref={this._stickyBelowRef} className={classNames.stickyBelowItems} />\n        </div>\n      </div>\n    );\n  }\n\n  public setStickiesDistanceFromTop(): void {\n    if (this.contentContainer) {\n      this._stickies.forEach(sticky => {\n        sticky.setDistanceFromTop(this.contentContainer as HTMLDivElement);\n      });\n    }\n  }\n\n  public forceLayoutUpdate() {\n    this._onWindowResize();\n  }\n\n  public subscribe = (handler: Function): void => {\n    this._subscribers.add(handler);\n  };\n\n  public unsubscribe = (handler: Function): void => {\n    this._subscribers.delete(handler);\n  };\n\n  public addSticky = (sticky: Sticky): void => {\n    this._stickies.add(sticky);\n\n    // If ScrollablePane is mounted, then sort sticky in correct place\n    if (this.contentContainer) {\n      sticky.setDistanceFromTop(this.contentContainer);\n      this.sortSticky(sticky);\n    }\n  };\n\n  public removeSticky = (sticky: Sticky): void => {\n    this._stickies.delete(sticky);\n    this._removeStickyFromContainers(sticky);\n    this.notifySubscribers();\n  };\n\n  public sortSticky = (sticky: Sticky, sortAgain?: boolean): void => {\n    if (this.stickyAbove && this.stickyBelow) {\n      if (sortAgain) {\n        this._removeStickyFromContainers(sticky);\n      }\n      if (sticky.canStickyTop && sticky.stickyContentTop) {\n        this._addToStickyContainer(sticky, this.stickyAbove, sticky.stickyContentTop);\n      }\n\n      if (sticky.canStickyBottom && sticky.stickyContentBottom) {\n        this._addToStickyContainer(sticky, this.stickyBelow, sticky.stickyContentBottom);\n      }\n    }\n  };\n\n  public updateStickyRefHeights = (): void => {\n    const stickyItems = this._stickies;\n\n    let stickyTopHeight = 0;\n    let stickyBottomHeight = 0;\n\n    stickyItems.forEach((sticky: Sticky) => {\n      const { isStickyTop, isStickyBottom } = sticky.state;\n      if (sticky.nonStickyContent) {\n        if (isStickyTop) {\n          stickyTopHeight += sticky.nonStickyContent.offsetHeight;\n        }\n        if (isStickyBottom) {\n          stickyBottomHeight += sticky.nonStickyContent.offsetHeight;\n        }\n        this._checkStickyStatus(sticky);\n      }\n    });\n\n    this.setState({\n      stickyTopHeight: stickyTopHeight,\n      stickyBottomHeight: stickyBottomHeight,\n    });\n  };\n\n  public notifySubscribers = (): void => {\n    if (this.contentContainer) {\n      this._subscribers.forEach(handle => {\n        // this.stickyBelow is passed in for calculating distance to determine Sticky status\n        handle(this.contentContainer, this.stickyBelow);\n      });\n    }\n  };\n\n  public getScrollPosition = (): number => {\n    if (this.contentContainer) {\n      return this.contentContainer.scrollTop;\n    }\n\n    return 0;\n  };\n\n  public syncScrollSticky = (sticky: Sticky): void => {\n    if (sticky && this.contentContainer) {\n      sticky.syncScroll(this.contentContainer);\n    }\n  };\n\n  private _getScrollablePaneContext = (): IScrollablePaneContext => {\n    return {\n      scrollablePane: {\n        subscribe: this.subscribe,\n        unsubscribe: this.unsubscribe,\n        addSticky: this.addSticky,\n        removeSticky: this.removeSticky,\n        updateStickyRefHeights: this.updateStickyRefHeights,\n        sortSticky: this.sortSticky,\n        notifySubscribers: this.notifySubscribers,\n        syncScrollSticky: this.syncScrollSticky,\n      },\n    };\n  };\n\n  private _checkStickyStatus(sticky: Sticky): void {\n    if (this.stickyAbove && this.stickyBelow && this.contentContainer && sticky.nonStickyContent) {\n      // If sticky is sticky, then append content to appropriate container\n      if (sticky.state.isStickyTop || sticky.state.isStickyBottom) {\n        if (\n          sticky.state.isStickyTop &&\n          !this.stickyAbove.contains(sticky.nonStickyContent) &&\n          sticky.stickyContentTop\n        ) {\n          sticky.addSticky(sticky.stickyContentTop);\n        }\n\n        if (\n          sticky.state.isStickyBottom &&\n          !this.stickyBelow.contains(sticky.nonStickyContent) &&\n          sticky.stickyContentBottom\n        ) {\n          sticky.addSticky(sticky.stickyContentBottom);\n        }\n      } else if (!this.contentContainer.contains(sticky.nonStickyContent)) {\n        // Reset sticky if it's not sticky and not in the contentContainer element\n        sticky.resetSticky();\n      }\n    }\n  }\n\n  private _addToStickyContainer = (\n    sticky: Sticky,\n    stickyContainer: HTMLDivElement,\n    stickyContentToAdd: HTMLDivElement,\n  ): void => {\n    // If there's no children, append child to list, otherwise, sort though array and append at correct position\n    if (!stickyContainer.children.length) {\n      stickyContainer.appendChild(stickyContentToAdd);\n    } else {\n      // If stickyContentToAdd isn't a child element of target container, then append\n      if (!stickyContainer.contains(stickyContentToAdd)) {\n        const stickyChildrenElements: Element[] = [].slice.call(stickyContainer.children);\n\n        const stickyList: Sticky[] = [];\n        // Get stickies.  Filter by canStickyTop/Bottom, then sort by distance from top, and then\n        // filter by elements that are in the stickyContainer already.\n        this._stickies.forEach(stickyItem => {\n          if (stickyContainer === this.stickyAbove && sticky.canStickyTop) {\n            stickyList.push(stickyItem);\n          } else if (sticky.canStickyBottom) {\n            stickyList.push(stickyItem);\n          }\n        });\n\n        const stickyListSorted = stickyList\n          .sort((a, b) => {\n            return (a.state.distanceFromTop || 0) - (b.state.distanceFromTop || 0);\n          })\n          .filter(item => {\n            const stickyContent =\n              stickyContainer === this.stickyAbove ? item.stickyContentTop : item.stickyContentBottom;\n            if (stickyContent) {\n              return stickyChildrenElements.indexOf(stickyContent) > -1;\n            }\n            return false;\n          });\n\n        // Get first element that has a distance from top that is further than our sticky that is being added\n        let targetStickyToAppendBefore: Sticky | undefined = undefined;\n        for (const stickyListItem of stickyListSorted) {\n          if ((stickyListItem.state.distanceFromTop || 0) >= (sticky.state.distanceFromTop || 0)) {\n            targetStickyToAppendBefore = stickyListItem;\n            break;\n          }\n        }\n\n        // If target element to append before is known, grab respective stickyContentTop/Bottom element\n        // and insert before\n        let targetContainer: HTMLDivElement | null = null;\n        if (targetStickyToAppendBefore) {\n          targetContainer =\n            stickyContainer === this.stickyAbove\n              ? targetStickyToAppendBefore.stickyContentTop\n              : targetStickyToAppendBefore.stickyContentBottom;\n        }\n        stickyContainer.insertBefore(stickyContentToAdd, targetContainer);\n      }\n    }\n  };\n\n  private _removeStickyFromContainers = (sticky: Sticky): void => {\n    if (this.stickyAbove && sticky.stickyContentTop && this.stickyAbove.contains(sticky.stickyContentTop)) {\n      this.stickyAbove.removeChild(sticky.stickyContentTop);\n    }\n    if (this.stickyBelow && sticky.stickyContentBottom && this.stickyBelow.contains(sticky.stickyContentBottom)) {\n      this.stickyBelow.removeChild(sticky.stickyContentBottom);\n    }\n  };\n\n  private _onWindowResize = (): void => {\n    const scrollbarWidth = this._getScrollbarWidth();\n    const scrollbarHeight = this._getScrollbarHeight();\n\n    this.setState({\n      scrollbarWidth,\n      scrollbarHeight,\n    });\n\n    this.notifySubscribers();\n  };\n\n  private _getStickyContainerStyle = (height: number, isTop: boolean): React.CSSProperties => {\n    return {\n      height: height,\n      ...(getRTL(this.props.theme)\n        ? {\n            right: '0',\n            left: `${this.state.scrollbarWidth || this._getScrollbarWidth() || 0}px`,\n          }\n        : {\n            left: '0',\n            right: `${this.state.scrollbarWidth || this._getScrollbarWidth() || 0}px`,\n          }),\n      ...(isTop\n        ? {\n            top: '0',\n          }\n        : {\n            bottom: `${this.state.scrollbarHeight || this._getScrollbarHeight() || 0}px`,\n          }),\n    };\n  };\n\n  private _getScrollbarWidth(): number {\n    const { contentContainer } = this;\n    return contentContainer ? contentContainer.offsetWidth - contentContainer.clientWidth : 0;\n  }\n\n  private _getScrollbarHeight(): number {\n    const { contentContainer } = this;\n    return contentContainer ? contentContainer.offsetHeight - contentContainer.clientHeight : 0;\n  }\n\n  private _onScroll = () => {\n    const { contentContainer } = this;\n\n    if (contentContainer) {\n      this._stickies.forEach((sticky: Sticky) => {\n        sticky.syncScroll(contentContainer);\n      });\n    }\n\n    this._notifyThrottled();\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}