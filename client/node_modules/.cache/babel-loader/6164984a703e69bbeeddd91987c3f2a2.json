{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, getNativeProps, imgProperties } from '../../Utilities';\nimport { ImageCoverStyle, ImageFit, ImageLoadState } from './Image.types';\nvar getClassNames = classNamesFunction();\nvar KEY_PREFIX = 'fabricImage';\nvar ImageBase = /** @class */function (_super) {\n  __extends(ImageBase, _super);\n  function ImageBase(props) {\n    var _this = _super.call(this, props) || this;\n    // Make an initial assumption about the image layout until we can\n    // check the rendered element. The value here only takes effect when\n    // shouldStartVisible is true.\n    _this._coverStyle = ImageCoverStyle.portrait;\n    _this._imageElement = React.createRef();\n    _this._frameElement = React.createRef();\n    _this._onImageLoaded = function (ev) {\n      var _a = _this.props,\n        src = _a.src,\n        onLoad = _a.onLoad;\n      if (onLoad) {\n        onLoad(ev);\n      }\n      _this._computeCoverStyle(_this.props);\n      if (src) {\n        _this.setState({\n          loadState: ImageLoadState.loaded\n        });\n      }\n    };\n    _this._onImageError = function (ev) {\n      if (_this.props.onError) {\n        _this.props.onError(ev);\n      }\n      _this.setState({\n        loadState: ImageLoadState.error\n      });\n    };\n    _this.state = {\n      loadState: ImageLoadState.notLoaded\n    };\n    return _this;\n  }\n  ImageBase.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    if (nextProps.src !== this.props.src) {\n      this.setState({\n        loadState: ImageLoadState.notLoaded\n      });\n    } else if (this.state.loadState === ImageLoadState.loaded) {\n      this._computeCoverStyle(nextProps);\n    }\n  };\n  ImageBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    this._checkImageLoaded();\n    if (this.props.onLoadingStateChange && prevState.loadState !== this.state.loadState) {\n      this.props.onLoadingStateChange(this.state.loadState);\n    }\n  };\n  ImageBase.prototype.render = function () {\n    var imageProps = getNativeProps(this.props, imgProperties, ['width', 'height']);\n    var _a = this.props,\n      src = _a.src,\n      alt = _a.alt,\n      width = _a.width,\n      height = _a.height,\n      shouldFadeIn = _a.shouldFadeIn,\n      shouldStartVisible = _a.shouldStartVisible,\n      className = _a.className,\n      imageFit = _a.imageFit,\n      role = _a.role,\n      maximizeFrame = _a.maximizeFrame,\n      styles = _a.styles,\n      theme = _a.theme;\n    var loadState = this.state.loadState;\n    var coverStyle = this.props.coverStyle !== undefined ? this.props.coverStyle : this._coverStyle;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      width: width,\n      height: height,\n      maximizeFrame: maximizeFrame,\n      shouldFadeIn: shouldFadeIn,\n      shouldStartVisible: shouldStartVisible,\n      isLoaded: loadState === ImageLoadState.loaded || loadState === ImageLoadState.notLoaded && this.props.shouldStartVisible,\n      isLandscape: coverStyle === ImageCoverStyle.landscape,\n      isCenter: imageFit === ImageFit.center,\n      isCenterContain: imageFit === ImageFit.centerContain,\n      isCenterCover: imageFit === ImageFit.centerCover,\n      isContain: imageFit === ImageFit.contain,\n      isCover: imageFit === ImageFit.cover,\n      isNone: imageFit === ImageFit.none,\n      isError: loadState === ImageLoadState.error,\n      isNotImageFit: imageFit === undefined\n    });\n    // If image dimensions aren't specified, the natural size of the image is used.\n    return React.createElement(\"div\", {\n      className: classNames.root,\n      style: {\n        width: width,\n        height: height\n      },\n      ref: this._frameElement\n    }, React.createElement(\"img\", __assign({}, imageProps, {\n      onLoad: this._onImageLoaded,\n      onError: this._onImageError,\n      key: KEY_PREFIX + this.props.src || '',\n      className: classNames.image,\n      ref: this._imageElement,\n      src: src,\n      alt: alt,\n      role: role\n    })));\n  };\n  ImageBase.prototype._checkImageLoaded = function () {\n    var src = this.props.src;\n    var loadState = this.state.loadState;\n    if (loadState === ImageLoadState.notLoaded) {\n      // testing if naturalWidth and naturalHeight are greater than zero is better than checking\n      // .complete, because .complete will also be set to true if the image breaks. However,\n      // for some browsers, SVG images do not have a naturalWidth or naturalHeight, so fall back\n      // to checking .complete for these images.\n      var isLoaded = this._imageElement.current ? src && this._imageElement.current.naturalWidth > 0 && this._imageElement.current.naturalHeight > 0 || this._imageElement.current.complete && ImageBase._svgRegex.test(src) : false;\n      if (isLoaded) {\n        this._computeCoverStyle(this.props);\n        this.setState({\n          loadState: ImageLoadState.loaded\n        });\n      }\n    }\n  };\n  ImageBase.prototype._computeCoverStyle = function (props) {\n    var imageFit = props.imageFit,\n      width = props.width,\n      height = props.height;\n    // Do not compute cover style if it was already specified in props\n    if ((imageFit === ImageFit.cover || imageFit === ImageFit.contain || imageFit === ImageFit.centerContain || imageFit === ImageFit.centerCover) && this.props.coverStyle === undefined && this._imageElement.current && this._frameElement.current) {\n      // Determine the desired ratio using the width and height props.\n      // If those props aren't available, measure measure the frame.\n      var desiredRatio = void 0;\n      if (typeof width === 'number' && typeof height === 'number' && imageFit !== ImageFit.centerContain && imageFit !== ImageFit.centerCover) {\n        desiredRatio = width / height;\n      } else {\n        desiredRatio = this._frameElement.current.clientWidth / this._frameElement.current.clientHeight;\n      }\n      // Examine the source image to determine its original ratio.\n      var naturalRatio = this._imageElement.current.naturalWidth / this._imageElement.current.naturalHeight;\n      // Should we crop from the top or the sides?\n      if (naturalRatio > desiredRatio) {\n        this._coverStyle = ImageCoverStyle.landscape;\n      } else {\n        this._coverStyle = ImageCoverStyle.portrait;\n      }\n    }\n  };\n  ImageBase.defaultProps = {\n    shouldFadeIn: true\n  };\n  ImageBase._svgRegex = /\\.svg$/i;\n  return ImageBase;\n}(React.Component);\nexport { ImageBase };","map":{"version":3,"sources":["components/Image/Image.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { classNamesFunction, getNativeProps, imgProperties } from '../../Utilities';\nimport { IImageProps, IImageStyleProps, IImageStyles, ImageCoverStyle, ImageFit, ImageLoadState } from './Image.types';\n\nconst getClassNames = classNamesFunction<IImageStyleProps, IImageStyles>();\n\nexport interface IImageState {\n  loadState?: ImageLoadState;\n}\n\nconst KEY_PREFIX = 'fabricImage';\n\nexport class ImageBase extends React.Component<IImageProps, IImageState> {\n  public static defaultProps = {\n    shouldFadeIn: true,\n  };\n\n  private static _svgRegex = /\\.svg$/i;\n\n  // Make an initial assumption about the image layout until we can\n  // check the rendered element. The value here only takes effect when\n  // shouldStartVisible is true.\n  private _coverStyle: ImageCoverStyle = ImageCoverStyle.portrait;\n  private _imageElement = React.createRef<HTMLImageElement>();\n  private _frameElement = React.createRef<HTMLDivElement>();\n\n  constructor(props: IImageProps) {\n    super(props);\n\n    this.state = {\n      loadState: ImageLoadState.notLoaded,\n    };\n  }\n\n  public UNSAFE_componentWillReceiveProps(nextProps: IImageProps): void {\n    if (nextProps.src !== this.props.src) {\n      this.setState({\n        loadState: ImageLoadState.notLoaded,\n      });\n    } else if (this.state.loadState === ImageLoadState.loaded) {\n      this._computeCoverStyle(nextProps);\n    }\n  }\n\n  public componentDidUpdate(prevProps: IImageProps, prevState: IImageState) {\n    this._checkImageLoaded();\n    if (this.props.onLoadingStateChange && prevState.loadState !== this.state.loadState) {\n      this.props.onLoadingStateChange(this.state.loadState!);\n    }\n  }\n\n  public render(): JSX.Element {\n    const imageProps = getNativeProps<React.ImgHTMLAttributes<HTMLImageElement>>(this.props, imgProperties, [\n      'width',\n      'height',\n    ]);\n    const {\n      src,\n      alt,\n      width,\n      height,\n      shouldFadeIn,\n      shouldStartVisible,\n      className,\n      imageFit,\n      role,\n      maximizeFrame,\n      styles,\n      theme,\n    } = this.props;\n    const { loadState } = this.state;\n    const coverStyle = this.props.coverStyle !== undefined ? this.props.coverStyle : this._coverStyle;\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      width,\n      height,\n      maximizeFrame,\n      shouldFadeIn,\n      shouldStartVisible,\n      isLoaded:\n        loadState === ImageLoadState.loaded ||\n        (loadState === ImageLoadState.notLoaded && this.props.shouldStartVisible),\n      isLandscape: coverStyle === ImageCoverStyle.landscape,\n      isCenter: imageFit === ImageFit.center,\n      isCenterContain: imageFit === ImageFit.centerContain,\n      isCenterCover: imageFit === ImageFit.centerCover,\n      isContain: imageFit === ImageFit.contain,\n      isCover: imageFit === ImageFit.cover,\n      isNone: imageFit === ImageFit.none,\n      isError: loadState === ImageLoadState.error,\n      isNotImageFit: imageFit === undefined,\n    });\n\n    // If image dimensions aren't specified, the natural size of the image is used.\n    return (\n      <div className={classNames.root} style={{ width: width, height: height }} ref={this._frameElement}>\n        <img\n          {...imageProps}\n          onLoad={this._onImageLoaded}\n          onError={this._onImageError}\n          key={KEY_PREFIX + this.props.src || ''}\n          className={classNames.image}\n          ref={this._imageElement}\n          src={src}\n          alt={alt}\n          role={role}\n        />\n      </div>\n    );\n  }\n\n  private _onImageLoaded = (ev: React.SyntheticEvent<HTMLImageElement>): void => {\n    const { src, onLoad } = this.props;\n    if (onLoad) {\n      onLoad(ev);\n    }\n\n    this._computeCoverStyle(this.props);\n\n    if (src) {\n      this.setState({\n        loadState: ImageLoadState.loaded,\n      });\n    }\n  };\n\n  private _checkImageLoaded(): void {\n    const { src } = this.props;\n    const { loadState } = this.state;\n\n    if (loadState === ImageLoadState.notLoaded) {\n      // testing if naturalWidth and naturalHeight are greater than zero is better than checking\n      // .complete, because .complete will also be set to true if the image breaks. However,\n      // for some browsers, SVG images do not have a naturalWidth or naturalHeight, so fall back\n      // to checking .complete for these images.\n      const isLoaded: boolean = this._imageElement.current\n        ? (src && this._imageElement.current.naturalWidth > 0 && this._imageElement.current.naturalHeight > 0) ||\n          (this._imageElement.current.complete && ImageBase._svgRegex.test(src!))\n        : false;\n\n      if (isLoaded) {\n        this._computeCoverStyle(this.props);\n        this.setState({\n          loadState: ImageLoadState.loaded,\n        });\n      }\n    }\n  }\n\n  private _computeCoverStyle(props: IImageProps): void {\n    const { imageFit, width, height } = props;\n\n    // Do not compute cover style if it was already specified in props\n    if (\n      (imageFit === ImageFit.cover ||\n        imageFit === ImageFit.contain ||\n        imageFit === ImageFit.centerContain ||\n        imageFit === ImageFit.centerCover) &&\n      this.props.coverStyle === undefined &&\n      this._imageElement.current &&\n      this._frameElement.current\n    ) {\n      // Determine the desired ratio using the width and height props.\n      // If those props aren't available, measure measure the frame.\n      let desiredRatio;\n      if (\n        typeof width === 'number' &&\n        typeof height === 'number' &&\n        imageFit !== ImageFit.centerContain &&\n        imageFit !== ImageFit.centerCover\n      ) {\n        desiredRatio = width / height;\n      } else {\n        desiredRatio = this._frameElement.current.clientWidth / this._frameElement.current.clientHeight;\n      }\n\n      // Examine the source image to determine its original ratio.\n      const naturalRatio = this._imageElement.current.naturalWidth / this._imageElement.current.naturalHeight;\n\n      // Should we crop from the top or the sides?\n      if (naturalRatio > desiredRatio) {\n        this._coverStyle = ImageCoverStyle.landscape;\n      } else {\n        this._coverStyle = ImageCoverStyle.portrait;\n      }\n    }\n  }\n\n  private _onImageError = (ev: React.SyntheticEvent<HTMLImageElement>): void => {\n    if (this.props.onError) {\n      this.props.onError(ev);\n    }\n    this.setState({\n      loadState: ImageLoadState.error,\n    });\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}