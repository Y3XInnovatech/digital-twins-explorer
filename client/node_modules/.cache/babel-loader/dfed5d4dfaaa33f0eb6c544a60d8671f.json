{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst events_1 = require(\"events\");\nconst jsiterable_1 = __importDefault(require(\"jsiterable\"));\nconst edge_1 = __importDefault(require(\"./edge\"));\nconst graphIndex_1 = __importDefault(require(\"./graphIndex\"));\nconst vertex_1 = __importStar(require(\"./vertex\"));\nclass JsonldGraph extends events_1.EventEmitter {\n  /**\n   * Creates an instance of JsonLdGraph.\n   * @memberof JsonLdGraph\n   */\n  constructor(contexts) {\n    super();\n    this._index = new graphIndex_1.default();\n    this._index.on('edgeCreated', indexEdge => this.emit('edgeAdded', new edge_1.default(indexEdge, this._index)));\n    this._index.on('edgeDeleted', indexEdge => this.emit('edgeRemoved', new edge_1.default(indexEdge, this._index)));\n    this._index.on('nodeCreated', indexNode => this.emit('vertexAdded', new vertex_1.default(indexNode, this._index)));\n    this._index.on('nodeDeleted', indexNode => this.emit('vertexRemoved', new vertex_1.default(indexNode, this._index)));\n    this._index.on('nodeIdChanged', (indexNode, previousId) => this.emit('vertexIdChanged', new vertex_1.default(indexNode, this._index), previousId));\n    if (contexts && contexts.length > 0) {\n      for (const {\n        uri,\n        context\n      } of contexts) {\n        this._index.addContext(uri, context);\n      }\n    }\n  }\n  /**\n   * @description Gets the contexts registered with the graph.\n   * @readonly\n   * @type {Iterable<[string, any]>}\n   * @memberof JsonldGraph\n   */\n  get contexts() {\n    return this._index.contexts;\n  }\n  /**\n   * @description Gets the count of edges in the graph.\n   * @readonly\n   * @type {number}\n   * @memberof JsonLdGraph\n   */\n  get edgeCount() {\n    return this._index.edgeCount;\n  }\n  /**\n   * @description Gets the count of vertices in the graph.\n   * @readonly\n   * @type {number}\n   * @memberof JsonLdGraph\n   */\n  get vertexCount() {\n    return this._index.nodeCount;\n  }\n  /**\n   * @description Adds a context.\n   * @param {string} uri The uri of the context to add.\n   * @param {*} context The context object.\n   * @memberof JsonLdGraph\n   */\n  addContext(uri, context) {\n    this._index.addContext(uri, context);\n  }\n  /**\n   * @description Adds a prefix to the graph that allows accessing and creating edges & vertices using short ids containing the prefix.\n   * @param {string} prefix The prefix to add.\n   * @param {string} uri A valid URI that the prefix maps to.\n   * @memberof JsonldGraph\n   */\n  addPrefix(prefix, uri) {\n    this._index.addPrefix(prefix, uri);\n  }\n  /**\n   * @description Creates a new vertex.\n   * @param {string} id Id of the vertex to create.\n   * @returns {Vertex}\n   * @memberof JsonLdGraph\n   */\n  createVertex(id) {\n    if (!id) {\n      throw new ReferenceError(`Invalid id. id is ${id}`);\n    }\n    const existing = this._index.getNode(id);\n    if (existing) {\n      return new vertex_1.default(existing, this._index);\n    } else {\n      const node = this._index.createNode(id);\n      return new vertex_1.default(node, this._index);\n    }\n  }\n  /**\n   * @description Gets edges in the graph.\n   * @param {string} [label] Optional label to filter only edges with the specified label.\n   * @returns {Iterable<Edge>}\n   * @memberof JsonLdGraph\n   */\n  getEdges(label) {\n    return new jsiterable_1.default(this._index.getEdges(label)).map(x => new edge_1.default(x, this._index));\n  }\n  /**\n   * @description Gets all vertices with the specified incoming edge.\n   * @param {string} edgeLabel The label of the incoming edge.\n   * @param {(string | VertexSelector)} [vertexSelector] Optional vertex selector that is used to filter only matching vertices.\n   * @returns {Iterable<Vertex>}\n   * @memberof JsonLdGraph\n   */\n  getIncoming(edgeLabel, vertexSelector) {\n    if (!edgeLabel) {\n      throw new ReferenceError(`Invalid edgeLabel. edgeLabel is ${edgeLabel}`);\n    }\n    const filter = new vertex_1.VertexFilter(vertexSelector);\n    return new jsiterable_1.default(this._index.getEdgeIncoming(edgeLabel)).map(node => new vertex_1.default(node, this._index)).filter(vertex => filter.match(vertex));\n  }\n  /**\n   * @description Gets all vertices with the specified outgoing edge.\n   * @param {string} edgeLabel The label of the outgoing edge.\n   * @param {(string | VertexSelector)} [vertexSelector] Optional vertex selector that is used to filter only matching vertices.\n   * @returns {Iterable<Vertex}\n   * @memberof JsonLdGraph\n   */\n  getOutgoing(edgeLabel, vertexSelector) {\n    if (!edgeLabel) {\n      throw new ReferenceError(`Invalid edgeLabel. edgeLabel is ${edgeLabel}`);\n    }\n    const filter = new vertex_1.VertexFilter(vertexSelector);\n    return new jsiterable_1.default(this._index.getEdgeOutgoing(edgeLabel)).map(node => new vertex_1.default(node, this._index)).filter(vertex => filter.match(vertex));\n  }\n  /**\n   * @description Gets all vertices in the graph.\n   * @param {VertexSelector} [vertexSelector] Optional vertex selector that is used to filter only matching vertices.\n   * @returns {Iterable<Vertex>}\n   * @memberof JsonLdGraph\n   */\n  getVertices(vertexSelector) {\n    const filter = new vertex_1.VertexFilter(vertexSelector);\n    return new jsiterable_1.default(this._index.getNodes()).map(node => new vertex_1.default(node, this._index)).filter(vertex => filter.match(vertex));\n  }\n  /**\n   * @description Gets a specific vertex in the graph.\n   * @param {string} id Id of the vertex to get.\n   * @returns {Vertex}\n   * @memberof JsonLdGraph\n   */\n  getVertex(id) {\n    if (!id) {\n      throw new ReferenceError(`Invalid id. id is ${id}`);\n    }\n    const node = this._index.getNode(id);\n    if (!node) {\n      return null;\n    } else {\n      return new vertex_1.default(node, this._index);\n    }\n  }\n  /**\n   * @description Checks if a edge exists.\n   * @param {string} label The label of the edge.\n   * @param {string} fromVertexId The outgoing vertex id.\n   * @param {string} toVertexId The incoming vertex id.\n   * @returns {boolean}\n   * @memberof JsonLdGraph\n   */\n  hasEdge(label, fromVertexId, toVertexId) {\n    return this._index.hasEdge(label, fromVertexId, toVertexId);\n  }\n  /**\n   * @description Checks if a vertex exists.\n   * @param {string} id The id of the vertex to check.\n   * @returns {boolean}\n   * @memberof JsonLdGraph\n   */\n  hasVertex(id) {\n    return this._index.hasNode(id);\n  }\n  /**\n   * @description Loads one or more documents into the graph.\n   * @param {(any | any[])} inputs Input documents to load into the graph.\n   * @param {string|string[]|object|object[]} [contexts] Optional contexts to use for importing the documents.\n   * @param {string} [base] Optional base IRI of the inputs.\n   * @returns {Promise<Set<string>>} A set containing all vertices that were created / added as part of the load.\n   * @memberof JsonLdGraph\n   */\n  load(inputs, contexts, base) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this._index.load(inputs, contexts, base);\n    });\n  }\n  /**\n   * @description Merges a set of JSON-LD documents into the graph.\n   * @param {(any | any[])} inputs The inputs to merge.\n   * @param {string[]} [contexts] The contexts to merge.\n   * @param {string} [base] The base IRI of the document.\n   * @returns {Promise<Set<string>>} A set containing all vertices that were created / added as part of the load.\n   * @memberof JsonLdGraph\n   */\n  merge(inputs, contexts, base) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this._index.merge(inputs, contexts, base);\n    });\n  }\n  /**\n   * @description Removes a context.\n   * @param {string} uri The uri of the context to remove.\n   * @returns {void}\n   * @memberof JsonLdGraph\n   */\n  removeContext(uri) {\n    return this._index.removeContext(uri);\n  }\n  /**\n   * @description Removes a prefix previously added to the graph.\n   * @param {string} prefix The prefix to remove from the graph.\n   * @returns {void}\n   * @memberof JsonldGraph\n   */\n  removePrefix(prefix) {\n    return this._index.removePrefix(prefix);\n  }\n  /**\n   * @description Removes a vertex from the graph.\n   * @param {(string | Vertex)} vertex The vertex id or vertex instance to remove from the graph.\n   * @memberof JsonLdGraph\n   */\n  removeVertex(vertex) {\n    if (!vertex) {\n      throw new ReferenceError(`Invalid vertex. vertex is ${vertex}`);\n    }\n    const nodeId = typeof vertex === 'string' ? vertex : vertex.id;\n    this._index.removeNode(nodeId);\n  }\n  /**\n   * @description Gets a JSON representation of the graph.\n   * @param {string[]} contexts Contexts to use for compaction.\n   * @param {*} [frame] Optional frame to use for formatting the JSON output.\n   * @returns {Promise<any>}\n   * @memberof JsonLdGraph\n   */\n  /* tslint:disable:promise-function-async*/\n  toJson(options) {\n    return this._index.toJson(options);\n  }\n}\nexports.JsonldGraph = JsonldGraph;\nexports.default = JsonldGraph;","map":{"version":3,"sources":["../src/graph.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst jsiterable_1 = __importDefault(require(\"jsiterable\"));\nconst edge_1 = __importDefault(require(\"./edge\"));\nconst graphIndex_1 = __importDefault(require(\"./graphIndex\"));\nconst vertex_1 = __importStar(require(\"./vertex\"));\nclass JsonldGraph extends events_1.EventEmitter {\n    /**\n     * Creates an instance of JsonLdGraph.\n     * @memberof JsonLdGraph\n     */\n    constructor(contexts) {\n        super();\n        this._index = new graphIndex_1.default();\n        this._index.on('edgeCreated', indexEdge => this.emit('edgeAdded', new edge_1.default(indexEdge, this._index)));\n        this._index.on('edgeDeleted', indexEdge => this.emit('edgeRemoved', new edge_1.default(indexEdge, this._index)));\n        this._index.on('nodeCreated', indexNode => this.emit('vertexAdded', new vertex_1.default(indexNode, this._index)));\n        this._index.on('nodeDeleted', indexNode => this.emit('vertexRemoved', new vertex_1.default(indexNode, this._index)));\n        this._index.on('nodeIdChanged', (indexNode, previousId) => this.emit('vertexIdChanged', new vertex_1.default(indexNode, this._index), previousId));\n        if (contexts && contexts.length > 0) {\n            for (const { uri, context } of contexts) {\n                this._index.addContext(uri, context);\n            }\n        }\n    }\n    /**\n     * @description Gets the contexts registered with the graph.\n     * @readonly\n     * @type {Iterable<[string, any]>}\n     * @memberof JsonldGraph\n     */\n    get contexts() {\n        return this._index.contexts;\n    }\n    /**\n     * @description Gets the count of edges in the graph.\n     * @readonly\n     * @type {number}\n     * @memberof JsonLdGraph\n     */\n    get edgeCount() {\n        return this._index.edgeCount;\n    }\n    /**\n     * @description Gets the count of vertices in the graph.\n     * @readonly\n     * @type {number}\n     * @memberof JsonLdGraph\n     */\n    get vertexCount() {\n        return this._index.nodeCount;\n    }\n    /**\n     * @description Adds a context.\n     * @param {string} uri The uri of the context to add.\n     * @param {*} context The context object.\n     * @memberof JsonLdGraph\n     */\n    addContext(uri, context) {\n        this._index.addContext(uri, context);\n    }\n    /**\n     * @description Adds a prefix to the graph that allows accessing and creating edges & vertices using short ids containing the prefix.\n     * @param {string} prefix The prefix to add.\n     * @param {string} uri A valid URI that the prefix maps to.\n     * @memberof JsonldGraph\n     */\n    addPrefix(prefix, uri) {\n        this._index.addPrefix(prefix, uri);\n    }\n    /**\n     * @description Creates a new vertex.\n     * @param {string} id Id of the vertex to create.\n     * @returns {Vertex}\n     * @memberof JsonLdGraph\n     */\n    createVertex(id) {\n        if (!id) {\n            throw new ReferenceError(`Invalid id. id is ${id}`);\n        }\n        const existing = this._index.getNode(id);\n        if (existing) {\n            return new vertex_1.default(existing, this._index);\n        }\n        else {\n            const node = this._index.createNode(id);\n            return new vertex_1.default(node, this._index);\n        }\n    }\n    /**\n     * @description Gets edges in the graph.\n     * @param {string} [label] Optional label to filter only edges with the specified label.\n     * @returns {Iterable<Edge>}\n     * @memberof JsonLdGraph\n     */\n    getEdges(label) {\n        return new jsiterable_1.default(this._index.getEdges(label)).map(x => new edge_1.default(x, this._index));\n    }\n    /**\n     * @description Gets all vertices with the specified incoming edge.\n     * @param {string} edgeLabel The label of the incoming edge.\n     * @param {(string | VertexSelector)} [vertexSelector] Optional vertex selector that is used to filter only matching vertices.\n     * @returns {Iterable<Vertex>}\n     * @memberof JsonLdGraph\n     */\n    getIncoming(edgeLabel, vertexSelector) {\n        if (!edgeLabel) {\n            throw new ReferenceError(`Invalid edgeLabel. edgeLabel is ${edgeLabel}`);\n        }\n        const filter = new vertex_1.VertexFilter(vertexSelector);\n        return new jsiterable_1.default(this._index.getEdgeIncoming(edgeLabel))\n            .map(node => new vertex_1.default(node, this._index))\n            .filter(vertex => filter.match(vertex));\n    }\n    /**\n     * @description Gets all vertices with the specified outgoing edge.\n     * @param {string} edgeLabel The label of the outgoing edge.\n     * @param {(string | VertexSelector)} [vertexSelector] Optional vertex selector that is used to filter only matching vertices.\n     * @returns {Iterable<Vertex}\n     * @memberof JsonLdGraph\n     */\n    getOutgoing(edgeLabel, vertexSelector) {\n        if (!edgeLabel) {\n            throw new ReferenceError(`Invalid edgeLabel. edgeLabel is ${edgeLabel}`);\n        }\n        const filter = new vertex_1.VertexFilter(vertexSelector);\n        return new jsiterable_1.default(this._index.getEdgeOutgoing(edgeLabel))\n            .map(node => new vertex_1.default(node, this._index))\n            .filter(vertex => filter.match(vertex));\n    }\n    /**\n     * @description Gets all vertices in the graph.\n     * @param {VertexSelector} [vertexSelector] Optional vertex selector that is used to filter only matching vertices.\n     * @returns {Iterable<Vertex>}\n     * @memberof JsonLdGraph\n     */\n    getVertices(vertexSelector) {\n        const filter = new vertex_1.VertexFilter(vertexSelector);\n        return new jsiterable_1.default(this._index.getNodes())\n            .map(node => new vertex_1.default(node, this._index))\n            .filter(vertex => filter.match(vertex));\n    }\n    /**\n     * @description Gets a specific vertex in the graph.\n     * @param {string} id Id of the vertex to get.\n     * @returns {Vertex}\n     * @memberof JsonLdGraph\n     */\n    getVertex(id) {\n        if (!id) {\n            throw new ReferenceError(`Invalid id. id is ${id}`);\n        }\n        const node = this._index.getNode(id);\n        if (!node) {\n            return null;\n        }\n        else {\n            return new vertex_1.default(node, this._index);\n        }\n    }\n    /**\n     * @description Checks if a edge exists.\n     * @param {string} label The label of the edge.\n     * @param {string} fromVertexId The outgoing vertex id.\n     * @param {string} toVertexId The incoming vertex id.\n     * @returns {boolean}\n     * @memberof JsonLdGraph\n     */\n    hasEdge(label, fromVertexId, toVertexId) {\n        return this._index.hasEdge(label, fromVertexId, toVertexId);\n    }\n    /**\n     * @description Checks if a vertex exists.\n     * @param {string} id The id of the vertex to check.\n     * @returns {boolean}\n     * @memberof JsonLdGraph\n     */\n    hasVertex(id) {\n        return this._index.hasNode(id);\n    }\n    /**\n     * @description Loads one or more documents into the graph.\n     * @param {(any | any[])} inputs Input documents to load into the graph.\n     * @param {string|string[]|object|object[]} [contexts] Optional contexts to use for importing the documents.\n     * @param {string} [base] Optional base IRI of the inputs.\n     * @returns {Promise<Set<string>>} A set containing all vertices that were created / added as part of the load.\n     * @memberof JsonLdGraph\n     */\n    load(inputs, contexts, base) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._index.load(inputs, contexts, base);\n        });\n    }\n    /**\n     * @description Merges a set of JSON-LD documents into the graph.\n     * @param {(any | any[])} inputs The inputs to merge.\n     * @param {string[]} [contexts] The contexts to merge.\n     * @param {string} [base] The base IRI of the document.\n     * @returns {Promise<Set<string>>} A set containing all vertices that were created / added as part of the load.\n     * @memberof JsonLdGraph\n     */\n    merge(inputs, contexts, base) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._index.merge(inputs, contexts, base);\n        });\n    }\n    /**\n     * @description Removes a context.\n     * @param {string} uri The uri of the context to remove.\n     * @returns {void}\n     * @memberof JsonLdGraph\n     */\n    removeContext(uri) {\n        return this._index.removeContext(uri);\n    }\n    /**\n     * @description Removes a prefix previously added to the graph.\n     * @param {string} prefix The prefix to remove from the graph.\n     * @returns {void}\n     * @memberof JsonldGraph\n     */\n    removePrefix(prefix) {\n        return this._index.removePrefix(prefix);\n    }\n    /**\n     * @description Removes a vertex from the graph.\n     * @param {(string | Vertex)} vertex The vertex id or vertex instance to remove from the graph.\n     * @memberof JsonLdGraph\n     */\n    removeVertex(vertex) {\n        if (!vertex) {\n            throw new ReferenceError(`Invalid vertex. vertex is ${vertex}`);\n        }\n        const nodeId = typeof vertex === 'string' ? vertex : vertex.id;\n        this._index.removeNode(nodeId);\n    }\n    /**\n     * @description Gets a JSON representation of the graph.\n     * @param {string[]} contexts Contexts to use for compaction.\n     * @param {*} [frame] Optional frame to use for formatting the JSON output.\n     * @returns {Promise<any>}\n     * @memberof JsonLdGraph\n     */\n    /* tslint:disable:promise-function-async*/\n    toJson(options) {\n        return this._index.toJson(options);\n    }\n}\nexports.JsonldGraph = JsonldGraph;\nexports.default = JsonldGraph;\n//# sourceMappingURL=graph.js.map"]},"metadata":{},"sourceType":"script"}