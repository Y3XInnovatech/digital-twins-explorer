{"ast":null,"code":"/**\n * A JavaScript implementation of the JSON-LD API.\n *\n * @author Dave Longley\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2011-2019 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nconst canonize = require('rdf-canonize');\nconst util = require('./util');\nconst ContextResolver = require('./ContextResolver');\nconst IdentifierIssuer = util.IdentifierIssuer;\nconst JsonLdError = require('./JsonLdError');\nconst LRU = require('lru-cache');\nconst NQuads = require('./NQuads');\nconst Rdfa = require('./Rdfa');\nconst {\n  expand: _expand\n} = require('./expand');\nconst {\n  flatten: _flatten\n} = require('./flatten');\nconst {\n  fromRDF: _fromRDF\n} = require('./fromRdf');\nconst {\n  toRDF: _toRDF\n} = require('./toRdf');\nconst {\n  frameMergedOrDefault: _frameMergedOrDefault\n} = require('./frame');\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString\n} = require('./types');\nconst {\n  isSubjectReference: _isSubjectReference\n} = require('./graphTypes');\nconst {\n  getInitialContext: _getInitialContext,\n  process: _processContext\n} = require('./context');\nconst {\n  compact: _compact,\n  compactIri: _compactIri,\n  removePreserve: _removePreserve\n} = require('./compact');\nconst {\n  createNodeMap: _createNodeMap,\n  createMergedNodeMap: _createMergedNodeMap,\n  mergeNodeMaps: _mergeNodeMaps\n} = require('./nodeMap');\n\n// determine if in-browser or using node.js\nconst _nodejs = typeof process !== 'undefined' && process.versions && process.versions.node;\nconst _browser = !_nodejs && (typeof window !== 'undefined' || typeof self !== 'undefined');\n\n/* eslint-disable indent */\n// attaches jsonld API to the given object\nconst wrapper = function (jsonld) {\n  /** Registered RDF dataset parsers hashed by content-type. */\n  const _rdfParsers = {};\n\n  // resolved context cache\n  // TODO: consider basing max on context size rather than number\n  const RESOLVED_CONTEXT_CACHE_MAX_SIZE = 100;\n  const _resolvedContextCache = new LRU({\n    max: RESOLVED_CONTEXT_CACHE_MAX_SIZE\n  });\n\n  /* Core API */\n\n  /**\n   * Performs JSON-LD compaction.\n   *\n   * @param input the JSON-LD input to compact.\n   * @param ctx the context to compact with.\n   * @param [options] options to use:\n   *          [base] the base IRI to use.\n   *          [compactArrays] true to compact arrays to single values when\n   *            appropriate, false not to (default: true).\n   *          [compactToRelative] true to compact IRIs to be relative to document\n   *            base, false to keep absolute (default: true)\n   *          [graph] true to always output a top-level graph (default: false).\n   *          [expandContext] a context to expand with.\n   *          [skipExpansion] true to assume the input is expanded and skip\n   *            expansion, false not to, defaults to false.\n   *          [documentLoader(url, options)] the document loader.\n   *          [expansionMap(info)] a function that can be used to custom map\n   *            unmappable values (or to throw an error when they are detected);\n   *            if this function returns `undefined` then the default behavior\n   *            will be used.\n   *          [framing] true if compaction is occuring during a framing operation.\n   *          [compactionMap(info)] a function that can be used to custom map\n   *            unmappable values (or to throw an error when they are detected);\n   *            if this function returns `undefined` then the default behavior\n   *            will be used.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the compacted output.\n   */\n  jsonld.compact = async function (input, ctx, options) {\n    if (arguments.length < 2) {\n      throw new TypeError('Could not compact, too few arguments.');\n    }\n    if (ctx === null) {\n      throw new JsonLdError('The compaction context must not be null.', 'jsonld.CompactError', {\n        code: 'invalid local context'\n      });\n    }\n\n    // nothing to compact\n    if (input === null) {\n      return null;\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      compactArrays: true,\n      compactToRelative: true,\n      graph: false,\n      skipExpansion: false,\n      link: false,\n      issuer: new IdentifierIssuer('_:b'),\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n    if (options.link) {\n      // force skip expansion when linking, \"link\" is not part of the public\n      // API, it should only be called from framing\n      options.skipExpansion = true;\n    }\n    if (!options.compactToRelative) {\n      delete options.base;\n    }\n\n    // expand input\n    let expanded;\n    if (options.skipExpansion) {\n      expanded = input;\n    } else {\n      expanded = await jsonld.expand(input, options);\n    }\n\n    // process context\n    const activeCtx = await jsonld.processContext(_getInitialContext(options), ctx, options);\n\n    // do compaction\n    let compacted = await _compact({\n      activeCtx,\n      element: expanded,\n      options,\n      compactionMap: options.compactionMap\n    });\n\n    // perform clean up\n    if (options.compactArrays && !options.graph && _isArray(compacted)) {\n      if (compacted.length === 1) {\n        // simplify to a single item\n        compacted = compacted[0];\n      } else if (compacted.length === 0) {\n        // simplify to an empty object\n        compacted = {};\n      }\n    } else if (options.graph && _isObject(compacted)) {\n      // always use array if graph option is on\n      compacted = [compacted];\n    }\n\n    // follow @context key\n    if (_isObject(ctx) && '@context' in ctx) {\n      ctx = ctx['@context'];\n    }\n\n    // build output context\n    ctx = util.clone(ctx);\n    if (!_isArray(ctx)) {\n      ctx = [ctx];\n    }\n    // remove empty contexts\n    const tmp = ctx;\n    ctx = [];\n    for (let i = 0; i < tmp.length; ++i) {\n      if (!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {\n        ctx.push(tmp[i]);\n      }\n    }\n\n    // remove array if only one context\n    const hasContext = ctx.length > 0;\n    if (ctx.length === 1) {\n      ctx = ctx[0];\n    }\n\n    // add context and/or @graph\n    if (_isArray(compacted)) {\n      // use '@graph' keyword\n      const graphAlias = _compactIri({\n        activeCtx,\n        iri: '@graph',\n        relativeTo: {\n          vocab: true\n        }\n      });\n      const graph = compacted;\n      compacted = {};\n      if (hasContext) {\n        compacted['@context'] = ctx;\n      }\n      compacted[graphAlias] = graph;\n    } else if (_isObject(compacted) && hasContext) {\n      // reorder keys so @context is first\n      const graph = compacted;\n      compacted = {\n        '@context': ctx\n      };\n      for (const key in graph) {\n        compacted[key] = graph[key];\n      }\n    }\n    if (options.framing) {\n      // get graph alias\n      const graph = _compactIri({\n        activeCtx,\n        iri: '@graph',\n        relativeTo: {\n          vocab: true\n        }\n      });\n      // remove @preserve from results\n      options.link = {};\n      compacted[graph] = _removePreserve(activeCtx, compacted[graph], options);\n    }\n    return compacted;\n  };\n\n  /**\n   * Performs JSON-LD expansion.\n   *\n   * @param input the JSON-LD input to expand.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [keepFreeFloatingNodes] true to keep free-floating nodes,\n   *            false not to, defaults to false.\n   *          [documentLoader(url, options)] the document loader.\n   *          [expansionMap(info)] a function that can be used to custom map\n   *            unmappable values (or to throw an error when they are detected);\n   *            if this function returns `undefined` then the default behavior\n   *            will be used.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the expanded output.\n   */\n  jsonld.expand = async function (input, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not expand, too few arguments.');\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      keepFreeFloatingNodes: false,\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n    if (options.expansionMap === false) {\n      options.expansionMap = undefined;\n    }\n\n    // build set of objects that may have @contexts to resolve\n    const toResolve = {};\n\n    // build set of contexts to process prior to expansion\n    const contextsToProcess = [];\n\n    // if an `expandContext` has been given ensure it gets resolved\n    if ('expandContext' in options) {\n      const expandContext = util.clone(options.expandContext);\n      if (_isObject(expandContext) && '@context' in expandContext) {\n        toResolve.expandContext = expandContext;\n      } else {\n        toResolve.expandContext = {\n          '@context': expandContext\n        };\n      }\n      contextsToProcess.push(toResolve.expandContext);\n    }\n\n    // if input is a string, attempt to dereference remote document\n    let defaultBase;\n    if (!_isString(input)) {\n      // input is not a URL, do not need to retrieve it first\n      toResolve.input = util.clone(input);\n    } else {\n      // load remote doc\n      const remoteDoc = await jsonld.get(input, options);\n      defaultBase = remoteDoc.documentUrl;\n      toResolve.input = remoteDoc.document;\n      if (remoteDoc.contextUrl) {\n        // context included in HTTP link header and must be resolved\n        toResolve.remoteContext = {\n          '@context': remoteDoc.contextUrl\n        };\n        contextsToProcess.push(toResolve.remoteContext);\n      }\n    }\n\n    // set default base\n    if (!('base' in options)) {\n      options.base = defaultBase || '';\n    }\n\n    // process any additional contexts\n    let activeCtx = _getInitialContext(options);\n    for (const localCtx of contextsToProcess) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx,\n        options\n      });\n    }\n\n    // expand resolved input\n    let expanded = await _expand({\n      activeCtx,\n      element: toResolve.input,\n      options,\n      expansionMap: options.expansionMap\n    });\n\n    // optimize away @graph with no other properties\n    if (_isObject(expanded) && '@graph' in expanded && Object.keys(expanded).length === 1) {\n      expanded = expanded['@graph'];\n    } else if (expanded === null) {\n      expanded = [];\n    }\n\n    // normalize to an array\n    if (!_isArray(expanded)) {\n      expanded = [expanded];\n    }\n    return expanded;\n  };\n\n  /**\n   * Performs JSON-LD flattening.\n   *\n   * @param input the JSON-LD to flatten.\n   * @param ctx the context to use to compact the flattened output, or null.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the flattened output.\n   */\n  jsonld.flatten = async function (input, ctx, options) {\n    if (arguments.length < 1) {\n      return new TypeError('Could not flatten, too few arguments.');\n    }\n    if (typeof ctx === 'function') {\n      ctx = null;\n    } else {\n      ctx = ctx || null;\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n\n    // expand input\n    const expanded = await jsonld.expand(input, options);\n\n    // do flattening\n    const flattened = _flatten(expanded);\n    if (ctx === null) {\n      // no compaction required\n      return flattened;\n    }\n\n    // compact result (force @graph option to true, skip expansion)\n    options.graph = true;\n    options.skipExpansion = true;\n    const compacted = await jsonld.compact(flattened, ctx, options);\n    return compacted;\n  };\n\n  /**\n   * Performs JSON-LD framing.\n   *\n   * @param input the JSON-LD input to frame.\n   * @param frame the JSON-LD frame to use.\n   * @param [options] the framing options.\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [embed] default @embed flag: '@last', '@always', '@never', '@link'\n   *            (default: '@last').\n   *          [explicit] default @explicit flag (default: false).\n   *          [requireAll] default @requireAll flag (default: true).\n   *          [omitDefault] default @omitDefault flag (default: false).\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the framed output.\n   */\n  jsonld.frame = async function (input, frame, options) {\n    if (arguments.length < 2) {\n      throw new TypeError('Could not frame, too few arguments.');\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      embed: '@last',\n      explicit: false,\n      requireAll: true,\n      omitDefault: false,\n      pruneBlankNodeIdentifiers: true,\n      bnodesToClear: [],\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n\n    // if frame is a string, attempt to dereference remote document\n    if (_isString(frame)) {\n      // load remote doc\n      const remoteDoc = await jsonld.get(frame, options);\n      frame = remoteDoc.document;\n      if (remoteDoc.contextUrl) {\n        // inject link header @context into frame\n        let ctx = frame['@context'];\n        if (!ctx) {\n          ctx = remoteDoc.contextUrl;\n        } else if (_isArray(ctx)) {\n          ctx.push(remoteDoc.contextUrl);\n        } else {\n          ctx = [ctx, remoteDoc.contextUrl];\n        }\n        frame['@context'] = ctx;\n      }\n    }\n    const frameContext = frame ? frame['@context'] || {} : {};\n\n    // expand input\n    const expanded = await jsonld.expand(input, options);\n\n    // expand frame\n    const opts = {\n      ...options\n    };\n    opts.isFrame = true;\n    opts.keepFreeFloatingNodes = true;\n    const expandedFrame = await jsonld.expand(frame, opts);\n\n    // if the unexpanded frame includes a key expanding to @graph, frame the\n    // default graph, otherwise, the merged graph\n    // FIXME should look for aliases of @graph\n    opts.merged = !('@graph' in frame);\n    // do framing\n    const framed = _frameMergedOrDefault(expanded, expandedFrame, opts);\n\n    // compact result (force @graph option to true, skip expansion,\n    // check for linked embeds)\n    opts.graph = true;\n    opts.skipExpansion = true;\n    opts.link = {};\n    opts.framing = true;\n    const compacted = await jsonld.compact(framed, frameContext, opts);\n    return compacted;\n  };\n\n  /**\n   * **Experimental**\n   *\n   * Links a JSON-LD document's nodes in memory.\n   *\n   * @param input the JSON-LD document to link.\n   * @param [ctx] the JSON-LD context to apply.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the linked output.\n   */\n  jsonld.link = async function (input, ctx, options) {\n    // API matches running frame with a wildcard frame and embed: '@link'\n    // get arguments\n    const frame = {};\n    if (ctx) {\n      frame['@context'] = ctx;\n    }\n    frame['@embed'] = '@link';\n    return jsonld.frame(input, frame, options);\n  };\n\n  /**\n   * Performs RDF dataset normalization on the given input. The input is JSON-LD\n   * unless the 'inputFormat' option is used. The output is an RDF dataset\n   * unless the 'format' option is used.\n   *\n   * @param input the input to normalize as JSON-LD or as a format specified by\n   *          the 'inputFormat' option.\n   * @param [options] the options to use:\n   *          [algorithm] the normalization algorithm to use, `URDNA2015` or\n   *            `URGNA2012` (default: `URDNA2015`).\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [skipExpansion] true to assume the input is expanded and skip\n   *            expansion, false not to, defaults to false.\n   *          [inputFormat] the format if input is not JSON-LD:\n   *            'application/n-quads' for N-Quads.\n   *          [format] the format if output is a string:\n   *            'application/n-quads' for N-Quads.\n   *          [documentLoader(url, options)] the document loader.\n   *          [useNative] true to use a native canonize algorithm\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the normalized output.\n   */\n  jsonld.normalize = jsonld.canonize = async function (input, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not canonize, too few arguments.');\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      algorithm: 'URDNA2015',\n      skipExpansion: false,\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n    if ('inputFormat' in options) {\n      if (options.inputFormat !== 'application/n-quads' && options.inputFormat !== 'application/nquads') {\n        throw new JsonLdError('Unknown canonicalization input format.', 'jsonld.CanonizeError');\n      }\n      // TODO: `await` for async parsers\n      const parsedInput = NQuads.parse(input);\n\n      // do canonicalization\n      return canonize.canonize(parsedInput, options);\n    }\n\n    // convert to RDF dataset then do normalization\n    const opts = {\n      ...options\n    };\n    delete opts.format;\n    opts.produceGeneralizedRdf = false;\n    const dataset = await jsonld.toRDF(input, opts);\n\n    // do canonicalization\n    return canonize.canonize(dataset, options);\n  };\n\n  /**\n   * Converts an RDF dataset to JSON-LD.\n   *\n   * @param dataset a serialized string of RDF in a format specified by the\n   *          format option or an RDF dataset to convert.\n   * @param [options] the options to use:\n   *          [format] the format if dataset param must first be parsed:\n   *            'application/n-quads' for N-Quads (default).\n   *          [rdfParser] a custom RDF-parser to use to parse the dataset.\n   *          [useRdfType] true to use rdf:type, false to use @type\n   *            (default: false).\n   *          [useNativeTypes] true to convert XSD types into native types\n   *            (boolean, integer, double), false not to (default: false).\n   *\n   * @return a Promise that resolves to the JSON-LD document.\n   */\n  jsonld.fromRDF = async function (dataset, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not convert from RDF, too few arguments.');\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      format: _isString(dataset) ? 'application/n-quads' : undefined\n    });\n    const {\n      format\n    } = options;\n    let {\n      rdfParser\n    } = options;\n\n    // handle special format\n    if (format) {\n      // check supported formats\n      rdfParser = rdfParser || _rdfParsers[format];\n      if (!rdfParser) {\n        throw new JsonLdError('Unknown input format.', 'jsonld.UnknownFormat', {\n          format\n        });\n      }\n    } else {\n      // no-op parser, assume dataset already parsed\n      rdfParser = () => dataset;\n    }\n\n    // rdfParser must be synchronous or return a promise, no callback support\n    const parsedDataset = await rdfParser(dataset);\n    return _fromRDF(parsedDataset, options);\n  };\n\n  /**\n   * Outputs the RDF dataset found in the given JSON-LD object.\n   *\n   * @param input the JSON-LD input.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [skipExpansion] true to assume the input is expanded and skip\n   *            expansion, false not to, defaults to false.\n   *          [format] the format to use to output a string:\n   *            'application/n-quads' for N-Quads.\n   *          [produceGeneralizedRdf] true to output generalized RDF, false\n   *            to produce only standard RDF (default: false).\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the RDF dataset.\n   */\n  jsonld.toRDF = async function (input, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not convert to RDF, too few arguments.');\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      skipExpansion: false,\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n\n    // TODO: support toRDF custom map?\n    let expanded;\n    if (options.skipExpansion) {\n      expanded = input;\n    } else {\n      // expand input\n      expanded = await jsonld.expand(input, options);\n    }\n\n    // output RDF dataset\n    const dataset = _toRDF(expanded, options);\n    if (options.format) {\n      if (options.format === 'application/n-quads' || options.format === 'application/nquads') {\n        return await NQuads.serialize(dataset);\n      }\n      throw new JsonLdError('Unknown output format.', 'jsonld.UnknownFormat', {\n        format: options.format\n      });\n    }\n    return dataset;\n  };\n\n  /**\n   * **Experimental**\n   *\n   * Recursively flattens the nodes in the given JSON-LD input into a merged\n   * map of node ID => node. All graphs will be merged into the default graph.\n   *\n   * @param input the JSON-LD input.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the merged node map.\n   */\n  jsonld.createNodeMap = async function (input, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not create node map, too few arguments.');\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n\n    // expand input\n    const expanded = await jsonld.expand(input, options);\n    return _createMergedNodeMap(expanded, options);\n  };\n\n  /**\n   * **Experimental**\n   *\n   * Merges two or more JSON-LD documents into a single flattened document.\n   *\n   * @param docs the JSON-LD documents to merge together.\n   * @param ctx the context to use to compact the merged result, or null.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n   *          [mergeNodes] true to merge properties for nodes with the same ID,\n   *            false to ignore new properties for nodes with the same ID once\n   *            the ID has been defined; note that this may not prevent merging\n   *            new properties where a node is in the `object` position\n   *            (default: true).\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the merged output.\n   */\n  jsonld.merge = async function (docs, ctx, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not merge, too few arguments.');\n    }\n    if (!_isArray(docs)) {\n      throw new TypeError('Could not merge, \"docs\" must be an array.');\n    }\n    if (typeof ctx === 'function') {\n      ctx = null;\n    } else {\n      ctx = ctx || null;\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n\n    // expand all documents\n    const expanded = await Promise.all(docs.map(doc => {\n      const opts = {\n        ...options\n      };\n      return jsonld.expand(doc, opts);\n    }));\n    let mergeNodes = true;\n    if ('mergeNodes' in options) {\n      mergeNodes = options.mergeNodes;\n    }\n    const issuer = options.issuer || new IdentifierIssuer('_:b');\n    const graphs = {\n      '@default': {}\n    };\n    for (let i = 0; i < expanded.length; ++i) {\n      // uniquely relabel blank nodes\n      const doc = util.relabelBlankNodes(expanded[i], {\n        issuer: new IdentifierIssuer('_:b' + i + '-')\n      });\n\n      // add nodes to the shared node map graphs if merging nodes, to a\n      // separate graph set if not\n      const _graphs = mergeNodes || i === 0 ? graphs : {\n        '@default': {}\n      };\n      _createNodeMap(doc, _graphs, '@default', issuer);\n      if (_graphs !== graphs) {\n        // merge document graphs but don't merge existing nodes\n        for (const graphName in _graphs) {\n          const _nodeMap = _graphs[graphName];\n          if (!(graphName in graphs)) {\n            graphs[graphName] = _nodeMap;\n            continue;\n          }\n          const nodeMap = graphs[graphName];\n          for (const key in _nodeMap) {\n            if (!(key in nodeMap)) {\n              nodeMap[key] = _nodeMap[key];\n            }\n          }\n        }\n      }\n    }\n\n    // add all non-default graphs to default graph\n    const defaultGraph = _mergeNodeMaps(graphs);\n\n    // produce flattened output\n    const flattened = [];\n    const keys = Object.keys(defaultGraph).sort();\n    for (let ki = 0; ki < keys.length; ++ki) {\n      const node = defaultGraph[keys[ki]];\n      // only add full subjects to top-level\n      if (!_isSubjectReference(node)) {\n        flattened.push(node);\n      }\n    }\n    if (ctx === null) {\n      return flattened;\n    }\n\n    // compact result (force @graph option to true, skip expansion)\n    options.graph = true;\n    options.skipExpansion = true;\n    const compacted = await jsonld.compact(flattened, ctx, options);\n    return compacted;\n  };\n\n  /**\n   * The default document loader for external documents.\n   *\n   * @param url the URL to load.\n   *\n   * @return a promise that resolves to the remote document.\n   */\n  Object.defineProperty(jsonld, 'documentLoader', {\n    get: () => jsonld._documentLoader,\n    set: v => jsonld._documentLoader = v\n  });\n  // default document loader not implemented\n  jsonld.documentLoader = async url => {\n    throw new JsonLdError('Could not retrieve a JSON-LD document from the URL. URL ' + 'dereferencing not implemented.', 'jsonld.LoadDocumentError', {\n      code: 'loading document failed',\n      url\n    });\n  };\n\n  /**\n   * Gets a remote JSON-LD document using the default document loader or\n   * one given in the passed options.\n   *\n   * @param url the URL to fetch.\n   * @param [options] the options to use:\n   *          [documentLoader] the document loader to use.\n   *\n   * @return a Promise that resolves to the retrieved remote document.\n   */\n  jsonld.get = async function (url, options) {\n    let load;\n    if (typeof options.documentLoader === 'function') {\n      load = options.documentLoader;\n    } else {\n      load = jsonld.documentLoader;\n    }\n    const remoteDoc = await load(url);\n    try {\n      if (!remoteDoc.document) {\n        throw new JsonLdError('No remote document found at the given URL.', 'jsonld.NullRemoteDocument');\n      }\n      if (_isString(remoteDoc.document)) {\n        remoteDoc.document = JSON.parse(remoteDoc.document);\n      }\n    } catch (e) {\n      throw new JsonLdError('Could not retrieve a JSON-LD document from the URL.', 'jsonld.LoadDocumentError', {\n        code: 'loading document failed',\n        cause: e,\n        remoteDoc\n      });\n    }\n    return remoteDoc;\n  };\n\n  /**\n   * Processes a local context, resolving any URLs as necessary, and returns a\n   * new active context.\n   *\n   * @param activeCtx the current active context.\n   * @param localCtx the local context to process.\n   * @param [options] the options to use:\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the new active context.\n   */\n  jsonld.processContext = async function (activeCtx, localCtx, options) {\n    // set default options\n    options = _setDefaults(options, {\n      base: '',\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n\n    // return initial context early for null context\n    if (localCtx === null) {\n      return _getInitialContext(options);\n    }\n\n    // get URLs in localCtx\n    localCtx = util.clone(localCtx);\n    if (!(_isObject(localCtx) && '@context' in localCtx)) {\n      localCtx = {\n        '@context': localCtx\n      };\n    }\n    return _processContext({\n      activeCtx,\n      localCtx,\n      options\n    });\n  };\n\n  // backwards compatibility\n  jsonld.getContextValue = require('./context').getContextValue;\n\n  /**\n   * Document loaders.\n   */\n  jsonld.documentLoaders = {};\n  jsonld.documentLoaders.node = require('./documentLoaders/node');\n  jsonld.documentLoaders.xhr = require('./documentLoaders/xhr');\n\n  /**\n   * Assigns the default document loader for external document URLs to a built-in\n   * default. Supported types currently include: 'xhr' and 'node'.\n   *\n   * @param type the type to set.\n   * @param [params] the parameters required to use the document loader.\n   */\n  jsonld.useDocumentLoader = function (type) {\n    if (!(type in jsonld.documentLoaders)) {\n      throw new JsonLdError('Unknown document loader type: \"' + type + '\"', 'jsonld.UnknownDocumentLoader', {\n        type\n      });\n    }\n\n    // set document loader\n    jsonld.documentLoader = jsonld.documentLoaders[type].apply(jsonld, Array.prototype.slice.call(arguments, 1));\n  };\n\n  /**\n   * Registers an RDF dataset parser by content-type, for use with\n   * jsonld.fromRDF. An RDF dataset parser will always be given one parameter,\n   * a string of input. An RDF dataset parser can be synchronous or\n   * asynchronous (by returning a promise).\n   *\n   * @param contentType the content-type for the parser.\n   * @param parser(input) the parser function (takes a string as a parameter\n   *          and either returns an RDF dataset or a Promise that resolves to one.\n   */\n  jsonld.registerRDFParser = function (contentType, parser) {\n    _rdfParsers[contentType] = parser;\n  };\n\n  /**\n   * Unregisters an RDF dataset parser by content-type.\n   *\n   * @param contentType the content-type for the parser.\n   */\n  jsonld.unregisterRDFParser = function (contentType) {\n    delete _rdfParsers[contentType];\n  };\n\n  // register the N-Quads RDF parser\n  jsonld.registerRDFParser('application/n-quads', NQuads.parse);\n  jsonld.registerRDFParser('application/nquads', NQuads.parse);\n\n  // register the RDFa API RDF parser\n  jsonld.registerRDFParser('rdfa-api', Rdfa.parse);\n\n  /* URL API */\n  jsonld.url = require('./url');\n\n  /* Utility API */\n  jsonld.util = util;\n  // backwards compatibility\n  Object.assign(jsonld, util);\n\n  // reexpose API as jsonld.promises for backwards compatability\n  jsonld.promises = jsonld;\n\n  // backwards compatibility\n  jsonld.RequestQueue = require('./RequestQueue');\n\n  /* WebIDL API */\n  jsonld.JsonLdProcessor = require('./JsonLdProcessor')(jsonld);\n\n  // setup browser global JsonLdProcessor\n  if (_browser && typeof global.JsonLdProcessor === 'undefined') {\n    Object.defineProperty(global, 'JsonLdProcessor', {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: jsonld.JsonLdProcessor\n    });\n  }\n\n  // set platform-specific defaults/APIs\n  if (_nodejs) {\n    // use node document loader by default\n    jsonld.useDocumentLoader('node');\n  } else if (typeof XMLHttpRequest !== 'undefined') {\n    // use xhr document loader by default\n    jsonld.useDocumentLoader('xhr');\n  }\n  function _setDefaults(options, {\n    documentLoader = jsonld.documentLoader,\n    ...defaults\n  }) {\n    return Object.assign({}, {\n      documentLoader\n    }, defaults, options);\n  }\n\n  // end of jsonld API `wrapper` factory\n  return jsonld;\n};\n\n// external APIs:\n\n// used to generate a new jsonld API instance\nconst factory = function () {\n  return wrapper(function () {\n    return factory();\n  });\n};\n\n// wrap the main jsonld API instance\nwrapper(factory);\n// export API\nmodule.exports = factory;","map":{"version":3,"names":["canonize","require","util","ContextResolver","IdentifierIssuer","JsonLdError","LRU","NQuads","Rdfa","expand","_expand","flatten","_flatten","fromRDF","_fromRDF","toRDF","_toRDF","frameMergedOrDefault","_frameMergedOrDefault","isArray","_isArray","isObject","_isObject","isString","_isString","isSubjectReference","_isSubjectReference","getInitialContext","_getInitialContext","process","_processContext","compact","_compact","compactIri","_compactIri","removePreserve","_removePreserve","createNodeMap","_createNodeMap","createMergedNodeMap","_createMergedNodeMap","mergeNodeMaps","_mergeNodeMaps","_nodejs","versions","node","_browser","window","self","wrapper","jsonld","_rdfParsers","RESOLVED_CONTEXT_CACHE_MAX_SIZE","_resolvedContextCache","max","input","ctx","options","arguments","length","TypeError","code","_setDefaults","base","compactArrays","compactToRelative","graph","skipExpansion","link","issuer","contextResolver","sharedCache","expanded","activeCtx","processContext","compacted","element","compactionMap","clone","tmp","i","Object","keys","push","hasContext","graphAlias","iri","relativeTo","vocab","key","framing","keepFreeFloatingNodes","expansionMap","undefined","toResolve","contextsToProcess","expandContext","defaultBase","remoteDoc","get","documentUrl","document","contextUrl","remoteContext","localCtx","flattened","frame","embed","explicit","requireAll","omitDefault","pruneBlankNodeIdentifiers","bnodesToClear","frameContext","opts","isFrame","expandedFrame","merged","framed","normalize","algorithm","inputFormat","parsedInput","parse","format","produceGeneralizedRdf","dataset","rdfParser","parsedDataset","serialize","merge","docs","Promise","all","map","doc","mergeNodes","graphs","relabelBlankNodes","_graphs","graphName","_nodeMap","nodeMap","defaultGraph","sort","ki","defineProperty","_documentLoader","set","v","documentLoader","url","load","JSON","e","cause","getContextValue","documentLoaders","xhr","useDocumentLoader","type","apply","Array","prototype","slice","call","registerRDFParser","contentType","parser","unregisterRDFParser","assign","promises","RequestQueue","JsonLdProcessor","global","writable","enumerable","configurable","value","XMLHttpRequest","defaults","factory","module","exports"],"sources":["/home/saharsh/digital-twins-explorer/client/node_modules/jsonld/lib/jsonld.js"],"sourcesContent":["/**\n * A JavaScript implementation of the JSON-LD API.\n *\n * @author Dave Longley\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2011-2019 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nconst canonize = require('rdf-canonize');\nconst util = require('./util');\nconst ContextResolver = require('./ContextResolver');\nconst IdentifierIssuer = util.IdentifierIssuer;\nconst JsonLdError = require('./JsonLdError');\nconst LRU = require('lru-cache');\nconst NQuads = require('./NQuads');\nconst Rdfa = require('./Rdfa');\n\nconst {expand: _expand} = require('./expand');\nconst {flatten: _flatten} = require('./flatten');\nconst {fromRDF: _fromRDF} = require('./fromRdf');\nconst {toRDF: _toRDF} = require('./toRdf');\n\nconst {\n  frameMergedOrDefault: _frameMergedOrDefault\n} = require('./frame');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString\n} = require('./types');\n\nconst {\n  isSubjectReference: _isSubjectReference,\n} = require('./graphTypes');\n\nconst {\n  getInitialContext: _getInitialContext,\n  process: _processContext\n} = require('./context');\n\nconst {\n  compact: _compact,\n  compactIri: _compactIri,\n  removePreserve: _removePreserve\n} = require('./compact');\n\nconst {\n  createNodeMap: _createNodeMap,\n  createMergedNodeMap: _createMergedNodeMap,\n  mergeNodeMaps: _mergeNodeMaps\n} = require('./nodeMap');\n\n// determine if in-browser or using node.js\nconst _nodejs = (\n  typeof process !== 'undefined' && process.versions && process.versions.node);\nconst _browser = !_nodejs &&\n  (typeof window !== 'undefined' || typeof self !== 'undefined');\n\n/* eslint-disable indent */\n// attaches jsonld API to the given object\nconst wrapper = function(jsonld) {\n\n/** Registered RDF dataset parsers hashed by content-type. */\nconst _rdfParsers = {};\n\n// resolved context cache\n// TODO: consider basing max on context size rather than number\nconst RESOLVED_CONTEXT_CACHE_MAX_SIZE = 100;\nconst _resolvedContextCache = new LRU({max: RESOLVED_CONTEXT_CACHE_MAX_SIZE});\n\n/* Core API */\n\n/**\n * Performs JSON-LD compaction.\n *\n * @param input the JSON-LD input to compact.\n * @param ctx the context to compact with.\n * @param [options] options to use:\n *          [base] the base IRI to use.\n *          [compactArrays] true to compact arrays to single values when\n *            appropriate, false not to (default: true).\n *          [compactToRelative] true to compact IRIs to be relative to document\n *            base, false to keep absolute (default: true)\n *          [graph] true to always output a top-level graph (default: false).\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false.\n *          [documentLoader(url, options)] the document loader.\n *          [expansionMap(info)] a function that can be used to custom map\n *            unmappable values (or to throw an error when they are detected);\n *            if this function returns `undefined` then the default behavior\n *            will be used.\n *          [framing] true if compaction is occuring during a framing operation.\n *          [compactionMap(info)] a function that can be used to custom map\n *            unmappable values (or to throw an error when they are detected);\n *            if this function returns `undefined` then the default behavior\n *            will be used.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the compacted output.\n */\njsonld.compact = async function(input, ctx, options) {\n  if(arguments.length < 2) {\n    throw new TypeError('Could not compact, too few arguments.');\n  }\n\n  if(ctx === null) {\n    throw new JsonLdError(\n      'The compaction context must not be null.',\n      'jsonld.CompactError', {code: 'invalid local context'});\n  }\n\n  // nothing to compact\n  if(input === null) {\n    return null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    compactArrays: true,\n    compactToRelative: true,\n    graph: false,\n    skipExpansion: false,\n    link: false,\n    issuer: new IdentifierIssuer('_:b'),\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n  if(options.link) {\n    // force skip expansion when linking, \"link\" is not part of the public\n    // API, it should only be called from framing\n    options.skipExpansion = true;\n  }\n  if(!options.compactToRelative) {\n    delete options.base;\n  }\n\n  // expand input\n  let expanded;\n  if(options.skipExpansion) {\n    expanded = input;\n  } else {\n    expanded = await jsonld.expand(input, options);\n  }\n\n  // process context\n  const activeCtx = await jsonld.processContext(\n    _getInitialContext(options), ctx, options);\n\n  // do compaction\n  let compacted = await _compact({\n    activeCtx,\n    element: expanded,\n    options,\n    compactionMap: options.compactionMap\n  });\n\n  // perform clean up\n  if(options.compactArrays && !options.graph && _isArray(compacted)) {\n    if(compacted.length === 1) {\n      // simplify to a single item\n      compacted = compacted[0];\n    } else if(compacted.length === 0) {\n      // simplify to an empty object\n      compacted = {};\n    }\n  } else if(options.graph && _isObject(compacted)) {\n    // always use array if graph option is on\n    compacted = [compacted];\n  }\n\n  // follow @context key\n  if(_isObject(ctx) && '@context' in ctx) {\n    ctx = ctx['@context'];\n  }\n\n  // build output context\n  ctx = util.clone(ctx);\n  if(!_isArray(ctx)) {\n    ctx = [ctx];\n  }\n  // remove empty contexts\n  const tmp = ctx;\n  ctx = [];\n  for(let i = 0; i < tmp.length; ++i) {\n    if(!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {\n      ctx.push(tmp[i]);\n    }\n  }\n\n  // remove array if only one context\n  const hasContext = (ctx.length > 0);\n  if(ctx.length === 1) {\n    ctx = ctx[0];\n  }\n\n  // add context and/or @graph\n  if(_isArray(compacted)) {\n    // use '@graph' keyword\n    const graphAlias = _compactIri({\n      activeCtx, iri: '@graph', relativeTo: {vocab: true}\n    });\n    const graph = compacted;\n    compacted = {};\n    if(hasContext) {\n      compacted['@context'] = ctx;\n    }\n    compacted[graphAlias] = graph;\n  } else if(_isObject(compacted) && hasContext) {\n    // reorder keys so @context is first\n    const graph = compacted;\n    compacted = {'@context': ctx};\n    for(const key in graph) {\n      compacted[key] = graph[key];\n    }\n  }\n\n  if(options.framing) {\n    // get graph alias\n    const graph = _compactIri({\n      activeCtx, iri: '@graph', relativeTo: {vocab: true}\n    });\n    // remove @preserve from results\n    options.link = {};\n    compacted[graph] = _removePreserve(activeCtx, compacted[graph], options);\n  }\n\n  return compacted;\n};\n\n/**\n * Performs JSON-LD expansion.\n *\n * @param input the JSON-LD input to expand.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [keepFreeFloatingNodes] true to keep free-floating nodes,\n *            false not to, defaults to false.\n *          [documentLoader(url, options)] the document loader.\n *          [expansionMap(info)] a function that can be used to custom map\n *            unmappable values (or to throw an error when they are detected);\n *            if this function returns `undefined` then the default behavior\n *            will be used.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the expanded output.\n */\njsonld.expand = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not expand, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    keepFreeFloatingNodes: false,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n  if(options.expansionMap === false) {\n    options.expansionMap = undefined;\n  }\n\n  // build set of objects that may have @contexts to resolve\n  const toResolve = {};\n\n  // build set of contexts to process prior to expansion\n  const contextsToProcess = [];\n\n  // if an `expandContext` has been given ensure it gets resolved\n  if('expandContext' in options) {\n    const expandContext = util.clone(options.expandContext);\n    if(_isObject(expandContext) && '@context' in expandContext) {\n      toResolve.expandContext = expandContext;\n    } else {\n      toResolve.expandContext = {'@context': expandContext};\n    }\n    contextsToProcess.push(toResolve.expandContext);\n  }\n\n  // if input is a string, attempt to dereference remote document\n  let defaultBase;\n  if(!_isString(input)) {\n    // input is not a URL, do not need to retrieve it first\n    toResolve.input = util.clone(input);\n  } else {\n    // load remote doc\n    const remoteDoc = await jsonld.get(input, options);\n    defaultBase = remoteDoc.documentUrl;\n    toResolve.input = remoteDoc.document;\n    if(remoteDoc.contextUrl) {\n      // context included in HTTP link header and must be resolved\n      toResolve.remoteContext = {'@context': remoteDoc.contextUrl};\n      contextsToProcess.push(toResolve.remoteContext);\n    }\n  }\n\n  // set default base\n  if(!('base' in options)) {\n    options.base = defaultBase || '';\n  }\n\n  // process any additional contexts\n  let activeCtx = _getInitialContext(options);\n  for(const localCtx of contextsToProcess) {\n    activeCtx = await _processContext({activeCtx, localCtx, options});\n  }\n\n  // expand resolved input\n  let expanded = await _expand({\n    activeCtx,\n    element: toResolve.input,\n    options,\n    expansionMap: options.expansionMap\n  });\n\n  // optimize away @graph with no other properties\n  if(_isObject(expanded) && ('@graph' in expanded) &&\n    Object.keys(expanded).length === 1) {\n    expanded = expanded['@graph'];\n  } else if(expanded === null) {\n    expanded = [];\n  }\n\n  // normalize to an array\n  if(!_isArray(expanded)) {\n    expanded = [expanded];\n  }\n\n  return expanded;\n};\n\n/**\n * Performs JSON-LD flattening.\n *\n * @param input the JSON-LD to flatten.\n * @param ctx the context to use to compact the flattened output, or null.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the flattened output.\n */\njsonld.flatten = async function(input, ctx, options) {\n  if(arguments.length < 1) {\n    return new TypeError('Could not flatten, too few arguments.');\n  }\n\n  if(typeof ctx === 'function') {\n    ctx = null;\n  } else {\n    ctx = ctx || null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  // do flattening\n  const flattened = _flatten(expanded);\n\n  if(ctx === null) {\n    // no compaction required\n    return flattened;\n  }\n\n  // compact result (force @graph option to true, skip expansion)\n  options.graph = true;\n  options.skipExpansion = true;\n  const compacted = await jsonld.compact(flattened, ctx, options);\n\n  return compacted;\n};\n\n/**\n * Performs JSON-LD framing.\n *\n * @param input the JSON-LD input to frame.\n * @param frame the JSON-LD frame to use.\n * @param [options] the framing options.\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [embed] default @embed flag: '@last', '@always', '@never', '@link'\n *            (default: '@last').\n *          [explicit] default @explicit flag (default: false).\n *          [requireAll] default @requireAll flag (default: true).\n *          [omitDefault] default @omitDefault flag (default: false).\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the framed output.\n */\njsonld.frame = async function(input, frame, options) {\n  if(arguments.length < 2) {\n    throw new TypeError('Could not frame, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    embed: '@last',\n    explicit: false,\n    requireAll: true,\n    omitDefault: false,\n    pruneBlankNodeIdentifiers: true,\n    bnodesToClear: [],\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // if frame is a string, attempt to dereference remote document\n  if(_isString(frame)) {\n    // load remote doc\n    const remoteDoc = await jsonld.get(frame, options);\n    frame = remoteDoc.document;\n\n    if(remoteDoc.contextUrl) {\n      // inject link header @context into frame\n      let ctx = frame['@context'];\n      if(!ctx) {\n        ctx = remoteDoc.contextUrl;\n      } else if(_isArray(ctx)) {\n        ctx.push(remoteDoc.contextUrl);\n      } else {\n        ctx = [ctx, remoteDoc.contextUrl];\n      }\n      frame['@context'] = ctx;\n    }\n  }\n\n  const frameContext = frame ? frame['@context'] || {} : {};\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  // expand frame\n  const opts = {...options};\n  opts.isFrame = true;\n  opts.keepFreeFloatingNodes = true;\n  const expandedFrame = await jsonld.expand(frame, opts);\n\n  // if the unexpanded frame includes a key expanding to @graph, frame the\n  // default graph, otherwise, the merged graph\n  // FIXME should look for aliases of @graph\n  opts.merged = !('@graph' in frame);\n  // do framing\n  const framed = _frameMergedOrDefault(expanded, expandedFrame, opts);\n\n  // compact result (force @graph option to true, skip expansion,\n  // check for linked embeds)\n  opts.graph = true;\n  opts.skipExpansion = true;\n  opts.link = {};\n  opts.framing = true;\n  const compacted = await jsonld.compact(framed, frameContext, opts);\n\n  return compacted;\n};\n\n/**\n * **Experimental**\n *\n * Links a JSON-LD document's nodes in memory.\n *\n * @param input the JSON-LD document to link.\n * @param [ctx] the JSON-LD context to apply.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the linked output.\n */\njsonld.link = async function(input, ctx, options) {\n  // API matches running frame with a wildcard frame and embed: '@link'\n  // get arguments\n  const frame = {};\n  if(ctx) {\n    frame['@context'] = ctx;\n  }\n  frame['@embed'] = '@link';\n  return jsonld.frame(input, frame, options);\n};\n\n/**\n * Performs RDF dataset normalization on the given input. The input is JSON-LD\n * unless the 'inputFormat' option is used. The output is an RDF dataset\n * unless the 'format' option is used.\n *\n * @param input the input to normalize as JSON-LD or as a format specified by\n *          the 'inputFormat' option.\n * @param [options] the options to use:\n *          [algorithm] the normalization algorithm to use, `URDNA2015` or\n *            `URGNA2012` (default: `URDNA2015`).\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false.\n *          [inputFormat] the format if input is not JSON-LD:\n *            'application/n-quads' for N-Quads.\n *          [format] the format if output is a string:\n *            'application/n-quads' for N-Quads.\n *          [documentLoader(url, options)] the document loader.\n *          [useNative] true to use a native canonize algorithm\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the normalized output.\n */\njsonld.normalize = jsonld.canonize = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not canonize, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    algorithm: 'URDNA2015',\n    skipExpansion: false,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n  if('inputFormat' in options) {\n    if(options.inputFormat !== 'application/n-quads' &&\n      options.inputFormat !== 'application/nquads') {\n      throw new JsonLdError(\n        'Unknown canonicalization input format.',\n        'jsonld.CanonizeError');\n    }\n    // TODO: `await` for async parsers\n    const parsedInput = NQuads.parse(input);\n\n    // do canonicalization\n    return canonize.canonize(parsedInput, options);\n  }\n\n  // convert to RDF dataset then do normalization\n  const opts = {...options};\n  delete opts.format;\n  opts.produceGeneralizedRdf = false;\n  const dataset = await jsonld.toRDF(input, opts);\n\n  // do canonicalization\n  return canonize.canonize(dataset, options);\n};\n\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset a serialized string of RDF in a format specified by the\n *          format option or an RDF dataset to convert.\n * @param [options] the options to use:\n *          [format] the format if dataset param must first be parsed:\n *            'application/n-quads' for N-Quads (default).\n *          [rdfParser] a custom RDF-parser to use to parse the dataset.\n *          [useRdfType] true to use rdf:type, false to use @type\n *            (default: false).\n *          [useNativeTypes] true to convert XSD types into native types\n *            (boolean, integer, double), false not to (default: false).\n *\n * @return a Promise that resolves to the JSON-LD document.\n */\njsonld.fromRDF = async function(dataset, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not convert from RDF, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    format: _isString(dataset) ? 'application/n-quads' : undefined\n  });\n\n  const {format} = options;\n  let {rdfParser} = options;\n\n  // handle special format\n  if(format) {\n    // check supported formats\n    rdfParser = rdfParser || _rdfParsers[format];\n    if(!rdfParser) {\n      throw new JsonLdError(\n        'Unknown input format.',\n        'jsonld.UnknownFormat', {format});\n    }\n  } else {\n    // no-op parser, assume dataset already parsed\n    rdfParser = () => dataset;\n  }\n\n  // rdfParser must be synchronous or return a promise, no callback support\n  const parsedDataset = await rdfParser(dataset);\n  return _fromRDF(parsedDataset, options);\n};\n\n/**\n * Outputs the RDF dataset found in the given JSON-LD object.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false.\n *          [format] the format to use to output a string:\n *            'application/n-quads' for N-Quads.\n *          [produceGeneralizedRdf] true to output generalized RDF, false\n *            to produce only standard RDF (default: false).\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the RDF dataset.\n */\njsonld.toRDF = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not convert to RDF, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    skipExpansion: false,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // TODO: support toRDF custom map?\n  let expanded;\n  if(options.skipExpansion) {\n    expanded = input;\n  } else {\n    // expand input\n    expanded = await jsonld.expand(input, options);\n  }\n\n  // output RDF dataset\n  const dataset = _toRDF(expanded, options);\n  if(options.format) {\n    if(options.format === 'application/n-quads' ||\n      options.format === 'application/nquads') {\n      return await NQuads.serialize(dataset);\n    }\n    throw new JsonLdError(\n      'Unknown output format.',\n      'jsonld.UnknownFormat', {format: options.format});\n  }\n\n  return dataset;\n};\n\n/**\n * **Experimental**\n *\n * Recursively flattens the nodes in the given JSON-LD input into a merged\n * map of node ID => node. All graphs will be merged into the default graph.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the merged node map.\n */\njsonld.createNodeMap = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not create node map, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  return _createMergedNodeMap(expanded, options);\n};\n\n/**\n * **Experimental**\n *\n * Merges two or more JSON-LD documents into a single flattened document.\n *\n * @param docs the JSON-LD documents to merge together.\n * @param ctx the context to use to compact the merged result, or null.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *          [mergeNodes] true to merge properties for nodes with the same ID,\n *            false to ignore new properties for nodes with the same ID once\n *            the ID has been defined; note that this may not prevent merging\n *            new properties where a node is in the `object` position\n *            (default: true).\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the merged output.\n */\njsonld.merge = async function(docs, ctx, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not merge, too few arguments.');\n  }\n  if(!_isArray(docs)) {\n    throw new TypeError('Could not merge, \"docs\" must be an array.');\n  }\n\n  if(typeof ctx === 'function') {\n    ctx = null;\n  } else {\n    ctx = ctx || null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand all documents\n  const expanded = await Promise.all(docs.map(doc => {\n    const opts = {...options};\n    return jsonld.expand(doc, opts);\n  }));\n\n  let mergeNodes = true;\n  if('mergeNodes' in options) {\n    mergeNodes = options.mergeNodes;\n  }\n\n  const issuer = options.issuer || new IdentifierIssuer('_:b');\n  const graphs = {'@default': {}};\n\n  for(let i = 0; i < expanded.length; ++i) {\n    // uniquely relabel blank nodes\n    const doc = util.relabelBlankNodes(expanded[i], {\n      issuer: new IdentifierIssuer('_:b' + i + '-')\n    });\n\n    // add nodes to the shared node map graphs if merging nodes, to a\n    // separate graph set if not\n    const _graphs = (mergeNodes || i === 0) ? graphs : {'@default': {}};\n    _createNodeMap(doc, _graphs, '@default', issuer);\n\n    if(_graphs !== graphs) {\n      // merge document graphs but don't merge existing nodes\n      for(const graphName in _graphs) {\n        const _nodeMap = _graphs[graphName];\n        if(!(graphName in graphs)) {\n          graphs[graphName] = _nodeMap;\n          continue;\n        }\n        const nodeMap = graphs[graphName];\n        for(const key in _nodeMap) {\n          if(!(key in nodeMap)) {\n            nodeMap[key] = _nodeMap[key];\n          }\n        }\n      }\n    }\n  }\n\n  // add all non-default graphs to default graph\n  const defaultGraph = _mergeNodeMaps(graphs);\n\n  // produce flattened output\n  const flattened = [];\n  const keys = Object.keys(defaultGraph).sort();\n  for(let ki = 0; ki < keys.length; ++ki) {\n    const node = defaultGraph[keys[ki]];\n    // only add full subjects to top-level\n    if(!_isSubjectReference(node)) {\n      flattened.push(node);\n    }\n  }\n\n  if(ctx === null) {\n    return flattened;\n  }\n\n  // compact result (force @graph option to true, skip expansion)\n  options.graph = true;\n  options.skipExpansion = true;\n  const compacted = await jsonld.compact(flattened, ctx, options);\n\n  return compacted;\n};\n\n/**\n * The default document loader for external documents.\n *\n * @param url the URL to load.\n *\n * @return a promise that resolves to the remote document.\n */\nObject.defineProperty(jsonld, 'documentLoader', {\n  get: () => jsonld._documentLoader,\n  set: v => jsonld._documentLoader = v\n});\n// default document loader not implemented\njsonld.documentLoader = async url => {\n  throw new JsonLdError(\n    'Could not retrieve a JSON-LD document from the URL. URL ' +\n    'dereferencing not implemented.', 'jsonld.LoadDocumentError',\n    {code: 'loading document failed', url});\n};\n\n/**\n * Gets a remote JSON-LD document using the default document loader or\n * one given in the passed options.\n *\n * @param url the URL to fetch.\n * @param [options] the options to use:\n *          [documentLoader] the document loader to use.\n *\n * @return a Promise that resolves to the retrieved remote document.\n */\njsonld.get = async function(url, options) {\n  let load;\n  if(typeof options.documentLoader === 'function') {\n    load = options.documentLoader;\n  } else {\n    load = jsonld.documentLoader;\n  }\n\n  const remoteDoc = await load(url);\n\n  try {\n    if(!remoteDoc.document) {\n      throw new JsonLdError(\n        'No remote document found at the given URL.',\n        'jsonld.NullRemoteDocument');\n    }\n    if(_isString(remoteDoc.document)) {\n      remoteDoc.document = JSON.parse(remoteDoc.document);\n    }\n  } catch(e) {\n    throw new JsonLdError(\n      'Could not retrieve a JSON-LD document from the URL.',\n      'jsonld.LoadDocumentError', {\n        code: 'loading document failed',\n        cause: e,\n        remoteDoc\n      });\n  }\n\n  return remoteDoc;\n};\n\n/**\n * Processes a local context, resolving any URLs as necessary, and returns a\n * new active context.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context to process.\n * @param [options] the options to use:\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the new active context.\n */\njsonld.processContext = async function(\n  activeCtx, localCtx, options) {\n  // set default options\n  options = _setDefaults(options, {\n    base: '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // return initial context early for null context\n  if(localCtx === null) {\n    return _getInitialContext(options);\n  }\n\n  // get URLs in localCtx\n  localCtx = util.clone(localCtx);\n  if(!(_isObject(localCtx) && '@context' in localCtx)) {\n    localCtx = {'@context': localCtx};\n  }\n\n  return _processContext({activeCtx, localCtx, options});\n};\n\n// backwards compatibility\njsonld.getContextValue = require('./context').getContextValue;\n\n/**\n * Document loaders.\n */\njsonld.documentLoaders = {};\njsonld.documentLoaders.node = require('./documentLoaders/node');\njsonld.documentLoaders.xhr = require('./documentLoaders/xhr');\n\n/**\n * Assigns the default document loader for external document URLs to a built-in\n * default. Supported types currently include: 'xhr' and 'node'.\n *\n * @param type the type to set.\n * @param [params] the parameters required to use the document loader.\n */\njsonld.useDocumentLoader = function(type) {\n  if(!(type in jsonld.documentLoaders)) {\n    throw new JsonLdError(\n      'Unknown document loader type: \"' + type + '\"',\n      'jsonld.UnknownDocumentLoader',\n      {type});\n  }\n\n  // set document loader\n  jsonld.documentLoader = jsonld.documentLoaders[type].apply(\n    jsonld, Array.prototype.slice.call(arguments, 1));\n};\n\n/**\n * Registers an RDF dataset parser by content-type, for use with\n * jsonld.fromRDF. An RDF dataset parser will always be given one parameter,\n * a string of input. An RDF dataset parser can be synchronous or\n * asynchronous (by returning a promise).\n *\n * @param contentType the content-type for the parser.\n * @param parser(input) the parser function (takes a string as a parameter\n *          and either returns an RDF dataset or a Promise that resolves to one.\n */\njsonld.registerRDFParser = function(contentType, parser) {\n  _rdfParsers[contentType] = parser;\n};\n\n/**\n * Unregisters an RDF dataset parser by content-type.\n *\n * @param contentType the content-type for the parser.\n */\njsonld.unregisterRDFParser = function(contentType) {\n  delete _rdfParsers[contentType];\n};\n\n// register the N-Quads RDF parser\njsonld.registerRDFParser('application/n-quads', NQuads.parse);\njsonld.registerRDFParser('application/nquads', NQuads.parse);\n\n// register the RDFa API RDF parser\njsonld.registerRDFParser('rdfa-api', Rdfa.parse);\n\n/* URL API */\njsonld.url = require('./url');\n\n/* Utility API */\njsonld.util = util;\n// backwards compatibility\nObject.assign(jsonld, util);\n\n// reexpose API as jsonld.promises for backwards compatability\njsonld.promises = jsonld;\n\n// backwards compatibility\njsonld.RequestQueue = require('./RequestQueue');\n\n/* WebIDL API */\njsonld.JsonLdProcessor = require('./JsonLdProcessor')(jsonld);\n\n// setup browser global JsonLdProcessor\nif(_browser && typeof global.JsonLdProcessor === 'undefined') {\n  Object.defineProperty(global, 'JsonLdProcessor', {\n    writable: true,\n    enumerable: false,\n    configurable: true,\n    value: jsonld.JsonLdProcessor\n  });\n}\n\n// set platform-specific defaults/APIs\nif(_nodejs) {\n  // use node document loader by default\n  jsonld.useDocumentLoader('node');\n} else if(typeof XMLHttpRequest !== 'undefined') {\n  // use xhr document loader by default\n  jsonld.useDocumentLoader('xhr');\n}\n\nfunction _setDefaults(options, {\n  documentLoader = jsonld.documentLoader,\n  ...defaults\n}) {\n  return Object.assign({}, {documentLoader}, defaults, options);\n}\n\n// end of jsonld API `wrapper` factory\nreturn jsonld;\n};\n\n// external APIs:\n\n// used to generate a new jsonld API instance\nconst factory = function() {\n  return wrapper(function() {\n    return factory();\n  });\n};\n\n// wrap the main jsonld API instance\nwrapper(factory);\n// export API\nmodule.exports = factory;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}