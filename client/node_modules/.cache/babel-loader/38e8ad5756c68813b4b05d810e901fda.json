{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\n// Utilities\nimport * as React from 'react';\nimport { classNamesFunction, elementContains, focusFirstChild, getDocument, KeyCodes, shallowCompare, getRTL, warnDeprecations, EventGroup, Async, initializeComponentRef } from '../../Utilities';\nimport { RectangleEdge, getOppositeEdge } from '../../utilities/positioning';\n// Component Dependencies\nimport { PositioningContainer } from './PositioningContainer/index';\nimport { Beak, BEAK_HEIGHT, BEAK_WIDTH } from './Beak/Beak';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { COACHMARK_HEIGHT, COACHMARK_WIDTH } from './Coachmark.styles';\nimport { FocusTrapZone } from '../../FocusTrapZone';\nvar getClassNames = classNamesFunction();\nexport var COACHMARK_ATTRIBUTE_NAME = 'data-coachmarkid';\nvar COMPONENT_NAME = 'Coachmark';\nvar CoachmarkBase = /** @class */function (_super) {\n  __extends(CoachmarkBase, _super);\n  function CoachmarkBase(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * The cached HTMLElement reference to the Entity Inner Host\n     * element.\n     */\n    _this._entityHost = React.createRef();\n    _this._entityInnerHostElement = React.createRef();\n    _this._translateAnimationContainer = React.createRef();\n    _this._ariaAlertContainer = React.createRef();\n    _this._childrenContainer = React.createRef();\n    _this._positioningContainer = React.createRef();\n    _this.dismiss = function (ev) {\n      var onDismiss = _this.props.onDismiss;\n      if (onDismiss) {\n        onDismiss(ev);\n      }\n    };\n    _this._onKeyDown = function (e) {\n      // Open coachmark if user presses ALT + C (arbitrary keypress for now)\n      if (e.altKey && e.which === KeyCodes.c || e.which === KeyCodes.enter && _this._translateAnimationContainer.current && _this._translateAnimationContainer.current.contains(e.target)) {\n        _this._onFocusHandler();\n      }\n    };\n    _this._onFocusHandler = function () {\n      if (_this.state.isCollapsed) {\n        _this._openCoachmark();\n      }\n    };\n    _this._onPositioned = function (positionData) {\n      _this._async.requestAnimationFrame(function () {\n        _this.setState({\n          targetAlignment: positionData.alignmentEdge,\n          targetPosition: positionData.targetEdge\n        });\n      });\n    };\n    _this._setBeakPosition = function () {\n      var beakLeft;\n      var beakTop;\n      var beakRight;\n      var beakBottom;\n      var transformOriginX;\n      var transformOriginY;\n      var targetAlignment = _this.state.targetAlignment;\n      var distanceAdjustment = '3px'; // Adjustment distance for Beak to shift towards Coachmark bubble.\n      switch (_this._beakDirection) {\n        // If Beak is pointing Up or Down\n        case RectangleEdge.top:\n        case RectangleEdge.bottom:\n          // If there is no target alignment, then beak is X-axis centered in callout\n          if (!targetAlignment) {\n            beakLeft = \"calc(50% - \" + BEAK_WIDTH / 2 + \"px)\";\n            transformOriginX = 'center';\n          } else {\n            // Beak is aligned to the left of target\n            if (targetAlignment === RectangleEdge.left) {\n              beakLeft = COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2 + \"px\";\n              transformOriginX = 'left';\n            } else {\n              // Beak is aligned to the right of target\n              beakRight = COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2 + \"px\";\n              transformOriginX = 'right';\n            }\n          }\n          if (_this._beakDirection === RectangleEdge.top) {\n            beakTop = distanceAdjustment;\n            transformOriginY = 'top';\n          } else {\n            beakBottom = distanceAdjustment;\n            transformOriginY = 'bottom';\n          }\n          break;\n        // If Beak is pointing Left or Right\n        case RectangleEdge.left:\n        case RectangleEdge.right:\n          // If there is no target alignment, then beak is Y-axis centered in callout\n          if (!targetAlignment) {\n            beakTop = \"calc(50% - \" + BEAK_WIDTH / 2 + \"px)\";\n            transformOriginY = \"center\";\n          } else {\n            // Beak is aligned to the top of target\n            if (targetAlignment === RectangleEdge.top) {\n              beakTop = COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2 + \"px\";\n              transformOriginY = \"top\";\n            } else {\n              // Beak is aligned to the bottom of target\n              beakBottom = COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2 + \"px\";\n              transformOriginY = \"bottom\";\n            }\n          }\n          if (_this._beakDirection === RectangleEdge.left) {\n            if (getRTL(_this.props.theme)) {\n              beakRight = distanceAdjustment;\n            } else {\n              beakLeft = distanceAdjustment;\n            }\n            transformOriginX = 'left';\n          } else {\n            if (getRTL(_this.props.theme)) {\n              beakLeft = distanceAdjustment;\n            } else {\n              beakRight = distanceAdjustment;\n            }\n            transformOriginX = 'right';\n          }\n          break;\n      }\n      _this.setState({\n        beakLeft: beakLeft,\n        beakRight: beakRight,\n        beakBottom: beakBottom,\n        beakTop: beakTop,\n        transformOrigin: transformOriginX + \" \" + transformOriginY\n      });\n    };\n    _this._openCoachmark = function () {\n      _this.setState({\n        isCollapsed: false\n      });\n      if (_this.props.onAnimationOpenStart) {\n        _this.props.onAnimationOpenStart();\n      }\n      _this._entityInnerHostElement.current && _this._entityInnerHostElement.current.addEventListener('transitionend', function () {\n        // Need setTimeout to trigger narrator\n        _this._async.setTimeout(function () {\n          if (_this._entityInnerHostElement.current) {\n            focusFirstChild(_this._entityInnerHostElement.current);\n          }\n        }, 1000);\n        if (_this.props.onAnimationOpenEnd) {\n          _this.props.onAnimationOpenEnd();\n        }\n      });\n    };\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    initializeComponentRef(_this);\n    warnDeprecations(COMPONENT_NAME, props, {\n      teachingBubbleRef: undefined,\n      collapsed: 'isCollapsed',\n      beakWidth: undefined,\n      beakHeight: undefined,\n      width: undefined,\n      height: undefined\n    });\n    // Set defaults for state\n    _this.state = {\n      isCollapsed: props.isCollapsed,\n      isBeaconAnimating: true,\n      isMeasuring: true,\n      entityInnerHostRect: {\n        width: 0,\n        height: 0\n      },\n      isMouseInProximity: false,\n      isMeasured: false\n    };\n    return _this;\n  }\n  Object.defineProperty(CoachmarkBase.prototype, \"_beakDirection\", {\n    get: function () {\n      var targetPosition = this.state.targetPosition;\n      if (targetPosition === undefined) {\n        return RectangleEdge.bottom;\n      }\n      return getOppositeEdge(targetPosition);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  CoachmarkBase.prototype.render = function () {\n    var _a = this.props,\n      beaconColorOne = _a.beaconColorOne,\n      beaconColorTwo = _a.beaconColorTwo,\n      children = _a.children,\n      target = _a.target,\n      color = _a.color,\n      positioningContainerProps = _a.positioningContainerProps,\n      ariaDescribedBy = _a.ariaDescribedBy,\n      ariaDescribedByText = _a.ariaDescribedByText,\n      ariaLabelledBy = _a.ariaLabelledBy,\n      ariaLabelledByText = _a.ariaLabelledByText,\n      ariaAlertText = _a.ariaAlertText,\n      delayBeforeCoachmarkAnimation = _a.delayBeforeCoachmarkAnimation,\n      styles = _a.styles,\n      theme = _a.theme,\n      className = _a.className,\n      persistentBeak = _a.persistentBeak;\n    var _b = this.state,\n      beakLeft = _b.beakLeft,\n      beakTop = _b.beakTop,\n      beakRight = _b.beakRight,\n      beakBottom = _b.beakBottom,\n      isCollapsed = _b.isCollapsed,\n      isBeaconAnimating = _b.isBeaconAnimating,\n      isMeasuring = _b.isMeasuring,\n      entityInnerHostRect = _b.entityInnerHostRect,\n      transformOrigin = _b.transformOrigin,\n      alertText = _b.alertText,\n      isMeasured = _b.isMeasured;\n    // Defaulting the main background before passing it to the styles because it is used for `Beak` too.\n    var defaultColor = color;\n    if (!defaultColor && theme) {\n      defaultColor = theme.semanticColors.primaryButtonBackground;\n    }\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      beaconColorOne: beaconColorOne,\n      beaconColorTwo: beaconColorTwo,\n      className: className,\n      isCollapsed: isCollapsed,\n      isBeaconAnimating: isBeaconAnimating,\n      isMeasuring: isMeasuring,\n      color: defaultColor,\n      transformOrigin: transformOrigin,\n      isMeasured: isMeasured,\n      entityHostHeight: entityInnerHostRect.height + \"px\",\n      entityHostWidth: entityInnerHostRect.width + \"px\",\n      width: COACHMARK_WIDTH + \"px\",\n      height: COACHMARK_HEIGHT + \"px\",\n      delayBeforeCoachmarkAnimation: delayBeforeCoachmarkAnimation + \"ms\"\n    });\n    var finalHeight = isCollapsed ? COACHMARK_HEIGHT : entityInnerHostRect.height;\n    return React.createElement(PositioningContainer, __assign({\n      target: target,\n      offsetFromTarget: BEAK_HEIGHT,\n      componentRef: this._positioningContainer,\n      finalHeight: finalHeight,\n      onPositioned: this._onPositioned,\n      bounds: this._getBounds()\n    }, positioningContainerProps), React.createElement(\"div\", {\n      className: classNames.root\n    }, ariaAlertText && React.createElement(\"div\", {\n      className: classNames.ariaContainer,\n      role: \"alert\",\n      ref: this._ariaAlertContainer,\n      \"aria-hidden\": !isCollapsed\n    }, alertText), React.createElement(\"div\", {\n      className: classNames.pulsingBeacon\n    }), React.createElement(\"div\", {\n      className: classNames.translateAnimationContainer,\n      ref: this._translateAnimationContainer\n    }, React.createElement(\"div\", {\n      className: classNames.scaleAnimationLayer\n    }, React.createElement(\"div\", {\n      className: classNames.rotateAnimationLayer\n    }, this._positioningContainer.current && (isCollapsed || persistentBeak) && React.createElement(Beak, {\n      left: beakLeft,\n      top: beakTop,\n      right: beakRight,\n      bottom: beakBottom,\n      direction: this._beakDirection,\n      color: defaultColor\n    }), React.createElement(\"div\", {\n      className: classNames.entityHost,\n      ref: this._entityHost,\n      tabIndex: -1,\n      \"data-is-focusable\": true,\n      role: \"dialog\",\n      \"aria-labelledby\": ariaLabelledBy,\n      \"aria-describedby\": ariaDescribedBy\n    }, isCollapsed && [ariaLabelledBy && React.createElement(\"p\", {\n      id: ariaLabelledBy,\n      key: 0,\n      className: classNames.ariaContainer\n    }, ariaLabelledByText), ariaDescribedBy && React.createElement(\"p\", {\n      id: ariaDescribedBy,\n      key: 1,\n      className: classNames.ariaContainer\n    }, ariaDescribedByText)], React.createElement(FocusTrapZone, {\n      isClickableOutsideFocusTrap: true,\n      forceFocusInsideTrap: false\n    }, React.createElement(\"div\", {\n      className: classNames.entityInnerHost,\n      ref: this._entityInnerHostElement\n    }, React.createElement(\"div\", {\n      className: classNames.childrenContainer,\n      ref: this._childrenContainer,\n      \"aria-hidden\": isCollapsed\n    }, children)))))))));\n  };\n  CoachmarkBase.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    if (this.props.isCollapsed && !newProps.isCollapsed) {\n      // The coachmark is about to open\n      this._openCoachmark();\n    }\n  };\n  CoachmarkBase.prototype.shouldComponentUpdate = function (newProps, newState) {\n    return !shallowCompare(newProps, this.props) || !shallowCompare(newState, this.state);\n  };\n  CoachmarkBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    if (prevState.targetAlignment !== this.state.targetAlignment || prevState.targetPosition !== this.state.targetPosition) {\n      this._setBeakPosition();\n    }\n    if (prevProps.preventDismissOnLostFocus !== this.props.preventDismissOnLostFocus) {\n      this._addListeners();\n    }\n  };\n  CoachmarkBase.prototype.componentDidMount = function () {\n    var _this = this;\n    this._async.requestAnimationFrame(function () {\n      if (_this._entityInnerHostElement.current && _this.state.entityInnerHostRect.width + _this.state.entityInnerHostRect.width === 0) {\n        _this.setState({\n          isMeasuring: false,\n          entityInnerHostRect: {\n            width: _this._entityInnerHostElement.current.offsetWidth,\n            height: _this._entityInnerHostElement.current.offsetHeight\n          },\n          isMeasured: true\n        });\n        _this._setBeakPosition();\n        _this.forceUpdate();\n      }\n      _this._addListeners();\n      // We don't want to the user to immediately trigger the Coachmark when it's opened\n      _this._async.setTimeout(function () {\n        _this._addProximityHandler(_this.props.mouseProximityOffset);\n      }, _this.props.delayBeforeMouseOpen);\n      // Need to add setTimeout to have narrator read change in alert container\n      if (_this.props.ariaAlertText) {\n        _this._async.setTimeout(function () {\n          if (_this.props.ariaAlertText && _this._ariaAlertContainer.current) {\n            _this.setState({\n              alertText: _this.props.ariaAlertText\n            });\n          }\n        }, 0);\n      }\n      if (!_this.props.preventFocusOnMount) {\n        _this._async.setTimeout(function () {\n          if (_this._entityHost.current) {\n            _this._entityHost.current.focus();\n          }\n        }, 1000);\n      }\n    });\n  };\n  CoachmarkBase.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n    this._events.dispose();\n  };\n  CoachmarkBase.prototype._addListeners = function () {\n    var preventDismissOnLostFocus = this.props.preventDismissOnLostFocus;\n    var currentDoc = getDocument();\n    this._events.off();\n    if (currentDoc) {\n      this._events.on(currentDoc, 'keydown', this._onKeyDown, true);\n      if (!preventDismissOnLostFocus) {\n        this._events.on(currentDoc, 'click', this._dismissOnLostFocus, true);\n        this._events.on(currentDoc, 'focus', this._dismissOnLostFocus, true);\n      }\n    }\n  };\n  CoachmarkBase.prototype._dismissOnLostFocus = function (ev) {\n    var clickTarget = ev.target;\n    var clickedOutsideCallout = this._translateAnimationContainer.current && !elementContains(this._translateAnimationContainer.current, clickTarget);\n    var target = this.props.target;\n    if (clickedOutsideCallout && clickTarget !== target && !elementContains(target, clickTarget)) {\n      this.dismiss(ev);\n    }\n  };\n  CoachmarkBase.prototype._getBounds = function () {\n    var _a = this.props,\n      isPositionForced = _a.isPositionForced,\n      positioningContainerProps = _a.positioningContainerProps;\n    if (isPositionForced) {\n      // If directionalHint direction is the top or bottom auto edge, then we want to set the left/right bounds\n      // to the window x-axis to have auto positioning work correctly.\n      if (positioningContainerProps && (positioningContainerProps.directionalHint === DirectionalHint.topAutoEdge || positioningContainerProps.directionalHint === DirectionalHint.bottomAutoEdge)) {\n        return {\n          left: 0,\n          top: -Infinity,\n          bottom: Infinity,\n          right: window.innerWidth,\n          width: window.innerWidth,\n          height: Infinity\n        };\n      } else {\n        return {\n          left: -Infinity,\n          top: -Infinity,\n          bottom: Infinity,\n          right: Infinity,\n          width: Infinity,\n          height: Infinity\n        };\n      }\n    } else {\n      return undefined;\n    }\n  };\n  CoachmarkBase.prototype._addProximityHandler = function (mouseProximityOffset) {\n    var _this = this;\n    if (mouseProximityOffset === void 0) {\n      mouseProximityOffset = 0;\n    }\n    /**\n     * An array of cached ids returned when setTimeout runs during\n     * the window resize event trigger.\n     */\n    var timeoutIds = [];\n    // Take the initial measure out of the initial render to prevent\n    // an unnecessary render.\n    this._async.setTimeout(function () {\n      _this._setTargetElementRect();\n      // When the window resizes we want to async\n      // get the bounding client rectangle.\n      // Every time the event is triggered we want to\n      // setTimeout and then clear any previous instances\n      // of setTimeout.\n      _this._events.on(window, 'resize', function () {\n        timeoutIds.forEach(function (value) {\n          clearInterval(value);\n        });\n        timeoutIds.push(_this._async.setTimeout(function () {\n          _this._setTargetElementRect();\n        }, 100));\n      });\n    }, 10);\n    // Every time the document's mouse move is triggered\n    // we want to check if inside of an element and\n    // set the state with the result.\n    this._events.on(document, 'mousemove', function (e) {\n      if (_this.state.isCollapsed) {\n        var mouseY = e.clientY;\n        var mouseX = e.clientX;\n        _this._setTargetElementRect();\n        var isMouseInProximity = _this._isInsideElement(mouseX, mouseY, mouseProximityOffset);\n        if (isMouseInProximity !== _this.state.isMouseInProximity) {\n          _this._openCoachmark();\n        }\n      }\n      if (_this.props.onMouseMove) {\n        _this.props.onMouseMove(e);\n      }\n    });\n  };\n  CoachmarkBase.prototype._setTargetElementRect = function () {\n    if (this._translateAnimationContainer && this._translateAnimationContainer.current) {\n      this._targetElementRect = this._translateAnimationContainer.current.getBoundingClientRect();\n    }\n  };\n  CoachmarkBase.prototype._isInsideElement = function (mouseX, mouseY, mouseProximityOffset) {\n    if (mouseProximityOffset === void 0) {\n      mouseProximityOffset = 0;\n    }\n    return mouseX > this._targetElementRect.left - mouseProximityOffset && mouseX < this._targetElementRect.left + this._targetElementRect.width + mouseProximityOffset && mouseY > this._targetElementRect.top - mouseProximityOffset && mouseY < this._targetElementRect.top + this._targetElementRect.height + mouseProximityOffset;\n  };\n  CoachmarkBase.defaultProps = {\n    isCollapsed: true,\n    mouseProximityOffset: 10,\n    delayBeforeMouseOpen: 3600,\n    delayBeforeCoachmarkAnimation: 0,\n    isPositionForced: true,\n    positioningContainerProps: {\n      directionalHint: DirectionalHint.bottomAutoEdge\n    }\n  };\n  return CoachmarkBase;\n}(React.Component);\nexport { CoachmarkBase };","map":{"version":3,"sources":["components/Coachmark/Coachmark.base.tsx"],"names":[],"mappings":"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","sourcesContent":["// Utilities\nimport * as React from 'react';\nimport {\n  classNamesFunction,\n  elementContains,\n  focusFirstChild,\n  getDocument,\n  IRectangle,\n  KeyCodes,\n  shallowCompare,\n  getRTL,\n  warnDeprecations,\n  EventGroup,\n  Async,\n  initializeComponentRef,\n} from '../../Utilities';\nimport { IPositionedData, RectangleEdge, getOppositeEdge } from '../../utilities/positioning';\n\n// Component Dependencies\nimport { PositioningContainer, IPositioningContainer } from './PositioningContainer/index';\nimport { Beak, BEAK_HEIGHT, BEAK_WIDTH } from './Beak/Beak';\nimport { DirectionalHint } from '../../common/DirectionalHint';\n\n// Coachmark\nimport { ICoachmark, ICoachmarkProps, ICoachmarkStyles, ICoachmarkStyleProps } from './Coachmark.types';\nimport { COACHMARK_HEIGHT, COACHMARK_WIDTH } from './Coachmark.styles';\nimport { FocusTrapZone } from '../../FocusTrapZone';\n\nconst getClassNames = classNamesFunction<ICoachmarkStyleProps, ICoachmarkStyles>();\n\nexport const COACHMARK_ATTRIBUTE_NAME = 'data-coachmarkid';\n\n/**\n * An interface for the cached dimensions of entity inner host.\n */\nexport interface IEntityRect {\n  width: number;\n  height: number;\n}\n\nexport interface ICoachmarkState {\n  /**\n   * Is the Coachmark currently collapsed into\n   * a tear drop shape\n   */\n  isCollapsed: boolean;\n\n  /**\n   * Enables/Disables the beacon that radiates\n   * from the center of the coachmark.\n   */\n  isBeaconAnimating: boolean;\n\n  /**\n   * Is the teaching bubble currently retreiving the\n   * original dimensions of the hosted entity.\n   */\n  isMeasuring: boolean;\n\n  /**\n   * Is the Coachmark done measuring the hosted entity\n   */\n  isMeasured: boolean;\n\n  /**\n   * Cached width and height of _entityInnerHostElement\n   */\n  entityInnerHostRect: IEntityRect;\n\n  /**\n   * Is the mouse in proximity of the default target element\n   */\n  isMouseInProximity: boolean;\n\n  /**\n   * The left position of the beak\n   */\n  beakLeft?: string;\n\n  /**\n   * The right position of the beak\n   */\n  beakTop?: string;\n\n  /**\n   * The right position of the beak\n   */\n  beakRight?: string;\n\n  /**\n   * The bottom position of the beak\n   */\n  beakBottom?: string;\n\n  /**\n   * Alignment edge of callout in relation to target\n   */\n  targetAlignment?: RectangleEdge;\n\n  /**\n   * Position of Coachmark/TeachingBubble in relation to target\n   */\n  targetPosition?: RectangleEdge;\n\n  /**\n   * Transform origin of teaching bubble callout\n   */\n  transformOrigin?: string;\n\n  /**\n   * ARIA alert text to read aloud with Narrator once the Coachmark is mounted\n   */\n  alertText?: string;\n}\n\nconst COMPONENT_NAME = 'Coachmark';\n\nexport class CoachmarkBase extends React.Component<ICoachmarkProps, ICoachmarkState> implements ICoachmark {\n  public static defaultProps: Partial<ICoachmarkProps> = {\n    isCollapsed: true,\n    mouseProximityOffset: 10,\n    delayBeforeMouseOpen: 3600, // The approximate time the coachmark shows up\n    delayBeforeCoachmarkAnimation: 0,\n    isPositionForced: true,\n    positioningContainerProps: {\n      directionalHint: DirectionalHint.bottomAutoEdge,\n    },\n  };\n\n  private _async: Async;\n  private _events: EventGroup;\n\n  /**\n   * The cached HTMLElement reference to the Entity Inner Host\n   * element.\n   */\n  private _entityHost = React.createRef<HTMLDivElement>();\n  private _entityInnerHostElement = React.createRef<HTMLDivElement>();\n  private _translateAnimationContainer = React.createRef<HTMLDivElement>();\n  private _ariaAlertContainer = React.createRef<HTMLDivElement>();\n  private _childrenContainer = React.createRef<HTMLDivElement>();\n  private _positioningContainer = React.createRef<IPositioningContainer>();\n\n  /**\n   * The target element the mouse would be in\n   * proximity to\n   */\n  private _targetElementRect: ClientRect;\n\n  constructor(props: ICoachmarkProps) {\n    super(props);\n\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n    initializeComponentRef(this);\n\n    warnDeprecations(COMPONENT_NAME, props, {\n      teachingBubbleRef: undefined,\n      collapsed: 'isCollapsed',\n      beakWidth: undefined,\n      beakHeight: undefined,\n      width: undefined,\n      height: undefined,\n    });\n\n    // Set defaults for state\n    this.state = {\n      isCollapsed: props.isCollapsed!,\n      isBeaconAnimating: true,\n      isMeasuring: true,\n      entityInnerHostRect: {\n        width: 0,\n        height: 0,\n      },\n      isMouseInProximity: false,\n      isMeasured: false,\n    };\n  }\n\n  private get _beakDirection(): RectangleEdge {\n    const { targetPosition } = this.state;\n    if (targetPosition === undefined) {\n      return RectangleEdge.bottom;\n    }\n\n    return getOppositeEdge(targetPosition);\n  }\n\n  public render(): JSX.Element {\n    const {\n      beaconColorOne,\n      beaconColorTwo,\n      children,\n      target,\n      color,\n      positioningContainerProps,\n      ariaDescribedBy,\n      ariaDescribedByText,\n      ariaLabelledBy,\n      ariaLabelledByText,\n      ariaAlertText,\n      delayBeforeCoachmarkAnimation,\n      styles,\n      theme,\n      className,\n      persistentBeak,\n    } = this.props;\n\n    const {\n      beakLeft,\n      beakTop,\n      beakRight,\n      beakBottom,\n      isCollapsed,\n      isBeaconAnimating,\n      isMeasuring,\n      entityInnerHostRect,\n      transformOrigin,\n      alertText,\n      isMeasured,\n    } = this.state;\n\n    // Defaulting the main background before passing it to the styles because it is used for `Beak` too.\n    let defaultColor = color;\n    if (!defaultColor && theme) {\n      defaultColor = theme.semanticColors.primaryButtonBackground;\n    }\n\n    const classNames = getClassNames(styles, {\n      theme,\n      beaconColorOne,\n      beaconColorTwo,\n      className,\n      isCollapsed,\n      isBeaconAnimating,\n      isMeasuring,\n      color: defaultColor,\n      transformOrigin,\n      isMeasured,\n      entityHostHeight: `${entityInnerHostRect.height}px`,\n      entityHostWidth: `${entityInnerHostRect.width}px`,\n      width: `${COACHMARK_WIDTH}px`,\n      height: `${COACHMARK_HEIGHT}px`,\n      delayBeforeCoachmarkAnimation: `${delayBeforeCoachmarkAnimation}ms`,\n    });\n\n    const finalHeight: number = isCollapsed ? COACHMARK_HEIGHT : entityInnerHostRect.height;\n\n    return (\n      <PositioningContainer\n        target={target}\n        offsetFromTarget={BEAK_HEIGHT}\n        componentRef={this._positioningContainer}\n        finalHeight={finalHeight}\n        onPositioned={this._onPositioned}\n        bounds={this._getBounds()}\n        {...positioningContainerProps}\n      >\n        <div className={classNames.root}>\n          {ariaAlertText && (\n            <div\n              className={classNames.ariaContainer}\n              role=\"alert\"\n              ref={this._ariaAlertContainer}\n              aria-hidden={!isCollapsed}\n            >\n              {alertText}\n            </div>\n          )}\n          <div className={classNames.pulsingBeacon} />\n          <div className={classNames.translateAnimationContainer} ref={this._translateAnimationContainer}>\n            <div className={classNames.scaleAnimationLayer}>\n              <div className={classNames.rotateAnimationLayer}>\n                {this._positioningContainer.current && (isCollapsed || persistentBeak) && (\n                  <Beak\n                    left={beakLeft}\n                    top={beakTop}\n                    right={beakRight}\n                    bottom={beakBottom}\n                    direction={this._beakDirection}\n                    color={defaultColor}\n                  />\n                )}\n                <div\n                  className={classNames.entityHost}\n                  ref={this._entityHost}\n                  tabIndex={-1}\n                  data-is-focusable={true}\n                  role=\"dialog\"\n                  aria-labelledby={ariaLabelledBy}\n                  aria-describedby={ariaDescribedBy}\n                >\n                  {isCollapsed && [\n                    ariaLabelledBy && (\n                      <p id={ariaLabelledBy} key={0} className={classNames.ariaContainer}>\n                        {ariaLabelledByText}\n                      </p>\n                    ),\n                    ariaDescribedBy && (\n                      <p id={ariaDescribedBy} key={1} className={classNames.ariaContainer}>\n                        {ariaDescribedByText}\n                      </p>\n                    ),\n                  ]}\n                  <FocusTrapZone isClickableOutsideFocusTrap={true} forceFocusInsideTrap={false}>\n                    <div className={classNames.entityInnerHost} ref={this._entityInnerHostElement}>\n                      <div\n                        className={classNames.childrenContainer}\n                        ref={this._childrenContainer}\n                        aria-hidden={isCollapsed}\n                      >\n                        {children}\n                      </div>\n                    </div>\n                  </FocusTrapZone>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </PositioningContainer>\n    );\n  }\n\n  public UNSAFE_componentWillReceiveProps(newProps: ICoachmarkProps): void {\n    if (this.props.isCollapsed && !newProps.isCollapsed) {\n      // The coachmark is about to open\n      this._openCoachmark();\n    }\n  }\n\n  public shouldComponentUpdate(newProps: ICoachmarkProps, newState: ICoachmarkState): boolean {\n    return !shallowCompare(newProps, this.props) || !shallowCompare(newState, this.state);\n  }\n\n  public componentDidUpdate(prevProps: ICoachmarkProps, prevState: ICoachmarkState): void {\n    if (\n      prevState.targetAlignment !== this.state.targetAlignment ||\n      prevState.targetPosition !== this.state.targetPosition\n    ) {\n      this._setBeakPosition();\n    }\n    if (prevProps.preventDismissOnLostFocus !== this.props.preventDismissOnLostFocus) {\n      this._addListeners();\n    }\n  }\n\n  public componentDidMount(): void {\n    this._async.requestAnimationFrame((): void => {\n      if (\n        this._entityInnerHostElement.current &&\n        this.state.entityInnerHostRect.width + this.state.entityInnerHostRect.width === 0\n      ) {\n        this.setState({\n          isMeasuring: false,\n          entityInnerHostRect: {\n            width: this._entityInnerHostElement.current.offsetWidth,\n            height: this._entityInnerHostElement.current.offsetHeight,\n          },\n          isMeasured: true,\n        });\n        this._setBeakPosition();\n        this.forceUpdate();\n      }\n\n      this._addListeners();\n\n      // We don't want to the user to immediately trigger the Coachmark when it's opened\n      this._async.setTimeout(() => {\n        this._addProximityHandler(this.props.mouseProximityOffset);\n      }, this.props.delayBeforeMouseOpen!);\n\n      // Need to add setTimeout to have narrator read change in alert container\n      if (this.props.ariaAlertText) {\n        this._async.setTimeout(() => {\n          if (this.props.ariaAlertText && this._ariaAlertContainer.current) {\n            this.setState({\n              alertText: this.props.ariaAlertText,\n            });\n          }\n        }, 0);\n      }\n\n      if (!this.props.preventFocusOnMount) {\n        this._async.setTimeout(() => {\n          if (this._entityHost.current) {\n            this._entityHost.current.focus();\n          }\n        }, 1000);\n      }\n    });\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  public dismiss = (ev?: Event | React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>): void => {\n    const { onDismiss } = this.props;\n\n    if (onDismiss) {\n      onDismiss(ev);\n    }\n  };\n\n  private _addListeners(): void {\n    const { preventDismissOnLostFocus } = this.props;\n    const currentDoc: Document = getDocument()!;\n\n    this._events.off();\n\n    if (currentDoc) {\n      this._events.on(currentDoc, 'keydown', this._onKeyDown, true);\n\n      if (!preventDismissOnLostFocus) {\n        this._events.on(currentDoc, 'click', this._dismissOnLostFocus, true);\n        this._events.on(currentDoc, 'focus', this._dismissOnLostFocus, true);\n      }\n    }\n  }\n\n  private _dismissOnLostFocus(ev: Event) {\n    const clickTarget = ev.target as HTMLElement;\n    const clickedOutsideCallout =\n      this._translateAnimationContainer.current &&\n      !elementContains(this._translateAnimationContainer.current, clickTarget);\n    const { target } = this.props;\n\n    if (clickedOutsideCallout && clickTarget !== target && !elementContains(target as HTMLElement, clickTarget)) {\n      this.dismiss(ev);\n    }\n  }\n\n  private _onKeyDown = (e: any): void => {\n    // Open coachmark if user presses ALT + C (arbitrary keypress for now)\n    if (\n      (e.altKey && e.which === KeyCodes.c) ||\n      (e.which === KeyCodes.enter &&\n        this._translateAnimationContainer.current &&\n        this._translateAnimationContainer.current.contains(e.target))\n    ) {\n      this._onFocusHandler();\n    }\n  };\n\n  private _onFocusHandler = (): void => {\n    if (this.state.isCollapsed) {\n      this._openCoachmark();\n    }\n  };\n\n  private _onPositioned = (positionData: IPositionedData): void => {\n    this._async.requestAnimationFrame((): void => {\n      this.setState({\n        targetAlignment: positionData.alignmentEdge,\n        targetPosition: positionData.targetEdge,\n      });\n    });\n  };\n\n  private _getBounds(): IRectangle | undefined {\n    const { isPositionForced, positioningContainerProps } = this.props;\n    if (isPositionForced) {\n      // If directionalHint direction is the top or bottom auto edge, then we want to set the left/right bounds\n      // to the window x-axis to have auto positioning work correctly.\n      if (\n        positioningContainerProps &&\n        (positioningContainerProps.directionalHint === DirectionalHint.topAutoEdge ||\n          positioningContainerProps.directionalHint === DirectionalHint.bottomAutoEdge)\n      ) {\n        return {\n          left: 0,\n          top: -Infinity,\n          bottom: Infinity,\n          right: window.innerWidth,\n          width: window.innerWidth,\n          height: Infinity,\n        };\n      } else {\n        return {\n          left: -Infinity,\n          top: -Infinity,\n          bottom: Infinity,\n          right: Infinity,\n          width: Infinity,\n          height: Infinity,\n        };\n      }\n    } else {\n      return undefined;\n    }\n  }\n\n  private _setBeakPosition = (): void => {\n    let beakLeft;\n    let beakTop;\n    let beakRight;\n    let beakBottom;\n    let transformOriginX;\n    let transformOriginY;\n\n    const { targetAlignment } = this.state;\n    const distanceAdjustment = '3px'; // Adjustment distance for Beak to shift towards Coachmark bubble.\n\n    switch (this._beakDirection) {\n      // If Beak is pointing Up or Down\n      case RectangleEdge.top:\n      case RectangleEdge.bottom:\n        // If there is no target alignment, then beak is X-axis centered in callout\n        if (!targetAlignment) {\n          beakLeft = `calc(50% - ${BEAK_WIDTH / 2}px)`;\n          transformOriginX = 'center';\n        } else {\n          // Beak is aligned to the left of target\n          if (targetAlignment === RectangleEdge.left) {\n            beakLeft = `${COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2}px`;\n            transformOriginX = 'left';\n          } else {\n            // Beak is aligned to the right of target\n            beakRight = `${COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2}px`;\n            transformOriginX = 'right';\n          }\n        }\n\n        if (this._beakDirection === RectangleEdge.top) {\n          beakTop = distanceAdjustment;\n          transformOriginY = 'top';\n        } else {\n          beakBottom = distanceAdjustment;\n          transformOriginY = 'bottom';\n        }\n        break;\n      // If Beak is pointing Left or Right\n      case RectangleEdge.left:\n      case RectangleEdge.right:\n        // If there is no target alignment, then beak is Y-axis centered in callout\n        if (!targetAlignment) {\n          beakTop = `calc(50% - ${BEAK_WIDTH / 2}px)`;\n          transformOriginY = `center`;\n        } else {\n          // Beak is aligned to the top of target\n          if (targetAlignment === RectangleEdge.top) {\n            beakTop = `${COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2}px`;\n            transformOriginY = `top`;\n          } else {\n            // Beak is aligned to the bottom of target\n            beakBottom = `${COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2}px`;\n            transformOriginY = `bottom`;\n          }\n        }\n\n        if (this._beakDirection === RectangleEdge.left) {\n          if (getRTL(this.props.theme)) {\n            beakRight = distanceAdjustment;\n          } else {\n            beakLeft = distanceAdjustment;\n          }\n          transformOriginX = 'left';\n        } else {\n          if (getRTL(this.props.theme)) {\n            beakLeft = distanceAdjustment;\n          } else {\n            beakRight = distanceAdjustment;\n          }\n          transformOriginX = 'right';\n        }\n        break;\n    }\n\n    this.setState({\n      beakLeft: beakLeft,\n      beakRight: beakRight,\n      beakBottom: beakBottom,\n      beakTop: beakTop,\n      transformOrigin: `${transformOriginX} ${transformOriginY}`,\n    });\n  };\n\n  private _openCoachmark = (): void => {\n    this.setState({\n      isCollapsed: false,\n    });\n\n    if (this.props.onAnimationOpenStart) {\n      this.props.onAnimationOpenStart();\n    }\n\n    this._entityInnerHostElement.current &&\n      this._entityInnerHostElement.current.addEventListener('transitionend', (): void => {\n        // Need setTimeout to trigger narrator\n        this._async.setTimeout(() => {\n          if (this._entityInnerHostElement.current) {\n            focusFirstChild(this._entityInnerHostElement.current);\n          }\n        }, 1000);\n\n        if (this.props.onAnimationOpenEnd) {\n          this.props.onAnimationOpenEnd();\n        }\n      });\n  };\n\n  private _addProximityHandler(mouseProximityOffset: number = 0): void {\n    /**\n     * An array of cached ids returned when setTimeout runs during\n     * the window resize event trigger.\n     */\n    const timeoutIds: number[] = [];\n\n    // Take the initial measure out of the initial render to prevent\n    // an unnecessary render.\n    this._async.setTimeout(() => {\n      this._setTargetElementRect();\n\n      // When the window resizes we want to async\n      // get the bounding client rectangle.\n      // Every time the event is triggered we want to\n      // setTimeout and then clear any previous instances\n      // of setTimeout.\n      this._events.on(window, 'resize', (): void => {\n        timeoutIds.forEach((value: number): void => {\n          clearInterval(value);\n        });\n\n        timeoutIds.push(\n          this._async.setTimeout((): void => {\n            this._setTargetElementRect();\n          }, 100),\n        );\n      });\n    }, 10);\n\n    // Every time the document's mouse move is triggered\n    // we want to check if inside of an element and\n    // set the state with the result.\n    this._events.on(document, 'mousemove', (e: MouseEvent) => {\n      if (this.state.isCollapsed) {\n        const mouseY = e.clientY;\n        const mouseX = e.clientX;\n        this._setTargetElementRect();\n        const isMouseInProximity = this._isInsideElement(mouseX, mouseY, mouseProximityOffset);\n\n        if (isMouseInProximity !== this.state.isMouseInProximity) {\n          this._openCoachmark();\n        }\n      }\n\n      if (this.props.onMouseMove) {\n        this.props.onMouseMove(e);\n      }\n    });\n  }\n\n  private _setTargetElementRect(): void {\n    if (this._translateAnimationContainer && this._translateAnimationContainer.current) {\n      this._targetElementRect = this._translateAnimationContainer!.current!.getBoundingClientRect();\n    }\n  }\n\n  private _isInsideElement(mouseX: number, mouseY: number, mouseProximityOffset: number = 0): boolean {\n    return (\n      mouseX > this._targetElementRect.left - mouseProximityOffset &&\n      mouseX < this._targetElementRect.left + this._targetElementRect.width + mouseProximityOffset &&\n      mouseY > this._targetElementRect.top - mouseProximityOffset &&\n      mouseY < this._targetElementRect.top + this._targetElementRect.height + mouseProximityOffset\n    );\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}