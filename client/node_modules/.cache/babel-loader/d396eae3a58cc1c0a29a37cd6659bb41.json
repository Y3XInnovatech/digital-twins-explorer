{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst constants_1 = require(\"./constants\");\nconst errors_1 = __importDefault(require(\"./errors\"));\nclass IRI {\n  constructor() {\n    this._prefixes = new Map();\n  }\n  addPrefix(prefix, iri) {\n    if (!prefix) {\n      throw new ReferenceError(`Invalid prefix. prefix is ${prefix}`);\n    }\n    if (!iri) {\n      throw new ReferenceError(`Invalid iri. iri is ${iri}`);\n    }\n    if (prefix.startsWith('http') || prefix.startsWith('https') || prefix.startsWith('urn')) {\n      throw new errors_1.default.InvalidPrefixError(prefix, 'Cannot use reserved prefixes `http`, `https` or `urn`');\n    }\n    if (prefix.startsWith(':') || prefix.endsWith(':')) {\n      throw new errors_1.default.InvalidPrefixError(prefix, 'Prefixes cannot start or end with the \":\" character1');\n    }\n    if (this._prefixes.has(prefix)) {\n      throw new errors_1.default.DuplicatePrefixError(prefix);\n    }\n    for (const [, mappedUri] of this._prefixes) {\n      if (mappedUri.toLowerCase() === iri.toLowerCase()) {\n        throw new errors_1.default.DuplicatePrefixUriError(prefix, iri);\n      }\n    }\n    this._prefixes.set(prefix, iri);\n  }\n  /**\n   * @description Performs a compaction of an IRI by substituting a matching prefix. If the IRI is already compacted, the exact same string is returned.\n   * @param {string} iri The IRI to compact.\n   * @returns {string}\n   * @memberof IRI\n   */\n  compact(iri) {\n    if (!iri) {\n      throw new ReferenceError(`Invalid iri. iri is ${iri}`);\n    }\n    if (iri.startsWith(constants_1.BlankNodePrefix) || iri === constants_1.JsonldKeywords.type || this._prefixes.size === 0) {\n      return iri;\n    }\n    for (const [prefix, mappedIRI] of this._prefixes) {\n      if (iri.startsWith(mappedIRI) && iri.toLowerCase() !== mappedIRI.toLowerCase()) {\n        let compacted = iri.replace(mappedIRI, '');\n        if (compacted.startsWith('/') || compacted.startsWith(':')) {\n          compacted = compacted.slice(1, compacted.length);\n        }\n        return `${prefix}:${compacted}`;\n      }\n    }\n    return iri;\n  }\n  /**\n   * @description Checks if two IRI's are equal.\n   * @param {string} iriA The IRI to compare.\n   * @param {string} iriB The IRI to compare.\n   * @returns {boolean} True if both IRI's are equal, else false.\n   * @memberof IRI\n   */\n  equal(iriA, iriB) {\n    return this.expand(iriA).toLowerCase() === this.expand(iriB).toLowerCase();\n  }\n  /**\n   * @description Performs an expansion of an IRI by fully expanding a prefix. If the IRI is already expanded, the exact same string is returned.\n   * @param {string} iri The compact IRI to expand.\n   * @returns {string}\n   * @memberof IRI\n   */\n  expand(iri) {\n    if (!iri) {\n      throw new ReferenceError(`Invalid iri. iri is ${iri}`);\n    }\n    if (iri.startsWith(constants_1.BlankNodePrefix) || iri === constants_1.JsonldKeywords.type || iri === constants_1.JsonldKeywords.id || this._prefixes.size === 0) {\n      return iri;\n    }\n    const prefixIndex = iri.indexOf(':');\n    if (prefixIndex <= 0) {\n      return iri;\n    }\n    const prefix = iri.substring(0, prefixIndex);\n    const component = iri.substring(prefixIndex + 1);\n    let expandedIRI;\n    if (this._prefixes.has(prefix)) {\n      expandedIRI = `${this._prefixes.get(prefix)}${component}`;\n    } else {\n      expandedIRI = iri;\n    }\n    return expandedIRI;\n  }\n  /**w\n   * @description Removes a prefix.\n   * @param {string} prefix The prefix to remove.\n   * @memberof IRI\n   */\n  removePrefix(prefix) {\n    if (!prefix) {\n      throw new ReferenceError(`Invalid prefix. prefix is ${prefix}`);\n    }\n    this._prefixes.delete(prefix);\n  }\n}\nexports.IRI = IRI;\nexports.default = IRI;","map":{"version":3,"sources":["../src/iri.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = require(\"./constants\");\nconst errors_1 = __importDefault(require(\"./errors\"));\nclass IRI {\n    constructor() {\n        this._prefixes = new Map();\n    }\n    addPrefix(prefix, iri) {\n        if (!prefix) {\n            throw new ReferenceError(`Invalid prefix. prefix is ${prefix}`);\n        }\n        if (!iri) {\n            throw new ReferenceError(`Invalid iri. iri is ${iri}`);\n        }\n        if (prefix.startsWith('http') || prefix.startsWith('https') || prefix.startsWith('urn')) {\n            throw new errors_1.default.InvalidPrefixError(prefix, 'Cannot use reserved prefixes `http`, `https` or `urn`');\n        }\n        if (prefix.startsWith(':') || prefix.endsWith(':')) {\n            throw new errors_1.default.InvalidPrefixError(prefix, 'Prefixes cannot start or end with the \":\" character1');\n        }\n        if (this._prefixes.has(prefix)) {\n            throw new errors_1.default.DuplicatePrefixError(prefix);\n        }\n        for (const [, mappedUri] of this._prefixes) {\n            if (mappedUri.toLowerCase() === iri.toLowerCase()) {\n                throw new errors_1.default.DuplicatePrefixUriError(prefix, iri);\n            }\n        }\n        this._prefixes.set(prefix, iri);\n    }\n    /**\n     * @description Performs a compaction of an IRI by substituting a matching prefix. If the IRI is already compacted, the exact same string is returned.\n     * @param {string} iri The IRI to compact.\n     * @returns {string}\n     * @memberof IRI\n     */\n    compact(iri) {\n        if (!iri) {\n            throw new ReferenceError(`Invalid iri. iri is ${iri}`);\n        }\n        if (iri.startsWith(constants_1.BlankNodePrefix) || iri === constants_1.JsonldKeywords.type || this._prefixes.size === 0) {\n            return iri;\n        }\n        for (const [prefix, mappedIRI] of this._prefixes) {\n            if (iri.startsWith(mappedIRI) && iri.toLowerCase() !== mappedIRI.toLowerCase()) {\n                let compacted = iri.replace(mappedIRI, '');\n                if (compacted.startsWith('/') || compacted.startsWith(':')) {\n                    compacted = compacted.slice(1, compacted.length);\n                }\n                return `${prefix}:${compacted}`;\n            }\n        }\n        return iri;\n    }\n    /**\n     * @description Checks if two IRI's are equal.\n     * @param {string} iriA The IRI to compare.\n     * @param {string} iriB The IRI to compare.\n     * @returns {boolean} True if both IRI's are equal, else false.\n     * @memberof IRI\n     */\n    equal(iriA, iriB) {\n        return this.expand(iriA).toLowerCase() === this.expand(iriB).toLowerCase();\n    }\n    /**\n     * @description Performs an expansion of an IRI by fully expanding a prefix. If the IRI is already expanded, the exact same string is returned.\n     * @param {string} iri The compact IRI to expand.\n     * @returns {string}\n     * @memberof IRI\n     */\n    expand(iri) {\n        if (!iri) {\n            throw new ReferenceError(`Invalid iri. iri is ${iri}`);\n        }\n        if (iri.startsWith(constants_1.BlankNodePrefix) ||\n            iri === constants_1.JsonldKeywords.type ||\n            iri === constants_1.JsonldKeywords.id ||\n            this._prefixes.size === 0) {\n            return iri;\n        }\n        const prefixIndex = iri.indexOf(':');\n        if (prefixIndex <= 0) {\n            return iri;\n        }\n        const prefix = iri.substring(0, prefixIndex);\n        const component = iri.substring(prefixIndex + 1);\n        let expandedIRI;\n        if (this._prefixes.has(prefix)) {\n            expandedIRI = `${this._prefixes.get(prefix)}${component}`;\n        }\n        else {\n            expandedIRI = iri;\n        }\n        return expandedIRI;\n    }\n    /**w\n     * @description Removes a prefix.\n     * @param {string} prefix The prefix to remove.\n     * @memberof IRI\n     */\n    removePrefix(prefix) {\n        if (!prefix) {\n            throw new ReferenceError(`Invalid prefix. prefix is ${prefix}`);\n        }\n        this._prefixes.delete(prefix);\n    }\n}\nexports.IRI = IRI;\nexports.default = IRI;\n//# sourceMappingURL=iri.js.map"]},"metadata":{},"sourceType":"script"}