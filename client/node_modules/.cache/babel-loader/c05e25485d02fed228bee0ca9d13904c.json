{"ast":null,"code":"import { be as __awaiter, bf as __generator, a as CancelledPromiseError, bg as __assign, bj as __spreadArray } from './Interfaces-f1972c79.js';\nimport { f as fn } from './immer.esm-8bf4cc8a.js';\nimport React__default, { useRef, useEffect, useState, useMemo, useReducer, useContext } from 'react';\nimport { A as AdapterResult } from './AdapterResult-96d676e4.js';\nimport './index-0a792490.js';\nvar SET_IS_LOADING = 'SET_IS_LOADING';\nvar SET_ADAPTER_RESULT = 'SET_ADAPTER_RESULT';\nvar SET_IS_LONG_POLLING = 'SET_IS_LONG_POLLING';\nvar SET_IS_INITIAL_CALL = 'SET_IS_INITIAL_CALL';\nvar SET_OAT_PROPERTY_EDITOR_CURRENT_PROPERTY_INDEX = 'SET_OAT_PROPERTY_EDITOR_CURRENT_PROPERTY_INDEX';\nvar SET_OAT_PROPERTY_EDITOR_CURRENT_NESTED_PROPERTY_INDEX = 'SET_OAT_PROPERTY_EDITOR_CURRENT_NESTED_PROPERTY_INDEX';\nvar SET_OAT_PROPERTY_EDITOR_DRAGGING_TEMPLATE = 'SET_OAT_PROPERTY_EDITOR_DRAGGING_TEMPLATE';\nvar SET_OAT_PROPERTY_EDITOR_DRAGGING_PROPERTY = 'SET_OAT_PROPERTY_EDITOR_DRAGGING_PROPERTY';\nvar SET_OAT_PROPERTY_MODAL_OPEN = 'SET_OAT_PROPERTY_MODAL_OPEN';\nvar SET_OAT_PROPERTY_MODAL_BODY = 'SET_OAT_PROPERTY_MODAL_BODY';\n\n/** Wraps promise with logic that allows for promise cancellation via cancel() method */\nfunction makeCancellable(promise, promisesRef) {\n  var isCancelled = false;\n  var returnValue = {\n    promise: null,\n    cancel: function () {\n      return null;\n    }\n  };\n  var wrappedPromise = new Promise(function (resolve, reject) {\n    function executePromise() {\n      return __awaiter(this, void 0, void 0, function () {\n        var val, error_1;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n              return [4 /*yield*/, promise];\n            case 1:\n              val = _a.sent();\n              if (isCancelled) {\n                reject(new CancelledPromiseError());\n              } else {\n                resolve(val);\n              }\n              return [3 /*break*/, 3];\n            case 2:\n              error_1 = _a.sent();\n              if (isCancelled) {\n                reject(new CancelledPromiseError());\n              } else {\n                reject(error_1);\n              }\n              return [3 /*break*/, 3];\n            case 3:\n              // Remove promise from promisesRef.current list once resolved/rejected\n              if (promisesRef && promisesRef.current.indexOf(returnValue) !== -1) {\n                promisesRef.current = promisesRef.current.filter(function (promise) {\n                  return promise !== returnValue;\n                });\n              }\n              return [2 /*return*/];\n          }\n        });\n      });\n    }\n    executePromise();\n  });\n  returnValue = {\n    promise: wrappedPromise,\n    cancel: function () {\n      isCancelled = true;\n    }\n  };\n  return returnValue;\n}\n/**\r\n * Exposes two functions: 'cancellablePromise' to wrap promises in cancellation code which auto cancels on unmount,\r\n * and 'cancel' function to manually cancel wrapped promises.  This hooks was adapted from the following repo:\r\n * https://github.com/rajeshnaroth/react-cancelable-promise-hook/blob/master/index.js\r\n */\nvar useCancellablePromise = function () {\n  var promises = useRef(null);\n  /** Cancel all active promises constructed by this hook's consumer */\n  function cancel() {\n    promises.current.forEach(function (p) {\n      return p.cancel();\n    });\n    promises.current = [];\n  }\n  // On unmount, cancel promises\n  useEffect(function () {\n    promises.current = promises.current || [];\n    return cancel;\n  }, []);\n  /** Function to construct cancellable promise if it is not already */\n  function cancellablePromise(p) {\n    var isICancellablePromise = p['cancel'] && typeof p['cancel'] === 'function';\n    var cPromise = !isICancellablePromise ? makeCancellable(p, promises) : p;\n    promises.current.push(cPromise);\n    return !isICancellablePromise ? cPromise.promise : p;\n  }\n  return {\n    cancellablePromise: cancellablePromise,\n    cancel: cancel\n  };\n};\nvar defaultPollingIntervalMillis = 1000;\nvar defaultPulseTimeoutMillis = 400;\n/**\r\n * Hook to wrap vanilla setInterval with smarter, unmount-safe logic.\r\n * Adapted from Dan Abramov's declarative setInterval blog post\r\n * https://overreacted.io/making-setinterval-declarative-with-react-hooks/\r\n */\nvar useLongPoll = function (_a) {\n  var callback = _a.callback,\n    _b = _a.pollingIntervalMillis,\n    pollingIntervalMillis = _b === void 0 ? defaultPollingIntervalMillis : _b,\n    _c = _a.pulseTimeoutMillis,\n    pulseTimeoutMillis = _c === void 0 ? defaultPulseTimeoutMillis : _c;\n  var _d = useState(false),\n    pulse = _d[0],\n    setPulse = _d[1];\n  var savedCallback = useRef(null);\n  var mountedRef = useRef(true);\n  // Remember the latest callback\n  useEffect(function () {\n    savedCallback.current = callback;\n  }, [callback]);\n  // Set up the interval\n  useEffect(function () {\n    var timeoutId, intervalId;\n    function tick() {\n      return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4 /*yield*/, savedCallback.current()];\n            case 1:\n              _a.sent();\n              mountedRef.current && setPulse(true);\n              timeoutId = setTimeout(function () {\n                return mountedRef.current && setPulse(false);\n              }, pulseTimeoutMillis);\n              return [2 /*return*/];\n          }\n        });\n      });\n    }\n    if (pollingIntervalMillis !== null) {\n      tick();\n      intervalId = setInterval(tick, pollingIntervalMillis);\n      return function () {\n        mountedRef.current = false;\n        clearInterval(intervalId);\n        clearTimeout(timeoutId);\n      };\n    }\n  }, [pollingIntervalMillis]);\n  return {\n    /**\r\n     * Boolean pulse variable. Toggled to true for pulseTimeoutMillis\r\n     * after callback completion, before returning to false.  Can be used\r\n     * for visual indication of updated data in UI.\r\n     */\n    pulse: pulse\n  };\n};\n\n// Sets up reducer with 'curried producer' - https://immerjs.github.io/immer/docs/curried-produce\n// Draft state can be directly modified.  Draft does not need to be explicitly returned.\nvar cardStateReducer = fn(function (draft, action) {\n  var payload = action.payload;\n  switch (action.type) {\n    case SET_IS_LOADING:\n      draft.isLoading = payload;\n      return;\n    case SET_ADAPTER_RESULT:\n      draft.adapterResult = payload;\n      return;\n    case SET_IS_LONG_POLLING:\n      draft.isLongPolling = payload;\n      return;\n    case SET_IS_INITIAL_CALL:\n      draft.isInitialCall = payload;\n      return;\n    default:\n      return;\n  }\n});\n/** Wraps adapter data fetching, loading, long polling, and promise cancelling logic */\nvar useAdapter = function (_a) {\n  var adapterMethod = _a.adapterMethod,\n    refetchDependencies = _a.refetchDependencies,\n    _b = _a.isLongPolling,\n    isLongPolling = _b === void 0 ? false : _b,\n    pollingIntervalMillis = _a.pollingIntervalMillis,\n    pulseTimeoutMillis = _a.pulseTimeoutMillis,\n    _c = _a.isAdapterCalledOnMount,\n    isAdapterCalledOnMount = _c === void 0 ? true : _c;\n  var defaultCardState = useMemo(function () {\n    return {\n      adapterResult: new AdapterResult({\n        result: null,\n        errorInfo: null\n      }),\n      isLoading: isAdapterCalledOnMount,\n      isLongPolling: isLongPolling,\n      isInitialCall: true\n    };\n  }, [isLongPolling]);\n  var mountedRef = useRef(null);\n  var _d = useReducer(cardStateReducer, defaultCardState),\n    state = _d[0],\n    dispatch = _d[1];\n  var _e = useCancellablePromise(),\n    cancellablePromise = _e.cancellablePromise,\n    cancel = _e.cancel;\n  var setIsLoading = function (isLoading) {\n    dispatch({\n      type: SET_IS_LOADING,\n      payload: isLoading\n    });\n  };\n  var setAdapterResult = function (adapterResult) {\n    if (!adapterResult) {\n      adapterResult = new AdapterResult({\n        result: null,\n        errorInfo: null\n      });\n    }\n    dispatch({\n      type: SET_ADAPTER_RESULT,\n      payload: adapterResult\n    });\n  };\n  var callAdapter = function (params) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var adapterResult, err_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            setIsLoading(true);\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, cancellablePromise(adapterMethod(params))];\n          case 2:\n            adapterResult = _a.sent();\n            if (mountedRef.current) {\n              setAdapterResult(adapterResult);\n              setIsLoading(false);\n            }\n            return [3 /*break*/, 4];\n          case 3:\n            err_1 = _a.sent();\n            if (!(err_1 instanceof CancelledPromiseError)) {\n              console.error('Unexpected promise error', err_1); // log unexpected errors\n              if (mountedRef.current) {\n                setIsLoading(false); // Toggle off loading state if component is still mounted\n              }\n            }\n            return [3 /*break*/, 4];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  var cancelAdapter = function (shouldPreserveResult) {\n    cancel(); // Cancel outstanding promises\n    if (mountedRef.current) {\n      if (!shouldPreserveResult) {\n        setAdapterResult(null);\n      }\n      setIsLoading(false);\n    }\n  };\n  var setIsLongPolling = function (isLongPolling) {\n    dispatch({\n      type: SET_IS_LONG_POLLING,\n      payload: isLongPolling\n    });\n  };\n  var longPoll = useLongPoll(__assign({\n    callback: callAdapter,\n    pollingIntervalMillis: !state.isLongPolling ? null : pollingIntervalMillis\n  }, pulseTimeoutMillis && {\n    pulseTimeoutMillis: pulseTimeoutMillis\n  }));\n  useEffect(function () {\n    if (isAdapterCalledOnMount) {\n      if (state.isInitialCall) {\n        callAdapter();\n        dispatch({\n          type: SET_IS_INITIAL_CALL,\n          payload: false\n        });\n      } else {\n        cancelAdapter();\n        callAdapter();\n      }\n    }\n  }, __spreadArray([], refetchDependencies));\n  useEffect(function () {\n    mountedRef.current = true; // Use ref to indicate mounted state\n    return function () {\n      mountedRef.current = false;\n      cancelAdapter();\n    };\n  }, []);\n  return {\n    isLoading: state.isLoading,\n    adapterResult: state.adapterResult,\n    callAdapter: callAdapter,\n    cancelAdapter: cancelAdapter,\n    setIsLongPolling: setIsLongPolling,\n    isLongPolling: state.isLongPolling,\n    pulse: longPoll.pulse\n  };\n};\nvar StableGuidRng = React__default.createContext(null);\nvar useStableGuidRng = function () {\n  return useContext(StableGuidRng);\n};\nexport { SET_OAT_PROPERTY_EDITOR_DRAGGING_TEMPLATE as S, useCancellablePromise as a, useLongPoll as b, SET_OAT_PROPERTY_EDITOR_CURRENT_NESTED_PROPERTY_INDEX as c, SET_OAT_PROPERTY_MODAL_OPEN as d, SET_OAT_PROPERTY_MODAL_BODY as e, SET_OAT_PROPERTY_EDITOR_DRAGGING_PROPERTY as f, SET_OAT_PROPERTY_EDITOR_CURRENT_PROPERTY_INDEX as g, useStableGuidRng as h, useAdapter as u };","map":{"version":3,"sources":["../../src/Models/Constants/ActionTypes.ts","../../src/Models/Hooks/useCancellablePromise.ts","../../src/Models/Hooks/useLongPoll.ts","../../src/Models/Hooks/useAdapter.ts","../../src/Models/Context/StableGuidRngProvider.tsx"],"names":["produce","React"],"mappings":"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","sourcesContent":["export const SET_CHART_PROPERTIES = 'SET_CHART_PROPERTIES';\nexport const SET_SELECTED_PROPERTIES = 'SET_SELECTED_PROPERTIES';\nexport const SET_TITLE = 'SET_TITLE';\nexport const SET_IS_LOADING = 'SET_IS_LOADING';\nexport const SET_ADAPTER_RESULT = 'SET_ADAPTER_RESULT';\nexport const SET_IS_LONG_POLLING = 'SET_IS_LONG_POLLING';\nexport const SET_IS_INITIAL_CALL = 'SET_IS_INITIAL_CALL';\nexport const SET_ADT_HIERARCHY_NODES = 'SET_ADT_HIERARCHY_NODES';\nexport const SET_ADT_HIERARCHY_NODE_PROPERTIES =\n    'SET_ADT_HIERARCHY_NODE_PROPERTIES';\nexport const SET_ADT_HIERARCHY_SELECTED_TWIN_ID =\n    'SET_ADT_HIERARCHY_SELECTED_TWIN_ID';\nexport const SET_ADT_HIERARCHY_SEARCH = 'SET_ADT_HIERARCHY_SEARCH';\nexport const SET_TWIN_LOOKUP_STATUS = 'SET_TWIN_LOOKUP_STATUS';\nexport const SET_ADT_SCENE_BUILDER_ELEMENTS = 'SET_ADT_SCENE_BUILDER_ELEMENTS';\nexport const SET_ADT_SCENE_BUILDER_BEHAVIORS =\n    'SET_ADT_SCENE_BUILDER_BEHAVIORS';\nexport const SET_ADT_SCENE_BUILDER_SELECTED_ELEMENT =\n    'SET_ADT_SCENE_BUILDER_SELECTED_ELEMENT';\nexport const SET_ADT_SCENE_ELEMENT_SELECTED_OBJECT_IDS =\n    'SET_ADT_SCENE_ELEMENT_SELECTED_OBJECT_IDS';\nexport const SET_ADT_SCENE_BUILDER_MODE = 'SET_ADT_SCENE_BUILDER_MODE';\n\nexport const SET_OAT_PROPERTY_EDITOR_CURRENT_PROPERTY_INDEX =\n    'SET_OAT_PROPERTY_EDITOR_CURRENT_PROPERTY_INDEX';\nexport const SET_OAT_PROPERTY_EDITOR_CURRENT_NESTED_PROPERTY_INDEX =\n    'SET_OAT_PROPERTY_EDITOR_CURRENT_NESTED_PROPERTY_INDEX';\nexport const SET_OAT_PROPERTY_EDITOR_DRAGGING_TEMPLATE =\n    'SET_OAT_PROPERTY_EDITOR_DRAGGING_TEMPLATE';\nexport const SET_OAT_PROPERTY_EDITOR_DRAGGING_PROPERTY =\n    'SET_OAT_PROPERTY_EDITOR_DRAGGING_PROPERTY';\nexport const SET_OAT_PROPERTY_MODAL_OPEN = 'SET_OAT_PROPERTY_MODAL_OPEN';\nexport const SET_OAT_PROPERTY_MODAL_BODY = 'SET_OAT_PROPERTY_MODAL_BODY';\n","import { useEffect, useRef } from 'react';\nimport { CancelledPromiseError } from '../Classes/Errors';\nimport { ICancellablePromise } from '../Constants/Interfaces';\nimport { CancellablePromise } from '../Constants/Types';\n\n/** Wraps promise with logic that allows for promise cancellation via cancel() method */\nexport function makeCancellable<T>(\n    promise: Promise<T>,\n    promisesRef?: React.MutableRefObject<any>\n): CancellablePromise<T> {\n    let isCancelled = false;\n    let returnValue: CancellablePromise<T> = {\n        promise: null,\n        cancel: () => null\n    };\n\n    const wrappedPromise = new Promise<T>((resolve, reject) => {\n        async function executePromise() {\n            try {\n                const val = await promise;\n                if (isCancelled) {\n                    reject(new CancelledPromiseError());\n                } else {\n                    resolve(val);\n                }\n            } catch (error) {\n                if (isCancelled) {\n                    reject(new CancelledPromiseError());\n                } else {\n                    reject(error);\n                }\n            }\n            // Remove promise from promisesRef.current list once resolved/rejected\n            if (\n                promisesRef &&\n                promisesRef.current.indexOf(returnValue) !== -1\n            ) {\n                promisesRef.current = promisesRef.current.filter(\n                    (promise) => promise !== returnValue\n                );\n            }\n        }\n        executePromise();\n    });\n\n    returnValue = {\n        promise: wrappedPromise,\n        cancel() {\n            isCancelled = true;\n        }\n    };\n\n    return returnValue;\n}\n\n/**\n * Exposes two functions: 'cancellablePromise' to wrap promises in cancellation code which auto cancels on unmount,\n * and 'cancel' function to manually cancel wrapped promises.  This hooks was adapted from the following repo:\n * https://github.com/rajeshnaroth/react-cancelable-promise-hook/blob/master/index.js\n */\nconst useCancellablePromise = () => {\n    const promises = useRef(null);\n\n    /** Cancel all active promises constructed by this hook's consumer */\n    function cancel() {\n        promises.current.forEach((p) => p.cancel());\n        promises.current = [];\n    }\n\n    // On unmount, cancel promises\n    useEffect(() => {\n        promises.current = promises.current || [];\n        return cancel;\n    }, []);\n\n    /** Function to construct cancellable promise if it is not already */\n    function cancellablePromise<T>(p: Promise<T> | ICancellablePromise<T>) {\n        const isICancellablePromise =\n            p['cancel'] && typeof p['cancel'] === 'function';\n        const cPromise = !isICancellablePromise\n            ? makeCancellable(p, promises)\n            : (p as ICancellablePromise<T>);\n        promises.current.push(cPromise);\n        return !isICancellablePromise\n            ? (cPromise as CancellablePromise<T>).promise\n            : (p as ICancellablePromise<T>);\n    }\n\n    return { cancellablePromise, cancel };\n};\n\nexport default useCancellablePromise;\n","import { useEffect, useRef, useState } from 'react';\nimport { UseLongPollParams } from '../Constants/Types';\n\nexport const defaultPollingIntervalMillis = 1000;\nexport const defaultPulseTimeoutMillis = 400;\n\n/**\n * Hook to wrap vanilla setInterval with smarter, unmount-safe logic.\n * Adapted from Dan Abramov's declarative setInterval blog post\n * https://overreacted.io/making-setinterval-declarative-with-react-hooks/\n */\nconst useLongPoll = ({\n    callback,\n    pollingIntervalMillis = defaultPollingIntervalMillis,\n    pulseTimeoutMillis = defaultPulseTimeoutMillis\n}: UseLongPollParams) => {\n    const [pulse, setPulse] = useState(false);\n    const savedCallback = useRef(null);\n    const mountedRef = useRef(true);\n\n    // Remember the latest callback\n    useEffect(() => {\n        savedCallback.current = callback;\n    }, [callback]);\n\n    // Set up the interval\n    useEffect(() => {\n        let timeoutId, intervalId;\n\n        async function tick() {\n            await savedCallback.current();\n            mountedRef.current && setPulse(true);\n            timeoutId = setTimeout(\n                () => mountedRef.current && setPulse(false),\n                pulseTimeoutMillis\n            );\n        }\n\n        if (pollingIntervalMillis !== null) {\n            tick();\n            intervalId = setInterval(tick, pollingIntervalMillis);\n            return () => {\n                mountedRef.current = false;\n                clearInterval(intervalId);\n                clearTimeout(timeoutId);\n            };\n        }\n    }, [pollingIntervalMillis]);\n\n    return {\n        /**\n         * Boolean pulse variable. Toggled to true for pulseTimeoutMillis\n         * after callback completion, before returning to false.  Can be used\n         * for visual indication of updated data in UI.\n         */\n        pulse\n    };\n};\n\nexport default useLongPoll;\n","import produce from 'immer';\nimport { useEffect, useMemo, useReducer, useRef } from 'react';\nimport AdapterResult from '../Classes/AdapterResult';\nimport { CancelledPromiseError } from '../Classes/Errors';\nimport {\n    SET_ADAPTER_RESULT,\n    SET_IS_LOADING,\n    SET_IS_LONG_POLLING,\n    SET_IS_INITIAL_CALL\n} from '../Constants/ActionTypes';\nimport { IAction, IAdapterData, IUseAdapter } from '../Constants/Interfaces';\nimport {\n    AdapterReturnType,\n    AdapterState,\n    AdapterMethodParams\n} from '../Constants/Types';\nimport useCancellablePromise from './useCancellablePromise';\nimport useLongPoll from './useLongPoll';\n\n// Sets up reducer with 'curried producer' - https://immerjs.github.io/immer/docs/curried-produce\n// Draft state can be directly modified.  Draft does not need to be explicitly returned.\nconst cardStateReducer = produce(\n    <T extends IAdapterData>(draft: AdapterState<T>, action: IAction) => {\n        const payload = action.payload;\n        switch (action.type) {\n            case SET_IS_LOADING:\n                draft.isLoading = payload;\n                return;\n            case SET_ADAPTER_RESULT:\n                draft.adapterResult = payload;\n                return;\n            case SET_IS_LONG_POLLING:\n                draft.isLongPolling = payload;\n                return;\n            case SET_IS_INITIAL_CALL:\n                draft.isInitialCall = payload;\n                return;\n            default:\n                return;\n        }\n    }\n);\n\ninterface Params<T extends IAdapterData> {\n    /** Callback which triggers adapter data fetch */\n    adapterMethod: (params?: AdapterMethodParams) => AdapterReturnType<T>;\n\n    /** Not to execute the adapter method when we use the useAdapter hook in first render */\n    isAdapterCalledOnMount?: boolean;\n\n    /** Array of dependencies that, when changed, should cancel the data fetch, nullify the data, and trigger a refetch.   */\n    refetchDependencies: any[];\n\n    /** Whether or not the adapterMethod is long polling */\n    isLongPolling?: boolean;\n\n    /** Long polling interval */\n    pollingIntervalMillis?: number;\n\n    /** Interval at which 'pulse' state is toggled for UI. */\n    pulseTimeoutMillis?: number;\n}\n\n/** Wraps adapter data fetching, loading, long polling, and promise cancelling logic */\nconst useAdapter = <T extends IAdapterData>({\n    adapterMethod,\n    refetchDependencies,\n    isLongPolling = false,\n    pollingIntervalMillis,\n    pulseTimeoutMillis,\n    isAdapterCalledOnMount = true\n}: Params<T>): IUseAdapter<T> => {\n    const defaultCardState: AdapterState<T> = useMemo(\n        () => ({\n            adapterResult: new AdapterResult<T>({\n                result: null,\n                errorInfo: null\n            }),\n            isLoading: isAdapterCalledOnMount,\n            isLongPolling,\n            isInitialCall: true\n        }),\n        [isLongPolling]\n    );\n\n    const mountedRef = useRef(null);\n\n    const [state, dispatch] = useReducer(cardStateReducer, defaultCardState);\n    const { cancellablePromise, cancel } = useCancellablePromise();\n\n    const setIsLoading = (isLoading: boolean) => {\n        dispatch({ type: SET_IS_LOADING, payload: isLoading });\n    };\n\n    const setAdapterResult = (adapterResult: AdapterResult<T>) => {\n        if (!adapterResult) {\n            adapterResult = new AdapterResult<T>({\n                result: null,\n                errorInfo: null\n            });\n        }\n        dispatch({ type: SET_ADAPTER_RESULT, payload: adapterResult });\n    };\n\n    const callAdapter = async (params?: AdapterMethodParams) => {\n        setIsLoading(true);\n        try {\n            const adapterResult = await cancellablePromise(\n                adapterMethod(params)\n            );\n            if (mountedRef.current) {\n                setAdapterResult(adapterResult);\n                setIsLoading(false);\n            }\n        } catch (err) {\n            if (!(err instanceof CancelledPromiseError)) {\n                console.error('Unexpected promise error', err); // log unexpected errors\n                if (mountedRef.current) {\n                    setIsLoading(false); // Toggle off loading state if component is still mounted\n                }\n            }\n        }\n    };\n\n    const cancelAdapter = (shouldPreserveResult?: boolean) => {\n        cancel(); // Cancel outstanding promises\n        if (mountedRef.current) {\n            if (!shouldPreserveResult) {\n                setAdapterResult(null);\n            }\n            setIsLoading(false);\n        }\n    };\n\n    const setIsLongPolling = (isLongPolling: boolean) => {\n        dispatch({\n            type: SET_IS_LONG_POLLING,\n            payload: isLongPolling\n        });\n    };\n\n    const longPoll = useLongPoll({\n        callback: callAdapter,\n        pollingIntervalMillis: !state.isLongPolling\n            ? null\n            : pollingIntervalMillis,\n        ...(pulseTimeoutMillis && { pulseTimeoutMillis })\n    });\n\n    useEffect(() => {\n        if (isAdapterCalledOnMount) {\n            if (state.isInitialCall) {\n                callAdapter();\n                dispatch({\n                    type: SET_IS_INITIAL_CALL,\n                    payload: false\n                });\n            } else {\n                cancelAdapter();\n                callAdapter();\n            }\n        }\n    }, [...refetchDependencies]);\n\n    useEffect(() => {\n        mountedRef.current = true; // Use ref to indicate mounted state\n        return () => {\n            mountedRef.current = false;\n            cancelAdapter();\n        };\n    }, []);\n\n    return {\n        isLoading: state.isLoading,\n        adapterResult: state.adapterResult as AdapterResult<T>,\n        callAdapter,\n        cancelAdapter,\n        setIsLongPolling,\n        isLongPolling: state.isLongPolling,\n        pulse: longPoll.pulse\n    };\n};\n\nexport default useAdapter;\n","import React, { useContext, useRef } from 'react';\nimport seedRandom from 'seedrandom';\n\nexport const StableGuidRng = React.createContext<() => number>(null);\nexport const useStableGuidRng = () => useContext(StableGuidRng);\n\ntype Props = {\n    children: React.ReactNode;\n    seed: string;\n};\n\nexport const StableGuidRngProvider = ({ children, seed }: Props) => {\n    const seededRandomNumGen = useRef(seedRandom(seed));\n    return (\n        <StableGuidRng.Provider value={seededRandomNumGen.current}>\n            {children}\n        </StableGuidRng.Provider>\n    );\n};\n"]},"metadata":{},"sourceType":"module"}