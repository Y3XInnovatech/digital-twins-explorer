{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { __awaiter, __extends, __generator } from \"tslib\";\nimport * as utils from \"../util/utils\";\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { DEFAULT_CLIENT_MAX_RETRY_INTERVAL, DEFAULT_CLIENT_RETRY_COUNT, DEFAULT_CLIENT_RETRY_INTERVAL, isNumber, updateRetryData, shouldRetry } from \"../util/exponentialBackoffStrategy\";\nimport { RestError } from \"../restError\";\nimport { logger } from \"../log\";\nexport function exponentialRetryPolicy(retryCount, retryInterval, maxRetryInterval) {\n  return {\n    create: function (nextPolicy, options) {\n      return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval);\n    }\n  };\n}\n/**\n * Describes the Retry Mode type. Currently supporting only Exponential.\n */\nexport var RetryMode;\n(function (RetryMode) {\n  RetryMode[RetryMode[\"Exponential\"] = 0] = \"Exponential\";\n})(RetryMode || (RetryMode = {}));\nexport var DefaultRetryOptions = {\n  maxRetries: DEFAULT_CLIENT_RETRY_COUNT,\n  retryDelayInMs: DEFAULT_CLIENT_RETRY_INTERVAL,\n  maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL\n};\n/**\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n */\nvar ExponentialRetryPolicy = /** @class */function (_super) {\n  __extends(ExponentialRetryPolicy, _super);\n  /**\n   * @param nextPolicy - The next RequestPolicy in the pipeline chain.\n   * @param options - The options for this RequestPolicy.\n   * @param retryCount - The client retry count.\n   * @param retryInterval - The client retry interval, in milliseconds.\n   * @param minRetryInterval - The minimum retry interval, in milliseconds.\n   * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n   */\n  function ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval) {\n    var _this = _super.call(this, nextPolicy, options) || this;\n    _this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    _this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    _this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n    return _this;\n  }\n  ExponentialRetryPolicy.prototype.sendRequest = function (request) {\n    var _this = this;\n    return this._nextPolicy.sendRequest(request.clone()).then(function (response) {\n      return retry(_this, request, response);\n    }).catch(function (error) {\n      return retry(_this, request, error.response, undefined, error);\n    });\n  };\n  return ExponentialRetryPolicy;\n}(BaseRequestPolicy);\nexport { ExponentialRetryPolicy };\nfunction retry(policy, request, response, retryData, requestError) {\n  return __awaiter(this, void 0, void 0, function () {\n    function shouldPolicyRetry(responseParam) {\n      var statusCode = responseParam === null || responseParam === void 0 ? void 0 : responseParam.status;\n      if (statusCode === undefined || statusCode < 500 && statusCode !== 408 || statusCode === 501 || statusCode === 505) {\n        return false;\n      }\n      return true;\n    }\n    var isAborted, res, err_1, err;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          retryData = updateRetryData({\n            retryInterval: policy.retryInterval,\n            minRetryInterval: 0,\n            maxRetryInterval: policy.maxRetryInterval\n          }, retryData, requestError);\n          isAborted = request.abortSignal && request.abortSignal.aborted;\n          if (!(!isAborted && shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, response))) return [3 /*break*/, 6];\n          logger.info(\"Retrying request in \" + retryData.retryInterval);\n          _a.label = 1;\n        case 1:\n          _a.trys.push([1, 4,, 5]);\n          return [4 /*yield*/, utils.delay(retryData.retryInterval)];\n        case 2:\n          _a.sent();\n          return [4 /*yield*/, policy._nextPolicy.sendRequest(request.clone())];\n        case 3:\n          res = _a.sent();\n          return [2 /*return*/, retry(policy, request, res, retryData)];\n        case 4:\n          err_1 = _a.sent();\n          return [2 /*return*/, retry(policy, request, response, retryData, err_1)];\n        case 5:\n          return [3 /*break*/, 7];\n        case 6:\n          if (isAborted || requestError || !response) {\n            err = retryData.error || new RestError(\"Failed to send the request.\", RestError.REQUEST_SEND_ERROR, response && response.status, response && response.request, response);\n            throw err;\n          } else {\n            return [2 /*return*/, response];\n          }\n          _a.label = 7;\n        case 7:\n          return [2 /*return*/];\n      }\n    });\n  });\n}","map":{"version":3,"sources":["../../../src/policies/exponentialRetryPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport * as utils from \"../util/utils\";\nimport { WebResourceLike } from \"../webResource\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions\n} from \"./requestPolicy\";\nimport {\n  RetryData,\n  RetryError,\n  DEFAULT_CLIENT_MAX_RETRY_INTERVAL,\n  DEFAULT_CLIENT_RETRY_COUNT,\n  DEFAULT_CLIENT_RETRY_INTERVAL,\n  isNumber,\n  updateRetryData,\n  shouldRetry\n} from \"../util/exponentialBackoffStrategy\";\nimport { RestError } from \"../restError\";\nimport { logger } from \"../log\";\n\nexport function exponentialRetryPolicy(\n  retryCount?: number,\n  retryInterval?: number,\n  maxRetryInterval?: number\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new ExponentialRetryPolicy(\n        nextPolicy,\n        options,\n        retryCount,\n        retryInterval,\n        maxRetryInterval\n      );\n    }\n  };\n}\n\n/**\n * Describes the Retry Mode type. Currently supporting only Exponential.\n */\nexport enum RetryMode {\n  Exponential\n}\n\n/**\n * Options that control how to retry failed requests.\n */\nexport interface RetryOptions {\n  /**\n   * The maximum number of retry attempts.  Defaults to 3.\n   */\n  maxRetries?: number;\n\n  /**\n   * The amount of delay in milliseconds between retry attempts. Defaults to 30000\n   * (30 seconds). The delay increases exponentially with each retry up to a maximum\n   * specified by maxRetryDelayInMs.\n   */\n  retryDelayInMs?: number;\n\n  /**\n   * The maximum delay in milliseconds allowed before retrying an operation. Defaults\n   * to 90000 (90 seconds).\n   */\n  maxRetryDelayInMs?: number;\n\n  /**\n   * Currently supporting only Exponential mode.\n   */\n  mode?: RetryMode;\n}\n\nexport const DefaultRetryOptions: RetryOptions = {\n  maxRetries: DEFAULT_CLIENT_RETRY_COUNT,\n  retryDelayInMs: DEFAULT_CLIENT_RETRY_INTERVAL,\n  maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL\n};\n\n/**\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n */\nexport class ExponentialRetryPolicy extends BaseRequestPolicy {\n  /**\n   * The client retry count.\n   */\n  retryCount: number;\n  /**\n   * The client retry interval in milliseconds.\n   */\n  retryInterval: number;\n  /**\n   * The maximum retry interval in milliseconds.\n   */\n  maxRetryInterval: number;\n\n  /**\n   * @param nextPolicy - The next RequestPolicy in the pipeline chain.\n   * @param options - The options for this RequestPolicy.\n   * @param retryCount - The client retry count.\n   * @param retryInterval - The client retry interval, in milliseconds.\n   * @param minRetryInterval - The minimum retry interval, in milliseconds.\n   * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n   */\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    retryCount?: number,\n    retryInterval?: number,\n    maxRetryInterval?: number\n  ) {\n    super(nextPolicy, options);\n    this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.maxRetryInterval = isNumber(maxRetryInterval)\n      ? maxRetryInterval\n      : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n\n  public sendRequest(request: WebResourceLike): Promise<HttpOperationResponse> {\n    return this._nextPolicy\n      .sendRequest(request.clone())\n      .then((response) => retry(this, request, response))\n      .catch((error) => retry(this, request, error.response, undefined, error));\n  }\n}\n\nasync function retry(\n  policy: ExponentialRetryPolicy,\n  request: WebResourceLike,\n  response?: HttpOperationResponse,\n  retryData?: RetryData,\n  requestError?: RetryError\n): Promise<HttpOperationResponse> {\n  function shouldPolicyRetry(responseParam?: HttpOperationResponse): boolean {\n    const statusCode = responseParam?.status;\n    if (\n      statusCode === undefined ||\n      (statusCode < 500 && statusCode !== 408) ||\n      statusCode === 501 ||\n      statusCode === 505\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  retryData = updateRetryData(\n    {\n      retryInterval: policy.retryInterval,\n      minRetryInterval: 0,\n      maxRetryInterval: policy.maxRetryInterval\n    },\n    retryData,\n    requestError\n  );\n\n  const isAborted: boolean | undefined = request.abortSignal && request.abortSignal.aborted;\n  if (!isAborted && shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, response)) {\n    logger.info(`Retrying request in ${retryData.retryInterval}`);\n    try {\n      await utils.delay(retryData.retryInterval);\n      const res = await policy._nextPolicy.sendRequest(request.clone());\n      return retry(policy, request, res, retryData);\n    } catch (err) {\n      return retry(policy, request, response, retryData, err);\n    }\n  } else if (isAborted || requestError || !response) {\n    // If the operation failed in the end, return all errors instead of just the last one\n    const err =\n      retryData.error ||\n      new RestError(\n        \"Failed to send the request.\",\n        RestError.REQUEST_SEND_ERROR,\n        response && response.status,\n        response && response.request,\n        response\n      );\n    throw err;\n  } else {\n    return response;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}