{"ast":null,"code":"/**\n * Rectangle helper class.\n *\n * @public\n * {@docCategory Rectangle}\n */\nvar Rectangle = /** @class */function () {\n  function Rectangle(left, right, top, bottom) {\n    if (left === void 0) {\n      left = 0;\n    }\n    if (right === void 0) {\n      right = 0;\n    }\n    if (top === void 0) {\n      top = 0;\n    }\n    if (bottom === void 0) {\n      bottom = 0;\n    }\n    this.top = top;\n    this.bottom = bottom;\n    this.left = left;\n    this.right = right;\n  }\n  Object.defineProperty(Rectangle.prototype, \"width\", {\n    /**\n     * Calculated automatically by subtracting the right from left\n     */\n    get: function () {\n      return this.right - this.left;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Rectangle.prototype, \"height\", {\n    /**\n     * Calculated automatically by subtracting the bottom from top.\n     */\n    get: function () {\n      return this.bottom - this.top;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Tests if another rect is approximately equal to this rect (within 4 decimal places.)\n   */\n  Rectangle.prototype.equals = function (rect) {\n    // Fixing to 4 decimal places because it allows enough precision and will handle cases when something\n    // should be rounded, like .999999 should round to 1.\n    return parseFloat(this.top.toFixed(4)) === parseFloat(rect.top.toFixed(4)) && parseFloat(this.bottom.toFixed(4)) === parseFloat(rect.bottom.toFixed(4)) && parseFloat(this.left.toFixed(4)) === parseFloat(rect.left.toFixed(4)) && parseFloat(this.right.toFixed(4)) === parseFloat(rect.right.toFixed(4));\n  };\n  return Rectangle;\n}();\nexport { Rectangle };","map":{"version":3,"sources":["Rectangle.ts"],"names":[],"mappings":"AAAA;;;;;AAKG;AACH,IAAA,SAAA,GAAA,aAAA,YAAA;EAME,SAAA,SAAA,CAAY,IAAgB,EAAE,KAAiB,EAAE,GAAe,EAAE,MAAkB,EAAA;IAAxE,IAAA,IAAA,KAAA,KAAA,CAAA,EAAA;MAAA,IAAA,GAAA,CAAgB;IAAA;IAAE,IAAA,KAAA,KAAA,KAAA,CAAA,EAAA;MAAA,KAAA,GAAA,CAAiB;IAAA;IAAE,IAAA,GAAA,KAAA,KAAA,CAAA,EAAA;MAAA,GAAA,GAAA,CAAe;IAAA;IAAE,IAAA,MAAA,KAAA,KAAA,CAAA,EAAA;MAAA,MAAA,GAAA,CAAkB;IAAA;IAClF,IAAI,CAAC,GAAG,GAAG,GAAG;IACd,IAAI,CAAC,MAAM,GAAG,MAAM;IACpB,IAAI,CAAC,IAAI,GAAG,IAAI;IAChB,IAAI,CAAC,KAAK,GAAG,KAAK;EACpB;EAKA,MAAA,CAAA,cAAA,CAAW,SAAA,CAAA,SAAA,EAAA,OAAK,EAAA;IAHhB;;AAEG;SACH,SAAA,CAAA,EAAA;MACE,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,IAAI;IAC/B,CAAC;;;IAAA;EAKD,MAAA,CAAA,cAAA,CAAW,SAAA,CAAA,SAAA,EAAA,QAAM,EAAA;IAHjB;;AAEG;SACH,SAAA,CAAA,EAAA;MACE,OAAO,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,GAAG;IAC/B,CAAC;;;IAAA;EAED;;AAEG;EACI,SAAA,CAAA,SAAA,CAAA,MAAM,GAAb,UAAc,IAAe,EAAA;IAC3B;IACA;IACA,OACE,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IACnE,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IACzE,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IACrE,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;EAE3E,CAAC;EACH,OAAA,SAAC;AAAD,CAAC,CAAA,CAAA","sourcesContent":["/**\n * Rectangle helper class.\n *\n * @public\n * {@docCategory Rectangle}\n */\nexport class Rectangle {\n  public top: number;\n  public bottom: number;\n  public left: number;\n  public right: number;\n\n  constructor(left: number = 0, right: number = 0, top: number = 0, bottom: number = 0) {\n    this.top = top;\n    this.bottom = bottom;\n    this.left = left;\n    this.right = right;\n  }\n\n  /**\n   * Calculated automatically by subtracting the right from left\n   */\n  public get width(): number {\n    return this.right - this.left;\n  }\n\n  /**\n   * Calculated automatically by subtracting the bottom from top.\n   */\n  public get height(): number {\n    return this.bottom - this.top;\n  }\n\n  /**\n   * Tests if another rect is approximately equal to this rect (within 4 decimal places.)\n   */\n  public equals(rect: Rectangle): boolean {\n    // Fixing to 4 decimal places because it allows enough precision and will handle cases when something\n    // should be rounded, like .999999 should round to 1.\n    return (\n      parseFloat(this.top.toFixed(4)) === parseFloat(rect.top.toFixed(4)) &&\n      parseFloat(this.bottom.toFixed(4)) === parseFloat(rect.bottom.toFixed(4)) &&\n      parseFloat(this.left.toFixed(4)) === parseFloat(rect.left.toFixed(4)) &&\n      parseFloat(this.right.toFixed(4)) === parseFloat(rect.right.toFixed(4))\n    );\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}