{"ast":null,"code":"var _a;\nvar LEFT = 'left';\nvar RIGHT = 'right';\nvar NO_FLIP = '@noflip';\nvar NAME_REPLACEMENTS = (_a = {}, _a[LEFT] = RIGHT, _a[RIGHT] = LEFT, _a);\nvar VALUE_REPLACEMENTS = {\n  'w-resize': 'e-resize',\n  'sw-resize': 'se-resize',\n  'nw-resize': 'ne-resize'\n};\n/**\n * RTLifies the rulePair in the array at the current index. This mutates the array for performance\n * reasons.\n */\nexport function rtlifyRules(options, rulePairs, index) {\n  if (options.rtl) {\n    var name_1 = rulePairs[index];\n    if (!name_1) {\n      return;\n    }\n    var value = rulePairs[index + 1];\n    if (typeof value === 'string' && value.indexOf(NO_FLIP) >= 0) {\n      rulePairs[index + 1] = value.replace(/\\s*(?:\\/\\*\\s*)?\\@noflip\\b(?:\\s*\\*\\/)?\\s*?/g, '');\n    } else if (name_1.indexOf(LEFT) >= 0) {\n      rulePairs[index] = name_1.replace(LEFT, RIGHT);\n    } else if (name_1.indexOf(RIGHT) >= 0) {\n      rulePairs[index] = name_1.replace(RIGHT, LEFT);\n    } else if (String(value).indexOf(LEFT) >= 0) {\n      rulePairs[index + 1] = value.replace(LEFT, RIGHT);\n    } else if (String(value).indexOf(RIGHT) >= 0) {\n      rulePairs[index + 1] = value.replace(RIGHT, LEFT);\n    } else if (NAME_REPLACEMENTS[name_1]) {\n      rulePairs[index] = NAME_REPLACEMENTS[name_1];\n    } else if (VALUE_REPLACEMENTS[value]) {\n      rulePairs[index + 1] = VALUE_REPLACEMENTS[value];\n    } else {\n      switch (name_1) {\n        case 'margin':\n        case 'padding':\n          rulePairs[index + 1] = flipQuad(value);\n          break;\n        case 'box-shadow':\n          rulePairs[index + 1] = negateNum(value, 0);\n          break;\n      }\n    }\n  }\n}\n/**\n * Given a string value in a space delimited format (e.g. \"1 2 3 4\"), negates a particular value.\n */\nfunction negateNum(value, partIndex) {\n  var parts = value.split(' ');\n  var numberVal = parseInt(parts[partIndex], 10);\n  parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));\n  return parts.join(' ');\n}\n/**\n * Given a string quad, flips the left and right values.\n */\nfunction flipQuad(value) {\n  if (typeof value === 'string') {\n    var parts = value.split(' ');\n    if (parts.length === 4) {\n      return parts[0] + \" \" + parts[3] + \" \" + parts[2] + \" \" + parts[1];\n    }\n  }\n  return value;\n}","map":{"version":3,"sources":["transforms/rtlifyRules.ts"],"names":[],"mappings":"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","sourcesContent":["import { IStyleOptions } from '../IStyleOptions';\n\nconst LEFT = 'left';\nconst RIGHT = 'right';\nconst NO_FLIP = '@noflip';\nconst NAME_REPLACEMENTS: { [key: string]: string } = {\n  [LEFT]: RIGHT,\n  [RIGHT]: LEFT,\n};\nconst VALUE_REPLACEMENTS: { [key: string]: string } = {\n  'w-resize': 'e-resize',\n  'sw-resize': 'se-resize',\n  'nw-resize': 'ne-resize',\n};\n\n/**\n * RTLifies the rulePair in the array at the current index. This mutates the array for performance\n * reasons.\n */\nexport function rtlifyRules(options: IStyleOptions, rulePairs: (string | number)[], index: number): void {\n  if (options.rtl) {\n    const name = rulePairs[index] as string;\n\n    if (!name) {\n      return;\n    }\n\n    const value = rulePairs[index + 1] as string;\n\n    if (typeof value === 'string' && value.indexOf(NO_FLIP) >= 0) {\n      rulePairs[index + 1] = value.replace(/\\s*(?:\\/\\*\\s*)?\\@noflip\\b(?:\\s*\\*\\/)?\\s*?/g, '');\n    } else if (name.indexOf(LEFT) >= 0) {\n      rulePairs[index] = name.replace(LEFT, RIGHT);\n    } else if (name.indexOf(RIGHT) >= 0) {\n      rulePairs[index] = name.replace(RIGHT, LEFT);\n    } else if (String(value).indexOf(LEFT) >= 0) {\n      rulePairs[index + 1] = value.replace(LEFT, RIGHT);\n    } else if (String(value).indexOf(RIGHT) >= 0) {\n      rulePairs[index + 1] = value.replace(RIGHT, LEFT);\n    } else if (NAME_REPLACEMENTS[name]) {\n      rulePairs[index] = NAME_REPLACEMENTS[name];\n    } else if (VALUE_REPLACEMENTS[value]) {\n      rulePairs[index + 1] = VALUE_REPLACEMENTS[value];\n    } else {\n      switch (name) {\n        case 'margin':\n        case 'padding':\n          rulePairs[index + 1] = flipQuad(value);\n          break;\n        case 'box-shadow':\n          rulePairs[index + 1] = negateNum(value, 0);\n          break;\n      }\n    }\n  }\n}\n\n/**\n * Given a string value in a space delimited format (e.g. \"1 2 3 4\"), negates a particular value.\n */\nfunction negateNum(value: string, partIndex: number): string {\n  const parts = value.split(' ');\n  const numberVal = parseInt(parts[partIndex], 10);\n\n  parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));\n\n  return parts.join(' ');\n}\n\n/**\n * Given a string quad, flips the left and right values.\n */\nfunction flipQuad(value: string): string {\n  if (typeof value === 'string') {\n    const parts = value.split(' ');\n\n    if (parts.length === 4) {\n      return `${parts[0]} ${parts[3]} ${parts[2]} ${parts[1]}`;\n    }\n  }\n\n  return value;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}