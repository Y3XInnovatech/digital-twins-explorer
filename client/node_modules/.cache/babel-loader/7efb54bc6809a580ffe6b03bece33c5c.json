{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { FocusZone, FocusZoneDirection } from '@fluentui/react-focus';\nimport { initializeComponentRef, classNamesFunction, divProperties, elementContains, focusFirstChild, getNativeProps, warnMutuallyExclusive } from '../../Utilities';\nimport { KeytipManager } from '../../utilities/keytips/KeytipManager';\nvar getClassNames = classNamesFunction();\nvar COMPONENT_NAME = 'OverflowSet';\nvar OverflowSetBase = /** @class */function (_super) {\n  __extends(OverflowSetBase, _super);\n  function OverflowSetBase(props) {\n    var _this = _super.call(this, props) || this;\n    _this._focusZone = React.createRef();\n    _this._persistedKeytips = {};\n    _this._keytipManager = KeytipManager.getInstance();\n    _this._divContainer = React.createRef();\n    _this._onRenderItems = function (items) {\n      return items.map(function (item, i) {\n        return React.createElement(\"div\", {\n          key: item.key,\n          className: _this._classNames.item\n        }, _this.props.onRenderItem(item));\n      });\n    };\n    _this._onRenderOverflowButtonWrapper = function (items) {\n      var wrapperDivProps = {\n        className: _this._classNames.overflowButton\n      };\n      var overflowKeytipSequences = _this.props.keytipSequences;\n      var newOverflowItems = [];\n      if (overflowKeytipSequences) {\n        items.forEach(function (overflowItem) {\n          var keytip = overflowItem.keytipProps;\n          if (keytip) {\n            // Create persisted keytip\n            var persistedKeytip = {\n              content: keytip.content,\n              keySequences: keytip.keySequences,\n              disabled: keytip.disabled || !!(overflowItem.disabled || overflowItem.isDisabled),\n              hasDynamicChildren: keytip.hasDynamicChildren,\n              hasMenu: keytip.hasMenu\n            };\n            if (keytip.hasDynamicChildren || _this._getSubMenuForItem(overflowItem)) {\n              // If the keytip has a submenu or children nodes, change onExecute to persistedKeytipExecute\n              persistedKeytip.onExecute = _this._keytipManager.menuExecute.bind(_this._keytipManager, overflowKeytipSequences, overflowItem.keytipProps.keySequences);\n            } else {\n              // If the keytip doesn't have a submenu, just execute the original function\n              persistedKeytip.onExecute = keytip.onExecute;\n            }\n            // Add this persisted keytip to our internal list, use a temporary uniqueID (its content)\n            // uniqueID will get updated on register\n            _this._persistedKeytips[persistedKeytip.content] = persistedKeytip;\n            // Add the overflow sequence to this item\n            var newOverflowItem = __assign(__assign({}, overflowItem), {\n              keytipProps: __assign(__assign({}, keytip), {\n                overflowSetSequence: overflowKeytipSequences\n              })\n            });\n            newOverflowItems.push(newOverflowItem);\n          } else {\n            // Nothing to change, add overflowItem to list\n            newOverflowItems.push(overflowItem);\n          }\n        });\n      } else {\n        newOverflowItems = items;\n      }\n      return React.createElement(\"div\", __assign({}, wrapperDivProps), _this.props.onRenderOverflowButton(newOverflowItems));\n    };\n    initializeComponentRef(_this);\n    warnMutuallyExclusive(COMPONENT_NAME, props, {\n      doNotContainWithinFocusZone: 'focusZoneProps'\n    });\n    return _this;\n  }\n  OverflowSetBase.prototype.render = function () {\n    var _a = this.props,\n      items = _a.items,\n      overflowItems = _a.overflowItems,\n      className = _a.className,\n      // eslint-disable-next-line deprecation/deprecation\n      focusZoneProps = _a.focusZoneProps,\n      styles = _a.styles,\n      vertical = _a.vertical,\n      // eslint-disable-next-line deprecation/deprecation\n      doNotContainWithinFocusZone = _a.doNotContainWithinFocusZone,\n      role = _a.role,\n      _b = _a.overflowSide,\n      overflowSide = _b === void 0 ? 'end' : _b;\n    this._classNames = getClassNames(styles, {\n      className: className,\n      vertical: vertical\n    });\n    var Tag;\n    var uniqueComponentProps;\n    if (doNotContainWithinFocusZone) {\n      Tag = 'div';\n      uniqueComponentProps = __assign(__assign({}, getNativeProps(this.props, divProperties)), {\n        ref: this._divContainer\n      });\n    } else {\n      Tag = FocusZone;\n      uniqueComponentProps = __assign(__assign(__assign({}, getNativeProps(this.props, divProperties)), focusZoneProps), {\n        componentRef: this._focusZone,\n        direction: vertical ? FocusZoneDirection.vertical : FocusZoneDirection.horizontal\n      });\n    }\n    var showOverflow = overflowItems && overflowItems.length > 0;\n    return React.createElement(Tag, __assign({\n      role: role || 'group',\n      \"aria-orientation\": role === 'menubar' ? vertical === true ? 'vertical' : 'horizontal' : undefined\n    }, uniqueComponentProps, {\n      className: this._classNames.root\n    }), overflowSide === 'start' && showOverflow && this._onRenderOverflowButtonWrapper(overflowItems), items && this._onRenderItems(items), overflowSide === 'end' && showOverflow && this._onRenderOverflowButtonWrapper(overflowItems));\n  };\n  /**\n   * Sets focus to the first tabbable item in the OverflowSet.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element,\n   * even if focus is already in theOverflowSet\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  OverflowSetBase.prototype.focus = function (forceIntoFirstElement) {\n    var focusSucceeded = false;\n    // eslint-disable-next-line deprecation/deprecation\n    if (this.props.doNotContainWithinFocusZone) {\n      if (this._divContainer.current) {\n        focusSucceeded = focusFirstChild(this._divContainer.current);\n      }\n    } else if (this._focusZone.current) {\n      focusSucceeded = this._focusZone.current.focus(forceIntoFirstElement);\n    }\n    return focusSucceeded;\n  };\n  /**\n   * Sets focus to a specific child element within the OverflowSet.\n   * @param childElement - The child element within the zone to focus.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  OverflowSetBase.prototype.focusElement = function (childElement) {\n    var focusSucceeded = false;\n    if (!childElement) {\n      return false;\n    }\n    // eslint-disable-next-line deprecation/deprecation\n    if (this.props.doNotContainWithinFocusZone) {\n      if (this._divContainer.current && elementContains(this._divContainer.current, childElement)) {\n        childElement.focus();\n        focusSucceeded = document.activeElement === childElement;\n      }\n    } else if (this._focusZone.current) {\n      focusSucceeded = this._focusZone.current.focusElement(childElement);\n    }\n    return focusSucceeded;\n  };\n  // Add keytip register/unregister handlers to lifecycle functions to correctly manage persisted keytips\n  OverflowSetBase.prototype.componentDidMount = function () {\n    this._registerPersistedKeytips();\n  };\n  OverflowSetBase.prototype.componentWillUnmount = function () {\n    this._unregisterPersistedKeytips();\n  };\n  OverflowSetBase.prototype.UNSAFE_componentWillUpdate = function () {\n    this._unregisterPersistedKeytips();\n  };\n  OverflowSetBase.prototype.componentDidUpdate = function () {\n    this._registerPersistedKeytips();\n  };\n  OverflowSetBase.prototype._registerPersistedKeytips = function () {\n    var _this = this;\n    Object.keys(this._persistedKeytips).forEach(function (key) {\n      var keytip = _this._persistedKeytips[key];\n      var uniqueID = _this._keytipManager.register(keytip, true);\n      // Update map\n      _this._persistedKeytips[uniqueID] = keytip;\n      delete _this._persistedKeytips[key];\n    });\n  };\n  OverflowSetBase.prototype._unregisterPersistedKeytips = function () {\n    var _this = this;\n    // Delete all persisted keytips saved\n    Object.keys(this._persistedKeytips).forEach(function (uniqueID) {\n      _this._keytipManager.unregister(_this._persistedKeytips[uniqueID], uniqueID, true);\n    });\n    this._persistedKeytips = {};\n  };\n  /**\n   * Gets the subMenu for an overflow item\n   * Checks if itemSubMenuProvider has been defined, if not defaults to subMenuProps\n   */\n  OverflowSetBase.prototype._getSubMenuForItem = function (item) {\n    if (this.props.itemSubMenuProvider) {\n      return this.props.itemSubMenuProvider(item);\n    }\n    if (item.subMenuProps) {\n      return item.subMenuProps.items;\n    }\n    return undefined;\n  };\n  return OverflowSetBase;\n}(React.Component);\nexport { OverflowSetBase };","map":{"version":3,"sources":["components/OverflowSet/OverflowSet.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\n\nimport { FocusZone, FocusZoneDirection, IFocusZone } from '@fluentui/react-focus';\nimport { IKeytipProps } from '../../Keytip';\nimport {\n  initializeComponentRef,\n  classNamesFunction,\n  divProperties,\n  elementContains,\n  focusFirstChild,\n  getNativeProps,\n  warnMutuallyExclusive,\n} from '../../Utilities';\nimport { IProcessedStyleSet } from '../../Styling';\nimport { KeytipManager } from '../../utilities/keytips/KeytipManager';\nimport {\n  IOverflowSet,\n  IOverflowSetItemProps,\n  IOverflowSetProps,\n  IOverflowSetStyles,\n  IOverflowSetStyleProps,\n} from './OverflowSet.types';\n\nconst getClassNames = classNamesFunction<IOverflowSetStyleProps, IOverflowSetStyles>();\nconst COMPONENT_NAME = 'OverflowSet';\n\nexport class OverflowSetBase extends React.Component<IOverflowSetProps, {}> implements IOverflowSet {\n  private _focusZone = React.createRef<IFocusZone>();\n  private _persistedKeytips: { [uniqueID: string]: IKeytipProps } = {};\n  private _keytipManager: KeytipManager = KeytipManager.getInstance();\n  private _divContainer = React.createRef<HTMLDivElement>();\n  private _classNames: IProcessedStyleSet<IOverflowSetStyles>;\n\n  constructor(props: IOverflowSetProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    warnMutuallyExclusive(COMPONENT_NAME, props, {\n      doNotContainWithinFocusZone: 'focusZoneProps',\n    });\n  }\n\n  public render(): JSX.Element {\n    const {\n      items,\n      overflowItems,\n      className,\n      // eslint-disable-next-line deprecation/deprecation\n      focusZoneProps,\n      styles,\n      vertical,\n      // eslint-disable-next-line deprecation/deprecation\n      doNotContainWithinFocusZone,\n      role,\n      overflowSide = 'end',\n    } = this.props;\n\n    this._classNames = getClassNames(styles, { className, vertical });\n\n    let Tag;\n    let uniqueComponentProps;\n\n    if (doNotContainWithinFocusZone) {\n      Tag = 'div';\n      uniqueComponentProps = {\n        ...getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties),\n        ref: this._divContainer,\n      };\n    } else {\n      Tag = FocusZone;\n      uniqueComponentProps = {\n        ...getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties),\n        ...focusZoneProps,\n        componentRef: this._focusZone,\n        direction: vertical ? FocusZoneDirection.vertical : FocusZoneDirection.horizontal,\n      };\n    }\n\n    const showOverflow = overflowItems && overflowItems.length > 0;\n\n    return (\n      <Tag\n        role={role || 'group'}\n        aria-orientation={role === 'menubar' ? (vertical === true ? 'vertical' : 'horizontal') : undefined}\n        {...uniqueComponentProps}\n        className={this._classNames.root}\n      >\n        {overflowSide === 'start' && showOverflow && this._onRenderOverflowButtonWrapper(overflowItems!)}\n        {items && this._onRenderItems(items)}\n        {overflowSide === 'end' && showOverflow && this._onRenderOverflowButtonWrapper(overflowItems!)}\n      </Tag>\n    );\n  }\n\n  /**\n   * Sets focus to the first tabbable item in the OverflowSet.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element,\n   * even if focus is already in theOverflowSet\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focus(forceIntoFirstElement?: boolean): boolean {\n    let focusSucceeded = false;\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (this.props.doNotContainWithinFocusZone) {\n      if (this._divContainer.current) {\n        focusSucceeded = focusFirstChild(this._divContainer.current);\n      }\n    } else if (this._focusZone.current) {\n      focusSucceeded = this._focusZone.current.focus(forceIntoFirstElement);\n    }\n\n    return focusSucceeded;\n  }\n\n  /**\n   * Sets focus to a specific child element within the OverflowSet.\n   * @param childElement - The child element within the zone to focus.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  public focusElement(childElement?: HTMLElement): boolean {\n    let focusSucceeded = false;\n\n    if (!childElement) {\n      return false;\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (this.props.doNotContainWithinFocusZone) {\n      if (this._divContainer.current && elementContains(this._divContainer.current, childElement)) {\n        childElement.focus();\n        focusSucceeded = document.activeElement === childElement;\n      }\n    } else if (this._focusZone.current) {\n      focusSucceeded = this._focusZone.current.focusElement(childElement);\n    }\n\n    return focusSucceeded;\n  }\n\n  // Add keytip register/unregister handlers to lifecycle functions to correctly manage persisted keytips\n  public componentDidMount() {\n    this._registerPersistedKeytips();\n  }\n\n  public componentWillUnmount() {\n    this._unregisterPersistedKeytips();\n  }\n\n  public UNSAFE_componentWillUpdate() {\n    this._unregisterPersistedKeytips();\n  }\n\n  public componentDidUpdate() {\n    this._registerPersistedKeytips();\n  }\n\n  private _registerPersistedKeytips() {\n    Object.keys(this._persistedKeytips).forEach((key: string) => {\n      const keytip = this._persistedKeytips[key];\n      const uniqueID = this._keytipManager.register(keytip, true);\n      // Update map\n      this._persistedKeytips[uniqueID] = keytip;\n      delete this._persistedKeytips[key];\n    });\n  }\n\n  private _unregisterPersistedKeytips() {\n    // Delete all persisted keytips saved\n    Object.keys(this._persistedKeytips).forEach((uniqueID: string) => {\n      this._keytipManager.unregister(this._persistedKeytips[uniqueID], uniqueID, true);\n    });\n    this._persistedKeytips = {};\n  }\n\n  private _onRenderItems = (items: IOverflowSetItemProps[]): JSX.Element[] => {\n    return items.map((item, i) => {\n      return (\n        <div key={item.key} className={this._classNames.item}>\n          {this.props.onRenderItem(item)}\n        </div>\n      );\n    });\n  };\n\n  private _onRenderOverflowButtonWrapper = (items: any[]): JSX.Element => {\n    const wrapperDivProps: React.HTMLProps<HTMLDivElement> = {\n      className: this._classNames.overflowButton,\n    };\n\n    const overflowKeytipSequences = this.props.keytipSequences;\n    let newOverflowItems: any[] = [];\n\n    if (overflowKeytipSequences) {\n      items.forEach(overflowItem => {\n        const keytip = (overflowItem as IOverflowSetItemProps).keytipProps;\n        if (keytip) {\n          // Create persisted keytip\n          const persistedKeytip: IKeytipProps = {\n            content: keytip.content,\n            keySequences: keytip.keySequences,\n            disabled: keytip.disabled || !!(overflowItem.disabled || overflowItem.isDisabled),\n            hasDynamicChildren: keytip.hasDynamicChildren,\n            hasMenu: keytip.hasMenu,\n          };\n\n          if (keytip.hasDynamicChildren || this._getSubMenuForItem(overflowItem)) {\n            // If the keytip has a submenu or children nodes, change onExecute to persistedKeytipExecute\n            persistedKeytip.onExecute = this._keytipManager.menuExecute.bind(\n              this._keytipManager,\n              overflowKeytipSequences,\n              overflowItem.keytipProps.keySequences,\n            );\n          } else {\n            // If the keytip doesn't have a submenu, just execute the original function\n            persistedKeytip.onExecute = keytip.onExecute;\n          }\n\n          // Add this persisted keytip to our internal list, use a temporary uniqueID (its content)\n          // uniqueID will get updated on register\n          this._persistedKeytips[persistedKeytip.content] = persistedKeytip;\n\n          // Add the overflow sequence to this item\n          const newOverflowItem = {\n            ...overflowItem,\n            keytipProps: {\n              ...keytip,\n              overflowSetSequence: overflowKeytipSequences,\n            },\n          };\n          newOverflowItems.push(newOverflowItem);\n        } else {\n          // Nothing to change, add overflowItem to list\n          newOverflowItems.push(overflowItem);\n        }\n      });\n    } else {\n      newOverflowItems = items;\n    }\n    return <div {...wrapperDivProps}>{this.props.onRenderOverflowButton(newOverflowItems)}</div>;\n  };\n\n  /**\n   * Gets the subMenu for an overflow item\n   * Checks if itemSubMenuProvider has been defined, if not defaults to subMenuProps\n   */\n  private _getSubMenuForItem(item: any): any[] | boolean | undefined {\n    if (this.props.itemSubMenuProvider) {\n      return this.props.itemSubMenuProvider(item);\n    }\n    if (item.subMenuProps) {\n      return item.subMenuProps.items;\n    }\n    return undefined;\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}