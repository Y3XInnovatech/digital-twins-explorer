{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { KeyCodes, getNativeProps, inputProperties, isIE11, Async, initializeComponentRef } from '../../Utilities';\nvar SELECTION_FORWARD = 'forward';\nvar SELECTION_BACKWARD = 'backward';\n/**\n * {@docCategory Autofill}\n */\nvar Autofill = /** @class */function (_super) {\n  __extends(Autofill, _super);\n  function Autofill(props) {\n    var _this = _super.call(this, props) || this;\n    _this._inputElement = React.createRef();\n    _this._autoFillEnabled = true;\n    _this._isComposing = false;\n    // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and langauges like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n    _this._onCompositionStart = function (ev) {\n      _this._isComposing = true;\n      _this._autoFillEnabled = false;\n    };\n    // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n    _this._onCompositionUpdate = function () {\n      if (isIE11()) {\n        _this._updateValue(_this._getCurrentInputValue(), true);\n      }\n    };\n    // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and langauges like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n    _this._onCompositionEnd = function (ev) {\n      var inputValue = _this._getCurrentInputValue();\n      _this._tryEnableAutofill(inputValue, _this.value, false, true);\n      _this._isComposing = false;\n      // Due to timing, this needs to be async, otherwise no text will be selected.\n      _this._async.setTimeout(function () {\n        // it's technically possible that the value of _isComposing is reset during this timeout,\n        // so explicitly trigger this with composing=true here, since it is supposed to be the\n        // update for composition end\n        _this._updateValue(_this._getCurrentInputValue(), false);\n      }, 0);\n    };\n    _this._onClick = function () {\n      if (_this._value && _this._value !== '' && _this._autoFillEnabled) {\n        _this._autoFillEnabled = false;\n      }\n    };\n    _this._onKeyDown = function (ev) {\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      }\n      // If the event is actively being composed, then don't alert autofill.\n      // Right now typing does not have isComposing, once that has been fixed any should be removed.\n      if (!ev.nativeEvent.isComposing) {\n        switch (ev.which) {\n          case KeyCodes.backspace:\n            _this._autoFillEnabled = false;\n            break;\n          case KeyCodes.left:\n          case KeyCodes.right:\n            if (_this._autoFillEnabled) {\n              _this._value = _this.state.displayValue;\n              _this._autoFillEnabled = false;\n            }\n            break;\n          default:\n            if (!_this._autoFillEnabled) {\n              if (_this.props.enableAutofillOnKeyPress.indexOf(ev.which) !== -1) {\n                _this._autoFillEnabled = true;\n              }\n            }\n            break;\n        }\n      }\n    };\n    _this._onInputChanged = function (ev) {\n      var value = _this._getCurrentInputValue(ev);\n      if (!_this._isComposing) {\n        _this._tryEnableAutofill(value, _this._value, ev.nativeEvent.isComposing);\n      }\n      // If it is not IE11 and currently composing, update the value\n      if (!(isIE11() && _this._isComposing)) {\n        var nativeEventComposing = ev.nativeEvent.isComposing;\n        var isComposing = nativeEventComposing === undefined ? _this._isComposing : nativeEventComposing;\n        _this._updateValue(value, isComposing);\n      }\n    };\n    _this._onChanged = function () {\n      // Swallow this event, we don't care about it\n      // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose\n      return;\n    };\n    /**\n     * Updates the current input value as well as getting a new display value.\n     * @param newValue - The new value from the input\n     */\n    _this._updateValue = function (newValue, composing) {\n      // Only proceed if the value is nonempty and is different from the old value\n      // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus\n      if (!newValue && newValue === _this._value) {\n        return;\n      }\n      _this._value = _this.props.onInputChange ? _this.props.onInputChange(newValue, composing) : newValue;\n      _this.setState({\n        displayValue: _this._getDisplayValue(_this._value, _this.props.suggestedDisplayValue)\n      }, function () {\n        return _this._notifyInputChange(_this._value, composing);\n      });\n    };\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._value = props.defaultVisibleValue || '';\n    _this.state = {\n      displayValue: props.defaultVisibleValue || ''\n    };\n    return _this;\n  }\n  Object.defineProperty(Autofill.prototype, \"cursorLocation\", {\n    get: function () {\n      if (this._inputElement.current) {\n        var inputElement = this._inputElement.current;\n        if (inputElement.selectionDirection !== SELECTION_FORWARD) {\n          return inputElement.selectionEnd;\n        } else {\n          return inputElement.selectionStart;\n        }\n      } else {\n        return -1;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"isValueSelected\", {\n    get: function () {\n      return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"value\", {\n    get: function () {\n      return this._value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"selectionStart\", {\n    get: function () {\n      return this._inputElement.current ? this._inputElement.current.selectionStart : -1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"selectionEnd\", {\n    get: function () {\n      return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"inputElement\", {\n    get: function () {\n      return this._inputElement.current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Autofill.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    if (this.props.updateValueInWillReceiveProps) {\n      var updatedInputValue = this.props.updateValueInWillReceiveProps();\n      // Don't update if we have a null value or the value isn't changing\n      // the value should still update if an empty string is passed in\n      if (updatedInputValue !== null && updatedInputValue !== this._value) {\n        this._value = updatedInputValue;\n      }\n    }\n    var newDisplayValue = this._getDisplayValue(this._value, nextProps.suggestedDisplayValue);\n    if (typeof newDisplayValue === 'string') {\n      this.setState({\n        displayValue: newDisplayValue\n      });\n    }\n  };\n  Autofill.prototype.componentDidUpdate = function () {\n    var value = this._value;\n    var _a = this.props,\n      suggestedDisplayValue = _a.suggestedDisplayValue,\n      shouldSelectFullInputValueInComponentDidUpdate = _a.shouldSelectFullInputValueInComponentDidUpdate,\n      preventValueSelection = _a.preventValueSelection;\n    var differenceIndex = 0;\n    if (preventValueSelection) {\n      return;\n    }\n    if (this._autoFillEnabled && value && suggestedDisplayValue && this._doesTextStartWith(suggestedDisplayValue, value)) {\n      var shouldSelectFullRange = false;\n      if (shouldSelectFullInputValueInComponentDidUpdate) {\n        shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();\n      }\n      if (shouldSelectFullRange && this._inputElement.current) {\n        this._inputElement.current.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);\n      } else {\n        while (differenceIndex < value.length && value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()) {\n          differenceIndex++;\n        }\n        if (differenceIndex > 0 && this._inputElement.current) {\n          this._inputElement.current.setSelectionRange(differenceIndex, suggestedDisplayValue.length, SELECTION_BACKWARD);\n        }\n      }\n    }\n  };\n  Autofill.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n  };\n  Autofill.prototype.render = function () {\n    var displayValue = this.state.displayValue;\n    var nativeProps = getNativeProps(this.props, inputProperties);\n    return React.createElement(\"input\", __assign({\n      autoCapitalize: \"off\",\n      autoComplete: \"off\",\n      \"aria-autocomplete\": 'both'\n    }, nativeProps, {\n      ref: this._inputElement,\n      value: displayValue,\n      onCompositionStart: this._onCompositionStart,\n      onCompositionUpdate: this._onCompositionUpdate,\n      onCompositionEnd: this._onCompositionEnd,\n      // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.\n      onChange: this._onChanged,\n      onInput: this._onInputChanged,\n      onKeyDown: this._onKeyDown,\n      onClick: this.props.onClick ? this.props.onClick : this._onClick,\n      \"data-lpignore\": true\n    }));\n  };\n  Autofill.prototype.focus = function () {\n    this._inputElement.current && this._inputElement.current.focus();\n  };\n  Autofill.prototype.clear = function () {\n    this._autoFillEnabled = true;\n    this._updateValue('', false);\n    this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);\n  };\n  Autofill.prototype._getCurrentInputValue = function (ev) {\n    if (ev && ev.target && ev.target.value) {\n      return ev.target.value;\n    } else if (this.inputElement && this.inputElement.value) {\n      return this.inputElement.value;\n    } else {\n      return '';\n    }\n  };\n  /**\n   * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,\n   * whether or not any text is selected, and only if the new input value is longer than the old input value.\n   * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then\n   * it should be completed.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.\n   * @param newValue - new input value\n   * @param oldValue - old input value\n   * @param isComposing - if true then the text is actively being composed and it has not completed.\n   * @param isComposed - if the text is a composed text value.\n   */\n  Autofill.prototype._tryEnableAutofill = function (newValue, oldValue, isComposing, isComposed) {\n    if (!isComposing && newValue && this._inputElement.current && this._inputElement.current.selectionStart === newValue.length && !this._autoFillEnabled && (newValue.length > oldValue.length || isComposed)) {\n      this._autoFillEnabled = true;\n    }\n  };\n  Autofill.prototype._notifyInputChange = function (newValue, composing) {\n    if (this.props.onInputValueChange) {\n      this.props.onInputValueChange(newValue, composing);\n    }\n  };\n  /**\n   * Returns a string that should be used as the display value.\n   * It evaluates this based on whether or not the suggested value starts with the input value\n   * and whether or not autofill is enabled.\n   * @param inputValue - the value that the input currently has.\n   * @param suggestedDisplayValue - the possible full value\n   */\n  Autofill.prototype._getDisplayValue = function (inputValue, suggestedDisplayValue) {\n    var displayValue = inputValue;\n    if (suggestedDisplayValue && inputValue && this._doesTextStartWith(suggestedDisplayValue, displayValue) && this._autoFillEnabled) {\n      displayValue = suggestedDisplayValue;\n    }\n    return displayValue;\n  };\n  Autofill.prototype._doesTextStartWith = function (text, startWith) {\n    if (!text || !startWith) {\n      return false;\n    }\n    return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;\n  };\n  Autofill.defaultProps = {\n    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up]\n  };\n  return Autofill;\n}(React.Component);\nexport { Autofill };\n/**\n *  @deprecated do not use.\n * {@docCategory Autofill}\n */\nvar BaseAutoFill = /** @class */function (_super) {\n  __extends(BaseAutoFill, _super);\n  function BaseAutoFill() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  return BaseAutoFill;\n}(Autofill);\nexport { BaseAutoFill };","map":{"version":3,"sources":["components/Autofill/Autofill.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { IAutofillProps, IAutofill } from './Autofill.types';\nimport { KeyCodes, getNativeProps, inputProperties, isIE11, Async, initializeComponentRef } from '../../Utilities';\n\nexport interface IAutofillState {\n  displayValue?: string;\n}\n\nconst SELECTION_FORWARD = 'forward';\nconst SELECTION_BACKWARD = 'backward';\n\n/**\n * {@docCategory Autofill}\n */\nexport class Autofill extends React.Component<IAutofillProps, IAutofillState> implements IAutofill {\n  public static defaultProps = {\n    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up] as KeyCodes[],\n  };\n\n  private _inputElement = React.createRef<HTMLInputElement>();\n  private _autoFillEnabled = true;\n  private _value: string;\n  private _isComposing: boolean = false;\n  private _async: Async;\n\n  constructor(props: IAutofillProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n\n    this._value = props.defaultVisibleValue || '';\n    this.state = {\n      displayValue: props.defaultVisibleValue || '',\n    };\n  }\n\n  public get cursorLocation(): number | null {\n    if (this._inputElement.current) {\n      const inputElement = this._inputElement.current;\n      if (inputElement.selectionDirection !== SELECTION_FORWARD) {\n        return inputElement.selectionEnd;\n      } else {\n        return inputElement.selectionStart;\n      }\n    } else {\n      return -1;\n    }\n  }\n\n  public get isValueSelected(): boolean {\n    return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);\n  }\n\n  public get value(): string {\n    return this._value;\n  }\n\n  public get selectionStart(): number | null {\n    return this._inputElement.current ? this._inputElement.current.selectionStart : -1;\n  }\n\n  public get selectionEnd(): number | null {\n    return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;\n  }\n\n  public get inputElement(): HTMLInputElement | null {\n    return this._inputElement.current;\n  }\n\n  public UNSAFE_componentWillReceiveProps(nextProps: IAutofillProps): void {\n    if (this.props.updateValueInWillReceiveProps) {\n      const updatedInputValue = this.props.updateValueInWillReceiveProps();\n      // Don't update if we have a null value or the value isn't changing\n      // the value should still update if an empty string is passed in\n      if (updatedInputValue !== null && updatedInputValue !== this._value) {\n        this._value = updatedInputValue;\n      }\n    }\n\n    const newDisplayValue = this._getDisplayValue(this._value, nextProps.suggestedDisplayValue);\n\n    if (typeof newDisplayValue === 'string') {\n      this.setState({ displayValue: newDisplayValue });\n    }\n  }\n\n  public componentDidUpdate() {\n    const value = this._value;\n    const { suggestedDisplayValue, shouldSelectFullInputValueInComponentDidUpdate, preventValueSelection } = this.props;\n    let differenceIndex = 0;\n\n    if (preventValueSelection) {\n      return;\n    }\n\n    if (\n      this._autoFillEnabled &&\n      value &&\n      suggestedDisplayValue &&\n      this._doesTextStartWith(suggestedDisplayValue, value)\n    ) {\n      let shouldSelectFullRange = false;\n\n      if (shouldSelectFullInputValueInComponentDidUpdate) {\n        shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();\n      }\n\n      if (shouldSelectFullRange && this._inputElement.current) {\n        this._inputElement.current.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);\n      } else {\n        while (\n          differenceIndex < value.length &&\n          value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()\n        ) {\n          differenceIndex++;\n        }\n        if (differenceIndex > 0 && this._inputElement.current) {\n          this._inputElement.current.setSelectionRange(\n            differenceIndex,\n            suggestedDisplayValue.length,\n            SELECTION_BACKWARD,\n          );\n        }\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n  }\n\n  public render(): JSX.Element {\n    const { displayValue } = this.state;\n\n    const nativeProps = getNativeProps<React.InputHTMLAttributes<HTMLInputElement>>(this.props, inputProperties);\n    return (\n      <input\n        autoCapitalize=\"off\"\n        autoComplete=\"off\"\n        aria-autocomplete={'both'}\n        {...nativeProps}\n        ref={this._inputElement}\n        value={displayValue}\n        onCompositionStart={this._onCompositionStart}\n        onCompositionUpdate={this._onCompositionUpdate}\n        onCompositionEnd={this._onCompositionEnd}\n        // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.\n        onChange={this._onChanged}\n        onInput={this._onInputChanged}\n        onKeyDown={this._onKeyDown}\n        onClick={this.props.onClick ? this.props.onClick : this._onClick}\n        data-lpignore={true}\n      />\n    );\n  }\n\n  public focus() {\n    this._inputElement.current && this._inputElement.current.focus();\n  }\n\n  public clear() {\n    this._autoFillEnabled = true;\n    this._updateValue('', false);\n    this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);\n  }\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and langauges like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionStart = (ev: React.CompositionEvent<HTMLInputElement>) => {\n    this._isComposing = true;\n    this._autoFillEnabled = false;\n  };\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionUpdate = () => {\n    if (isIE11()) {\n      this._updateValue(this._getCurrentInputValue(), true);\n    }\n  };\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and langauges like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionEnd = (ev: React.CompositionEvent<HTMLInputElement>) => {\n    const inputValue = this._getCurrentInputValue();\n    this._tryEnableAutofill(inputValue, this.value, false, true);\n    this._isComposing = false;\n    // Due to timing, this needs to be async, otherwise no text will be selected.\n    this._async.setTimeout(() => {\n      // it's technically possible that the value of _isComposing is reset during this timeout,\n      // so explicitly trigger this with composing=true here, since it is supposed to be the\n      // update for composition end\n      this._updateValue(this._getCurrentInputValue(), false);\n    }, 0);\n  };\n\n  private _onClick = () => {\n    if (this._value && this._value !== '' && this._autoFillEnabled) {\n      this._autoFillEnabled = false;\n    }\n  };\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLInputElement>) => {\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // If the event is actively being composed, then don't alert autofill.\n    // Right now typing does not have isComposing, once that has been fixed any should be removed.\n    if (!(ev.nativeEvent as any).isComposing) {\n      switch (ev.which) {\n        case KeyCodes.backspace:\n          this._autoFillEnabled = false;\n          break;\n        case KeyCodes.left:\n        case KeyCodes.right:\n          if (this._autoFillEnabled) {\n            this._value = this.state.displayValue!;\n            this._autoFillEnabled = false;\n          }\n          break;\n        default:\n          if (!this._autoFillEnabled) {\n            if (this.props.enableAutofillOnKeyPress!.indexOf(ev.which) !== -1) {\n              this._autoFillEnabled = true;\n            }\n          }\n          break;\n      }\n    }\n  };\n\n  private _onInputChanged = (ev: React.FormEvent<HTMLElement>) => {\n    const value: string = this._getCurrentInputValue(ev);\n\n    if (!this._isComposing) {\n      this._tryEnableAutofill(value, this._value, (ev.nativeEvent as any).isComposing);\n    }\n\n    // If it is not IE11 and currently composing, update the value\n    if (!(isIE11() && this._isComposing)) {\n      const nativeEventComposing = (ev.nativeEvent as any).isComposing;\n      const isComposing = nativeEventComposing === undefined ? this._isComposing : nativeEventComposing;\n      this._updateValue(value, isComposing);\n    }\n  };\n\n  private _onChanged = (): void => {\n    // Swallow this event, we don't care about it\n    // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose\n    return;\n  };\n\n  private _getCurrentInputValue(ev?: React.FormEvent<HTMLElement>): string {\n    if (ev && ev.target && (ev.target as any).value) {\n      return (ev.target as any).value;\n    } else if (this.inputElement && this.inputElement.value) {\n      return this.inputElement.value;\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,\n   * whether or not any text is selected, and only if the new input value is longer than the old input value.\n   * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then\n   * it should be completed.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.\n   * @param newValue - new input value\n   * @param oldValue - old input value\n   * @param isComposing - if true then the text is actively being composed and it has not completed.\n   * @param isComposed - if the text is a composed text value.\n   */\n  private _tryEnableAutofill(newValue: string, oldValue: string, isComposing?: boolean, isComposed?: boolean): void {\n    if (\n      !isComposing &&\n      newValue &&\n      this._inputElement.current &&\n      this._inputElement.current.selectionStart === newValue.length &&\n      !this._autoFillEnabled &&\n      (newValue.length > oldValue.length || isComposed)\n    ) {\n      this._autoFillEnabled = true;\n    }\n  }\n\n  private _notifyInputChange(newValue: string, composing: boolean): void {\n    if (this.props.onInputValueChange) {\n      this.props.onInputValueChange(newValue, composing);\n    }\n  }\n\n  /**\n   * Updates the current input value as well as getting a new display value.\n   * @param newValue - The new value from the input\n   */\n  private _updateValue = (newValue: string, composing: boolean) => {\n    // Only proceed if the value is nonempty and is different from the old value\n    // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus\n    if (!newValue && newValue === this._value) {\n      return;\n    }\n    this._value = this.props.onInputChange ? this.props.onInputChange(newValue, composing) : newValue;\n    this.setState(\n      {\n        displayValue: this._getDisplayValue(this._value, this.props.suggestedDisplayValue),\n      },\n      () => this._notifyInputChange(this._value, composing),\n    );\n  };\n\n  /**\n   * Returns a string that should be used as the display value.\n   * It evaluates this based on whether or not the suggested value starts with the input value\n   * and whether or not autofill is enabled.\n   * @param inputValue - the value that the input currently has.\n   * @param suggestedDisplayValue - the possible full value\n   */\n  private _getDisplayValue(inputValue: string, suggestedDisplayValue?: string): string {\n    let displayValue = inputValue;\n    if (\n      suggestedDisplayValue &&\n      inputValue &&\n      this._doesTextStartWith(suggestedDisplayValue, displayValue) &&\n      this._autoFillEnabled\n    ) {\n      displayValue = suggestedDisplayValue;\n    }\n    return displayValue;\n  }\n\n  private _doesTextStartWith(text: string, startWith: string): boolean {\n    if (!text || !startWith) {\n      return false;\n    }\n    return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;\n  }\n}\n\n/**\n *  @deprecated do not use.\n * {@docCategory Autofill}\n */\nexport class BaseAutoFill extends Autofill {}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}