{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { JsonldGraph } from \"jsonld-graph\";\nimport { apiService } from \"./ApiService\";\nimport context from \"./ref/context\";\nimport context3 from \"./ref/context3\";\nimport quantitativeTypes from \"./ref/quantitativeTypes\";\nimport iotCentralContext from \"./ref/iotCentralContext\";\nconst REL_TARGET_ANY = \"*\";\nconst getModelDisplayName = vertex => vertex.getAttributeValue(\"dtmi:dtdl:property:displayName;2\");\nconst getModelDescription = vertex => vertex.getAttributeValue(\"dtmi:dtdl:property:description;2\");\nconst getPropertyName = vertex => vertex.getAttributeValue(\"dtmi:dtdl:property:name;2\");\nconst getPropertyWritable = vertex => vertex.getAttributeValue(\"http://azure.com/DigitalTwin/MetaModel/undefinedTerm/writable\");\nconst inferTarget = vertex => {\n  const targetEdge = vertex.getOutgoing(\"dtmi:dtdl:property:target;2\").first();\n  return targetEdge ? targetEdge.toVertex.id : REL_TARGET_ANY;\n};\nconst inferSchema = vertex => {\n  const schemaEdge = vertex.getOutgoing(\"dtmi:dtdl:property:schema;2\").first();\n  if (!schemaEdge) {\n    return null;\n  }\n  if (schemaEdge.toVertex.isType(\"dtmi:dtdl:class:Object;2\")) {\n    const fields = [...schemaEdge.toVertex.getOutgoing(\"dtmi:dtdl:property:fields;2\").map(edge => ({\n      name: getPropertyName(edge.toVertex),\n      schema: inferSchema(edge.toVertex)\n    })).filter(edge => !!edge.schema)];\n    return {\n      type: \"Object\",\n      fields\n    };\n  }\n  if (schemaEdge.toVertex.isType(\"dtmi:dtdl:class:Enum;2\")) {\n    return {\n      type: \"Enum\",\n      values: [...schemaEdge.toVertex.getOutgoing(\"dtmi:dtdl:property:enumValues;2\").map(edge => ({\n        name: getPropertyName(edge.toVertex),\n        value: edge.toVertex.getAttributeValue(\"dtmi:dtdl:property:enumValue;2\"),\n        displayName: edge.toVertex.getAttributeValue(\"dtmi:dtdl:property:displayName;2\")\n      }))],\n      valueSchema: \"string\"\n    };\n  }\n  if (schemaEdge.toVertex.isType(\"dtmi:dtdl:class:Map;2\")) {\n    return {\n      type: \"Map\",\n      fields: [...schemaEdge.toVertex.getOutgoing(\"dtmi:dtdl:property:fields;2\").map(edge => ({\n        name: getPropertyName(edge.toVertex),\n        schema: inferSchema(edge.toVertex)\n      })).filter(edge => !!edge.schema)]\n    };\n  }\n  return schemaEdge.toVertex.id;\n};\nexport class ModelService {\n  constructor() {\n    this.addModels = async models => {\n      await this.initialize();\n      await this.modelGraph.load(models);\n    };\n    this.removeModel = modelId => {\n      const model = this.modelGraph.getVertex(modelId);\n      if (model) {\n        this.modelGraph.removeVertex(model);\n      }\n    };\n    this.modelGraph = null;\n  }\n  async initialize() {\n    if (!this.modelGraph) {\n      const models = await apiService.queryModels();\n      this.modelGraph = new JsonldGraph([{\n        uri: \"dtmi:iotcentral:context;2\",\n        context: iotCentralContext\n      }, {\n        uri: \"dtmi:dtdl:context;2\",\n        context\n      }, {\n        uri: \"dtmi:dtdl:context;3\",\n        context: context3\n      }, {\n        uri: \"dtmi:dtdl:extension:quantitativeTypes;1\",\n        context: quantitativeTypes\n      }]);\n      await this._loadGraph(models.map(x => x.model));\n    }\n  }\n  async initializeWithModels(models) {\n    this.modelGraph = new JsonldGraph([{\n      uri: \"dtmi:iotcentral:context;2\",\n      context: iotCentralContext\n    }, {\n      uri: \"dtmi:dtdl:context;2\",\n      context\n    }, {\n      uri: \"dtmi:dtdl:context;3\",\n      context: context3\n    }, {\n      uri: \"dtmi:dtdl:extension:quantitativeTypes;1\",\n      context: quantitativeTypes\n    }]);\n    await this._loadGraph(models);\n  }\n  async getModelIdsForUpload(models) {\n    await this.initializeWithModels(models);\n    const sortedModels = [];\n    const checkedList = [];\n    const vertices = this.modelGraph.getVertices(x => x.isType(\"dtmi:dtdl:class:Interface;2\")).items();\n    for (const vertice of vertices) {\n      this._addReferencedModels(vertice, sortedModels, checkedList);\n    }\n    return sortedModels;\n  }\n  async getRelationships(sourceModelId, targetModelId) {\n    await this.initialize();\n    const sourceModel = await this.getModel(sourceModelId);\n    if (targetModelId) {\n      const targetModel = await this.getModel(targetModelId);\n      return sourceModel.relationships.filter(x => x.target === REL_TARGET_ANY || x.target === targetModelId || targetModel.bases.some(y => y === x.target)).map(x => x.name);\n    }\n    return sourceModel.relationships;\n  }\n  async getModelById(sourceModelId) {\n    await this.initialize();\n    return await this.getModel(sourceModelId);\n  }\n  async getProperties(sourceModelId) {\n    await this.initialize();\n    const sourceModel = await this.getModel(sourceModelId);\n    return this._getChildComponentProperties(sourceModel);\n  }\n  async getTelemetries(sourceModelId) {\n    await this.initialize();\n    return await this.getModel(sourceModelId).telemetries;\n  }\n  async getBases(modelId) {\n    await this.initialize();\n    const sourceModel = await this.getModel(modelId);\n    return sourceModel.bases;\n  }\n  async deleteAll() {\n    await this.initialize();\n    const models = this.modelGraph.getVertices(x => x.isType(\"dtmi:dtdl:class:Interface;2\")).items();\n    while (models.length > 0) {\n      const referenced = {};\n      for (const m of models) {\n        m.getOutgoing(\"dtmi:dtdl:property:extends;2\").filter(x => x.toVertex.isType(\"dtmi:dtdl:class:Interface;2\")).items().forEach(x => referenced[x.toVertex.id] = x.toVertex);\n        m.getOutgoing(\"dtmi:dtdl:property:contents;2\").filter(x => x.toVertex.isType(\"dtmi:dtdl:class:Component;2\")).items().map(x => x.toVertex.getOutgoing(\"dtmi:dtdl:property:schema;2\").first()).filter(x => x).forEach(x => referenced[x.toVertex.id] = x.toVertex);\n      }\n      for (const m of models.filter(x => !referenced[x.id])) {\n        await apiService.deleteModel(m.id);\n        models.splice(models.indexOf(m), 1);\n      }\n    }\n  }\n  async createPayload(modelId) {\n    await this.initialize();\n    const model = await this.getModel(modelId);\n    const payload = {\n      $metadata: {\n        $model: modelId\n      }\n    };\n    for (const component of model.components) {\n      const componentPayload = {\n        $metadata: {}\n      };\n      payload[component.name] = componentPayload;\n    }\n    return payload;\n  }\n\n  // eslint-disable-next-line complexity\n  getPropertyDefaultValue(schema, current) {\n    const isCurrentUndefined = typeof current === \"undefined\";\n    if (typeof schema === \"object\") {\n      var _schema$type;\n      if (!isCurrentUndefined) {\n        return current;\n      }\n      const schemaType = (_schema$type = schema.type) !== null && _schema$type !== void 0 ? _schema$type : schema[\"@type\"];\n      const objectProperties = {};\n      switch (schemaType) {\n        case \"Object\":\n          for (const field of schema.fields) {\n            objectProperties[field.name] = this.getPropertyDefaultValue(field.schema);\n          }\n          return objectProperties;\n        case \"Enum\":\n          return isCurrentUndefined ? this.getPropertyDefaultValue(schema.valueSchema, current) : current;\n        case \"Map\":\n        default:\n          return isCurrentUndefined ? {} : current;\n      }\n    }\n    switch (schema) {\n      case \"dtmi:dtdl:instance:Schema:double;2\":\n      case \"dtmi:dtdl:instance:Schema:integer;2\":\n      case \"dtmi:dtdl:instance:Schema:long;2\":\n      case \"dtmi:dtdl:instance:Schema:float;2\":\n      case \"double\":\n      case \"integer\":\n      case \"long\":\n      case \"float\":\n        return isCurrentUndefined ? \"\" : current;\n      case \"dtmi:dtdl:instance:Schema:string;2\":\n      case \"string\":\n        return isCurrentUndefined ? \"\" : current.toString();\n      case \"dtmi:dtdl:instance:Schema:boolean;2\":\n      case \"boolean\":\n        return isCurrentUndefined ? \"\" : current;\n      default:\n        return isCurrentUndefined ? \"\" : current;\n    }\n  }\n  async getAllModels() {\n    await this.initialize();\n    const models = this.modelGraph.getVertices(x => x.isType(\"dtmi:dtdl:class:Interface;2\")).items();\n    return models.map(model => {\n      const contents = {\n        id: model.id,\n        displayName: model.getAttributeValue(\"dtmi:dtdl:property:displayName;2\"),\n        properties: [],\n        componentProperties: [],\n        relationships: [],\n        telemetries: [],\n        bases: [],\n        rootBases: [],\n        components: []\n      };\n      this._mapModel(model, contents);\n      return contents;\n    });\n  }\n  async getModel(modelId) {\n    await this.initialize();\n    return this._getModel(modelId);\n  }\n  async getModels(modelIds) {\n    await this.initialize();\n    return modelIds.map(id => this._getModel(id));\n  }\n  chunkModelsList(array, size) {\n    const chunkedArr = [];\n    let index = 0;\n    while (index < array.length) {\n      chunkedArr.push(array.slice(index, size + index));\n      index += size;\n    }\n    return chunkedArr;\n  }\n  async _loadGraph(models) {\n    await this.modelGraph.load(models);\n    models.forEach(x => this.modelGraph.getVertex(x[\"@id\"]).addAttributeValue(\"is_defined\", true));\n  }\n  _addReferencedModels(vertice, sortedModels, checkedList) {\n    if (checkedList.some(id => id === vertice.id)) {\n      return;\n    }\n    checkedList.push(vertice.id);\n    vertice.getOutgoing(\"dtmi:dtdl:property:extends;2\").filter(x => x.toVertex.isType(\"dtmi:dtdl:class:Interface;2\")).items().forEach(x => this._addReferencedModels(x.toVertex, sortedModels, checkedList));\n    vertice.getOutgoing(\"dtmi:dtdl:property:contents;2\").filter(x => x.toVertex.isType(\"dtmi:dtdl:class:Component;2\")).items().map(x => x.toVertex.getOutgoing(\"dtmi:dtdl:property:schema;2\").first()).filter(x => x).forEach(x => this._addReferencedModels(x.toVertex, sortedModels, checkedList));\n    sortedModels.push(vertice.id);\n  }\n  _getModel(modelId) {\n    const contents = {\n      properties: [],\n      componentProperties: [],\n      relationships: [],\n      telemetries: [],\n      bases: [],\n      rootBases: [],\n      components: [],\n      isDefined: false\n    };\n    const model = this.modelGraph.getVertex(modelId);\n    if (model) {\n      contents.id = model.id;\n      this._mapModel(model, contents);\n    } else {\n      contents.id = modelId;\n    }\n    return contents;\n  }\n  _mapModel(vertex, contents, isExtended = false) {\n    const safeAdd = (collection, item) => Object.keys(item).every(x => item[x] !== null) && collection.push(item);\n    if (!contents.displayName) {\n      contents.displayName = getModelDisplayName(vertex);\n    }\n    if (!isExtended) {\n      contents.description = getModelDescription(vertex);\n      contents.isDefined = vertex.hasAttributeValue(\"is_defined\", true);\n    }\n    vertex.getOutgoing(\"dtmi:dtdl:property:contents;2\").items().forEach(x => {\n      if (x.toVertex.isType(\"dtmi:dtdl:class:Property;2\")) {\n        safeAdd(contents.properties, {\n          name: getPropertyName(x.toVertex),\n          schema: inferSchema(x.toVertex),\n          writable: getPropertyWritable(x.toVertex)\n        });\n      }\n      if (x.toVertex.isType(\"dtmi:dtdl:class:Telemetry;2\")) {\n        safeAdd(contents.telemetries, {\n          name: getPropertyName(x.toVertex),\n          schema: inferSchema(x.toVertex)\n        });\n      }\n      if (x.toVertex.isType(\"dtmi:dtdl:class:Relationship;2\")) {\n        const outgoing = x.toVertex.getOutgoing(\"dtmi:dtdl:property:properties;2\");\n        const properties = outgoing.items().map(v => getPropertyName(v.toVertex));\n        safeAdd(contents.relationships, {\n          name: getPropertyName(x.toVertex),\n          target: inferTarget(x.toVertex),\n          properties\n        });\n      }\n      if (x.toVertex.isType(\"dtmi:dtdl:class:Component;2\")) {\n        const component = this._getModel(inferSchema(x.toVertex));\n        component.name = getPropertyName(x.toVertex);\n        component.schema = inferSchema(x.toVertex);\n        safeAdd(contents.components, {\n          ...component,\n          isExtended\n        });\n      }\n    });\n    vertex.getOutgoing(\"dtmi:dtdl:property:extends;2\").items().forEach(x => {\n      contents.bases.push(x.toVertex.id);\n      if (!isExtended) {\n        contents.rootBases.push(x.toVertex.id);\n      }\n      this._mapModel(x.toVertex, contents, true);\n    });\n    contents.componentProperties = this._getChildComponentProperties(contents);\n  }\n  _getChildComponentProperties(component) {\n    const properties = {};\n    component.properties.forEach(property => {\n      var _property$writable;\n      properties[property.name] = {\n        schema: property.schema,\n        writable: (_property$writable = property.writable) !== null && _property$writable !== void 0 ? _property$writable : true\n      };\n    });\n    component.components.forEach(c => {\n      properties[c.name] = this._getChildComponentProperties(c);\n    });\n    return properties;\n  }\n}","map":{"version":3,"names":["JsonldGraph","apiService","context","context3","quantitativeTypes","iotCentralContext","REL_TARGET_ANY","getModelDisplayName","vertex","getAttributeValue","getModelDescription","getPropertyName","getPropertyWritable","inferTarget","targetEdge","getOutgoing","first","toVertex","id","inferSchema","schemaEdge","isType","fields","map","edge","name","schema","filter","type","values","value","displayName","valueSchema","ModelService","constructor","addModels","models","initialize","modelGraph","load","removeModel","modelId","model","getVertex","removeVertex","queryModels","uri","_loadGraph","x","initializeWithModels","getModelIdsForUpload","sortedModels","checkedList","vertices","getVertices","items","vertice","_addReferencedModels","getRelationships","sourceModelId","targetModelId","sourceModel","getModel","targetModel","relationships","target","bases","some","y","getModelById","getProperties","_getChildComponentProperties","getTelemetries","telemetries","getBases","deleteAll","length","referenced","m","forEach","deleteModel","splice","indexOf","createPayload","payload","$metadata","$model","component","components","componentPayload","getPropertyDefaultValue","current","isCurrentUndefined","_schema$type","schemaType","objectProperties","field","toString","getAllModels","contents","properties","componentProperties","rootBases","_mapModel","_getModel","getModels","modelIds","chunkModelsList","array","size","chunkedArr","index","push","slice","addAttributeValue","isDefined","isExtended","safeAdd","collection","item","Object","keys","every","description","hasAttributeValue","writable","outgoing","v","property","_property$writable","c"],"sources":["/home/saharsh/Music/digital-twins-explorer/client/src/services/ModelService.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { JsonldGraph } from \"jsonld-graph\";\n\nimport { apiService } from \"./ApiService\";\nimport context from \"./ref/context\";\nimport context3 from \"./ref/context3\";\nimport quantitativeTypes from \"./ref/quantitativeTypes\";\nimport iotCentralContext from \"./ref/iotCentralContext\";\n\nconst REL_TARGET_ANY = \"*\";\nconst getModelDisplayName = vertex => vertex.getAttributeValue(\"dtmi:dtdl:property:displayName;2\");\nconst getModelDescription = vertex => vertex.getAttributeValue(\"dtmi:dtdl:property:description;2\");\nconst getPropertyName = vertex => vertex.getAttributeValue(\"dtmi:dtdl:property:name;2\");\nconst getPropertyWritable = vertex => vertex.getAttributeValue(\"http://azure.com/DigitalTwin/MetaModel/undefinedTerm/writable\");\n\nconst inferTarget = vertex => {\n  const targetEdge = vertex.getOutgoing(\"dtmi:dtdl:property:target;2\").first();\n  return targetEdge ? targetEdge.toVertex.id : REL_TARGET_ANY;\n};\n\nconst inferSchema = vertex => {\n  const schemaEdge = vertex.getOutgoing(\"dtmi:dtdl:property:schema;2\").first();\n  if (!schemaEdge) {\n    return null;\n  }\n  if (schemaEdge.toVertex.isType(\"dtmi:dtdl:class:Object;2\")) {\n    const fields = [ ...schemaEdge.toVertex.getOutgoing(\"dtmi:dtdl:property:fields;2\")\n      .map(edge => ({\n        name: getPropertyName(edge.toVertex),\n        schema: inferSchema(edge.toVertex)\n      }))\n      .filter(edge => !!edge.schema) ];\n    return {\n      type: \"Object\",\n      fields\n    };\n  }\n\n  if (schemaEdge.toVertex.isType(\"dtmi:dtdl:class:Enum;2\")) {\n    return {\n      type: \"Enum\",\n      values: [ ...schemaEdge.toVertex.getOutgoing(\"dtmi:dtdl:property:enumValues;2\").map(edge => ({\n        name: getPropertyName(edge.toVertex),\n        value: edge.toVertex.getAttributeValue(\"dtmi:dtdl:property:enumValue;2\"),\n        displayName: edge.toVertex.getAttributeValue(\"dtmi:dtdl:property:displayName;2\")\n      })) ],\n      valueSchema: \"string\"\n    };\n  }\n\n  if (schemaEdge.toVertex.isType(\"dtmi:dtdl:class:Map;2\")) {\n    return {\n      type: \"Map\",\n      fields: [ ...schemaEdge.toVertex.getOutgoing(\"dtmi:dtdl:property:fields;2\")\n        .map(edge => ({\n          name: getPropertyName(edge.toVertex),\n          schema: inferSchema(edge.toVertex)\n        }))\n        .filter(edge => !!edge.schema) ]\n    };\n  }\n\n  return schemaEdge.toVertex.id;\n};\n\nexport class ModelService {\n\n  constructor() {\n    this.modelGraph = null;\n  }\n\n  async initialize() {\n    if (!this.modelGraph) {\n      const models = await apiService.queryModels();\n      this.modelGraph = new JsonldGraph([\n        { uri: \"dtmi:iotcentral:context;2\", context: iotCentralContext },\n        { uri: \"dtmi:dtdl:context;2\", context },\n        { uri: \"dtmi:dtdl:context;3\", context: context3 },\n        { uri: \"dtmi:dtdl:extension:quantitativeTypes;1\", context: quantitativeTypes}\n      ]);\n      await this._loadGraph(models.map(x => x.model));\n    }\n  }\n\n  async initializeWithModels(models) {\n    this.modelGraph = new JsonldGraph([\n      { uri: \"dtmi:iotcentral:context;2\", context: iotCentralContext },\n      { uri: \"dtmi:dtdl:context;2\", context },\n      { uri: \"dtmi:dtdl:context;3\", context: context3 },\n      { uri: \"dtmi:dtdl:extension:quantitativeTypes;1\", context: quantitativeTypes}\n    ]);\n    await this._loadGraph(models);\n  }\n\n  async getModelIdsForUpload(models) {\n    await this.initializeWithModels(models);\n    const sortedModels = [];\n    const checkedList = [];\n    const vertices = this.modelGraph.getVertices(x => x.isType(\"dtmi:dtdl:class:Interface;2\")).items();\n    for (const vertice of vertices) {\n      this._addReferencedModels(vertice, sortedModels, checkedList);\n    }\n    return sortedModels;\n  }\n\n  async getRelationships(sourceModelId, targetModelId) {\n    await this.initialize();\n    const sourceModel = await this.getModel(sourceModelId);\n    if (targetModelId) {\n      const targetModel = await this.getModel(targetModelId);\n      return sourceModel\n        .relationships\n        .filter(x => x.target === REL_TARGET_ANY || x.target === targetModelId || targetModel.bases.some(y => y === x.target))\n        .map(x => x.name);\n    }\n    return sourceModel.relationships;\n  }\n\n  async getModelById(sourceModelId) {\n    await this.initialize();\n    return await this.getModel(sourceModelId);\n  }\n\n  async getProperties(sourceModelId) {\n    await this.initialize();\n    const sourceModel = await this.getModel(sourceModelId);\n    return this._getChildComponentProperties(sourceModel);\n  }\n\n  async getTelemetries(sourceModelId) {\n    await this.initialize();\n    return await this.getModel(sourceModelId).telemetries;\n  }\n\n  async getBases(modelId) {\n    await this.initialize();\n    const sourceModel = await this.getModel(modelId);\n    return sourceModel.bases;\n  }\n\n  async deleteAll() {\n    await this.initialize();\n    const models = this.modelGraph.getVertices(x => x.isType(\"dtmi:dtdl:class:Interface;2\")).items();\n\n    while (models.length > 0) {\n      const referenced = {};\n      for (const m of models) {\n        m.getOutgoing(\"dtmi:dtdl:property:extends;2\")\n          .filter(x => x.toVertex.isType(\"dtmi:dtdl:class:Interface;2\"))\n          .items()\n          .forEach(x => referenced[x.toVertex.id] = x.toVertex);\n        m.getOutgoing(\"dtmi:dtdl:property:contents;2\")\n          .filter(x => x.toVertex.isType(\"dtmi:dtdl:class:Component;2\"))\n          .items()\n          .map(x => x.toVertex.getOutgoing(\"dtmi:dtdl:property:schema;2\").first())\n          .filter(x => x)\n          .forEach(x => referenced[x.toVertex.id] = x.toVertex);\n      }\n\n      for (const m of models.filter(x => !referenced[x.id])) {\n        await apiService.deleteModel(m.id);\n        models.splice(models.indexOf(m), 1);\n      }\n    }\n  }\n\n  async createPayload(modelId) {\n    await this.initialize();\n    const model = await this.getModel(modelId);\n    const payload = {\n      $metadata: {\n        $model: modelId\n      }\n    };\n    for (const component of model.components) {\n      const componentPayload = {\n        $metadata: {\n        }\n      };\n      payload[component.name] = componentPayload;\n    }\n    return payload;\n  }\n\n  // eslint-disable-next-line complexity\n  getPropertyDefaultValue(schema, current) {\n    const isCurrentUndefined = typeof current === \"undefined\";\n    if (typeof schema === \"object\") {\n      if (!isCurrentUndefined) {\n        return current;\n      }\n      const schemaType = schema.type ?? schema[\"@type\"];\n      const objectProperties = {};\n      switch (schemaType) {\n        case \"Object\":\n          for (const field of schema.fields) {\n            objectProperties[field.name] = this.getPropertyDefaultValue(field.schema);\n          }\n          return objectProperties;\n        case \"Enum\":\n          return isCurrentUndefined ? this.getPropertyDefaultValue(schema.valueSchema, current) : current;\n        case \"Map\":\n        default:\n          return isCurrentUndefined ? {} : current;\n      }\n    }\n\n    switch (schema) {\n      case \"dtmi:dtdl:instance:Schema:double;2\":\n      case \"dtmi:dtdl:instance:Schema:integer;2\":\n      case \"dtmi:dtdl:instance:Schema:long;2\":\n      case \"dtmi:dtdl:instance:Schema:float;2\":\n      case \"double\":\n      case \"integer\":\n      case \"long\":\n      case \"float\":\n        return isCurrentUndefined ? \"\" : current;\n      case \"dtmi:dtdl:instance:Schema:string;2\":\n      case \"string\":\n        return isCurrentUndefined ? \"\" : current.toString();\n      case \"dtmi:dtdl:instance:Schema:boolean;2\":\n      case \"boolean\":\n        return isCurrentUndefined ? \"\" : current;\n      default:\n        return isCurrentUndefined ? \"\" : current;\n    }\n  }\n\n  async getAllModels() {\n    await this.initialize();\n    const models = this.modelGraph.getVertices(x => x.isType(\"dtmi:dtdl:class:Interface;2\")).items();\n    return models.map(model => {\n      const contents = {\n        id: model.id,\n        displayName: model.getAttributeValue(\"dtmi:dtdl:property:displayName;2\"),\n        properties: [],\n        componentProperties: [],\n        relationships: [],\n        telemetries: [],\n        bases: [],\n        rootBases: [],\n        components: []\n      };\n      this._mapModel(model, contents);\n      return contents;\n    });\n  }\n\n  async getModel(modelId) {\n    await this.initialize();\n    return this._getModel(modelId);\n  }\n\n  async getModels(modelIds) {\n    await this.initialize();\n    return modelIds.map(id => this._getModel(id));\n  }\n\n  addModels = async models => {\n    await this.initialize();\n    await this.modelGraph.load(models);\n  }\n\n  removeModel = modelId => {\n    const model = this.modelGraph.getVertex(modelId);\n    if (model) {\n      this.modelGraph.removeVertex(model);\n    }\n  }\n\n  chunkModelsList(array, size) {\n    const chunkedArr = [];\n    let index = 0;\n    while (index < array.length) {\n      chunkedArr.push(array.slice(index, size + index));\n      index += size;\n    }\n    return chunkedArr;\n  }\n\n  async _loadGraph(models) {\n    await this.modelGraph.load(models);\n    models.forEach(x => this.modelGraph.getVertex(x[\"@id\"]).addAttributeValue(\"is_defined\", true));\n  }\n\n  _addReferencedModels(vertice, sortedModels, checkedList) {\n    if (checkedList.some(id => id === vertice.id)) {\n      return;\n    }\n    checkedList.push(vertice.id);\n    vertice.getOutgoing(\"dtmi:dtdl:property:extends;2\")\n      .filter(x => x.toVertex.isType(\"dtmi:dtdl:class:Interface;2\"))\n      .items()\n      .forEach(x => this._addReferencedModels(x.toVertex, sortedModels, checkedList));\n    vertice.getOutgoing(\"dtmi:dtdl:property:contents;2\")\n      .filter(x => x.toVertex.isType(\"dtmi:dtdl:class:Component;2\"))\n      .items()\n      .map(x => x.toVertex.getOutgoing(\"dtmi:dtdl:property:schema;2\").first())\n      .filter(x => x)\n      .forEach(x => this._addReferencedModels(x.toVertex, sortedModels, checkedList));\n    sortedModels.push(vertice.id);\n  }\n\n  _getModel(modelId) {\n    const contents = {\n      properties: [],\n      componentProperties: [],\n      relationships: [],\n      telemetries: [],\n      bases: [],\n      rootBases: [],\n      components: [],\n      isDefined: false\n    };\n    const model = this.modelGraph.getVertex(modelId);\n    if (model) {\n      contents.id = model.id;\n      this._mapModel(model, contents);\n    } else {\n      contents.id = modelId;\n    }\n    return contents;\n  }\n\n  _mapModel(vertex, contents, isExtended = false) {\n    const safeAdd = (collection, item) => Object.keys(item).every(x => item[x] !== null) && collection.push(item);\n\n    if (!contents.displayName) {\n      contents.displayName = getModelDisplayName(vertex);\n    }\n    if (!isExtended) {\n      contents.description = getModelDescription(vertex);\n      contents.isDefined = vertex.hasAttributeValue(\"is_defined\", true);\n    }\n\n    vertex\n      .getOutgoing(\"dtmi:dtdl:property:contents;2\")\n      .items()\n      .forEach(x => {\n        if (x.toVertex.isType(\"dtmi:dtdl:class:Property;2\")) {\n          safeAdd(contents.properties, {\n            name: getPropertyName(x.toVertex),\n            schema: inferSchema(x.toVertex),\n            writable: getPropertyWritable(x.toVertex)\n          });\n        }\n\n        if (x.toVertex.isType(\"dtmi:dtdl:class:Telemetry;2\")) {\n          safeAdd(contents.telemetries, {\n            name: getPropertyName(x.toVertex),\n            schema: inferSchema(x.toVertex)\n          });\n        }\n\n        if (x.toVertex.isType(\"dtmi:dtdl:class:Relationship;2\")) {\n          const outgoing = x.toVertex.getOutgoing(\"dtmi:dtdl:property:properties;2\");\n          const properties = outgoing.items().map(v => getPropertyName(v.toVertex));\n\n          safeAdd(contents.relationships, {\n            name: getPropertyName(x.toVertex),\n            target: inferTarget(x.toVertex),\n            properties\n          });\n        }\n\n        if (x.toVertex.isType(\"dtmi:dtdl:class:Component;2\")) {\n          const component = this._getModel(inferSchema(x.toVertex));\n          component.name = getPropertyName(x.toVertex);\n          component.schema = inferSchema(x.toVertex);\n          safeAdd(contents.components, {...component, isExtended});\n        }\n      });\n\n    vertex\n      .getOutgoing(\"dtmi:dtdl:property:extends;2\")\n      .items()\n      .forEach(x => {\n        contents.bases.push(x.toVertex.id);\n        if (!isExtended) {\n          contents.rootBases.push(x.toVertex.id);\n        }\n        this._mapModel(x.toVertex, contents, true);\n      });\n\n    contents.componentProperties = this._getChildComponentProperties(contents);\n  }\n\n  _getChildComponentProperties(component) {\n    const properties = {};\n    component.properties.forEach(property => {\n      properties[property.name] = {\n        schema: property.schema,\n        writable: property.writable ?? true\n      };\n    });\n\n    component.components.forEach(c => {\n      properties[c.name] = this._getChildComponentProperties(c);\n    });\n\n    return properties;\n  }\n\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}