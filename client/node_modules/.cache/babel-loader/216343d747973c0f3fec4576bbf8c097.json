{"ast":null,"code":"import { __spreadArrays } from \"tslib\";\nimport { find, values } from '../../Utilities';\nimport { mergeOverflows, sequencesToID } from '../../utilities/keytips/KeytipUtils';\nimport { KTP_LAYER_ID } from '../../utilities/keytips/KeytipConstants';\n/**\n * This class is responsible for handling the parent/child relationships between keytips\n */\nvar KeytipTree = /** @class */function () {\n  /**\n   * KeytipTree constructor\n   */\n  function KeytipTree() {\n    this.nodeMap = {};\n    // Root has no keytipSequence\n    this.root = {\n      id: KTP_LAYER_ID,\n      children: [],\n      parent: '',\n      keySequences: []\n    };\n    this.nodeMap[this.root.id] = this.root;\n  }\n  /**\n   * Add a keytip node to this KeytipTree\n   *\n   * @param keytipProps - Keytip to add to the Tree\n   * @param uniqueID - Unique ID for this keytip\n   * @param persisted - T/F if this keytip should be marked as persisted\n   */\n  KeytipTree.prototype.addNode = function (keytipProps, uniqueID, persisted) {\n    var fullSequence = this._getFullSequence(keytipProps);\n    var nodeID = sequencesToID(fullSequence);\n    // Take off the last item to calculate the parent sequence\n    fullSequence.pop();\n    // Parent ID is the root if there aren't any more sequences\n    var parentID = this._getParentID(fullSequence);\n    // Create node and add to map\n    var node = this._createNode(nodeID, parentID, [], keytipProps, persisted);\n    this.nodeMap[uniqueID] = node;\n    // Try to add self to parents children, if they exist\n    var parent = this.getNode(parentID);\n    if (parent) {\n      parent.children.push(nodeID);\n    }\n  };\n  /**\n   * Updates a node in the tree\n   *\n   * @param keytipProps - Keytip props to update\n   * @param uniqueID - Unique ID for this keytip\n   */\n  KeytipTree.prototype.updateNode = function (keytipProps, uniqueID) {\n    var fullSequence = this._getFullSequence(keytipProps);\n    var nodeID = sequencesToID(fullSequence);\n    // Take off the last item to calculate the parent sequence\n    fullSequence.pop();\n    // Parent ID is the root if there aren't any more sequences\n    var parentID = this._getParentID(fullSequence);\n    var node = this.nodeMap[uniqueID];\n    var prevParent = node.parent;\n    var prevParentNode = this.getNode(prevParent);\n    var parent = this.getNode(parentID);\n    if (node) {\n      if (prevParentNode && prevParent !== parentID) {\n        // If parent has changed, remove child from old parent\n        var childIndex = prevParentNode.children.indexOf(node.id);\n        if (childIndex >= 0) {\n          prevParentNode.children.splice(childIndex, 1);\n        }\n      }\n      // If the ID of the node has changed, update node's parent's array of children with new ID\n      if (parent && node.id !== nodeID) {\n        var index = parent.children.indexOf(node.id);\n        if (index >= 0) {\n          parent.children[index] = nodeID;\n        } else {\n          parent.children.push(nodeID);\n        }\n      }\n      // Update values\n      node.id = nodeID;\n      node.keySequences = keytipProps.keySequences;\n      node.overflowSetSequence = keytipProps.overflowSetSequence;\n      node.onExecute = keytipProps.onExecute;\n      node.onReturn = keytipProps.onReturn;\n      node.hasDynamicChildren = keytipProps.hasDynamicChildren;\n      node.hasMenu = keytipProps.hasMenu;\n      node.parent = parentID;\n      node.disabled = keytipProps.disabled;\n    }\n  };\n  /**\n   * Removes a node from the KeytipTree\n   *\n   * @param sequence - full string of the node to remove\n   */\n  KeytipTree.prototype.removeNode = function (keytipProps, uniqueID) {\n    var fullSequence = this._getFullSequence(keytipProps);\n    var nodeID = sequencesToID(fullSequence);\n    // Take off the last sequence to calculate the parent ID\n    fullSequence.pop();\n    // Parent ID is the root if there aren't any more sequences\n    var parentID = this._getParentID(fullSequence);\n    var parent = this.getNode(parentID);\n    if (parent) {\n      // Remove node from its parent's children\n      parent.children.splice(parent.children.indexOf(nodeID), 1);\n    }\n    if (this.nodeMap[uniqueID]) {\n      // Remove the node from the nodeMap\n      delete this.nodeMap[uniqueID];\n    }\n  };\n  /**\n   * Searches the currentKeytip's children to exactly match a sequence. Will not match disabled nodes but\n   * will match persisted nodes\n   *\n   * @param keySequence - string to match\n   * @param currentKeytip - The keytip whose children will try to match\n   * @returns The node that exactly matched the keySequence, or undefined if none matched\n   */\n  KeytipTree.prototype.getExactMatchedNode = function (keySequence, currentKeytip) {\n    var _this = this;\n    var possibleNodes = this.getNodes(currentKeytip.children);\n    return find(possibleNodes, function (node) {\n      return _this._getNodeSequence(node) === keySequence && !node.disabled;\n    });\n  };\n  /**\n   * Searches the currentKeytip's children to find nodes that start with the given sequence. Will not match\n   * disabled nodes but will match persisted nodes\n   *\n   * @param keySequence - string to partially match\n   * @param currentKeytip - The keytip whose children will try to partially match\n   * @returns List of tree nodes that partially match the given sequence\n   */\n  KeytipTree.prototype.getPartiallyMatchedNodes = function (keySequence, currentKeytip) {\n    var _this = this;\n    // Get children that are persisted\n    var possibleNodes = this.getNodes(currentKeytip.children);\n    return possibleNodes.filter(function (node) {\n      return _this._getNodeSequence(node).indexOf(keySequence) === 0 && !node.disabled;\n    });\n  };\n  /**\n   * Get the non-persisted children of the give node\n   * If no node is given, will use the 'currentKeytip'\n   *\n   * @param node - Node to get the children for\n   * @returns List of node IDs that are the children of the node\n   */\n  KeytipTree.prototype.getChildren = function (node) {\n    var _this = this;\n    if (!node) {\n      node = this.currentKeytip;\n      if (!node) {\n        return [];\n      }\n    }\n    var children = node.children;\n    return Object.keys(this.nodeMap).reduce(function (nodes, key) {\n      if (children.indexOf(_this.nodeMap[key].id) >= 0 && !_this.nodeMap[key].persisted) {\n        nodes.push(_this.nodeMap[key].id);\n      }\n      return nodes;\n    }, []);\n  };\n  /**\n   * Gets all nodes from their IDs\n   *\n   * @param ids - List of keytip IDs\n   * @returns Array of nodes that match the given IDs, can be empty\n   */\n  KeytipTree.prototype.getNodes = function (ids) {\n    var _this = this;\n    return Object.keys(this.nodeMap).reduce(function (nodes, key) {\n      if (ids.indexOf(_this.nodeMap[key].id) >= 0) {\n        nodes.push(_this.nodeMap[key]);\n      }\n      return nodes;\n    }, []);\n  };\n  /**\n   * Gets a single node from its ID\n   *\n   * @param id - ID of the node to get\n   * @returns Node with the given ID, if found\n   */\n  KeytipTree.prototype.getNode = function (id) {\n    var nodeMapValues = values(this.nodeMap);\n    return find(nodeMapValues, function (node) {\n      return node.id === id;\n    });\n  };\n  /**\n   * Tests if the currentKeytip in this.keytipTree is the parent of 'keytipProps'\n   *\n   * @param keytipProps - Keytip to test the parent for\n   * @returns T/F if the currentKeytip is this keytipProps' parent\n   */\n  KeytipTree.prototype.isCurrentKeytipParent = function (keytipProps) {\n    if (this.currentKeytip) {\n      var fullSequence = __spreadArrays(keytipProps.keySequences);\n      if (keytipProps.overflowSetSequence) {\n        fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n      }\n      // Take off the last sequence to calculate the parent ID\n      fullSequence.pop();\n      // Parent ID is the root if there aren't any more sequences\n      var parentID = fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n      var matchesCurrWithoutOverflow = false;\n      if (this.currentKeytip.overflowSetSequence) {\n        var currKeytipIdWithoutOverflow = sequencesToID(this.currentKeytip.keySequences);\n        matchesCurrWithoutOverflow = currKeytipIdWithoutOverflow === parentID;\n      }\n      return matchesCurrWithoutOverflow || this.currentKeytip.id === parentID;\n    }\n    return false;\n  };\n  KeytipTree.prototype._getParentID = function (fullSequence) {\n    return fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n  };\n  KeytipTree.prototype._getFullSequence = function (keytipProps) {\n    var fullSequence = __spreadArrays(keytipProps.keySequences);\n    if (keytipProps.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n    }\n    return fullSequence;\n  };\n  KeytipTree.prototype._getNodeSequence = function (node) {\n    var fullSequence = __spreadArrays(node.keySequences);\n    if (node.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, node.overflowSetSequence);\n    }\n    return fullSequence[fullSequence.length - 1];\n  };\n  KeytipTree.prototype._createNode = function (id, parentId, children, keytipProps, persisted) {\n    var _this = this;\n    var keySequences = keytipProps.keySequences,\n      hasDynamicChildren = keytipProps.hasDynamicChildren,\n      overflowSetSequence = keytipProps.overflowSetSequence,\n      hasMenu = keytipProps.hasMenu,\n      onExecute = keytipProps.onExecute,\n      onReturn = keytipProps.onReturn,\n      disabled = keytipProps.disabled;\n    var node = {\n      id: id,\n      keySequences: keySequences,\n      overflowSetSequence: overflowSetSequence,\n      parent: parentId,\n      children: children,\n      onExecute: onExecute,\n      onReturn: onReturn,\n      hasDynamicChildren: hasDynamicChildren,\n      hasMenu: hasMenu,\n      disabled: disabled,\n      persisted: persisted\n    };\n    node.children = Object.keys(this.nodeMap).reduce(function (array, nodeMapKey) {\n      if (_this.nodeMap[nodeMapKey].parent === id) {\n        array.push(_this.nodeMap[nodeMapKey].id);\n      }\n      return array;\n    }, []);\n    return node;\n  };\n  return KeytipTree;\n}();\nexport { KeytipTree };","map":{"version":3,"sources":["components/KeytipLayer/KeytipTree.ts"],"names":[],"mappings":"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","sourcesContent":["import { find, values } from '../../Utilities';\nimport { IKeytipProps } from '../../Keytip';\nimport { IKeytipTreeNode } from './IKeytipTreeNode';\nimport { mergeOverflows, sequencesToID } from '../../utilities/keytips/KeytipUtils';\nimport { KTP_LAYER_ID } from '../../utilities/keytips/KeytipConstants';\n\n/**\n * This class is responsible for handling the parent/child relationships between keytips\n */\nexport class KeytipTree {\n  public currentKeytip?: IKeytipTreeNode;\n  public root: IKeytipTreeNode;\n  public nodeMap: { [nodeId: string]: IKeytipTreeNode } = {};\n\n  /**\n   * KeytipTree constructor\n   */\n  constructor() {\n    // Root has no keytipSequence\n    this.root = {\n      id: KTP_LAYER_ID,\n      children: [],\n      parent: '',\n      keySequences: [],\n    };\n    this.nodeMap[this.root.id] = this.root;\n  }\n\n  /**\n   * Add a keytip node to this KeytipTree\n   *\n   * @param keytipProps - Keytip to add to the Tree\n   * @param uniqueID - Unique ID for this keytip\n   * @param persisted - T/F if this keytip should be marked as persisted\n   */\n  public addNode(keytipProps: IKeytipProps, uniqueID: string, persisted?: boolean): void {\n    const fullSequence = this._getFullSequence(keytipProps);\n    const nodeID = sequencesToID(fullSequence);\n\n    // Take off the last item to calculate the parent sequence\n    fullSequence.pop();\n    // Parent ID is the root if there aren't any more sequences\n    const parentID = this._getParentID(fullSequence);\n\n    // Create node and add to map\n    const node = this._createNode(nodeID, parentID, [], keytipProps, persisted);\n    this.nodeMap[uniqueID] = node;\n\n    // Try to add self to parents children, if they exist\n    const parent = this.getNode(parentID);\n    if (parent) {\n      parent.children.push(nodeID);\n    }\n  }\n\n  /**\n   * Updates a node in the tree\n   *\n   * @param keytipProps - Keytip props to update\n   * @param uniqueID - Unique ID for this keytip\n   */\n  public updateNode(keytipProps: IKeytipProps, uniqueID: string): void {\n    const fullSequence = this._getFullSequence(keytipProps);\n    const nodeID = sequencesToID(fullSequence);\n\n    // Take off the last item to calculate the parent sequence\n    fullSequence.pop();\n    // Parent ID is the root if there aren't any more sequences\n    const parentID = this._getParentID(fullSequence);\n    const node = this.nodeMap[uniqueID];\n    const prevParent = node.parent;\n    const prevParentNode = this.getNode(prevParent);\n    const parent = this.getNode(parentID);\n    if (node) {\n      if (prevParentNode && prevParent !== parentID) {\n        // If parent has changed, remove child from old parent\n        const childIndex = prevParentNode.children.indexOf(node.id);\n        if (childIndex >= 0) {\n          prevParentNode.children.splice(childIndex, 1);\n        }\n      }\n      // If the ID of the node has changed, update node's parent's array of children with new ID\n      if (parent && node.id !== nodeID) {\n        const index = parent.children.indexOf(node.id);\n        if (index >= 0) {\n          parent.children[index] = nodeID;\n        } else {\n          parent.children.push(nodeID);\n        }\n      }\n      // Update values\n      node.id = nodeID;\n      node.keySequences = keytipProps.keySequences;\n      node.overflowSetSequence = keytipProps.overflowSetSequence;\n      node.onExecute = keytipProps.onExecute;\n      node.onReturn = keytipProps.onReturn;\n      node.hasDynamicChildren = keytipProps.hasDynamicChildren;\n      node.hasMenu = keytipProps.hasMenu;\n      node.parent = parentID;\n      node.disabled = keytipProps.disabled;\n    }\n  }\n\n  /**\n   * Removes a node from the KeytipTree\n   *\n   * @param sequence - full string of the node to remove\n   */\n  public removeNode(keytipProps: IKeytipProps, uniqueID: string): void {\n    const fullSequence = this._getFullSequence(keytipProps);\n    const nodeID = sequencesToID(fullSequence);\n\n    // Take off the last sequence to calculate the parent ID\n    fullSequence.pop();\n\n    // Parent ID is the root if there aren't any more sequences\n    const parentID = this._getParentID(fullSequence);\n    const parent = this.getNode(parentID);\n    if (parent) {\n      // Remove node from its parent's children\n      parent.children.splice(parent.children.indexOf(nodeID), 1);\n    }\n\n    if (this.nodeMap[uniqueID]) {\n      // Remove the node from the nodeMap\n      delete this.nodeMap[uniqueID];\n    }\n  }\n\n  /**\n   * Searches the currentKeytip's children to exactly match a sequence. Will not match disabled nodes but\n   * will match persisted nodes\n   *\n   * @param keySequence - string to match\n   * @param currentKeytip - The keytip whose children will try to match\n   * @returns The node that exactly matched the keySequence, or undefined if none matched\n   */\n  public getExactMatchedNode(keySequence: string, currentKeytip: IKeytipTreeNode): IKeytipTreeNode | undefined {\n    const possibleNodes = this.getNodes(currentKeytip.children);\n    return find(possibleNodes, (node: IKeytipTreeNode) => {\n      return this._getNodeSequence(node) === keySequence && !node.disabled;\n    });\n  }\n\n  /**\n   * Searches the currentKeytip's children to find nodes that start with the given sequence. Will not match\n   * disabled nodes but will match persisted nodes\n   *\n   * @param keySequence - string to partially match\n   * @param currentKeytip - The keytip whose children will try to partially match\n   * @returns List of tree nodes that partially match the given sequence\n   */\n  public getPartiallyMatchedNodes(keySequence: string, currentKeytip: IKeytipTreeNode): IKeytipTreeNode[] {\n    // Get children that are persisted\n    const possibleNodes = this.getNodes(currentKeytip.children);\n    return possibleNodes.filter((node: IKeytipTreeNode) => {\n      return this._getNodeSequence(node).indexOf(keySequence) === 0 && !node.disabled;\n    });\n  }\n\n  /**\n   * Get the non-persisted children of the give node\n   * If no node is given, will use the 'currentKeytip'\n   *\n   * @param node - Node to get the children for\n   * @returns List of node IDs that are the children of the node\n   */\n  public getChildren(node?: IKeytipTreeNode): string[] {\n    if (!node) {\n      node = this.currentKeytip;\n      if (!node) {\n        return [];\n      }\n    }\n    const children = node.children;\n    return Object.keys(this.nodeMap).reduce((nodes: string[], key: string): string[] => {\n      if (children.indexOf(this.nodeMap[key].id) >= 0 && !this.nodeMap[key].persisted) {\n        nodes.push(this.nodeMap[key].id);\n      }\n      return nodes;\n    }, []);\n  }\n\n  /**\n   * Gets all nodes from their IDs\n   *\n   * @param ids - List of keytip IDs\n   * @returns Array of nodes that match the given IDs, can be empty\n   */\n  public getNodes(ids: string[]): IKeytipTreeNode[] {\n    return Object.keys(this.nodeMap).reduce((nodes: IKeytipTreeNode[], key: string): IKeytipTreeNode[] => {\n      if (ids.indexOf(this.nodeMap[key].id) >= 0) {\n        nodes.push(this.nodeMap[key]);\n      }\n      return nodes;\n    }, []);\n  }\n\n  /**\n   * Gets a single node from its ID\n   *\n   * @param id - ID of the node to get\n   * @returns Node with the given ID, if found\n   */\n  public getNode(id: string): IKeytipTreeNode | undefined {\n    const nodeMapValues = values<IKeytipTreeNode>(this.nodeMap);\n    return find(nodeMapValues, (node: IKeytipTreeNode): boolean => {\n      return node.id === id;\n    });\n  }\n\n  /**\n   * Tests if the currentKeytip in this.keytipTree is the parent of 'keytipProps'\n   *\n   * @param keytipProps - Keytip to test the parent for\n   * @returns T/F if the currentKeytip is this keytipProps' parent\n   */\n  public isCurrentKeytipParent(keytipProps: IKeytipProps): boolean {\n    if (this.currentKeytip) {\n      let fullSequence = [...keytipProps.keySequences];\n      if (keytipProps.overflowSetSequence) {\n        fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n      }\n      // Take off the last sequence to calculate the parent ID\n      fullSequence.pop();\n      // Parent ID is the root if there aren't any more sequences\n      const parentID = fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n      let matchesCurrWithoutOverflow = false;\n      if (this.currentKeytip.overflowSetSequence) {\n        const currKeytipIdWithoutOverflow = sequencesToID(this.currentKeytip.keySequences);\n        matchesCurrWithoutOverflow = currKeytipIdWithoutOverflow === parentID;\n      }\n      return matchesCurrWithoutOverflow || this.currentKeytip.id === parentID;\n    }\n    return false;\n  }\n\n  private _getParentID(fullSequence: string[]): string {\n    return fullSequence.length === 0 ? this.root.id : sequencesToID(fullSequence);\n  }\n\n  private _getFullSequence(keytipProps: IKeytipProps): string[] {\n    let fullSequence = [...keytipProps.keySequences];\n    if (keytipProps.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, keytipProps.overflowSetSequence);\n    }\n    return fullSequence;\n  }\n\n  private _getNodeSequence(node: IKeytipTreeNode): string {\n    let fullSequence = [...node.keySequences];\n    if (node.overflowSetSequence) {\n      fullSequence = mergeOverflows(fullSequence, node.overflowSetSequence);\n    }\n    return fullSequence[fullSequence.length - 1];\n  }\n\n  private _createNode(\n    id: string,\n    parentId: string,\n    children: string[],\n    keytipProps: IKeytipProps,\n    persisted?: boolean,\n  ): IKeytipTreeNode {\n    const {\n      keySequences,\n      hasDynamicChildren,\n      overflowSetSequence,\n      hasMenu,\n      onExecute,\n      onReturn,\n      disabled,\n    } = keytipProps;\n    const node = {\n      id,\n      keySequences,\n      overflowSetSequence,\n      parent: parentId,\n      children,\n      onExecute,\n      onReturn,\n      hasDynamicChildren,\n      hasMenu,\n      disabled,\n      persisted,\n    };\n    node.children = Object.keys(this.nodeMap).reduce((array: string[], nodeMapKey: string): string[] => {\n      if (this.nodeMap[nodeMapKey].parent === id) {\n        array.push(this.nodeMap[nodeMapKey].id);\n      }\n      return array;\n    }, []);\n    return node;\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}