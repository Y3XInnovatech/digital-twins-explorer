{"ast":null,"code":"import { __extends } from \"tslib\";\nimport * as React from 'react';\nimport { hoistMethods, unhoistMethods } from '../../Utilities';\nvar BaseDecorator = /** @class */function (_super) {\n  __extends(BaseDecorator, _super);\n  function BaseDecorator(props) {\n    var _this = _super.call(this, props) || this;\n    _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);\n    return _this;\n  }\n  /**\n   * Updates the ref to the component composed by the decorator, which will also take care of hoisting\n   * (and unhoisting as appropriate) methods from said component.\n   *\n   * Pass this method as the argument to the 'ref' property of the composed component.\n   */\n  BaseDecorator.prototype._updateComposedComponentRef = function (composedComponentInstance) {\n    this._composedComponentInstance = composedComponentInstance;\n    if (composedComponentInstance) {\n      this._hoisted = hoistMethods(this, composedComponentInstance);\n    } else if (this._hoisted) {\n      unhoistMethods(this, this._hoisted);\n    }\n  };\n  return BaseDecorator;\n}(React.Component);\nexport { BaseDecorator };","map":{"version":3,"sources":["utilities/decorators/BaseDecorator.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAK,MAAM,OAAO;AAC9B,SAAS,YAAY,EAAE,cAAc,QAAQ,iBAAiB;AAE9D,IAAA,aAAA,GAAA,aAAA,UAAA,MAAA,EAAA;EAAmD,SAAA,CAAA,aAAA,EAAA,MAAA,CAAA;EAKjD,SAAA,aAAA,CAAY,KAAa,EAAA;IAAzB,IAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAK,CAAC,IAAA,IAAA;IACZ,KAAI,CAAC,2BAA2B,GAAG,KAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,KAAI,CAAC;;EAChF;EAEA;;;;;AAKG;EACO,aAAA,CAAA,SAAA,CAAA,2BAA2B,GAArC,UAAsC,yBAA0D,EAAA;IAC9F,IAAI,CAAC,0BAA0B,GAAG,yBAAyB;IAC3D,IAAI,yBAAyB,EAAE;MAC7B,IAAI,CAAC,QAAQ,GAAG,YAAY,CAAC,IAAI,EAAE,yBAAyB,CAAC;KAC9D,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;MACxB,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC;IACpC;EACH,CAAC;EACH,OAAA,aAAC;AAAD,CAAC,CAxBkD,KAAK,CAAC,SAAS,CAAA","sourcesContent":["import * as React from 'react';\nimport { hoistMethods, unhoistMethods } from '../../Utilities';\n\nexport class BaseDecorator<TProps, TState> extends React.Component<TProps, TState> {\n  protected _composedComponentInstance: React.Component<TProps, TState>;\n\n  private _hoisted: string[];\n\n  constructor(props: TProps) {\n    super(props);\n    this._updateComposedComponentRef = this._updateComposedComponentRef.bind(this);\n  }\n\n  /**\n   * Updates the ref to the component composed by the decorator, which will also take care of hoisting\n   * (and unhoisting as appropriate) methods from said component.\n   *\n   * Pass this method as the argument to the 'ref' property of the composed component.\n   */\n  protected _updateComposedComponentRef(composedComponentInstance: React.Component<TProps, TState>): void {\n    this._composedComponentInstance = composedComponentInstance;\n    if (composedComponentInstance) {\n      this._hoisted = hoistMethods(this, composedComponentInstance);\n    } else if (this._hoisted) {\n      unhoistMethods(this, this._hoisted);\n    }\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}