{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { TextField } from '../TextField';\nimport { initializeComponentRef, KeyCodes } from '../../../Utilities';\nimport { clearNext, clearPrev, clearRange, DEFAULT_MASK_FORMAT_CHARS, getLeftFormatIndex, getMaskDisplay, getRightFormatIndex, insertString, parseMask } from './inputMask';\nexport var DEFAULT_MASK_CHAR = '_';\nvar MaskedTextField = /** @class */function (_super) {\n  __extends(MaskedTextField, _super);\n  function MaskedTextField(props) {\n    var _this = _super.call(this, props) || this;\n    _this._textField = React.createRef();\n    _this._onFocus = function (event) {\n      if (_this.props.onFocus) {\n        _this.props.onFocus(event);\n      }\n      _this._isFocused = true;\n      // Move the cursor position to the leftmost unfilled position\n      for (var i = 0; i < _this._maskCharData.length; i++) {\n        if (!_this._maskCharData[i].value) {\n          _this.setState({\n            maskCursorPosition: _this._maskCharData[i].displayIndex\n          });\n          break;\n        }\n      }\n    };\n    _this._onBlur = function (event) {\n      if (_this.props.onBlur) {\n        _this.props.onBlur(event);\n      }\n      _this._isFocused = false;\n      _this._moveCursorOnMouseUp = true;\n    };\n    _this._onMouseDown = function (event) {\n      if (_this.props.onMouseDown) {\n        _this.props.onMouseDown(event);\n      }\n      if (!_this._isFocused) {\n        _this._moveCursorOnMouseUp = true;\n      }\n    };\n    _this._onMouseUp = function (event) {\n      if (_this.props.onMouseUp) {\n        _this.props.onMouseUp(event);\n      }\n      // Move the cursor on mouseUp after focusing the textField\n      if (_this._moveCursorOnMouseUp) {\n        _this._moveCursorOnMouseUp = false;\n        // Move the cursor position to the rightmost unfilled position\n        for (var i = 0; i < _this._maskCharData.length; i++) {\n          if (!_this._maskCharData[i].value) {\n            _this.setState({\n              maskCursorPosition: _this._maskCharData[i].displayIndex\n            });\n            break;\n          }\n        }\n      }\n    };\n    _this._onInputChange = function (ev, value) {\n      var textField = _this._textField.current;\n      if (_this._changeSelectionData === null && textField) {\n        _this._changeSelectionData = {\n          changeType: 'default',\n          selectionStart: textField.selectionStart !== null ? textField.selectionStart : -1,\n          selectionEnd: textField.selectionEnd !== null ? textField.selectionEnd : -1\n        };\n      }\n      if (!_this._changeSelectionData) {\n        return;\n      }\n      var displayValue = _this.state.displayValue;\n      // The initial value of cursorPos does not matter\n      var cursorPos = 0;\n      var _a = _this._changeSelectionData,\n        changeType = _a.changeType,\n        selectionStart = _a.selectionStart,\n        selectionEnd = _a.selectionEnd;\n      if (changeType === 'textPasted') {\n        var charsSelected = selectionEnd - selectionStart;\n        var charCount = value.length + charsSelected - displayValue.length;\n        var startPos = selectionStart;\n        var pastedString = value.substr(startPos, charCount);\n        // Clear any selected characters\n        if (charsSelected) {\n          _this._maskCharData = clearRange(_this._maskCharData, selectionStart, charsSelected);\n        }\n        cursorPos = insertString(_this._maskCharData, startPos, pastedString);\n      } else if (changeType === 'delete' || changeType === 'backspace') {\n        // isDel is true If the characters are removed LTR, otherwise RTL\n        var isDel = changeType === 'delete';\n        var charCount = selectionEnd - selectionStart;\n        if (charCount) {\n          // charCount is > 0 if range was deleted\n          _this._maskCharData = clearRange(_this._maskCharData, selectionStart, charCount);\n          cursorPos = getRightFormatIndex(_this._maskCharData, selectionStart);\n        } else {\n          // If charCount === 0, there was no selection and a single character was deleted\n          if (isDel) {\n            _this._maskCharData = clearNext(_this._maskCharData, selectionStart);\n            cursorPos = getRightFormatIndex(_this._maskCharData, selectionStart);\n          } else {\n            _this._maskCharData = clearPrev(_this._maskCharData, selectionStart);\n            cursorPos = getLeftFormatIndex(_this._maskCharData, selectionStart);\n          }\n        }\n      } else if (value.length > displayValue.length) {\n        // This case is if the user added characters\n        var charCount = value.length - displayValue.length;\n        var startPos = selectionEnd - charCount;\n        var enteredString = value.substr(startPos, charCount);\n        cursorPos = insertString(_this._maskCharData, startPos, enteredString);\n      } else if (value.length <= displayValue.length) {\n        /**\n         * This case is reached only if the user has selected a block of 1 or more\n         * characters and input a character replacing the characters they've selected.\n         */\n        var charCount = 1;\n        var selectCount = displayValue.length + charCount - value.length;\n        var startPos = selectionEnd - charCount;\n        var enteredString = value.substr(startPos, charCount);\n        // Clear the selected range\n        _this._maskCharData = clearRange(_this._maskCharData, startPos, selectCount);\n        // Insert the printed character\n        cursorPos = insertString(_this._maskCharData, startPos, enteredString);\n      }\n      _this._changeSelectionData = null;\n      var newValue = getMaskDisplay(_this.props.mask, _this._maskCharData, _this.props.maskChar);\n      _this.setState({\n        displayValue: newValue,\n        maskCursorPosition: cursorPos\n      });\n      // Perform onChange after input has been processed. Return value is expected to be the displayed text\n      if (_this.props.onChange) {\n        _this.props.onChange(ev, newValue);\n      }\n    };\n    _this._onKeyDown = function (event) {\n      var current = _this._textField.current;\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(event);\n      }\n      _this._changeSelectionData = null;\n      if (current && current.value) {\n        var keyCode = event.keyCode,\n          ctrlKey = event.ctrlKey,\n          metaKey = event.metaKey;\n        // Ignore ctrl and meta keydown\n        if (ctrlKey || metaKey) {\n          return;\n        }\n        // On backspace or delete, store the selection and the keyCode\n        if (keyCode === KeyCodes.backspace || keyCode === KeyCodes.del) {\n          var selectionStart = event.target.selectionStart;\n          var selectionEnd = event.target.selectionEnd;\n          // Check if backspace or delete press is valid.\n          if (!(keyCode === KeyCodes.backspace && selectionEnd && selectionEnd > 0) && !(keyCode === KeyCodes.del && selectionStart !== null && selectionStart < current.value.length)) {\n            return;\n          }\n          _this._changeSelectionData = {\n            changeType: keyCode === KeyCodes.backspace ? 'backspace' : 'delete',\n            selectionStart: selectionStart !== null ? selectionStart : -1,\n            selectionEnd: selectionEnd !== null ? selectionEnd : -1\n          };\n        }\n      }\n    };\n    _this._onPaste = function (event) {\n      if (_this.props.onPaste) {\n        _this.props.onPaste(event);\n      }\n      var selectionStart = event.target.selectionStart;\n      var selectionEnd = event.target.selectionEnd;\n      // Store the paste selection range\n      _this._changeSelectionData = {\n        changeType: 'textPasted',\n        selectionStart: selectionStart !== null ? selectionStart : -1,\n        selectionEnd: selectionEnd !== null ? selectionEnd : -1\n      };\n    };\n    initializeComponentRef(_this);\n    // Translate mask into charData\n    _this._maskCharData = parseMask(props.mask, props.maskFormat);\n    // If an initial value is provided, use it to populate the format chars\n    props.value !== undefined && _this.setValue(props.value);\n    _this._isFocused = false;\n    _this._moveCursorOnMouseUp = false;\n    _this.state = {\n      displayValue: getMaskDisplay(props.mask, _this._maskCharData, props.maskChar)\n    };\n    return _this;\n  }\n  MaskedTextField.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    if (newProps.mask !== this.props.mask || newProps.value !== this.props.value) {\n      this._maskCharData = parseMask(newProps.mask, newProps.maskFormat);\n      newProps.value !== undefined && this.setValue(newProps.value);\n      this.setState({\n        displayValue: getMaskDisplay(newProps.mask, this._maskCharData, newProps.maskChar)\n      });\n    }\n  };\n  MaskedTextField.prototype.componentDidUpdate = function () {\n    // Move the cursor to the start of the mask format on update\n    if (this._isFocused && this.state.maskCursorPosition !== undefined && this._textField.current) {\n      this._textField.current.setSelectionRange(this.state.maskCursorPosition, this.state.maskCursorPosition);\n    }\n  };\n  MaskedTextField.prototype.render = function () {\n    return React.createElement(TextField, __assign({}, this.props, {\n      onFocus: this._onFocus,\n      onBlur: this._onBlur,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onChange: this._onInputChange,\n      onKeyDown: this._onKeyDown,\n      onPaste: this._onPaste,\n      value: this.state.displayValue || '',\n      componentRef: this._textField\n    }));\n  };\n  Object.defineProperty(MaskedTextField.prototype, \"value\", {\n    /**\n     * @returns The value of all filled format characters or undefined if not all format characters are filled\n     */\n    get: function () {\n      var value = '';\n      for (var i = 0; i < this._maskCharData.length; i++) {\n        if (!this._maskCharData[i].value) {\n          return undefined;\n        }\n        value += this._maskCharData[i].value;\n      }\n      return value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  MaskedTextField.prototype.setValue = function (newValue) {\n    var valueIndex = 0;\n    var charDataIndex = 0;\n    while (valueIndex < newValue.length && charDataIndex < this._maskCharData.length) {\n      // Test if the next character in the new value fits the next format character\n      var testVal = newValue[valueIndex];\n      if (this._maskCharData[charDataIndex].format.test(testVal)) {\n        this._maskCharData[charDataIndex].value = testVal;\n        charDataIndex++;\n      }\n      valueIndex++;\n    }\n  };\n  MaskedTextField.prototype.focus = function () {\n    var current = this._textField.current;\n    current && current.focus();\n  };\n  MaskedTextField.prototype.blur = function () {\n    var current = this._textField.current;\n    current && current.blur();\n  };\n  MaskedTextField.prototype.select = function () {\n    var current = this._textField.current;\n    current && current.select();\n  };\n  MaskedTextField.prototype.setSelectionStart = function (value) {\n    var current = this._textField.current;\n    current && current.setSelectionStart(value);\n  };\n  MaskedTextField.prototype.setSelectionEnd = function (value) {\n    var current = this._textField.current;\n    current && current.setSelectionEnd(value);\n  };\n  MaskedTextField.prototype.setSelectionRange = function (start, end) {\n    var current = this._textField.current;\n    current && current.setSelectionRange(start, end);\n  };\n  Object.defineProperty(MaskedTextField.prototype, \"selectionStart\", {\n    get: function () {\n      var current = this._textField.current;\n      return current && current.selectionStart !== null ? current.selectionStart : -1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MaskedTextField.prototype, \"selectionEnd\", {\n    get: function () {\n      var current = this._textField.current;\n      return current && current.selectionEnd ? current.selectionEnd : -1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  MaskedTextField.defaultProps = {\n    maskChar: DEFAULT_MASK_CHAR,\n    maskFormat: DEFAULT_MASK_FORMAT_CHARS\n  };\n  return MaskedTextField;\n}(React.Component);\nexport { MaskedTextField };","map":{"version":3,"sources":["components/TextField/MaskedTextField/MaskedTextField.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { TextField } from '../TextField';\nimport { ITextField, IMaskedTextFieldProps } from '../TextField.types';\nimport { initializeComponentRef, KeyCodes } from '../../../Utilities';\n\nimport {\n  clearNext,\n  clearPrev,\n  clearRange,\n  DEFAULT_MASK_FORMAT_CHARS,\n  getLeftFormatIndex,\n  getMaskDisplay,\n  getRightFormatIndex,\n  IMaskValue,\n  insertString,\n  parseMask,\n} from './inputMask';\n\n/**\n * State for the MaskedTextField component.\n */\nexport interface IMaskedTextFieldState {\n  /**\n   * The mask string formatted with the input value.\n   * This is what is displayed inside the TextField\n   * @example\n   *  `Phone Number: 12_ - 4___`\n   */\n  displayValue: string;\n  /** The index into the rendered value of the first unfilled format character */\n  maskCursorPosition?: number;\n}\n\nexport const DEFAULT_MASK_CHAR = '_';\n\ntype InputChangeType = 'default' | 'backspace' | 'delete' | 'textPasted';\n\nexport class MaskedTextField extends React.Component<IMaskedTextFieldProps, IMaskedTextFieldState>\n  implements ITextField {\n  public static defaultProps: IMaskedTextFieldProps = {\n    maskChar: DEFAULT_MASK_CHAR,\n    maskFormat: DEFAULT_MASK_FORMAT_CHARS,\n  };\n\n  private _textField = React.createRef<ITextField>();\n\n  /**\n   *  An array of data containing information regarding the format characters,\n   *  their indices inside the display text, and their corresponding values.\n   * @example\n   * ```\n   *  [\n   *    { value: '1', displayIndex: 16, format: /[0-9]/ },\n   *    { value: '2', displayIndex: 17, format: /[0-9]/ },\n   *    { displayIndex: 18, format: /[0-9]/ },\n   *    { value: '4', displayIndex: 22, format: /[0-9]/ },\n   *    ...\n   *  ]\n   * ```\n   */\n  private _maskCharData: IMaskValue[];\n  /** True if the TextField is focused */\n  private _isFocused: boolean;\n  /** True if the TextField was not focused and it was clicked into */\n  private _moveCursorOnMouseUp: boolean;\n\n  /** The stored selection data prior to input change events. */\n  private _changeSelectionData: {\n    changeType: InputChangeType;\n    selectionStart: number;\n    selectionEnd: number;\n  } | null;\n\n  constructor(props: IMaskedTextFieldProps) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    // Translate mask into charData\n    this._maskCharData = parseMask(props.mask, props.maskFormat);\n    // If an initial value is provided, use it to populate the format chars\n    props.value !== undefined && this.setValue(props.value);\n\n    this._isFocused = false;\n    this._moveCursorOnMouseUp = false;\n\n    this.state = {\n      displayValue: getMaskDisplay(props.mask, this._maskCharData, props.maskChar),\n    };\n  }\n\n  public UNSAFE_componentWillReceiveProps(newProps: IMaskedTextFieldProps) {\n    if (newProps.mask !== this.props.mask || newProps.value !== this.props.value) {\n      this._maskCharData = parseMask(newProps.mask, newProps.maskFormat);\n      newProps.value !== undefined && this.setValue(newProps.value);\n\n      this.setState({\n        displayValue: getMaskDisplay(newProps.mask, this._maskCharData, newProps.maskChar),\n      });\n    }\n  }\n\n  public componentDidUpdate() {\n    // Move the cursor to the start of the mask format on update\n    if (this._isFocused && this.state.maskCursorPosition !== undefined && this._textField.current) {\n      this._textField.current.setSelectionRange(this.state.maskCursorPosition, this.state.maskCursorPosition);\n    }\n  }\n\n  public render() {\n    return (\n      <TextField\n        {...this.props}\n        onFocus={this._onFocus}\n        onBlur={this._onBlur}\n        onMouseDown={this._onMouseDown}\n        onMouseUp={this._onMouseUp}\n        onChange={this._onInputChange}\n        onKeyDown={this._onKeyDown}\n        onPaste={this._onPaste}\n        value={this.state.displayValue || ''}\n        componentRef={this._textField}\n      />\n    );\n  }\n\n  /**\n   * @returns The value of all filled format characters or undefined if not all format characters are filled\n   */\n  public get value(): string | undefined {\n    let value = '';\n\n    for (let i = 0; i < this._maskCharData.length; i++) {\n      if (!this._maskCharData[i].value) {\n        return undefined;\n      }\n      value += this._maskCharData[i].value;\n    }\n    return value;\n  }\n\n  public setValue(newValue: string): void {\n    let valueIndex = 0;\n    let charDataIndex = 0;\n\n    while (valueIndex < newValue.length && charDataIndex < this._maskCharData.length) {\n      // Test if the next character in the new value fits the next format character\n      const testVal = newValue[valueIndex];\n      if (this._maskCharData[charDataIndex].format.test(testVal)) {\n        this._maskCharData[charDataIndex].value = testVal;\n        charDataIndex++;\n      }\n      valueIndex++;\n    }\n  }\n\n  public focus(): void {\n    const { current } = this._textField;\n\n    current && current.focus();\n  }\n\n  public blur(): void {\n    const { current } = this._textField;\n\n    current && current.blur();\n  }\n\n  public select(): void {\n    const { current } = this._textField;\n\n    current && current.select();\n  }\n\n  public setSelectionStart(value: number): void {\n    const { current } = this._textField;\n\n    current && current.setSelectionStart(value);\n  }\n\n  public setSelectionEnd(value: number): void {\n    const { current } = this._textField;\n\n    current && current.setSelectionEnd(value);\n  }\n\n  public setSelectionRange(start: number, end: number): void {\n    const { current } = this._textField;\n    current && current.setSelectionRange(start, end);\n  }\n\n  public get selectionStart(): number | null {\n    const { current } = this._textField;\n\n    return current && current.selectionStart !== null ? current.selectionStart : -1;\n  }\n\n  public get selectionEnd(): number | null {\n    const { current } = this._textField;\n\n    return current && current.selectionEnd ? current.selectionEnd : -1;\n  }\n\n  private _onFocus = (event: React.FocusEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n    if (this.props.onFocus) {\n      this.props.onFocus(event);\n    }\n\n    this._isFocused = true;\n\n    // Move the cursor position to the leftmost unfilled position\n    for (let i = 0; i < this._maskCharData.length; i++) {\n      if (!this._maskCharData[i].value) {\n        this.setState({\n          maskCursorPosition: this._maskCharData[i].displayIndex,\n        });\n        break;\n      }\n    }\n  };\n\n  private _onBlur = (event: React.FocusEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n    if (this.props.onBlur) {\n      this.props.onBlur(event);\n    }\n\n    this._isFocused = false;\n    this._moveCursorOnMouseUp = true;\n  };\n\n  private _onMouseDown = (event: React.MouseEvent<HTMLInputElement>) => {\n    if (this.props.onMouseDown) {\n      this.props.onMouseDown(event);\n    }\n\n    if (!this._isFocused) {\n      this._moveCursorOnMouseUp = true;\n    }\n  };\n\n  private _onMouseUp = (event: React.MouseEvent<HTMLInputElement>) => {\n    if (this.props.onMouseUp) {\n      this.props.onMouseUp(event);\n    }\n\n    // Move the cursor on mouseUp after focusing the textField\n    if (this._moveCursorOnMouseUp) {\n      this._moveCursorOnMouseUp = false;\n      // Move the cursor position to the rightmost unfilled position\n      for (let i = 0; i < this._maskCharData.length; i++) {\n        if (!this._maskCharData[i].value) {\n          this.setState({\n            maskCursorPosition: this._maskCharData[i].displayIndex,\n          });\n          break;\n        }\n      }\n    }\n  };\n\n  private _onInputChange = (ev: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>, value: string) => {\n    const textField = this._textField.current;\n    if (this._changeSelectionData === null && textField) {\n      this._changeSelectionData = {\n        changeType: 'default',\n        selectionStart: textField.selectionStart !== null ? textField.selectionStart : -1,\n        selectionEnd: textField.selectionEnd !== null ? textField.selectionEnd : -1,\n      };\n    }\n    if (!this._changeSelectionData) {\n      return;\n    }\n\n    const { displayValue } = this.state;\n\n    // The initial value of cursorPos does not matter\n    let cursorPos = 0;\n    const { changeType, selectionStart, selectionEnd } = this._changeSelectionData;\n\n    if (changeType === 'textPasted') {\n      const charsSelected = selectionEnd - selectionStart;\n      const charCount = value.length + charsSelected - displayValue.length;\n      const startPos = selectionStart;\n      const pastedString = value.substr(startPos, charCount);\n\n      // Clear any selected characters\n      if (charsSelected) {\n        this._maskCharData = clearRange(this._maskCharData, selectionStart, charsSelected);\n      }\n      cursorPos = insertString(this._maskCharData, startPos, pastedString);\n    } else if (changeType === 'delete' || changeType === 'backspace') {\n      // isDel is true If the characters are removed LTR, otherwise RTL\n      const isDel = changeType === 'delete';\n      const charCount = selectionEnd - selectionStart;\n\n      if (charCount) {\n        // charCount is > 0 if range was deleted\n        this._maskCharData = clearRange(this._maskCharData, selectionStart, charCount);\n        cursorPos = getRightFormatIndex(this._maskCharData, selectionStart);\n      } else {\n        // If charCount === 0, there was no selection and a single character was deleted\n        if (isDel) {\n          this._maskCharData = clearNext(this._maskCharData, selectionStart);\n          cursorPos = getRightFormatIndex(this._maskCharData, selectionStart);\n        } else {\n          this._maskCharData = clearPrev(this._maskCharData, selectionStart);\n          cursorPos = getLeftFormatIndex(this._maskCharData, selectionStart);\n        }\n      }\n    } else if (value.length > displayValue.length) {\n      // This case is if the user added characters\n      const charCount = value.length - displayValue.length;\n      const startPos = selectionEnd - charCount;\n      const enteredString = value.substr(startPos, charCount);\n\n      cursorPos = insertString(this._maskCharData, startPos, enteredString);\n    } else if (value.length <= displayValue.length) {\n      /**\n       * This case is reached only if the user has selected a block of 1 or more\n       * characters and input a character replacing the characters they've selected.\n       */\n      const charCount = 1;\n      const selectCount = displayValue.length + charCount - value.length;\n      const startPos = selectionEnd - charCount;\n      const enteredString = value.substr(startPos, charCount);\n\n      // Clear the selected range\n      this._maskCharData = clearRange(this._maskCharData, startPos, selectCount);\n      // Insert the printed character\n      cursorPos = insertString(this._maskCharData, startPos, enteredString);\n    }\n\n    this._changeSelectionData = null;\n\n    const newValue = getMaskDisplay(this.props.mask, this._maskCharData, this.props.maskChar);\n\n    this.setState({\n      displayValue: newValue,\n      maskCursorPosition: cursorPos,\n    });\n\n    // Perform onChange after input has been processed. Return value is expected to be the displayed text\n    if (this.props.onChange) {\n      this.props.onChange(ev, newValue);\n    }\n  };\n\n  private _onKeyDown = (event: React.KeyboardEvent<HTMLInputElement>) => {\n    const { current } = this._textField;\n\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(event);\n    }\n\n    this._changeSelectionData = null;\n    if (current && current.value) {\n      const { keyCode, ctrlKey, metaKey } = event;\n\n      // Ignore ctrl and meta keydown\n      if (ctrlKey || metaKey) {\n        return;\n      }\n\n      // On backspace or delete, store the selection and the keyCode\n      if (keyCode === KeyCodes.backspace || keyCode === KeyCodes.del) {\n        const selectionStart = (event.target as HTMLInputElement).selectionStart;\n        const selectionEnd = (event.target as HTMLInputElement).selectionEnd;\n\n        // Check if backspace or delete press is valid.\n        if (\n          !(keyCode === KeyCodes.backspace && selectionEnd && selectionEnd > 0) &&\n          !(keyCode === KeyCodes.del && selectionStart !== null && selectionStart < current.value.length)\n        ) {\n          return;\n        }\n\n        this._changeSelectionData = {\n          changeType: keyCode === KeyCodes.backspace ? 'backspace' : 'delete',\n          selectionStart: selectionStart !== null ? selectionStart : -1,\n          selectionEnd: selectionEnd !== null ? selectionEnd : -1,\n        };\n      }\n    }\n  };\n\n  private _onPaste = (event: React.ClipboardEvent<HTMLInputElement>) => {\n    if (this.props.onPaste) {\n      this.props.onPaste(event);\n    }\n\n    const selectionStart = (event.target as HTMLInputElement).selectionStart;\n    const selectionEnd = (event.target as HTMLInputElement).selectionEnd;\n    // Store the paste selection range\n    this._changeSelectionData = {\n      changeType: 'textPasted',\n      selectionStart: selectionStart !== null ? selectionStart : -1,\n      selectionEnd: selectionEnd !== null ? selectionEnd : -1,\n    };\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}