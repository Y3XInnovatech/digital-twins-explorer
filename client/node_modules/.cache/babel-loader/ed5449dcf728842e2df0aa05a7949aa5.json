{"ast":null,"code":"import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\n/**\n * Counter for mounted component that uses focus rectangle.\n * We want to cleanup the listners before last component that uses focus rectangle unmounts.\n */\nvar mountCounters = new WeakMap();\nfunction setMountCounters(key, delta) {\n  var newValue;\n  var currValue = mountCounters.get(key);\n  if (currValue) {\n    newValue = currValue + delta;\n  } else {\n    newValue = 1;\n  }\n  mountCounters.set(key, newValue);\n  return newValue;\n}\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown and mousedown events. (It will only do it once per window,\n *    so it's safe to call this method multiple times.)\n * 2. When the user presses directional keyboard keys, adds the 'ms-Fabric--isFocusVisible' classname\n *    to the document body, removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user clicks a mouse button, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    document body, removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.\n */\nexport function useFocusRects(rootRef) {\n  React.useEffect(function () {\n    var _a, _b;\n    var win = getWindow((_a = rootRef) === null || _a === void 0 ? void 0 : _a.current);\n    if (!win || ((_b = win.FabricConfig) === null || _b === void 0 ? void 0 : _b.disableFocusRects) === true) {\n      return undefined;\n    }\n    var count = setMountCounters(win, 1);\n    if (count <= 1) {\n      win.addEventListener('mousedown', _onMouseDown, true);\n      win.addEventListener('pointerdown', _onPointerDown, true);\n      win.addEventListener('keydown', _onKeyDown, true);\n    }\n    return function () {\n      var _a;\n      if (!win || ((_a = win.FabricConfig) === null || _a === void 0 ? void 0 : _a.disableFocusRects) === true) {\n        return;\n      }\n      count = setMountCounters(win, -1);\n      if (count === 0) {\n        win.removeEventListener('mousedown', _onMouseDown, true);\n        win.removeEventListener('pointerdown', _onPointerDown, true);\n        win.removeEventListener('keydown', _onKeyDown, true);\n      }\n    };\n  }, [rootRef]);\n}\n/**\n * Function Component wrapper which enables calling `useFocusRects` hook.\n * Renders nothing.\n */\nexport var FocusRects = function (props) {\n  useFocusRects(props.rootRef);\n  return null;\n};\nfunction _onMouseDown(ev) {\n  setFocusVisibility(false, ev.target);\n}\nfunction _onPointerDown(ev) {\n  if (ev.pointerType !== 'mouse') {\n    setFocusVisibility(false, ev.target);\n  }\n}\nfunction _onKeyDown(ev) {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target);\n  }\n}","map":{"version":3,"sources":["useFocusRects.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\n\n/**\n * Counter for mounted component that uses focus rectangle.\n * We want to cleanup the listners before last component that uses focus rectangle unmounts.\n */\nlet mountCounters = new WeakMap<Window, number>();\n\nfunction setMountCounters(key: Window, delta: number): number {\n  let newValue;\n  const currValue = mountCounters.get(key);\n  if (currValue) {\n    newValue = currValue + delta;\n  } else {\n    newValue = 1;\n  }\n\n  mountCounters.set(key, newValue);\n  return newValue;\n}\n\ntype AppWindow = (Window & { FabricConfig?: { disableFocusRects?: boolean } }) | undefined;\n\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown and mousedown events. (It will only do it once per window,\n *    so it's safe to call this method multiple times.)\n * 2. When the user presses directional keyboard keys, adds the 'ms-Fabric--isFocusVisible' classname\n *    to the document body, removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user clicks a mouse button, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    document body, removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.\n */\nexport function useFocusRects(rootRef?: React.RefObject<HTMLElement>): void {\n  React.useEffect(() => {\n    const win = getWindow(rootRef?.current) as AppWindow;\n\n    if (!win || win.FabricConfig?.disableFocusRects === true) {\n      return undefined;\n    }\n\n    let count = setMountCounters(win, 1);\n    if (count <= 1) {\n      win.addEventListener('mousedown', _onMouseDown, true);\n      win.addEventListener('pointerdown', _onPointerDown, true);\n      win.addEventListener('keydown', _onKeyDown, true);\n    }\n\n    return () => {\n      if (!win || win.FabricConfig?.disableFocusRects === true) {\n        return;\n      }\n\n      count = setMountCounters(win, -1);\n      if (count === 0) {\n        win.removeEventListener('mousedown', _onMouseDown, true);\n        win.removeEventListener('pointerdown', _onPointerDown, true);\n        win.removeEventListener('keydown', _onKeyDown, true);\n      }\n    };\n  }, [rootRef]);\n}\n\n/**\n * Function Component wrapper which enables calling `useFocusRects` hook.\n * Renders nothing.\n */\nexport const FocusRects: React.FunctionComponent<{ rootRef?: React.RefObject<HTMLElement> }> = props => {\n  useFocusRects(props.rootRef);\n  return null;\n};\n\nfunction _onMouseDown(ev: MouseEvent): void {\n  setFocusVisibility(false, ev.target as Element);\n}\n\nfunction _onPointerDown(ev: PointerEvent): void {\n  if (ev.pointerType !== 'mouse') {\n    setFocusVisibility(false, ev.target as Element);\n  }\n}\n\nfunction _onKeyDown(ev: KeyboardEvent): void {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target as Element);\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}