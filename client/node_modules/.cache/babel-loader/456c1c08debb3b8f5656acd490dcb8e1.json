{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @description Iterable wrapper that exposes functional operations to work with arrays, maps, sets and generic iterables\n * @export\n * @class Iterable\n * @implements {Iterable<T>}\n * @template T\n */\nclass Iterable {\n  /**\n   * Creates an instance of Iterable.\n   * @param {Iterable<T>} source The source iterable to use. This can be any object that supports\n   * the {Symbol.iterator} symbol, or a function that returns an Iterable (e.g., a generator)\n   * @memberof Iterable\n   */\n  constructor(source) {\n    this.source = source;\n  }\n  [Symbol.iterator]() {\n    const src = this.source;\n    return (typeof src === 'function' ? src() : src)[Symbol.iterator]();\n  }\n  /**\n   * @description Gets the count of elements in the source iterable. The entire iterable is traversed to get the count.\n   * @returns {number} The count of elements in the source iterable.\n   * @memberof Iterable\n   */\n  count() {\n    let num = 0;\n    for (const _ of this) {\n      ++num;\n    }\n    return num;\n  }\n  /**\n   * @description Returns an iterable containing only distinct entities found in the source iterable.\n   * @returns {Iterable<T>} Iterable containing distinct entities.\n   * @memberof Iterable\n   */\n  distinct(keySelector) {\n    if (!keySelector) {\n      throw new ReferenceError(`Invalid keySelector. keySelector is ${keySelector}`);\n    }\n    const src = this;\n    return new Iterable(function* () {\n      const set = new Set();\n      let index = 0;\n      for (const item of src) {\n        const key = keySelector(item, index++);\n        if (!set.has(key)) {\n          set.add(key);\n          yield item;\n        }\n      }\n    });\n  }\n  /**\n   * @description Returns an iterable that returns only filtered elements from the source.\n   * @param {(item: T, index: number) => boolean} filter The filter to apply on the source.\n   * @returns {Iterable<T>} Iterable containing filtered entities.\n   * @memberof Iterable\n   */\n  filter(filter) {\n    if (!filter) {\n      throw new ReferenceError(`Invalid filter. filter is '${filter}'`);\n    }\n    const src = this;\n    return new Iterable(function* () {\n      let index = 0;\n      for (const item of src) {\n        if (filter(item, index++)) {\n          yield item;\n        }\n      }\n    });\n  }\n  /**\n   * @description Gets the first element from the source iterable.\n   * @param {(item: T, index: number) => boolean} [filter] Optional filter applied to find the first matching element.\n   * @returns {T} The first element from the source iterable.\n   * @memberof Iterable\n   */\n  first(filter) {\n    if (filter) {\n      let index = 0;\n      for (const item of this) {\n        if (filter(item, index++)) {\n          return item;\n        }\n      }\n      return null;\n    } else {\n      const {\n        done,\n        value\n      } = this[Symbol.iterator]().next();\n      return done ? null : value;\n    }\n  }\n  /**\n   * @description Gets an array of items from the source iterable.\n   * @returns {T[]} Array of items from the source.\n   * @memberof Iterable\n   */\n  items() {\n    return [...this];\n  }\n  /**\n   * @description Calls a callback for each item in the source and returns the returned value from the callback.\n   * @template V\n   * @param {(item: T, index: number) => V} selector The callback function to invoke for each element in the source.\n   * @returns {Iterable<V>}\n   * @memberof Iterable\n   */\n  map(selector) {\n    const src = this;\n    return new Iterable(function* () {\n      let index = 0;\n      for (const item of src) {\n        yield selector(item, index++);\n      }\n    });\n  }\n  /**\n   * @description Calls a callback for each item in the source and returns individual result values from the callback.\n   * @template V\n   * @param {(item: T, index: number) => Iterable<V>} selector The callback function to invoke for each element in the source.\n   * @returns {Iterable<V>}\n   * @memberof Iterable\n   */\n  mapMany(selector) {\n    const src = this;\n    return new Iterable(function* () {\n      let index = 0;\n      for (const item of src) {\n        yield* selector(item, index++);\n      }\n    });\n  }\n  /**\n   * @description Determines whether the supplied callback function returns true for any element in the source.\n   * @param {(item: T, index: number) => boolean} filter The callback function to invoke.\n   * @returns {boolean}\n   * @memberof Iterable\n   */\n  some(filter) {\n    let index = 0;\n    for (const item of this) {\n      if (filter(item, index++)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * @description Determines whether all elements in the source satisfy the specified test.\n   * @param {(item: T, index: number) => boolean} test The test function.\n   * @returns {boolean}\n   * @memberof Iterable\n   */\n  every(test) {\n    let index = 0;\n    for (const item of this) {\n      if (!test(item, index++)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * @description Returns a new Iterable consisting of the elements in the\n   * current object followed by that of the input argument.\n   * @param other {LibIterable<T>} An iterable\n   * @returns {Iterable<T>} a new Iterable that contains elements from both sources\n   */\n  concat(other) {\n    const src = this;\n    return new Iterable(function* () {\n      yield* src;\n      yield* other;\n    });\n  }\n  /**\n   * @description Gets an empty iterable.\n   * @static\n   * @template T The element type of the iterable.\n   * @returns {Iterable<T>}\n   * @memberof Iterable\n   */\n  static empty() {\n    return new Iterable([]);\n  }\n  /**\n   * Returns an Iterable of the specified object's keys.\n   * @param obj {any} An object\n   * @returns {Iterable<string>} The keys of the specified object.\n   */\n  static keys(obj) {\n    return new Iterable(function* () {\n      for (const key in obj) {\n        yield key;\n      }\n    });\n  }\n  /**\n   * Returns an Iterable of the specified object's values.\n   * @param obj {any} An object\n   * @returns {Iterable<any>} The values of the specified object.\n   */\n  static values(obj) {\n    return new Iterable(function* () {\n      for (const key in obj) {\n        yield obj[key];\n      }\n    });\n  }\n}\nexports.Iterable = Iterable;\nexports.default = Iterable;","map":{"version":3,"names":["Object","defineProperty","exports","value","Iterable","constructor","source","Symbol","iterator","src","count","num","_","distinct","keySelector","ReferenceError","set","Set","index","item","key","has","add","filter","first","done","next","items","map","selector","mapMany","some","every","test","concat","other","empty","keys","obj","values","default"],"sources":["/home/saharsh/Music/digital-twins-explorer/client/node_modules/jsiterable/lib/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @description Iterable wrapper that exposes functional operations to work with arrays, maps, sets and generic iterables\n * @export\n * @class Iterable\n * @implements {Iterable<T>}\n * @template T\n */\nclass Iterable {\n    /**\n     * Creates an instance of Iterable.\n     * @param {Iterable<T>} source The source iterable to use. This can be any object that supports\n     * the {Symbol.iterator} symbol, or a function that returns an Iterable (e.g., a generator)\n     * @memberof Iterable\n     */\n    constructor(source) {\n        this.source = source;\n    }\n    [Symbol.iterator]() {\n        const src = this.source;\n        return (typeof src === 'function' ? src() : src)[Symbol.iterator]();\n    }\n    /**\n     * @description Gets the count of elements in the source iterable. The entire iterable is traversed to get the count.\n     * @returns {number} The count of elements in the source iterable.\n     * @memberof Iterable\n     */\n    count() {\n        let num = 0;\n        for (const _ of this) {\n            ++num;\n        }\n        return num;\n    }\n    /**\n     * @description Returns an iterable containing only distinct entities found in the source iterable.\n     * @returns {Iterable<T>} Iterable containing distinct entities.\n     * @memberof Iterable\n     */\n    distinct(keySelector) {\n        if (!keySelector) {\n            throw new ReferenceError(`Invalid keySelector. keySelector is ${keySelector}`);\n        }\n        const src = this;\n        return new Iterable(function* () {\n            const set = new Set();\n            let index = 0;\n            for (const item of src) {\n                const key = keySelector(item, index++);\n                if (!set.has(key)) {\n                    set.add(key);\n                    yield item;\n                }\n            }\n        });\n    }\n    /**\n     * @description Returns an iterable that returns only filtered elements from the source.\n     * @param {(item: T, index: number) => boolean} filter The filter to apply on the source.\n     * @returns {Iterable<T>} Iterable containing filtered entities.\n     * @memberof Iterable\n     */\n    filter(filter) {\n        if (!filter) {\n            throw new ReferenceError(`Invalid filter. filter is '${filter}'`);\n        }\n        const src = this;\n        return new Iterable(function* () {\n            let index = 0;\n            for (const item of src) {\n                if (filter(item, index++)) {\n                    yield item;\n                }\n            }\n        });\n    }\n    /**\n     * @description Gets the first element from the source iterable.\n     * @param {(item: T, index: number) => boolean} [filter] Optional filter applied to find the first matching element.\n     * @returns {T} The first element from the source iterable.\n     * @memberof Iterable\n     */\n    first(filter) {\n        if (filter) {\n            let index = 0;\n            for (const item of this) {\n                if (filter(item, index++)) {\n                    return item;\n                }\n            }\n            return null;\n        }\n        else {\n            const { done, value } = this[Symbol.iterator]().next();\n            return done ? null : value;\n        }\n    }\n    /**\n     * @description Gets an array of items from the source iterable.\n     * @returns {T[]} Array of items from the source.\n     * @memberof Iterable\n     */\n    items() {\n        return [...this];\n    }\n    /**\n     * @description Calls a callback for each item in the source and returns the returned value from the callback.\n     * @template V\n     * @param {(item: T, index: number) => V} selector The callback function to invoke for each element in the source.\n     * @returns {Iterable<V>}\n     * @memberof Iterable\n     */\n    map(selector) {\n        const src = this;\n        return new Iterable(function* () {\n            let index = 0;\n            for (const item of src) {\n                yield selector(item, index++);\n            }\n        });\n    }\n    /**\n     * @description Calls a callback for each item in the source and returns individual result values from the callback.\n     * @template V\n     * @param {(item: T, index: number) => Iterable<V>} selector The callback function to invoke for each element in the source.\n     * @returns {Iterable<V>}\n     * @memberof Iterable\n     */\n    mapMany(selector) {\n        const src = this;\n        return new Iterable(function* () {\n            let index = 0;\n            for (const item of src) {\n                yield* selector(item, index++);\n            }\n        });\n    }\n    /**\n     * @description Determines whether the supplied callback function returns true for any element in the source.\n     * @param {(item: T, index: number) => boolean} filter The callback function to invoke.\n     * @returns {boolean}\n     * @memberof Iterable\n     */\n    some(filter) {\n        let index = 0;\n        for (const item of this) {\n            if (filter(item, index++)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * @description Determines whether all elements in the source satisfy the specified test.\n     * @param {(item: T, index: number) => boolean} test The test function.\n     * @returns {boolean}\n     * @memberof Iterable\n     */\n    every(test) {\n        let index = 0;\n        for (const item of this) {\n            if (!test(item, index++)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * @description Returns a new Iterable consisting of the elements in the\n     * current object followed by that of the input argument.\n     * @param other {LibIterable<T>} An iterable\n     * @returns {Iterable<T>} a new Iterable that contains elements from both sources\n     */\n    concat(other) {\n        const src = this;\n        return new Iterable(function* () {\n            yield* src;\n            yield* other;\n        });\n    }\n    /**\n     * @description Gets an empty iterable.\n     * @static\n     * @template T The element type of the iterable.\n     * @returns {Iterable<T>}\n     * @memberof Iterable\n     */\n    static empty() {\n        return new Iterable([]);\n    }\n    /**\n     * Returns an Iterable of the specified object's keys.\n     * @param obj {any} An object\n     * @returns {Iterable<string>} The keys of the specified object.\n     */\n    static keys(obj) {\n        return new Iterable(function* () {\n            for (const key in obj) {\n                yield key;\n            }\n        });\n    }\n    /**\n     * Returns an Iterable of the specified object's values.\n     * @param obj {any} An object\n     * @returns {Iterable<any>} The values of the specified object.\n     */\n    static values(obj) {\n        return new Iterable(function* () {\n            for (const key in obj) {\n                yield obj[key];\n            }\n        });\n    }\n}\nexports.Iterable = Iterable;\nexports.default = Iterable;\n//# sourceMappingURL=index.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}