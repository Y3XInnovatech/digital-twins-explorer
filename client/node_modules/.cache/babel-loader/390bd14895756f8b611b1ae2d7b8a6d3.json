{"ast":null,"code":"import { EventGroup, getDocument } from '../../Utilities';\nvar MOUSEDOWN_PRIMARY_BUTTON = 0; // for mouse down event we are using ev.button property, 0 means left button\nvar MOUSEMOVE_PRIMARY_BUTTON = 1; // for mouse move event we are using ev.buttons property, 1 means left button\nvar DragDropHelper = /** @class */function () {\n  function DragDropHelper(params) {\n    this._selection = params.selection;\n    this._dragEnterCounts = {};\n    this._activeTargets = {};\n    this._lastId = 0;\n    // To make this class cheap to create, which allows simplifying some logic elsewhere,\n    // only initialize the event group and global event handlers as needed.\n    this._initialized = false;\n  }\n  DragDropHelper.prototype.dispose = function () {\n    if (this._events) {\n      this._events.dispose();\n    }\n  };\n  DragDropHelper.prototype.subscribe = function (root, events, dragDropOptions) {\n    var _this = this;\n    if (!this._initialized) {\n      this._events = new EventGroup(this);\n      var doc = getDocument();\n      // clear drag data when mouse up, use capture event to ensure it will be run\n      if (doc) {\n        this._events.on(doc.body, 'mouseup', this._onMouseUp.bind(this), true);\n        this._events.on(doc, 'mouseup', this._onDocumentMouseUp.bind(this), true);\n      }\n      this._initialized = true;\n    }\n    var _a = dragDropOptions.key,\n      key = _a === void 0 ? \"\" + ++this._lastId : _a;\n    var handlers = [];\n    var onDragStart;\n    var onDragLeave;\n    var onDragEnter;\n    var onDragEnd;\n    var onDrop;\n    var onDragOver;\n    var onMouseDown;\n    var isDraggable;\n    var isDroppable;\n    var activeTarget;\n    if (dragDropOptions && root) {\n      var eventMap = dragDropOptions.eventMap,\n        context = dragDropOptions.context,\n        updateDropState_1 = dragDropOptions.updateDropState;\n      var dragDropTarget = {\n        root: root,\n        options: dragDropOptions,\n        key: key\n      };\n      isDraggable = this._isDraggable(dragDropTarget);\n      isDroppable = this._isDroppable(dragDropTarget);\n      if (isDraggable || isDroppable) {\n        if (eventMap) {\n          for (var _i = 0, eventMap_1 = eventMap; _i < eventMap_1.length; _i++) {\n            var event_1 = eventMap_1[_i];\n            var handler = {\n              callback: event_1.callback.bind(null, context),\n              eventName: event_1.eventName\n            };\n            handlers.push(handler);\n            this._events.on(root, handler.eventName, handler.callback);\n          }\n        }\n      }\n      if (isDroppable) {\n        // If the target is droppable, wire up global event listeners to track drop-related events.\n        onDragLeave = function (event) {\n          if (!event.isHandled) {\n            event.isHandled = true;\n            _this._dragEnterCounts[key]--;\n            if (_this._dragEnterCounts[key] === 0) {\n              updateDropState_1(false /* isDropping */, event);\n            }\n          }\n        };\n        onDragEnter = function (event) {\n          event.preventDefault(); // needed for IE\n          if (!event.isHandled) {\n            event.isHandled = true;\n            _this._dragEnterCounts[key]++;\n            if (_this._dragEnterCounts[key] === 1) {\n              updateDropState_1(true /* isDropping */, event);\n            }\n          }\n        };\n        onDragEnd = function (event) {\n          _this._dragEnterCounts[key] = 0;\n          updateDropState_1(false /* isDropping */, event);\n        };\n        onDrop = function (event) {\n          _this._dragEnterCounts[key] = 0;\n          updateDropState_1(false /* isDropping */, event);\n          if (dragDropOptions.onDrop) {\n            dragDropOptions.onDrop(dragDropOptions.context.data, event);\n          }\n        };\n        onDragOver = function (event) {\n          event.preventDefault();\n          if (dragDropOptions.onDragOver) {\n            dragDropOptions.onDragOver(dragDropOptions.context.data, event);\n          }\n        };\n        this._dragEnterCounts[key] = 0;\n        // dragenter and dragleave will be fired when hover to the child element\n        // but we only want to change state when enter or leave the current element\n        // use the count to ensure it.\n        events.on(root, 'dragenter', onDragEnter);\n        events.on(root, 'dragleave', onDragLeave);\n        events.on(root, 'dragend', onDragEnd);\n        events.on(root, 'drop', onDrop);\n        events.on(root, 'dragover', onDragOver);\n      }\n      if (isDraggable) {\n        // If the target is draggable, wire up local event listeners for mouse events.\n        onMouseDown = this._onMouseDown.bind(this, dragDropTarget);\n        onDragEnd = this._onDragEnd.bind(this, dragDropTarget);\n        // We need to add in data so that on Firefox we show the ghost element when dragging\n        onDragStart = function (event) {\n          var options = dragDropOptions;\n          if (options && options.onDragStart) {\n            options.onDragStart(options.context.data, options.context.index, _this._selection.getSelection(), event);\n          }\n          _this._isDragging = true;\n          if (event.dataTransfer) {\n            event.dataTransfer.setData('id', root.id);\n          }\n        };\n        events.on(root, 'dragstart', onDragStart);\n        events.on(root, 'mousedown', onMouseDown);\n        events.on(root, 'dragend', onDragEnd);\n      }\n      activeTarget = {\n        target: dragDropTarget,\n        dispose: function () {\n          if (_this._activeTargets[key] === activeTarget) {\n            delete _this._activeTargets[key];\n          }\n          if (root) {\n            for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {\n              var handler = handlers_1[_i];\n              _this._events.off(root, handler.eventName, handler.callback);\n            }\n            if (isDroppable) {\n              events.off(root, 'dragenter', onDragEnter);\n              events.off(root, 'dragleave', onDragLeave);\n              events.off(root, 'dragend', onDragEnd);\n              events.off(root, 'dragover', onDragOver);\n              events.off(root, 'drop', onDrop);\n            }\n            if (isDraggable) {\n              events.off(root, 'dragstart', onDragStart);\n              events.off(root, 'mousedown', onMouseDown);\n              events.off(root, 'dragend', onDragEnd);\n            }\n          }\n        }\n      };\n      this._activeTargets[key] = activeTarget;\n    }\n    return {\n      key: key,\n      dispose: function () {\n        if (activeTarget) {\n          activeTarget.dispose();\n        }\n      }\n    };\n  };\n  DragDropHelper.prototype.unsubscribe = function (root, key) {\n    var activeTarget = this._activeTargets[key];\n    if (activeTarget) {\n      activeTarget.dispose();\n    }\n  };\n  DragDropHelper.prototype._onDragEnd = function (target, event) {\n    var options = target.options;\n    if (options.onDragEnd) {\n      options.onDragEnd(options.context.data, event);\n    }\n  };\n  /**\n   * clear drag data when mouse up on body\n   */\n  DragDropHelper.prototype._onMouseUp = function (event) {\n    this._isDragging = false;\n    if (this._dragData) {\n      for (var _i = 0, _a = Object.keys(this._activeTargets); _i < _a.length; _i++) {\n        var key = _a[_i];\n        var activeTarget = this._activeTargets[key];\n        if (activeTarget.target.root) {\n          this._events.off(activeTarget.target.root, 'mousemove');\n          this._events.off(activeTarget.target.root, 'mouseleave');\n        }\n      }\n      if (this._dragData.dropTarget) {\n        // raise dragleave event to let dropTarget know it need to remove dropping style\n        EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');\n        EventGroup.raise(this._dragData.dropTarget.root, 'drop');\n      }\n    }\n    this._dragData = null;\n  };\n  /**\n   * clear drag data when mouse up outside of the document\n   */\n  DragDropHelper.prototype._onDocumentMouseUp = function (event) {\n    var doc = getDocument();\n    if (doc && event.target === doc.documentElement) {\n      this._onMouseUp(event);\n    }\n  };\n  /**\n   * when mouse move over a new drop target while dragging some items,\n   * fire dragleave on the old target and fire dragenter to the new target\n   * The target will handle style change on dragenter and dragleave events.\n   */\n  DragDropHelper.prototype._onMouseMove = function (target, event) {\n    var\n      // use buttons property here since ev.button in some edge case is not updating well during the move.\n      // but firefox doesn't support it, so we set the default value when it is not defined.\n      _a = event.buttons,\n      // use buttons property here since ev.button in some edge case is not updating well during the move.\n      // but firefox doesn't support it, so we set the default value when it is not defined.\n      buttons = _a === void 0 ? MOUSEMOVE_PRIMARY_BUTTON : _a;\n    if (this._dragData && buttons !== MOUSEMOVE_PRIMARY_BUTTON) {\n      // cancel mouse down event and return early when the primary button is not pressed\n      this._onMouseUp(event);\n      return;\n    }\n    var root = target.root,\n      key = target.key;\n    if (this._isDragging) {\n      if (this._isDroppable(target)) {\n        // we can have nested drop targets in the DOM, like a folder inside a group. In that case, when we drag into\n        // the inner target (folder), we first set dropTarget to the inner element. But the same event is bubbled to the\n        // outer target too, and we need to prevent the outer one from taking over.\n        // So, check if the last dropTarget is not a child of the current.\n        if (this._dragData) {\n          if (this._dragData.dropTarget && this._dragData.dropTarget.key !== key && !this._isChild(root, this._dragData.dropTarget.root)) {\n            if (this._dragEnterCounts[this._dragData.dropTarget.key] > 0) {\n              EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');\n              EventGroup.raise(root, 'dragenter');\n              this._dragData.dropTarget = target;\n            }\n          }\n        }\n      }\n    }\n  };\n  /**\n   * when mouse leave a target while dragging some items, fire dragleave to the target\n   */\n  DragDropHelper.prototype._onMouseLeave = function (target, event) {\n    if (this._isDragging) {\n      if (this._dragData && this._dragData.dropTarget && this._dragData.dropTarget.key === target.key) {\n        EventGroup.raise(target.root, 'dragleave');\n        this._dragData.dropTarget = undefined;\n      }\n    }\n  };\n  /**\n   * when mouse down on a draggable item, we start to track dragdata.\n   */\n  DragDropHelper.prototype._onMouseDown = function (target, event) {\n    if (event.button !== MOUSEDOWN_PRIMARY_BUTTON) {\n      // Ignore anything except the primary button.\n      return;\n    }\n    if (this._isDraggable(target)) {\n      this._dragData = {\n        clientX: event.clientX,\n        clientY: event.clientY,\n        eventTarget: event.target,\n        dragTarget: target\n      };\n      for (var _i = 0, _a = Object.keys(this._activeTargets); _i < _a.length; _i++) {\n        var key = _a[_i];\n        var activeTarget = this._activeTargets[key];\n        if (activeTarget.target.root) {\n          this._events.on(activeTarget.target.root, 'mousemove', this._onMouseMove.bind(this, activeTarget.target));\n          this._events.on(activeTarget.target.root, 'mouseleave', this._onMouseLeave.bind(this, activeTarget.target));\n        }\n      }\n    } else {\n      this._dragData = null;\n    }\n  };\n  /**\n   * determine whether the child target is a descendant of the parent\n   */\n  DragDropHelper.prototype._isChild = function (parentElement, childElement) {\n    while (childElement && childElement.parentElement) {\n      if (childElement.parentElement === parentElement) {\n        return true;\n      }\n      childElement = childElement.parentElement;\n    }\n    return false;\n  };\n  DragDropHelper.prototype._isDraggable = function (target) {\n    var options = target.options;\n    return !!(options.canDrag && options.canDrag(options.context.data));\n  };\n  DragDropHelper.prototype._isDroppable = function (target) {\n    // TODO: take the drag item into consideration to prevent dragging an item into the same group\n    var options = target.options;\n    var dragContext = this._dragData && this._dragData.dragTarget ? this._dragData.dragTarget.options.context : undefined;\n    return !!(options.canDrop && options.canDrop(options.context, dragContext));\n  };\n  return DragDropHelper;\n}();\nexport { DragDropHelper };","map":{"version":3,"sources":["utilities/dragdrop/DragDropHelper.tsx"],"names":[],"mappings":"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","sourcesContent":["import { EventGroup, getDocument } from '../../Utilities';\nimport { IDragDropHelper, IDragDropTarget, IDragDropOptions, IDragDropEvent, IDragDropContext } from './interfaces';\nimport { ISelection } from '../../utilities/selection/interfaces';\n\nconst MOUSEDOWN_PRIMARY_BUTTON = 0; // for mouse down event we are using ev.button property, 0 means left button\nconst MOUSEMOVE_PRIMARY_BUTTON = 1; // for mouse move event we are using ev.buttons property, 1 means left button\n\nexport interface IDragDropHelperParams {\n  selection: ISelection;\n  minimumPixelsForDrag?: number;\n}\n\nexport class DragDropHelper implements IDragDropHelper {\n  private _dragEnterCounts: { [key: string]: number };\n  private _isDragging: boolean;\n  private _dragData: {\n    eventTarget: EventTarget | null;\n    clientX: number;\n    clientY: number;\n    dataTransfer?: DataTransfer;\n    dropTarget?: IDragDropTarget;\n    dragTarget?: IDragDropTarget;\n  } | null;\n  private _selection: ISelection;\n  private _activeTargets: {\n    [key: string]: {\n      target: IDragDropTarget;\n      dispose: () => void;\n    };\n  };\n  private _events: EventGroup;\n  private _lastId: number;\n  private _initialized: boolean;\n\n  constructor(params: IDragDropHelperParams) {\n    this._selection = params.selection;\n    this._dragEnterCounts = {};\n    this._activeTargets = {};\n    this._lastId = 0;\n    // To make this class cheap to create, which allows simplifying some logic elsewhere,\n    // only initialize the event group and global event handlers as needed.\n    this._initialized = false;\n  }\n\n  public dispose(): void {\n    if (this._events) {\n      this._events.dispose();\n    }\n  }\n\n  public subscribe(\n    root: HTMLElement,\n    events: EventGroup,\n    dragDropOptions: IDragDropOptions,\n  ): {\n    key: string;\n    dispose(): void;\n  } {\n    if (!this._initialized) {\n      this._events = new EventGroup(this);\n\n      const doc = getDocument();\n\n      // clear drag data when mouse up, use capture event to ensure it will be run\n      if (doc) {\n        this._events.on(doc.body, 'mouseup', this._onMouseUp.bind(this), true);\n        this._events.on(doc, 'mouseup', this._onDocumentMouseUp.bind(this), true);\n      }\n\n      this._initialized = true;\n    }\n\n    const { key = `${++this._lastId}` } = dragDropOptions;\n\n    const handlers: {\n      callback: (context: IDragDropContext, event?: any) => void;\n      eventName: string;\n    }[] = [];\n\n    let onDragStart: (event: DragEvent) => void;\n    let onDragLeave: (event: DragEvent) => void;\n    let onDragEnter: (event: DragEvent) => void;\n    let onDragEnd: (event: DragEvent) => void;\n    let onDrop: (event: DragEvent) => void;\n    let onDragOver: (event: DragEvent) => void;\n    let onMouseDown: (event: MouseEvent) => void;\n\n    let isDraggable: boolean;\n    let isDroppable: boolean;\n\n    let activeTarget: {\n      target: IDragDropTarget;\n      dispose: () => void;\n    };\n\n    if (dragDropOptions && root) {\n      const { eventMap, context, updateDropState } = dragDropOptions;\n\n      const dragDropTarget: IDragDropTarget = {\n        root: root,\n        options: dragDropOptions,\n        key: key,\n      };\n\n      isDraggable = this._isDraggable(dragDropTarget);\n      isDroppable = this._isDroppable(dragDropTarget);\n\n      if (isDraggable || isDroppable) {\n        if (eventMap) {\n          for (const event of eventMap) {\n            const handler = {\n              callback: event.callback.bind(null, context),\n              eventName: event.eventName,\n            };\n\n            handlers.push(handler);\n\n            this._events.on(root, handler.eventName, handler.callback);\n          }\n        }\n      }\n\n      if (isDroppable) {\n        // If the target is droppable, wire up global event listeners to track drop-related events.\n        onDragLeave = (event: DragEvent) => {\n          if (!(event as IDragDropEvent).isHandled) {\n            (event as IDragDropEvent).isHandled = true;\n            this._dragEnterCounts[key]--;\n            if (this._dragEnterCounts[key] === 0) {\n              updateDropState(false /* isDropping */, event);\n            }\n          }\n        };\n\n        onDragEnter = (event: DragEvent) => {\n          event.preventDefault(); // needed for IE\n          if (!(event as IDragDropEvent).isHandled) {\n            (event as IDragDropEvent).isHandled = true;\n            this._dragEnterCounts[key]++;\n            if (this._dragEnterCounts[key] === 1) {\n              updateDropState(true /* isDropping */, event);\n            }\n          }\n        };\n\n        onDragEnd = (event: DragEvent) => {\n          this._dragEnterCounts[key] = 0;\n          updateDropState(false /* isDropping */, event);\n        };\n\n        onDrop = (event: DragEvent) => {\n          this._dragEnterCounts[key] = 0;\n          updateDropState(false /* isDropping */, event);\n\n          if (dragDropOptions.onDrop) {\n            dragDropOptions.onDrop(dragDropOptions.context.data, event);\n          }\n        };\n\n        onDragOver = (event: DragEvent) => {\n          event.preventDefault();\n          if (dragDropOptions.onDragOver) {\n            dragDropOptions.onDragOver(dragDropOptions.context.data, event);\n          }\n        };\n\n        this._dragEnterCounts[key] = 0;\n\n        // dragenter and dragleave will be fired when hover to the child element\n        // but we only want to change state when enter or leave the current element\n        // use the count to ensure it.\n        events.on(root, 'dragenter', onDragEnter);\n        events.on(root, 'dragleave', onDragLeave);\n        events.on(root, 'dragend', onDragEnd);\n        events.on(root, 'drop', onDrop);\n        events.on(root, 'dragover', onDragOver);\n      }\n\n      if (isDraggable) {\n        // If the target is draggable, wire up local event listeners for mouse events.\n        onMouseDown = this._onMouseDown.bind(this, dragDropTarget);\n        onDragEnd = this._onDragEnd.bind(this, dragDropTarget);\n\n        // We need to add in data so that on Firefox we show the ghost element when dragging\n        onDragStart = (event: DragEvent) => {\n          const options = dragDropOptions;\n          if (options && options.onDragStart) {\n            options.onDragStart(options.context.data, options.context.index, this._selection.getSelection(), event);\n          }\n          this._isDragging = true;\n          if (event.dataTransfer) {\n            event.dataTransfer.setData('id', root.id);\n          }\n        };\n\n        events.on(root, 'dragstart', onDragStart);\n        events.on(root, 'mousedown', onMouseDown);\n        events.on(root, 'dragend', onDragEnd);\n      }\n\n      activeTarget = {\n        target: dragDropTarget,\n        dispose: () => {\n          if (this._activeTargets[key] === activeTarget) {\n            delete this._activeTargets[key];\n          }\n\n          if (root) {\n            for (const handler of handlers) {\n              this._events.off(root, handler.eventName, handler.callback);\n            }\n\n            if (isDroppable) {\n              events.off(root, 'dragenter', onDragEnter);\n              events.off(root, 'dragleave', onDragLeave);\n              events.off(root, 'dragend', onDragEnd);\n              events.off(root, 'dragover', onDragOver);\n              events.off(root, 'drop', onDrop);\n            }\n\n            if (isDraggable) {\n              events.off(root, 'dragstart', onDragStart);\n              events.off(root, 'mousedown', onMouseDown);\n              events.off(root, 'dragend', onDragEnd);\n            }\n          }\n        },\n      };\n\n      this._activeTargets[key] = activeTarget;\n    }\n\n    return {\n      key: key,\n      dispose: () => {\n        if (activeTarget) {\n          activeTarget.dispose();\n        }\n      },\n    };\n  }\n\n  public unsubscribe(root: HTMLElement, key: string): void {\n    const activeTarget = this._activeTargets[key];\n\n    if (activeTarget) {\n      activeTarget.dispose();\n    }\n  }\n\n  private _onDragEnd(target: IDragDropTarget, event: DragEvent): void {\n    const { options } = target;\n    if (options.onDragEnd) {\n      options.onDragEnd(options.context.data, event);\n    }\n  }\n\n  /**\n   * clear drag data when mouse up on body\n   */\n  private _onMouseUp(event: MouseEvent): void {\n    this._isDragging = false;\n    if (this._dragData) {\n      for (const key of Object.keys(this._activeTargets)) {\n        const activeTarget = this._activeTargets[key];\n\n        if (activeTarget.target.root) {\n          this._events.off(activeTarget.target.root, 'mousemove');\n          this._events.off(activeTarget.target.root, 'mouseleave');\n        }\n      }\n\n      if (this._dragData.dropTarget) {\n        // raise dragleave event to let dropTarget know it need to remove dropping style\n        EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');\n        EventGroup.raise(this._dragData.dropTarget.root, 'drop');\n      }\n    }\n    this._dragData = null;\n  }\n\n  /**\n   * clear drag data when mouse up outside of the document\n   */\n  private _onDocumentMouseUp(event: MouseEvent): void {\n    const doc = getDocument();\n\n    if (doc && event.target === doc.documentElement) {\n      this._onMouseUp(event);\n    }\n  }\n\n  /**\n   * when mouse move over a new drop target while dragging some items,\n   * fire dragleave on the old target and fire dragenter to the new target\n   * The target will handle style change on dragenter and dragleave events.\n   */\n  private _onMouseMove(target: IDragDropTarget, event: MouseEvent): void {\n    const {\n      // use buttons property here since ev.button in some edge case is not updating well during the move.\n      // but firefox doesn't support it, so we set the default value when it is not defined.\n      buttons = MOUSEMOVE_PRIMARY_BUTTON,\n    } = event;\n\n    if (this._dragData && buttons !== MOUSEMOVE_PRIMARY_BUTTON) {\n      // cancel mouse down event and return early when the primary button is not pressed\n      this._onMouseUp(event);\n      return;\n    }\n\n    const { root, key } = target;\n    if (this._isDragging) {\n      if (this._isDroppable(target)) {\n        // we can have nested drop targets in the DOM, like a folder inside a group. In that case, when we drag into\n        // the inner target (folder), we first set dropTarget to the inner element. But the same event is bubbled to the\n        // outer target too, and we need to prevent the outer one from taking over.\n        // So, check if the last dropTarget is not a child of the current.\n\n        if (this._dragData) {\n          if (\n            this._dragData.dropTarget &&\n            this._dragData.dropTarget.key !== key &&\n            !this._isChild(root, this._dragData.dropTarget.root)\n          ) {\n            if (this._dragEnterCounts[this._dragData.dropTarget.key] > 0) {\n              EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');\n              EventGroup.raise(root, 'dragenter');\n              this._dragData.dropTarget = target;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * when mouse leave a target while dragging some items, fire dragleave to the target\n   */\n  private _onMouseLeave(target: IDragDropTarget, event: MouseEvent): void {\n    if (this._isDragging) {\n      if (this._dragData && this._dragData.dropTarget && this._dragData.dropTarget.key === target.key) {\n        EventGroup.raise(target.root, 'dragleave');\n        this._dragData.dropTarget = undefined;\n      }\n    }\n  }\n\n  /**\n   * when mouse down on a draggable item, we start to track dragdata.\n   */\n  private _onMouseDown(target: IDragDropTarget, event: MouseEvent): void {\n    if (event.button !== MOUSEDOWN_PRIMARY_BUTTON) {\n      // Ignore anything except the primary button.\n      return;\n    }\n\n    if (this._isDraggable(target)) {\n      this._dragData = {\n        clientX: event.clientX,\n        clientY: event.clientY,\n        eventTarget: event.target,\n        dragTarget: target,\n      };\n\n      for (const key of Object.keys(this._activeTargets)) {\n        const activeTarget = this._activeTargets[key];\n        if (activeTarget.target.root) {\n          this._events.on(activeTarget.target.root, 'mousemove', this._onMouseMove.bind(this, activeTarget.target));\n          this._events.on(activeTarget.target.root, 'mouseleave', this._onMouseLeave.bind(this, activeTarget.target));\n        }\n      }\n    } else {\n      this._dragData = null;\n    }\n  }\n\n  /**\n   * determine whether the child target is a descendant of the parent\n   */\n  private _isChild(parentElement: HTMLElement, childElement: HTMLElement): boolean {\n    while (childElement && childElement.parentElement) {\n      if (childElement.parentElement === parentElement) {\n        return true;\n      }\n      childElement = childElement.parentElement;\n    }\n    return false;\n  }\n\n  private _isDraggable(target: IDragDropTarget): boolean {\n    const { options } = target;\n    return !!(options.canDrag && options.canDrag(options.context.data));\n  }\n\n  private _isDroppable(target: IDragDropTarget): boolean {\n    // TODO: take the drag item into consideration to prevent dragging an item into the same group\n    const { options } = target;\n    const dragContext =\n      this._dragData && this._dragData.dragTarget ? this._dragData.dragTarget.options.context : undefined;\n    return !!(options.canDrop && options.canDrop(options.context, dragContext));\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}