{"ast":null,"code":"import { useState, useEffect } from 'react';\nimport { dU as createSeededGUID, br as createGUID, a6 as DEFAULT_REFRESH_RATE_IN_MILLISECONDS, cc as deepCopy, bk as ViewerConfigUtility, bj as __spreadArray, bl as getDebugLogger } from './Interfaces-f1972c79.js';\nimport { h as useStableGuidRng, u as useAdapter } from './StableGuidRngProvider-bd327dc7.js';\nimport { s as shouldShowVisual, h as hasBadge } from './VisualRuleUtils-25544d0d.js';\nvar useGuid = function () {\n  var stableGuidRng = useStableGuidRng();\n  var guid = useState(stableGuidRng ? createSeededGUID(stableGuidRng) : createGUID())[0];\n  return guid;\n};\nvar debugLogging = false;\nvar logDebugConsole = getDebugLogger('useRuntimeSceneData', debugLogging);\nvar useRuntimeSceneData = function (adapter, sceneId, scenesConfig, /** Optional array of layer Ids to apply SceneVisual behavior filtering */\nselectedLayerIds) {\n  if (selectedLayerIds === void 0) {\n    selectedLayerIds = null;\n  }\n  var _a = useState(''),\n    modelUrl = _a[0],\n    setModelUrl = _a[1];\n  var _b = useState(DEFAULT_REFRESH_RATE_IN_MILLISECONDS),\n    pollingInterval = _b[0],\n    setPollingInterval = _b[1];\n  var _c = useState(null),\n    lastRefreshTime = _c[0],\n    setLastRefreshTime = _c[1];\n  var _d = useState([]),\n    sceneVisuals = _d[0],\n    setSceneVisuals = _d[1];\n  var _e = useState([]),\n    sceneBadges = _e[0],\n    setSceneBadges = _e[1];\n  var sceneData = useAdapter({\n    adapterMethod: function (args) {\n      var _a;\n      setLastRefreshTime(Date.now());\n      return adapter.getSceneData(sceneId, scenesConfig, selectedLayerIds, (_a = args === null || args === void 0 ? void 0 : args.isManualRefresh) !== null && _a !== void 0 ? _a : false);\n    },\n    refetchDependencies: [sceneId, scenesConfig, selectedLayerIds],\n    isLongPolling: true,\n    pollingIntervalMillis: pollingInterval\n  });\n  /**\r\n   * After getting ADT3DViewerData (including scene visuals along with 3d model URL) from adapter, parse it to\r\n   * update the colored meshes ids based on run expressions in behaviors against the returned ADT twin property data\r\n   *  */\n  useEffect(function () {\n    var _a, _b;\n    if ((_b = (_a = sceneData === null || sceneData === void 0 ? void 0 : sceneData.adapterResult) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b.data) {\n      var sceneVisuals_1 = deepCopy(sceneData.adapterResult.result.data.sceneVisuals);\n      if (selectedLayerIds) {\n        var behaviorIdsInSelectedLayers_1 = ViewerConfigUtility.getBehaviorIdsInSelectedLayers(scenesConfig, __spreadArray([], selectedLayerIds), sceneId);\n        // Apply layer filtering to behaviors - splice out behaviors not in selected layers\n        sceneVisuals_1.forEach(function (sv) {\n          var filteredBehaviors = sv.behaviors.filter(function (b) {\n            return behaviorIdsInSelectedLayers_1.includes(b.id);\n          });\n          sv.behaviors = filteredBehaviors;\n        });\n      }\n      var twinIds_1 = new Set();\n      var badgeVisuals_1 = [];\n      // for each scene visual retrieve the colored mesh ids and update it in the scene visual\n      // if they are triggered by the element's behaviors and currently active\n      sceneVisuals_1.forEach(function (sceneVisual) {\n        var _a;\n        sceneVisual.coloredMeshItems = [];\n        for (var twinId in sceneVisual.twins) {\n          twinIds_1.add(sceneVisual.twins[twinId].$dtId);\n        }\n        (_a = sceneVisual.behaviors) === null || _a === void 0 ? void 0 : _a.forEach(function (behavior) {\n          var _a;\n          (_a = behavior.visuals) === null || _a === void 0 ? void 0 : _a.forEach(function (visual) {\n            if (!ViewerConfigUtility.isVisualRule(visual)) {\n              return;\n            }\n            visual.valueRanges.forEach(function (condition) {\n              var _a;\n              // Check if visual will be shown, then determine if it is a badge or coloring\n              if (shouldShowVisual(visual.valueRangeType, sceneVisual.twins, visual.valueExpression, condition.values)) {\n                if (hasBadge(condition)) {\n                  var badge = buildBadgeVisual(sceneVisual, behavior, condition.visual.iconName, condition.visual.color);\n                  badgeVisuals_1.push(badge);\n                } else {\n                  (_a = sceneVisual.element.objectIDs) === null || _a === void 0 ? void 0 : _a.forEach(function (meshId) {\n                    var coloredMesh = {\n                      meshId: meshId,\n                      color: condition.visual.color\n                    };\n                    sceneVisual.coloredMeshItems.push(coloredMesh);\n                  });\n                }\n              }\n            });\n          });\n        });\n      });\n      var groupedBadges_1 = [];\n      badgeVisuals_1.forEach(function (badge) {\n        // create first group\n        if (groupedBadges_1.length === 0) {\n          groupedBadges_1.push({\n            id: badge.sceneViewBadge.meshId + badge.sceneViewBadge.id,\n            element: badge.sceneVisual.element,\n            behaviors: badge.sceneVisual.behaviors,\n            twins: badge.sceneVisual.twins,\n            meshId: badge.sceneViewBadge.meshId,\n            badges: [badge.sceneViewBadge]\n          });\n        } else {\n          var group = groupedBadges_1.find(function (ga) {\n            return ga.meshId === badge.sceneViewBadge.meshId;\n          });\n          // add to existing group\n          if (group) {\n            group.id += badge.sceneViewBadge.id;\n            group.badges.push(badge.sceneViewBadge);\n          } else {\n            // create new group\n            groupedBadges_1.push({\n              id: badge.sceneViewBadge.meshId + badge.sceneViewBadge.id,\n              element: badge.sceneVisual.element,\n              behaviors: badge.sceneVisual.behaviors,\n              twins: badge.sceneVisual.twins,\n              meshId: badge.sceneViewBadge.meshId,\n              badges: [badge.sceneViewBadge]\n            });\n          }\n        }\n      });\n      // fetch the config\n      var pollingConfig = ViewerConfigUtility.getPollingConfig(scenesConfig, sceneId);\n      var computeInterval = function (twinCount, pollingConfig) {\n        var fastestPossibleRefreshRateSeconds = twinCount * 500; // 2 twin/second\n        var actualRefreshRateSeconds = pollingConfig.minimumPollingFrequency ? Math.max(fastestPossibleRefreshRateSeconds, pollingConfig.minimumPollingFrequency) : fastestPossibleRefreshRateSeconds;\n        logDebugConsole('debug', \"Computing refresh rate. FastestPossible: \" + fastestPossibleRefreshRateSeconds + \". (Twins: \" + twinCount + \") Actual: \" + actualRefreshRateSeconds + \". Config: \", pollingConfig);\n        return actualRefreshRateSeconds;\n      };\n      setPollingInterval(computeInterval(twinIds_1.size, pollingConfig));\n      setModelUrl(sceneData.adapterResult.result.data.modelUrl);\n      setSceneVisuals(sceneVisuals_1);\n      setSceneBadges(groupedBadges_1);\n    }\n  }, [pollingInterval, sceneData.adapterResult.result, sceneId, scenesConfig, selectedLayerIds]);\n  return {\n    modelUrl: modelUrl,\n    sceneVisuals: sceneVisuals,\n    sceneBadges: sceneBadges,\n    isLoading: sceneData.isLoading,\n    triggerRuntimeRefetch: function () {\n      return sceneData.callAdapter({\n        isManualRefresh: true\n      });\n    },\n    lastRefreshTime: lastRefreshTime,\n    nextRefreshTime: lastRefreshTime + pollingInterval\n  };\n};\nfunction buildBadgeVisual(sceneVisual, behavior, iconName, color) {\n  var _a;\n  var meshId = (_a = sceneVisual.element.objectIDs) === null || _a === void 0 ? void 0 : _a[0];\n  var sceneViewBadge = {\n    id: behavior.id,\n    meshId: meshId,\n    color: color,\n    icon: iconName\n  };\n  return {\n    sceneVisual: sceneVisual,\n    sceneViewBadge: sceneViewBadge\n  };\n}\nexport { useRuntimeSceneData as a, useGuid as u };","map":{"version":3,"sources":["../../src/Models/Hooks/useGuid.ts","../../src/Models/Hooks/useRuntimeSceneData.ts"],"names":[],"mappings":"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","sourcesContent":["import { useState } from 'react';\nimport { createGUID, createSeededGUID } from '../Services/Utils';\nimport { useStableGuidRng } from '../Context/StableGuidRngProvider';\n\nconst useGuid = () => {\n    const stableGuidRng = useStableGuidRng();\n    const [guid] = useState(\n        stableGuidRng ? createSeededGUID(stableGuidRng) : createGUID()\n    );\n    return guid;\n};\n\nexport default useGuid;\n","import { useEffect, useState } from 'react';\nimport {\n    CustomMeshItem,\n    RuntimeBadge,\n    SceneViewBadge,\n    SceneViewBadgeGroup,\n    SceneVisual\n} from '../Classes/SceneView.types';\nimport ViewerConfigUtility from '../Classes/ViewerConfigUtility';\nimport { DEFAULT_REFRESH_RATE_IN_MILLISECONDS } from '../Constants';\nimport { IADT3DViewerAdapter } from '../Constants/Interfaces';\nimport { deepCopy, getDebugLogger } from '../Services/Utils';\nimport { hasBadge, shouldShowVisual } from '../SharedUtils/VisualRuleUtils';\nimport {\n    I3DScenesConfig,\n    IBehavior,\n    IPollingConfiguration\n} from '../Types/Generated/3DScenesConfiguration-v1.0.0';\nimport useAdapter from './useAdapter';\n\nconst debugLogging = false;\nconst logDebugConsole = getDebugLogger('useRuntimeSceneData', debugLogging);\n\nexport const useRuntimeSceneData = (\n    adapter: IADT3DViewerAdapter,\n    sceneId: string,\n    scenesConfig: I3DScenesConfig,\n    /** Optional array of layer Ids to apply SceneVisual behavior filtering */\n    selectedLayerIds: string[] = null\n) => {\n    const [modelUrl, setModelUrl] = useState('');\n    const [pollingInterval, setPollingInterval] = useState(\n        DEFAULT_REFRESH_RATE_IN_MILLISECONDS\n    );\n    const [lastRefreshTime, setLastRefreshTime] = useState<number>(null);\n    const [sceneVisuals, setSceneVisuals] = useState<Array<SceneVisual>>([]);\n    const [sceneBadges, setSceneBadges] = useState<Array<SceneViewBadgeGroup>>(\n        []\n    );\n\n    const sceneData = useAdapter({\n        adapterMethod: (args?: { isManualRefresh: boolean }) => {\n            setLastRefreshTime(Date.now());\n            return adapter.getSceneData(\n                sceneId,\n                scenesConfig,\n                selectedLayerIds,\n                args?.isManualRefresh ?? false\n            );\n        },\n        refetchDependencies: [sceneId, scenesConfig, selectedLayerIds],\n        isLongPolling: true,\n        pollingIntervalMillis: pollingInterval\n    });\n\n    /**\n     * After getting ADT3DViewerData (including scene visuals along with 3d model URL) from adapter, parse it to\n     * update the colored meshes ids based on run expressions in behaviors against the returned ADT twin property data\n     *  */\n    useEffect(() => {\n        if (sceneData?.adapterResult?.result?.data) {\n            const sceneVisuals = deepCopy(\n                sceneData.adapterResult.result.data.sceneVisuals\n            );\n\n            if (selectedLayerIds) {\n                const behaviorIdsInSelectedLayers = ViewerConfigUtility.getBehaviorIdsInSelectedLayers(\n                    scenesConfig,\n                    [...selectedLayerIds],\n                    sceneId\n                );\n\n                // Apply layer filtering to behaviors - splice out behaviors not in selected layers\n                sceneVisuals.forEach((sv) => {\n                    const filteredBehaviors = sv.behaviors.filter((b) =>\n                        behaviorIdsInSelectedLayers.includes(b.id)\n                    );\n                    sv.behaviors = filteredBehaviors;\n                });\n            }\n\n            const twinIds = new Set<string>();\n            const badgeVisuals: Array<{\n                sceneVisual: SceneVisual;\n                sceneViewBadge: SceneViewBadge;\n            }> = [];\n            // for each scene visual retrieve the colored mesh ids and update it in the scene visual\n            // if they are triggered by the element's behaviors and currently active\n            sceneVisuals.forEach((sceneVisual) => {\n                sceneVisual.coloredMeshItems = [];\n\n                for (const twinId in sceneVisual.twins) {\n                    twinIds.add(sceneVisual.twins[twinId].$dtId);\n                }\n\n                sceneVisual.behaviors?.forEach((behavior) => {\n                    behavior.visuals?.forEach((visual) => {\n                        if (!ViewerConfigUtility.isVisualRule(visual)) {\n                            return;\n                        }\n\n                        visual.valueRanges.forEach((condition) => {\n                            // Check if visual will be shown, then determine if it is a badge or coloring\n                            if (\n                                shouldShowVisual(\n                                    visual.valueRangeType,\n                                    sceneVisual.twins,\n                                    visual.valueExpression,\n                                    condition.values\n                                )\n                            ) {\n                                if (hasBadge(condition)) {\n                                    const badge = buildBadgeVisual(\n                                        sceneVisual,\n                                        behavior,\n                                        condition.visual.iconName,\n                                        condition.visual.color\n                                    );\n                                    badgeVisuals.push(badge);\n                                } else {\n                                    sceneVisual.element.objectIDs?.forEach(\n                                        (meshId) => {\n                                            const coloredMesh: CustomMeshItem = {\n                                                meshId: meshId,\n                                                color: condition.visual.color\n                                            };\n                                            sceneVisual.coloredMeshItems.push(\n                                                coloredMesh\n                                            );\n                                        }\n                                    );\n                                }\n                            }\n                        });\n                    });\n                });\n            });\n\n            const groupedBadges: SceneViewBadgeGroup[] = [];\n\n            badgeVisuals.forEach((badge) => {\n                // create first group\n                if (groupedBadges.length === 0) {\n                    groupedBadges.push({\n                        id:\n                            badge.sceneViewBadge.meshId +\n                            badge.sceneViewBadge.id,\n                        element: badge.sceneVisual.element,\n                        behaviors: badge.sceneVisual.behaviors,\n                        twins: badge.sceneVisual.twins,\n                        meshId: badge.sceneViewBadge.meshId,\n                        badges: [badge.sceneViewBadge]\n                    });\n                } else {\n                    const group = groupedBadges.find(\n                        (ga) => ga.meshId === badge.sceneViewBadge.meshId\n                    );\n\n                    // add to existing group\n                    if (group) {\n                        group.id += badge.sceneViewBadge.id;\n                        group.badges.push(badge.sceneViewBadge);\n                    } else {\n                        // create new group\n                        groupedBadges.push({\n                            id:\n                                badge.sceneViewBadge.meshId +\n                                badge.sceneViewBadge.id,\n                            element: badge.sceneVisual.element,\n                            behaviors: badge.sceneVisual.behaviors,\n                            twins: badge.sceneVisual.twins,\n                            meshId: badge.sceneViewBadge.meshId,\n                            badges: [badge.sceneViewBadge]\n                        });\n                    }\n                }\n            });\n\n            // fetch the config\n            const pollingConfig = ViewerConfigUtility.getPollingConfig(\n                scenesConfig,\n                sceneId\n            );\n\n            const computeInterval = (\n                twinCount: number,\n                pollingConfig: IPollingConfiguration\n            ) => {\n                const fastestPossibleRefreshRateSeconds = twinCount * 500; // 2 twin/second\n                const actualRefreshRateSeconds = pollingConfig.minimumPollingFrequency\n                    ? Math.max(\n                          fastestPossibleRefreshRateSeconds,\n                          pollingConfig.minimumPollingFrequency\n                      )\n                    : fastestPossibleRefreshRateSeconds;\n                logDebugConsole(\n                    'debug',\n                    `Computing refresh rate. FastestPossible: ${fastestPossibleRefreshRateSeconds}. (Twins: ${twinCount}) Actual: ${actualRefreshRateSeconds}. Config: `,\n                    pollingConfig\n                );\n                return actualRefreshRateSeconds;\n            };\n\n            setPollingInterval(computeInterval(twinIds.size, pollingConfig));\n            setModelUrl(sceneData.adapterResult.result.data.modelUrl);\n            setSceneVisuals(sceneVisuals);\n            setSceneBadges(groupedBadges);\n        }\n    }, [\n        pollingInterval,\n        sceneData.adapterResult.result,\n        sceneId,\n        scenesConfig,\n        selectedLayerIds\n    ]);\n\n    return {\n        modelUrl,\n        sceneVisuals,\n        sceneBadges,\n        isLoading: sceneData.isLoading,\n        triggerRuntimeRefetch: () =>\n            sceneData.callAdapter({ isManualRefresh: true }),\n        lastRefreshTime: lastRefreshTime,\n        nextRefreshTime: lastRefreshTime + pollingInterval\n    };\n};\n\nfunction buildBadgeVisual(\n    sceneVisual: SceneVisual,\n    behavior: IBehavior,\n    iconName: string,\n    color: string\n): { sceneVisual: SceneVisual; sceneViewBadge: RuntimeBadge } {\n    const meshId = sceneVisual.element.objectIDs?.[0];\n\n    const sceneViewBadge: RuntimeBadge = {\n        id: behavior.id,\n        meshId: meshId,\n        color: color,\n        icon: iconName\n    };\n\n    return {\n        sceneVisual: sceneVisual,\n        sceneViewBadge: sceneViewBadge\n    };\n}\n\nexport default useRuntimeSceneData;\n"]},"metadata":{},"sourceType":"module"}