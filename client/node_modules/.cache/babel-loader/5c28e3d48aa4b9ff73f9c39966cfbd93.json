{"ast":null,"code":"import { __assign, __decorate, __extends, __spreadArrays } from \"tslib\";\nimport * as React from 'react';\nimport { ContextualMenuItemType } from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, FocusZoneTabbableElements } from '../../FocusZone';\nimport { divProperties, getNativeProps, shallowCompare, warnDeprecations, Async, EventGroup, assign, classNamesFunction, css, getDocument, getFirstFocusable, getId, getLastFocusable, getRTL, getWindow, KeyCodes, shouldWrapFocus, isIOS, isMac, initializeComponentRef, memoizeFunction } from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { withResponsiveMode, ResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { Callout } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport { ContextualMenuSplitButton, ContextualMenuButton, ContextualMenuAnchor } from './ContextualMenuItemWrapper/index';\nimport { concatStyleSetsWithProps } from '../../Styling';\nimport { getItemStyles } from './ContextualMenu.classNames';\nvar getClassNames = classNamesFunction();\nvar getContextualMenuItemClassNames = classNamesFunction();\nexport function getSubmenuItems(item) {\n  return item.subMenuProps ? item.subMenuProps.items : item.items;\n}\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\nexport function canAnyMenuItemsCheck(items) {\n  return items.some(function (item) {\n    if (item.canCheck) {\n      return true;\n    }\n    // If the item is a section, check if any of the items in the section can check.\n    if (item.sectionProps && item.sectionProps.items.some(function (submenuItem) {\n      return submenuItem.canCheck === true;\n    })) {\n      return true;\n    }\n    return false;\n  });\n}\nvar NavigationIdleDelay = 250; /* ms */\nvar COMPONENT_NAME = 'ContextualMenu';\nvar _getMenuItemStylesFunction = memoizeFunction(function () {\n  var styles = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    styles[_i] = arguments[_i];\n  }\n  return function (styleProps) {\n    return concatStyleSetsWithProps.apply(void 0, __spreadArrays([styleProps, getItemStyles], styles));\n  };\n});\nvar ContextualMenuBase = /** @class */function (_super) {\n  __extends(ContextualMenuBase, _super);\n  function ContextualMenuBase(props) {\n    var _this = _super.call(this, props) || this;\n    _this._mounted = false;\n    _this.dismiss = function (ev, dismissAll) {\n      var onDismiss = _this.props.onDismiss;\n      if (onDismiss) {\n        onDismiss(ev, dismissAll);\n      }\n    };\n    _this._tryFocusPreviousActiveElement = function (options) {\n      if (_this.props.onRestoreFocus) {\n        _this.props.onRestoreFocus(options);\n      } else {\n        if (options && options.containsFocus && _this._previousActiveElement) {\n          // Make sure that the focus method actually exists\n          // In some cases the object might exist but not be a real element.\n          // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n          if (_this._previousActiveElement.focus) {\n            _this._previousActiveElement.focus();\n          }\n        }\n      }\n    };\n    _this._onRenderMenuList = function (menuListProps, defaultRender) {\n      var indexCorrection = 0;\n      var items = menuListProps.items,\n        totalItemCount = menuListProps.totalItemCount,\n        hasCheckmarks = menuListProps.hasCheckmarks,\n        hasIcons = menuListProps.hasIcons,\n        role = menuListProps.role;\n      return React.createElement(\"ul\", {\n        className: _this._classNames.list,\n        onKeyDown: _this._onKeyDown,\n        onKeyUp: _this._onKeyUp,\n        role: role !== null && role !== void 0 ? role : 'menu'\n      }, items.map(function (item, index) {\n        var menuItem = _this._renderMenuItem(item, index, indexCorrection, totalItemCount, hasCheckmarks, hasIcons);\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          var indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          indexCorrection += indexIncrease;\n        }\n        return menuItem;\n      }));\n    };\n    /**\n     * !!!IMPORTANT!!! Avoid mutating `item: IContextualMenuItem` argument. It will\n     * cause the menu items to always re-render because the component update is based on shallow comparison.\n     */\n    _this._renderMenuItem = function (item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n      var _a;\n      var renderedItems = [];\n      var iconProps = item.iconProps || {\n        iconName: 'None'\n      };\n      var getItemClassNames = item.getItemClassNames,\n        // eslint-disable-line deprecation/deprecation\n        itemProps = item.itemProps;\n      var styles = itemProps ? itemProps.styles : undefined;\n      // We only send a dividerClassName when the item to be rendered is a divider.\n      // For all other cases, the default divider style is used.\n      var dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n      var subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : '';\n      // eslint-disable-next-line deprecation/deprecation\n      var itemClassNames;\n      // IContextualMenuItem#getItemClassNames for backwards compatibility\n      // otherwise uses mergeStyles for class names.\n      if (getItemClassNames) {\n        itemClassNames = getItemClassNames(_this.props.theme, isItemDisabled(item), _this.state.expandedMenuItemKey === item.key, !!getIsChecked(item), !!item.href, iconProps.iconName !== 'None', item.className, dividerClassName, iconProps.className, subMenuIconClassName, item.primaryDisabled);\n      } else {\n        var itemStyleProps = {\n          theme: _this.props.theme,\n          disabled: isItemDisabled(item),\n          expanded: _this.state.expandedMenuItemKey === item.key,\n          checked: !!getIsChecked(item),\n          isAnchorLink: !!item.href,\n          knownIcon: iconProps.iconName !== 'None',\n          itemClassName: item.className,\n          dividerClassName: dividerClassName,\n          iconClassName: iconProps.className,\n          subMenuClassName: subMenuIconClassName,\n          primaryDisabled: item.primaryDisabled\n        };\n        // We need to generate default styles then override if styles are provided\n        // since the ContextualMenu currently handles item classNames.\n        itemClassNames = getContextualMenuItemClassNames(_getMenuItemStylesFunction((_a = _this._classNames.subComponentStyles) === null || _a === void 0 ? void 0 : _a.menuItem, styles), itemStyleProps);\n      }\n      // eslint-disable-next-line deprecation/deprecation\n      if (item.text === '-' || item.name === '-') {\n        item.itemType = ContextualMenuItemType.Divider;\n      }\n      switch (item.itemType) {\n        case ContextualMenuItemType.Divider:\n          renderedItems.push(_this._renderSeparator(index, itemClassNames));\n          break;\n        case ContextualMenuItemType.Header:\n          renderedItems.push(_this._renderSeparator(index, itemClassNames));\n          var headerItem = _this._renderHeaderMenuItem(item, itemClassNames, index, hasCheckmarks, hasIcons);\n          renderedItems.push(_this._renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n          break;\n        case ContextualMenuItemType.Section:\n          renderedItems.push(_this._renderSectionItem(item, itemClassNames, index, hasCheckmarks, hasIcons));\n          break;\n        default:\n          var menuItem = _this._renderNormalItem(item, itemClassNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n          renderedItems.push(_this._renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n          break;\n      }\n      // Since multiple nodes *could* be rendered, wrap them all in a fragment with this item's key.\n      // This ensures the reconciler handles multi-item output per-node correctly and does not re-mount content.\n      return React.createElement(React.Fragment, {\n        key: item.key\n      }, renderedItems);\n    };\n    _this._defaultMenuItemRenderer = function (item) {\n      var index = item.index,\n        focusableElementIndex = item.focusableElementIndex,\n        totalItemCount = item.totalItemCount,\n        hasCheckmarks = item.hasCheckmarks,\n        hasIcons = item.hasIcons;\n      return _this._renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n    };\n    _this._onKeyDown = function (ev) {\n      // Take note if we are processing an alt (option) or meta (command) keydown.\n      // See comment in _shouldHandleKeyUp for reasoning.\n      _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev);\n      // On Mac, pressing escape dismisses all levels of native context menus\n      var dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n      return _this._keyHandler(ev, _this._shouldHandleKeyDown, dismissAllMenus);\n    };\n    _this._shouldHandleKeyDown = function (ev) {\n      return ev.which === KeyCodes.escape || _this._shouldCloseSubMenu(ev) || ev.which === KeyCodes.up && (ev.altKey || ev.metaKey);\n    };\n    _this._onMenuFocusCapture = function (ev) {\n      if (_this.props.delayUpdateFocusOnHover) {\n        _this._shouldUpdateFocusOnMouseEvent = true;\n      }\n    };\n    _this._onKeyUp = function (ev) {\n      return _this._keyHandler(ev, _this._shouldHandleKeyUp, true /* dismissAllMenus */);\n    };\n    /**\n     * We close the menu on key up only if ALL of the following are true:\n     * - Most recent key down was alt or meta (command)\n     * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n     *   expand/collapse the menu)\n     * - We're not on a Mac (or iOS)\n     *\n     * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n     * closing any open context menus. There is not a similar behavior on Macs.\n     */\n    _this._shouldHandleKeyUp = function (ev) {\n      var keyPressIsAltOrMetaAlone = _this._lastKeyDownWasAltOrMeta && _this._isAltOrMeta(ev);\n      _this._lastKeyDownWasAltOrMeta = false;\n      return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n    };\n    /**\n     * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n     * if so, stops event propagation and dismisses menu(s).\n     * @param ev - The keyboard event.\n     * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n     * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n     * Only does anything if `shouldHandleKey` returns true.\n     * @returns Whether the event was handled.\n     */\n    _this._keyHandler = function (ev, shouldHandleKey, dismissAllMenus) {\n      var handled = false;\n      if (shouldHandleKey(ev)) {\n        _this._focusingPreviousElement = true;\n        _this.dismiss(ev, dismissAllMenus);\n        ev.preventDefault();\n        ev.stopPropagation();\n        handled = true;\n      }\n      return handled;\n    };\n    /**\n     * Checks if the submenu should be closed\n     */\n    _this._shouldCloseSubMenu = function (ev) {\n      var submenuCloseKey = getRTL(_this.props.theme) ? KeyCodes.right : KeyCodes.left;\n      if (ev.which !== submenuCloseKey || !_this.props.isSubMenu) {\n        return false;\n      }\n      return _this._adjustedFocusZoneProps.direction === FocusZoneDirection.vertical || !!_this._adjustedFocusZoneProps.checkForNoWrap && !shouldWrapFocus(ev.target, 'data-no-horizontal-wrap');\n    };\n    _this._onMenuKeyDown = function (ev) {\n      // Mark as handled if onKeyDown returns true (for handling collapse cases)\n      // or if we are attempting to expand a submenu\n      var handled = _this._onKeyDown(ev);\n      if (handled || !_this._host) {\n        return;\n      }\n      // If we have a modifier key being pressed, we do not want to move focus.\n      // Otherwise, handle up and down keys.\n      var hasModifier = !!(ev.altKey || ev.metaKey);\n      var isUp = ev.which === KeyCodes.up;\n      var isDown = ev.which === KeyCodes.down;\n      if (!hasModifier && (isUp || isDown)) {\n        var elementToFocus = isUp ? getLastFocusable(_this._host, _this._host.lastChild, true) : getFirstFocusable(_this._host, _this._host.firstChild, true);\n        if (elementToFocus) {\n          elementToFocus.focus();\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n    /**\n     * Scroll handler for the callout to make sure the mouse events\n     * for updating focus are not interacting during scroll\n     */\n    _this._onScroll = function () {\n      if (!_this._isScrollIdle && _this._scrollIdleTimeoutId !== undefined) {\n        _this._async.clearTimeout(_this._scrollIdleTimeoutId);\n        _this._scrollIdleTimeoutId = undefined;\n      } else {\n        _this._isScrollIdle = false;\n      }\n      _this._scrollIdleTimeoutId = _this._async.setTimeout(function () {\n        _this._isScrollIdle = true;\n      }, NavigationIdleDelay);\n    };\n    _this._onItemMouseEnterBase = function (item, ev, target) {\n      if (_this._shouldIgnoreMouseEvent()) {\n        return;\n      }\n      _this._updateFocusOnMouseEvent(item, ev, target);\n    };\n    _this._onItemMouseMoveBase = function (item, ev, target) {\n      var targetElement = ev.currentTarget;\n      // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n      if (_this._shouldUpdateFocusOnMouseEvent) {\n        _this._gotMouseMove = true;\n      } else {\n        return;\n      }\n      if (!_this._isScrollIdle || _this._enterTimerId !== undefined || targetElement === _this._targetWindow.document.activeElement) {\n        return;\n      }\n      _this._updateFocusOnMouseEvent(item, ev, target);\n    };\n    _this._onMouseItemLeave = function (item, ev) {\n      if (_this._shouldIgnoreMouseEvent()) {\n        return;\n      }\n      if (_this._enterTimerId !== undefined) {\n        _this._async.clearTimeout(_this._enterTimerId);\n        _this._enterTimerId = undefined;\n      }\n      if (_this.state.expandedMenuItemKey !== undefined) {\n        return;\n      }\n      /**\n       * IE11 focus() method forces parents to scroll to top of element.\n       * Edge and IE expose a setActive() function for focusable divs that\n       * sets the page focus but does not scroll the parent element.\n       */\n      if (_this._host.setActive) {\n        try {\n          _this._host.setActive();\n        } catch (e) {\n          /* no-op */\n        }\n      } else {\n        _this._host.focus();\n      }\n    };\n    _this._onItemMouseDown = function (item, ev) {\n      if (item.onMouseDown) {\n        item.onMouseDown(item, ev);\n      }\n    };\n    _this._onItemClick = function (item, ev) {\n      _this._onItemClickBase(item, ev, ev.currentTarget);\n    };\n    _this._onItemClickBase = function (item, ev, target) {\n      var items = getSubmenuItems(item);\n      // Cancel a async menu item hover timeout action from being taken and instead\n      // just trigger the click event instead.\n      _this._cancelSubMenuTimer();\n      if (!hasSubmenu(item) && (!items || !items.length)) {\n        // This is an item without a menu. Click it.\n        _this._executeItemClick(item, ev);\n      } else {\n        if (item.key !== _this.state.expandedMenuItemKey) {\n          // This has a collapsed sub menu. Expand it.\n          _this.setState({\n            // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n            // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n            // between a real click event and a keypress event (detail should be the number of mouse clicks).\n            // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n            // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n            // and \"\" for pressing \"Enter\" with Narrator on.\n            expandedByMouseClick: ev.nativeEvent.detail !== 0 || ev.nativeEvent.pointerType === 'mouse'\n          });\n          _this._onItemSubMenuExpand(item, target);\n        }\n      }\n      ev.stopPropagation();\n      ev.preventDefault();\n    };\n    _this._onAnchorClick = function (item, ev) {\n      _this._executeItemClick(item, ev);\n      ev.stopPropagation();\n    };\n    _this._executeItemClick = function (item, ev) {\n      if (item.disabled || item.isDisabled) {\n        return;\n      }\n      var dismiss = false;\n      if (item.onClick) {\n        dismiss = !!item.onClick(ev, item);\n      } else if (_this.props.onItemClick) {\n        dismiss = !!_this.props.onItemClick(ev, item);\n      }\n      if (dismiss || !ev.defaultPrevented) {\n        _this.dismiss(ev, true);\n        // This should be removed whenever possible.\n        // This ensures that the hidden dismissal action maintains the same behavior.\n        // If the menu is being dismissed then the previously focused element should\n        // get focused since the dismiss was triggered by a user click on an item\n        // Rather than focus being lost.\n        _this._focusingPreviousElement = true;\n      }\n    };\n    _this._onItemKeyDown = function (item, ev) {\n      var openKey = getRTL(_this.props.theme) ? KeyCodes.left : KeyCodes.right;\n      if (!item.disabled && (ev.which === openKey || ev.which === KeyCodes.enter || ev.which === KeyCodes.down && (ev.altKey || ev.metaKey))) {\n        _this.setState({\n          expandedByMouseClick: false\n        });\n        _this._onItemSubMenuExpand(item, ev.currentTarget);\n        ev.preventDefault();\n      }\n    };\n    // Cancel a async menu item hover timeout action from being taken and instead\n    // do new upcoming behavior\n    _this._cancelSubMenuTimer = function () {\n      if (_this._enterTimerId !== undefined) {\n        _this._async.clearTimeout(_this._enterTimerId);\n        _this._enterTimerId = undefined;\n      }\n    };\n    _this._onItemSubMenuExpand = function (item, target) {\n      if (_this.state.expandedMenuItemKey !== item.key) {\n        if (_this.state.expandedMenuItemKey) {\n          _this._onSubMenuDismiss();\n        }\n        // Focus the target to ensure when we close it, we're focusing on the correct element.\n        target.focus();\n        _this.setState({\n          expandedMenuItemKey: item.key,\n          submenuTarget: target\n        });\n      }\n    };\n    /**\n     * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n     * after the component is unmounted. The _mounted property is added to prevent\n     * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n     * code.\n     */\n    _this._onSubMenuDismiss = function (ev, dismissAll) {\n      if (dismissAll) {\n        _this.dismiss(ev, dismissAll);\n      } else if (_this._mounted) {\n        _this.setState({\n          dismissedMenuItemKey: _this.state.expandedMenuItemKey,\n          expandedMenuItemKey: undefined,\n          submenuTarget: undefined\n        });\n      }\n    };\n    _this._getSubMenuId = function (item) {\n      var subMenuId = _this.state.subMenuId;\n      if (item.subMenuProps && item.subMenuProps.id) {\n        subMenuId = item.subMenuProps.id;\n      }\n      return subMenuId;\n    };\n    _this._onPointerAndTouchEvent = function (ev) {\n      _this._cancelSubMenuTimer();\n    };\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    initializeComponentRef(_this);\n    warnDeprecations(COMPONENT_NAME, props, {\n      getMenuClassNames: 'styles'\n    });\n    _this.state = {\n      contextualMenuItems: undefined,\n      subMenuId: getId('ContextualMenu')\n    };\n    _this._id = props.id || getId('ContextualMenu');\n    _this._focusingPreviousElement = false;\n    _this._isScrollIdle = true;\n    _this._shouldUpdateFocusOnMouseEvent = !_this.props.delayUpdateFocusOnHover;\n    _this._gotMouseMove = false;\n    return _this;\n  }\n  ContextualMenuBase.prototype.shouldComponentUpdate = function (newProps, newState) {\n    if (!newProps.shouldUpdateWhenHidden && this.props.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return false;\n    }\n    return !shallowCompare(this.props, newProps) || !shallowCompare(this.state, newState);\n  };\n  ContextualMenuBase.prototype.UNSAFE_componentWillUpdate = function (newProps) {\n    if (newProps.target !== this.props.target) {\n      var newTarget = newProps.target;\n      this._setTargetWindowAndElement(newTarget);\n    }\n    if (this._isHidden(newProps) !== this._isHidden(this.props)) {\n      if (this._isHidden(newProps)) {\n        this._onMenuClosed();\n      } else {\n        this._onMenuOpened();\n        this._previousActiveElement = this._targetWindow ? this._targetWindow.document.activeElement : undefined;\n      }\n    }\n    if (newProps.delayUpdateFocusOnHover !== this.props.delayUpdateFocusOnHover) {\n      // update shouldUpdateFocusOnMouseEvent to follow what was passed in\n      this._shouldUpdateFocusOnMouseEvent = !newProps.delayUpdateFocusOnHover;\n      // If shouldUpdateFocusOnMouseEvent is false, we need to reset gotMouseMove to false\n      this._gotMouseMove = this._shouldUpdateFocusOnMouseEvent && this._gotMouseMove;\n    }\n  };\n  // Invoked once, both on the client and server, immediately before the initial rendering occurs.\n  ContextualMenuBase.prototype.UNSAFE_componentWillMount = function () {\n    var target = this.props.target;\n    this._setTargetWindowAndElement(target);\n    if (!this.props.hidden) {\n      this._previousActiveElement = this._targetWindow ? this._targetWindow.document.activeElement : undefined;\n    }\n  };\n  // Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.\n  ContextualMenuBase.prototype.componentDidMount = function () {\n    if (!this.props.hidden) {\n      this._onMenuOpened();\n    }\n    this._mounted = true;\n  };\n  // Invoked immediately before a component is unmounted from the DOM.\n  ContextualMenuBase.prototype.componentWillUnmount = function () {\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n    this._events.dispose();\n    this._async.dispose();\n    this._mounted = false;\n  };\n  ContextualMenuBase.prototype.render = function () {\n    var _this = this;\n    var isBeakVisible = this.props.isBeakVisible;\n    var _a = this.props,\n      items = _a.items,\n      labelElementId = _a.labelElementId,\n      id = _a.id,\n      className = _a.className,\n      beakWidth = _a.beakWidth,\n      directionalHint = _a.directionalHint,\n      directionalHintForRTL = _a.directionalHintForRTL,\n      alignTargetEdge = _a.alignTargetEdge,\n      gapSpace = _a.gapSpace,\n      coverTarget = _a.coverTarget,\n      ariaLabel = _a.ariaLabel,\n      doNotLayer = _a.doNotLayer,\n      target = _a.target,\n      bounds = _a.bounds,\n      useTargetWidth = _a.useTargetWidth,\n      useTargetAsMinWidth = _a.useTargetAsMinWidth,\n      directionalHintFixed = _a.directionalHintFixed,\n      shouldFocusOnMount = _a.shouldFocusOnMount,\n      shouldFocusOnContainer = _a.shouldFocusOnContainer,\n      title = _a.title,\n      styles = _a.styles,\n      theme = _a.theme,\n      calloutProps = _a.calloutProps,\n      _b = _a.onRenderSubMenu,\n      onRenderSubMenu = _b === void 0 ? this._onRenderSubMenu : _b,\n      _c = _a.onRenderMenuList,\n      onRenderMenuList = _c === void 0 ? this._onRenderMenuList : _c,\n      focusZoneProps = _a.focusZoneProps,\n      // eslint-disable-next-line deprecation/deprecation\n      getMenuClassNames = _a.getMenuClassNames;\n    this._classNames = getMenuClassNames ? getMenuClassNames(theme, className) : getClassNames(styles, {\n      theme: theme,\n      className: className\n    });\n    var hasIcons = itemsHaveIcons(items);\n    function itemsHaveIcons(contextualMenuItems) {\n      for (var _i = 0, contextualMenuItems_1 = contextualMenuItems; _i < contextualMenuItems_1.length; _i++) {\n        var item = contextualMenuItems_1[_i];\n        if (item.iconProps) {\n          return true;\n        }\n        if (item.itemType === ContextualMenuItemType.Section && item.sectionProps && itemsHaveIcons(item.sectionProps.items)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    this._adjustedFocusZoneProps = __assign(__assign({}, focusZoneProps), {\n      direction: this._getFocusZoneDirection()\n    });\n    var hasCheckmarks = canAnyMenuItemsCheck(items);\n    var submenuProps = this.state.expandedMenuItemKey && this.props.hidden !== true ? this._getSubmenuProps() : null;\n    isBeakVisible = isBeakVisible === undefined ? this.props.responsiveMode <= ResponsiveMode.medium : isBeakVisible;\n    /**\n     * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n     */\n    var contextMenuStyle;\n    var targetAsHtmlElement = this._target;\n    if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n      var targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n      var targetWidth = targetBoundingRect.width - 2; /* Accounts for 1px border */\n      if (useTargetWidth) {\n        contextMenuStyle = {\n          width: targetWidth\n        };\n      } else if (useTargetAsMinWidth) {\n        contextMenuStyle = {\n          minWidth: targetWidth\n        };\n      }\n    }\n    // The menu should only return if items were provided, if no items were provided then it should not appear.\n    if (items && items.length > 0) {\n      var totalItemCount = 0;\n      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n        var item = items_1[_i];\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          var itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          totalItemCount += itemCount;\n        }\n      }\n      var calloutStyles = this._classNames.subComponentStyles ? this._classNames.subComponentStyles.callout : undefined;\n      return React.createElement(Callout, __assign({\n        styles: calloutStyles,\n        onRestoreFocus: this._tryFocusPreviousActiveElement\n      }, calloutProps, {\n        target: target,\n        isBeakVisible: isBeakVisible,\n        beakWidth: beakWidth,\n        directionalHint: directionalHint,\n        directionalHintForRTL: directionalHintForRTL,\n        gapSpace: gapSpace,\n        coverTarget: coverTarget,\n        doNotLayer: doNotLayer,\n        className: css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className),\n        setInitialFocus: shouldFocusOnMount,\n        onDismiss: this.props.onDismiss,\n        onScroll: this._onScroll,\n        bounds: bounds,\n        directionalHintFixed: directionalHintFixed,\n        alignTargetEdge: alignTargetEdge,\n        hidden: this.props.hidden\n      }), React.createElement(\"div\", {\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": labelElementId,\n        style: contextMenuStyle,\n        ref: function (host) {\n          return _this._host = host;\n        },\n        id: id,\n        className: this._classNames.container,\n        tabIndex: shouldFocusOnContainer ? 0 : -1,\n        onKeyDown: this._onMenuKeyDown,\n        onKeyUp: this._onKeyUp,\n        onFocusCapture: this._onMenuFocusCapture\n      }, title && React.createElement(\"div\", {\n        className: this._classNames.title\n      }, \" \", title, \" \"), items && items.length ? React.createElement(FocusZone, __assign({\n        className: this._classNames.root,\n        isCircularNavigation: true,\n        handleTabKey: FocusZoneTabbableElements.all\n      }, this._adjustedFocusZoneProps), onRenderMenuList({\n        items: items,\n        totalItemCount: totalItemCount,\n        hasCheckmarks: hasCheckmarks,\n        hasIcons: hasIcons,\n        defaultMenuItemRenderer: this._defaultMenuItemRenderer\n      }, this._onRenderMenuList)) : null, submenuProps && onRenderSubMenu(submenuProps, this._onRenderSubMenu)));\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Return whether the contextual menu is hidden.\n   * Undefined value for hidden is equivalent to hidden being false.\n   * @param props - Props for the component\n   */\n  ContextualMenuBase.prototype._isHidden = function (props) {\n    return !!props.hidden;\n  };\n  ContextualMenuBase.prototype._onMenuOpened = function () {\n    this._events.on(this._targetWindow, 'resize', this.dismiss);\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n    this._gotMouseMove = false;\n    this.props.onMenuOpened && this.props.onMenuOpened(this.props);\n  };\n  ContextualMenuBase.prototype._onMenuClosed = function () {\n    this._events.off(this._targetWindow, 'resize', this.dismiss);\n    // This is kept for backwards compatability with hidden for right now.\n    // This preserves the way that this behaved in the past\n    // TODO find a better way to handle this by using the same conventions that\n    // Popup uses to determine if focus is contained when dismissal occurs\n    this._tryFocusPreviousActiveElement({\n      containsFocus: this._focusingPreviousElement,\n      documentContainsFocus: this._targetWindow.document.hasFocus(),\n      originalElement: this._previousActiveElement\n    });\n    this._focusingPreviousElement = false;\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n    // We need to dismiss any submenu related state properties,\n    // so that when the menu is shown again, the submenu is collapsed\n    this.setState({\n      expandedByMouseClick: undefined,\n      dismissedMenuItemKey: undefined,\n      expandedMenuItemKey: undefined,\n      submenuTarget: undefined\n    });\n  };\n  /**\n   * Gets the focusZoneDirection by using the arrowDirection if specified,\n   * the direction specificed in the focusZoneProps, or defaults to FocusZoneDirection.vertical\n   */\n  ContextualMenuBase.prototype._getFocusZoneDirection = function () {\n    var focusZoneProps = this.props.focusZoneProps;\n    return focusZoneProps && focusZoneProps.direction !== undefined ? focusZoneProps.direction : FocusZoneDirection.vertical;\n  };\n  ContextualMenuBase.prototype._onRenderSubMenu = function (subMenuProps, defaultRender) {\n    throw Error('ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' + 'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.');\n  };\n  ContextualMenuBase.prototype._renderSectionItem = function (sectionItem,\n  // eslint-disable-next-line deprecation/deprecation\n  menuClassNames, index, hasCheckmarks, hasIcons) {\n    var _this = this;\n    var _a;\n    var sectionProps = sectionItem.sectionProps;\n    if (!sectionProps) {\n      return;\n    }\n    var headerItem;\n    var groupProps;\n    if (sectionProps.title) {\n      var headerContextualMenuItem = undefined;\n      var ariaLabellledby = '';\n      if (typeof sectionProps.title === 'string') {\n        // Since title is a user-facing string, it needs to be stripped\n        // of whitespace in order to build a valid element ID\n        var id = this._id + sectionProps.title.replace(/\\s/g, '');\n        headerContextualMenuItem = {\n          key: \"section-\" + sectionProps.title + \"-title\",\n          itemType: ContextualMenuItemType.Header,\n          text: sectionProps.title,\n          id: id\n        };\n        ariaLabellledby = id;\n      } else {\n        headerContextualMenuItem = sectionProps.title;\n        ariaLabellledby = this._id + ((_a = sectionProps.title.text) === null || _a === void 0 ? void 0 : _a.replace(/\\s/g, ''));\n      }\n      if (headerContextualMenuItem) {\n        groupProps = {\n          role: 'group',\n          'aria-labelledby': ariaLabellledby\n        };\n        headerItem = this._renderHeaderMenuItem(headerContextualMenuItem, menuClassNames, index, hasCheckmarks, hasIcons);\n      }\n    }\n    if (sectionProps.items && sectionProps.items.length > 0) {\n      return React.createElement(\"li\", {\n        role: \"presentation\",\n        key: sectionProps.key || sectionItem.key || \"section-\" + index\n      }, React.createElement(\"div\", __assign({}, groupProps), React.createElement(\"ul\", {\n        className: this._classNames.list,\n        role: \"menu\"\n      }, sectionProps.topDivider && this._renderSeparator(index, menuClassNames, true, true), headerItem && this._renderListItem(headerItem, sectionItem.key || index, menuClassNames, sectionItem.title), sectionProps.items.map(function (contextualMenuItem, itemsIndex) {\n        return _this._renderMenuItem(contextualMenuItem, itemsIndex, itemsIndex, sectionProps.items.length, hasCheckmarks, hasIcons);\n      }), sectionProps.bottomDivider && this._renderSeparator(index, menuClassNames, false, true))));\n    }\n  };\n  ContextualMenuBase.prototype._renderListItem = function (content, key, classNames,\n  // eslint-disable-line deprecation/deprecation\n  title) {\n    return React.createElement(\"li\", {\n      role: \"presentation\",\n      title: title,\n      key: key,\n      className: classNames.item\n    }, content);\n  };\n  ContextualMenuBase.prototype._renderSeparator = function (index, classNames,\n  // eslint-disable-line deprecation/deprecation\n  top, fromSection) {\n    if (fromSection || index > 0) {\n      return React.createElement(\"li\", {\n        role: \"separator\",\n        key: 'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom'),\n        className: classNames.divider,\n        \"aria-hidden\": \"true\"\n      });\n    }\n    return null;\n  };\n  ContextualMenuBase.prototype._renderNormalItem = function (item, classNames,\n  // eslint-disable-line deprecation/deprecation\n  index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    if (item.onRender) {\n      return item.onRender(__assign({\n        'aria-posinset': focusableElementIndex + 1,\n        'aria-setsize': totalItemCount\n      }, item), this.dismiss);\n    }\n    if (item.href) {\n      return this._renderAnchorMenuItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n    }\n    if (item.split && hasSubmenu(item)) {\n      return this._renderSplitButton(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n    }\n    return this._renderButtonItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n  };\n  ContextualMenuBase.prototype._renderHeaderMenuItem = function (item,\n  // eslint-disable-next-line deprecation/deprecation\n  classNames, index, hasCheckmarks, hasIcons) {\n    var _a = this.props.contextualMenuItemAs,\n      ChildrenRenderer = _a === void 0 ? ContextualMenuItem : _a;\n    var itemProps = item.itemProps,\n      id = item.id;\n    var divHtmlProperties = itemProps && getNativeProps(itemProps, divProperties);\n    return (\n      // eslint-disable-next-line deprecation/deprecation\n      React.createElement(\"div\", __assign({\n        id: id,\n        className: this._classNames.header\n      }, divHtmlProperties, {\n        style: item.style\n      }), React.createElement(ChildrenRenderer, __assign({\n        item: item,\n        classNames: classNames,\n        index: index,\n        onCheckmarkClick: hasCheckmarks ? this._onItemClick : undefined,\n        hasIcons: hasIcons\n      }, itemProps)))\n    );\n  };\n  ContextualMenuBase.prototype._renderAnchorMenuItem = function (item,\n  // eslint-disable-next-line deprecation/deprecation\n  classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    var contextualMenuItemAs = this.props.contextualMenuItemAs;\n    var expandedMenuItemKey = this.state.expandedMenuItemKey;\n    return React.createElement(ContextualMenuAnchor, {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: this._onItemMouseEnterBase,\n      onItemMouseLeave: this._onMouseItemLeave,\n      onItemMouseMove: this._onItemMouseMoveBase,\n      onItemMouseDown: this._onItemMouseDown,\n      executeItemClick: this._executeItemClick,\n      onItemClick: this._onAnchorClick,\n      onItemKeyDown: this._onItemKeyDown,\n      getSubMenuId: this._getSubMenuId,\n      expandedMenuItemKey: expandedMenuItemKey,\n      openSubMenu: this._onItemSubMenuExpand,\n      dismissSubMenu: this._onSubMenuDismiss,\n      dismissMenu: this.dismiss\n    });\n  };\n  ContextualMenuBase.prototype._renderButtonItem = function (item,\n  // eslint-disable-next-line deprecation/deprecation\n  classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    var contextualMenuItemAs = this.props.contextualMenuItemAs;\n    var expandedMenuItemKey = this.state.expandedMenuItemKey;\n    return React.createElement(ContextualMenuButton, {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: this._onItemMouseEnterBase,\n      onItemMouseLeave: this._onMouseItemLeave,\n      onItemMouseMove: this._onItemMouseMoveBase,\n      onItemMouseDown: this._onItemMouseDown,\n      executeItemClick: this._executeItemClick,\n      onItemClick: this._onItemClick,\n      onItemClickBase: this._onItemClickBase,\n      onItemKeyDown: this._onItemKeyDown,\n      getSubMenuId: this._getSubMenuId,\n      expandedMenuItemKey: expandedMenuItemKey,\n      openSubMenu: this._onItemSubMenuExpand,\n      dismissSubMenu: this._onSubMenuDismiss,\n      dismissMenu: this.dismiss\n    });\n  };\n  ContextualMenuBase.prototype._renderSplitButton = function (item,\n  // eslint-disable-next-line deprecation/deprecation\n  classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    var contextualMenuItemAs = this.props.contextualMenuItemAs;\n    var expandedMenuItemKey = this.state.expandedMenuItemKey;\n    return React.createElement(ContextualMenuSplitButton, {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: this._onItemMouseEnterBase,\n      onItemMouseLeave: this._onMouseItemLeave,\n      onItemMouseMove: this._onItemMouseMoveBase,\n      onItemMouseDown: this._onItemMouseDown,\n      executeItemClick: this._executeItemClick,\n      onItemClick: this._onItemClick,\n      onItemClickBase: this._onItemClickBase,\n      onItemKeyDown: this._onItemKeyDown,\n      openSubMenu: this._onItemSubMenuExpand,\n      dismissSubMenu: this._onSubMenuDismiss,\n      dismissMenu: this.dismiss,\n      expandedMenuItemKey: expandedMenuItemKey,\n      onTap: this._onPointerAndTouchEvent\n    });\n  };\n  /**\n   * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n   */\n  ContextualMenuBase.prototype._isAltOrMeta = function (ev) {\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\n  };\n  ContextualMenuBase.prototype._shouldIgnoreMouseEvent = function () {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  };\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n  ContextualMenuBase.prototype._updateFocusOnMouseEvent = function (item, ev, target) {\n    var _this = this;\n    var targetElement = target ? target : ev.currentTarget;\n    var _a = this.props.subMenuHoverDelay,\n      timeoutDuration = _a === void 0 ? NavigationIdleDelay : _a;\n    if (item.key === this.state.expandedMenuItemKey) {\n      return;\n    }\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n      this._enterTimerId = undefined;\n    }\n    // If the menu is not expanded we can update focus without any delay\n    if (this.state.expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    }\n    // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      this._enterTimerId = this._async.setTimeout(function () {\n        targetElement.focus();\n        _this.setState({\n          expandedByMouseClick: true\n        });\n        _this._onItemSubMenuExpand(item, targetElement);\n        _this._enterTimerId = undefined;\n      }, timeoutDuration);\n    } else {\n      this._enterTimerId = this._async.setTimeout(function () {\n        _this._onSubMenuDismiss(ev);\n        targetElement.focus();\n        _this._enterTimerId = undefined;\n      }, timeoutDuration);\n    }\n  };\n  ContextualMenuBase.prototype._getSubmenuProps = function () {\n    var _a = this.state,\n      submenuTarget = _a.submenuTarget,\n      expandedMenuItemKey = _a.expandedMenuItemKey;\n    var item = this._findItemByKey(expandedMenuItemKey);\n    var submenuProps = null;\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item),\n        target: submenuTarget,\n        onDismiss: this._onSubMenuDismiss,\n        isSubMenu: true,\n        id: this.state.subMenuId,\n        shouldFocusOnMount: true,\n        shouldFocusOnContainer: this.state.expandedByMouseClick,\n        directionalHint: getRTL(this.props.theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className: this.props.className,\n        gapSpace: 0,\n        isBeakVisible: false\n      };\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n    }\n    return submenuProps;\n  };\n  ContextualMenuBase.prototype._findItemByKey = function (key) {\n    var items = this.props.items;\n    return this._findItemByKeyFromItems(key, items);\n  };\n  /**\n   * Returns the item that mathes a given key if any.\n   * @param key - The key of the item to match\n   * @param items - The items to look for the key\n   */\n  ContextualMenuBase.prototype._findItemByKeyFromItems = function (key, items) {\n    for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {\n      var item = items_2[_i];\n      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n        var match = this._findItemByKeyFromItems(key, item.sectionProps.items);\n        if (match) {\n          return match;\n        }\n      } else if (item.key && item.key === key) {\n        return item;\n      }\n    }\n  };\n  ContextualMenuBase.prototype._setTargetWindowAndElement = function (target) {\n    var currentElement = this._host;\n    if (target) {\n      if (typeof target === 'string') {\n        var currentDoc = getDocument(currentElement);\n        this._target = currentDoc ? currentDoc.querySelector(target) : null;\n        this._targetWindow = getWindow(currentElement);\n        // Cast to any prevents error about stopPropagation always existing\n      } else if (target.stopPropagation) {\n        this._targetWindow = getWindow(target.target);\n        this._target = target;\n      } else if (\n      // eslint-disable-next-line deprecation/deprecation\n      (target.left !== undefined || target.x !== undefined) && (\n      // eslint-disable-next-line deprecation/deprecation\n      target.top !== undefined || target.y !== undefined)) {\n        this._targetWindow = getWindow(currentElement);\n        this._target = target;\n      } else if (target.current !== undefined) {\n        this._target = target.current;\n        this._targetWindow = getWindow(this._target);\n      } else {\n        var targetElement = target;\n        this._targetWindow = getWindow(targetElement);\n        this._target = target;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement);\n    }\n  };\n  // The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\n  ContextualMenuBase.defaultProps = {\n    items: [],\n    shouldFocusOnMount: true,\n    gapSpace: 0,\n    directionalHint: DirectionalHint.bottomAutoEdge,\n    beakWidth: 16\n  };\n  ContextualMenuBase = __decorate([withResponsiveMode], ContextualMenuBase);\n  return ContextualMenuBase;\n}(React.Component);\nexport { ContextualMenuBase };","map":{"version":3,"sources":["components/ContextualMenu/ContextualMenu.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  IContextualMenuProps,\n  IContextualMenuItem,\n  ContextualMenuItemType,\n  IContextualMenuListProps,\n  IContextualMenuStyleProps,\n  IContextualMenuStyles,\n  IContextualMenuItemRenderProps,\n} from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, IFocusZoneProps, FocusZoneTabbableElements } from '../../FocusZone';\nimport { IMenuItemClassNames, IContextualMenuClassNames } from './ContextualMenu.classNames';\nimport {\n  divProperties,\n  getNativeProps,\n  shallowCompare,\n  warnDeprecations,\n  Async,\n  EventGroup,\n  assign,\n  classNamesFunction,\n  css,\n  getDocument,\n  getFirstFocusable,\n  getId,\n  getLastFocusable,\n  getRTL,\n  getWindow,\n  IRenderFunction,\n  Point,\n  KeyCodes,\n  shouldWrapFocus,\n  IStyleFunctionOrObject,\n  isIOS,\n  isMac,\n  initializeComponentRef,\n  memoizeFunction,\n} from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { withResponsiveMode, ResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { Callout, ICalloutContentStyleProps, ICalloutContentStyles } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport {\n  ContextualMenuSplitButton,\n  ContextualMenuButton,\n  ContextualMenuAnchor,\n} from './ContextualMenuItemWrapper/index';\nimport { IProcessedStyleSet, concatStyleSetsWithProps } from '../../Styling';\nimport { IContextualMenuItemStyleProps, IContextualMenuItemStyles } from './ContextualMenuItem.types';\nimport { getItemStyles } from './ContextualMenu.classNames';\nimport { Target } from '@uifabric/react-hooks';\n\nconst getClassNames = classNamesFunction<IContextualMenuStyleProps, IContextualMenuStyles>();\nconst getContextualMenuItemClassNames = classNamesFunction<IContextualMenuItemStyleProps, IContextualMenuItemStyles>();\n\nexport interface IContextualMenuState {\n  expandedMenuItemKey?: string;\n  /** True if the menu was expanded by mouse click OR hover (as opposed to by keyboard) */\n  expandedByMouseClick?: boolean;\n  dismissedMenuItemKey?: string;\n  contextualMenuItems?: IContextualMenuItem[];\n  contextualMenuTarget?: Element;\n  submenuTarget?: Element;\n  positions?: any;\n  slideDirectionalClassName?: string;\n  subMenuId?: string;\n  submenuDirection?: DirectionalHint;\n}\n\nexport function getSubmenuItems(item: IContextualMenuItem): IContextualMenuItem[] | undefined {\n  return item.subMenuProps ? item.subMenuProps.items : item.items;\n}\n\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\nexport function canAnyMenuItemsCheck(items: IContextualMenuItem[]): boolean {\n  return items.some(item => {\n    if (item.canCheck) {\n      return true;\n    }\n\n    // If the item is a section, check if any of the items in the section can check.\n    if (item.sectionProps && item.sectionProps.items.some(submenuItem => submenuItem.canCheck === true)) {\n      return true;\n    }\n\n    return false;\n  });\n}\n\nconst NavigationIdleDelay = 250; /* ms */\n\nconst COMPONENT_NAME = 'ContextualMenu';\n\nconst _getMenuItemStylesFunction = memoizeFunction(\n  (\n    ...styles: (IStyleFunctionOrObject<IContextualMenuItemStyleProps, IContextualMenuItemStyles> | undefined)[]\n  ): IStyleFunctionOrObject<IContextualMenuItemStyleProps, IContextualMenuItemStyles> => {\n    return (styleProps: IContextualMenuItemStyleProps) =>\n      concatStyleSetsWithProps(styleProps, getItemStyles, ...styles);\n  },\n);\n\n@withResponsiveMode\nexport class ContextualMenuBase extends React.Component<IContextualMenuProps, IContextualMenuState> {\n  // The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\n  public static defaultProps: IContextualMenuProps = {\n    items: [],\n    shouldFocusOnMount: true,\n    gapSpace: 0,\n    directionalHint: DirectionalHint.bottomAutoEdge,\n    beakWidth: 16,\n  };\n\n  private _async: Async;\n  private _events: EventGroup;\n  private _id: string;\n  private _host: HTMLElement;\n  private _previousActiveElement: HTMLElement | undefined;\n  private _enterTimerId: number | undefined;\n  private _targetWindow: Window;\n  private _target: Element | MouseEvent | Point | null;\n  private _isScrollIdle: boolean;\n  private _scrollIdleTimeoutId: number | undefined;\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\n  private _lastKeyDownWasAltOrMeta: boolean | undefined;\n  private _shouldUpdateFocusOnMouseEvent: boolean;\n  private _gotMouseMove: boolean;\n  private _mounted = false;\n  private _focusingPreviousElement: boolean;\n\n  private _adjustedFocusZoneProps: IFocusZoneProps;\n\n  // eslint-disable-next-line deprecation/deprecation\n  private _classNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames;\n\n  constructor(props: IContextualMenuProps) {\n    super(props);\n\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n    initializeComponentRef(this);\n\n    warnDeprecations(COMPONENT_NAME, props, {\n      getMenuClassNames: 'styles',\n    });\n\n    this.state = {\n      contextualMenuItems: undefined,\n      subMenuId: getId('ContextualMenu'),\n    };\n\n    this._id = props.id || getId('ContextualMenu');\n    this._focusingPreviousElement = false;\n    this._isScrollIdle = true;\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n    this._gotMouseMove = false;\n  }\n\n  public dismiss = (ev?: any, dismissAll?: boolean) => {\n    const { onDismiss } = this.props;\n\n    if (onDismiss) {\n      onDismiss(ev, dismissAll);\n    }\n  };\n\n  public shouldComponentUpdate(newProps: IContextualMenuProps, newState: IContextualMenuState): boolean {\n    if (!newProps.shouldUpdateWhenHidden && this.props.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return false;\n    }\n\n    return !shallowCompare(this.props, newProps) || !shallowCompare(this.state, newState);\n  }\n\n  public UNSAFE_componentWillUpdate(newProps: IContextualMenuProps): void {\n    if (newProps.target !== this.props.target) {\n      const newTarget = newProps.target;\n      this._setTargetWindowAndElement(newTarget!);\n    }\n\n    if (this._isHidden(newProps) !== this._isHidden(this.props)) {\n      if (this._isHidden(newProps)) {\n        this._onMenuClosed();\n      } else {\n        this._onMenuOpened();\n        this._previousActiveElement = this._targetWindow\n          ? (this._targetWindow.document.activeElement as HTMLElement)\n          : undefined;\n      }\n    }\n    if (newProps.delayUpdateFocusOnHover !== this.props.delayUpdateFocusOnHover) {\n      // update shouldUpdateFocusOnMouseEvent to follow what was passed in\n      this._shouldUpdateFocusOnMouseEvent = !newProps.delayUpdateFocusOnHover;\n\n      // If shouldUpdateFocusOnMouseEvent is false, we need to reset gotMouseMove to false\n      this._gotMouseMove = this._shouldUpdateFocusOnMouseEvent && this._gotMouseMove;\n    }\n  }\n\n  // Invoked once, both on the client and server, immediately before the initial rendering occurs.\n  public UNSAFE_componentWillMount() {\n    const target = this.props.target;\n    this._setTargetWindowAndElement(target!);\n    if (!this.props.hidden) {\n      this._previousActiveElement = this._targetWindow\n        ? (this._targetWindow.document.activeElement as HTMLElement)\n        : undefined;\n    }\n  }\n\n  // Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.\n  public componentDidMount(): void {\n    if (!this.props.hidden) {\n      this._onMenuOpened();\n    }\n\n    this._mounted = true;\n  }\n\n  // Invoked immediately before a component is unmounted from the DOM.\n  public componentWillUnmount() {\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._events.dispose();\n    this._async.dispose();\n    this._mounted = false;\n  }\n\n  public render(): JSX.Element | null {\n    let { isBeakVisible } = this.props;\n\n    const {\n      items,\n      labelElementId,\n      id,\n      className,\n      beakWidth,\n      directionalHint,\n      directionalHintForRTL,\n      alignTargetEdge,\n      gapSpace,\n      coverTarget,\n      ariaLabel,\n      doNotLayer,\n      target,\n      bounds,\n      useTargetWidth,\n      useTargetAsMinWidth,\n      directionalHintFixed,\n      shouldFocusOnMount,\n      shouldFocusOnContainer,\n      title,\n      styles,\n      theme,\n      calloutProps,\n      onRenderSubMenu = this._onRenderSubMenu,\n      onRenderMenuList = this._onRenderMenuList,\n      focusZoneProps,\n      // eslint-disable-next-line deprecation/deprecation\n      getMenuClassNames,\n    } = this.props;\n\n    this._classNames = getMenuClassNames\n      ? getMenuClassNames(theme!, className)\n      : getClassNames(styles, {\n          theme: theme!,\n          className: className,\n        });\n\n    const hasIcons = itemsHaveIcons(items);\n\n    function itemsHaveIcons(contextualMenuItems: IContextualMenuItem[]): boolean {\n      for (const item of contextualMenuItems) {\n        if (item.iconProps) {\n          return true;\n        }\n\n        if (\n          item.itemType === ContextualMenuItemType.Section &&\n          item.sectionProps &&\n          itemsHaveIcons(item.sectionProps.items)\n        ) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    this._adjustedFocusZoneProps = { ...focusZoneProps, direction: this._getFocusZoneDirection() };\n\n    const hasCheckmarks = canAnyMenuItemsCheck(items);\n    const submenuProps = this.state.expandedMenuItemKey && this.props.hidden !== true ? this._getSubmenuProps() : null;\n\n    isBeakVisible = isBeakVisible === undefined ? this.props.responsiveMode! <= ResponsiveMode.medium : isBeakVisible;\n    /**\n     * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n     */\n    let contextMenuStyle;\n    const targetAsHtmlElement = this._target as HTMLElement;\n    if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n      const targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n      const targetWidth = targetBoundingRect.width - 2; /* Accounts for 1px border */\n\n      if (useTargetWidth) {\n        contextMenuStyle = {\n          width: targetWidth,\n        };\n      } else if (useTargetAsMinWidth) {\n        contextMenuStyle = {\n          minWidth: targetWidth,\n        };\n      }\n    }\n\n    // The menu should only return if items were provided, if no items were provided then it should not appear.\n    if (items && items.length > 0) {\n      let totalItemCount = 0;\n      for (const item of items) {\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          const itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          totalItemCount += itemCount;\n        }\n      }\n\n      const calloutStyles = this._classNames.subComponentStyles\n        ? (this._classNames.subComponentStyles.callout as IStyleFunctionOrObject<\n            ICalloutContentStyleProps,\n            ICalloutContentStyles\n          >)\n        : undefined;\n\n      return (\n        <Callout\n          styles={calloutStyles}\n          onRestoreFocus={this._tryFocusPreviousActiveElement}\n          {...calloutProps}\n          target={target}\n          isBeakVisible={isBeakVisible}\n          beakWidth={beakWidth}\n          directionalHint={directionalHint}\n          directionalHintForRTL={directionalHintForRTL}\n          gapSpace={gapSpace}\n          coverTarget={coverTarget}\n          doNotLayer={doNotLayer}\n          className={css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className)}\n          setInitialFocus={shouldFocusOnMount}\n          onDismiss={this.props.onDismiss}\n          onScroll={this._onScroll}\n          bounds={bounds}\n          directionalHintFixed={directionalHintFixed}\n          alignTargetEdge={alignTargetEdge}\n          hidden={this.props.hidden}\n        >\n          <div\n            aria-label={ariaLabel}\n            aria-labelledby={labelElementId}\n            style={contextMenuStyle}\n            ref={(host: HTMLDivElement) => (this._host = host)}\n            id={id}\n            className={this._classNames.container}\n            tabIndex={shouldFocusOnContainer ? 0 : -1}\n            onKeyDown={this._onMenuKeyDown}\n            onKeyUp={this._onKeyUp}\n            onFocusCapture={this._onMenuFocusCapture}\n          >\n            {title && <div className={this._classNames.title}> {title} </div>}\n            {items && items.length ? (\n              <FocusZone\n                className={this._classNames.root}\n                isCircularNavigation={true}\n                handleTabKey={FocusZoneTabbableElements.all}\n                {...this._adjustedFocusZoneProps}\n              >\n                {onRenderMenuList(\n                  {\n                    items,\n                    totalItemCount,\n                    hasCheckmarks,\n                    hasIcons,\n                    defaultMenuItemRenderer: this._defaultMenuItemRenderer,\n                  },\n                  this._onRenderMenuList,\n                )}\n              </FocusZone>\n            ) : null}\n            {submenuProps && onRenderSubMenu(submenuProps, this._onRenderSubMenu)}\n          </div>\n        </Callout>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Return whether the contextual menu is hidden.\n   * Undefined value for hidden is equivalent to hidden being false.\n   * @param props - Props for the component\n   */\n  private _isHidden(props: IContextualMenuProps) {\n    return !!props.hidden;\n  }\n\n  private _onMenuOpened() {\n    this._events.on(this._targetWindow, 'resize', this.dismiss);\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n    this._gotMouseMove = false;\n    this.props.onMenuOpened && this.props.onMenuOpened(this.props);\n  }\n\n  private _onMenuClosed() {\n    this._events.off(this._targetWindow, 'resize', this.dismiss);\n\n    // This is kept for backwards compatability with hidden for right now.\n    // This preserves the way that this behaved in the past\n    // TODO find a better way to handle this by using the same conventions that\n    // Popup uses to determine if focus is contained when dismissal occurs\n    this._tryFocusPreviousActiveElement({\n      containsFocus: this._focusingPreviousElement,\n      documentContainsFocus: this._targetWindow.document.hasFocus(),\n      originalElement: this._previousActiveElement,\n    });\n\n    this._focusingPreviousElement = false;\n\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n\n    // We need to dismiss any submenu related state properties,\n    // so that when the menu is shown again, the submenu is collapsed\n    this.setState({\n      expandedByMouseClick: undefined,\n      dismissedMenuItemKey: undefined,\n      expandedMenuItemKey: undefined,\n      submenuTarget: undefined,\n    });\n  }\n\n  private _tryFocusPreviousActiveElement = (options: {\n    containsFocus: boolean;\n    documentContainsFocus: boolean;\n    originalElement: HTMLElement | Window | undefined;\n  }) => {\n    if (this.props.onRestoreFocus) {\n      this.props.onRestoreFocus(options);\n    } else {\n      if (options && options.containsFocus && this._previousActiveElement) {\n        // Make sure that the focus method actually exists\n        // In some cases the object might exist but not be a real element.\n        // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n        if (this._previousActiveElement.focus) {\n          this._previousActiveElement.focus();\n        }\n      }\n    }\n  };\n\n  /**\n   * Gets the focusZoneDirection by using the arrowDirection if specified,\n   * the direction specificed in the focusZoneProps, or defaults to FocusZoneDirection.vertical\n   */\n  private _getFocusZoneDirection() {\n    const { focusZoneProps } = this.props;\n    return focusZoneProps && focusZoneProps.direction !== undefined\n      ? focusZoneProps.direction\n      : FocusZoneDirection.vertical;\n  }\n\n  private _onRenderSubMenu(\n    subMenuProps: IContextualMenuProps,\n    defaultRender?: IRenderFunction<IContextualMenuProps>,\n  ): JSX.Element {\n    throw Error(\n      'ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' +\n        'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.',\n    );\n  }\n\n  private _onRenderMenuList = (\n    menuListProps: IContextualMenuListProps,\n    defaultRender?: IRenderFunction<IContextualMenuListProps>,\n  ): JSX.Element => {\n    let indexCorrection = 0;\n    const { items, totalItemCount, hasCheckmarks, hasIcons, role } = menuListProps;\n    return (\n      <ul className={this._classNames.list} onKeyDown={this._onKeyDown} onKeyUp={this._onKeyUp} role={role ?? 'menu'}>\n        {items.map((item, index) => {\n          const menuItem = this._renderMenuItem(item, index, indexCorrection, totalItemCount, hasCheckmarks, hasIcons);\n          if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n            const indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n            indexCorrection += indexIncrease;\n          }\n          return menuItem;\n        })}\n      </ul>\n    );\n  };\n\n  /**\n   * !!!IMPORTANT!!! Avoid mutating `item: IContextualMenuItem` argument. It will\n   * cause the menu items to always re-render because the component update is based on shallow comparison.\n   */\n  private _renderMenuItem = (\n    item: IContextualMenuItem,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ): JSX.Element => {\n    const renderedItems: React.ReactNode[] = [];\n    const iconProps = item.iconProps || { iconName: 'None' };\n    const {\n      getItemClassNames, // eslint-disable-line deprecation/deprecation\n      itemProps,\n    } = item;\n    const styles = itemProps ? itemProps.styles : undefined;\n\n    // We only send a dividerClassName when the item to be rendered is a divider.\n    // For all other cases, the default divider style is used.\n    const dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n    const subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : '';\n\n    // eslint-disable-next-line deprecation/deprecation\n    let itemClassNames: IMenuItemClassNames;\n\n    // IContextualMenuItem#getItemClassNames for backwards compatibility\n    // otherwise uses mergeStyles for class names.\n    if (getItemClassNames) {\n      itemClassNames = getItemClassNames(\n        this.props.theme!,\n        isItemDisabled(item),\n        this.state.expandedMenuItemKey === item.key,\n        !!getIsChecked(item),\n        !!item.href,\n        iconProps.iconName !== 'None',\n        item.className,\n        dividerClassName,\n        iconProps.className,\n        subMenuIconClassName,\n        item.primaryDisabled,\n      );\n    } else {\n      const itemStyleProps: IContextualMenuItemStyleProps = {\n        theme: this.props.theme!,\n        disabled: isItemDisabled(item),\n        expanded: this.state.expandedMenuItemKey === item.key,\n        checked: !!getIsChecked(item),\n        isAnchorLink: !!item.href,\n        knownIcon: iconProps.iconName !== 'None',\n        itemClassName: item.className,\n        dividerClassName,\n        iconClassName: iconProps.className,\n        subMenuClassName: subMenuIconClassName,\n        primaryDisabled: item.primaryDisabled,\n      };\n\n      // We need to generate default styles then override if styles are provided\n      // since the ContextualMenu currently handles item classNames.\n      itemClassNames = getContextualMenuItemClassNames(\n        _getMenuItemStylesFunction(this._classNames.subComponentStyles?.menuItem, styles),\n        itemStyleProps,\n      );\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (item.text === '-' || item.name === '-') {\n      item.itemType = ContextualMenuItemType.Divider;\n    }\n    switch (item.itemType) {\n      case ContextualMenuItemType.Divider:\n        renderedItems.push(this._renderSeparator(index, itemClassNames));\n        break;\n      case ContextualMenuItemType.Header:\n        renderedItems.push(this._renderSeparator(index, itemClassNames));\n        const headerItem = this._renderHeaderMenuItem(item, itemClassNames, index, hasCheckmarks, hasIcons);\n        renderedItems.push(this._renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n        break;\n      case ContextualMenuItemType.Section:\n        renderedItems.push(this._renderSectionItem(item, itemClassNames, index, hasCheckmarks, hasIcons));\n        break;\n      default:\n        const menuItem = this._renderNormalItem(\n          item,\n          itemClassNames,\n          index,\n          focusableElementIndex,\n          totalItemCount,\n          hasCheckmarks,\n          hasIcons,\n        );\n        renderedItems.push(this._renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n        break;\n    }\n\n    // Since multiple nodes *could* be rendered, wrap them all in a fragment with this item's key.\n    // This ensures the reconciler handles multi-item output per-node correctly and does not re-mount content.\n    return <React.Fragment key={item.key}>{renderedItems}</React.Fragment>;\n  };\n\n  private _defaultMenuItemRenderer = (item: IContextualMenuItemRenderProps): React.ReactNode => {\n    const { index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons } = item;\n    return this._renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n  };\n\n  private _renderSectionItem(\n    sectionItem: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    menuClassNames: IMenuItemClassNames,\n    index: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ) {\n    const sectionProps = sectionItem.sectionProps;\n    if (!sectionProps) {\n      return;\n    }\n\n    let headerItem;\n    let groupProps;\n    if (sectionProps.title) {\n      let headerContextualMenuItem: IContextualMenuItem | undefined = undefined;\n      let ariaLabellledby = '';\n      if (typeof sectionProps.title === 'string') {\n        // Since title is a user-facing string, it needs to be stripped\n        // of whitespace in order to build a valid element ID\n        const id = this._id + sectionProps.title.replace(/\\s/g, '');\n        headerContextualMenuItem = {\n          key: `section-${sectionProps.title}-title`,\n          itemType: ContextualMenuItemType.Header,\n          text: sectionProps.title,\n          id: id,\n        };\n        ariaLabellledby = id;\n      } else {\n        headerContextualMenuItem = sectionProps.title;\n        ariaLabellledby = this._id + sectionProps.title.text?.replace(/\\s/g, '');\n      }\n\n      if (headerContextualMenuItem) {\n        groupProps = {\n          role: 'group',\n          'aria-labelledby': ariaLabellledby,\n        };\n        headerItem = this._renderHeaderMenuItem(\n          headerContextualMenuItem,\n          menuClassNames,\n          index,\n          hasCheckmarks,\n          hasIcons,\n        );\n      }\n    }\n\n    if (sectionProps.items && sectionProps.items.length > 0) {\n      return (\n        <li role=\"presentation\" key={sectionProps.key || sectionItem.key || `section-${index}`}>\n          <div {...groupProps}>\n            <ul className={this._classNames.list} role=\"menu\">\n              {sectionProps.topDivider && this._renderSeparator(index, menuClassNames, true, true)}\n              {headerItem &&\n                this._renderListItem(headerItem, sectionItem.key || index, menuClassNames, sectionItem.title)}\n              {sectionProps.items.map((contextualMenuItem, itemsIndex) =>\n                this._renderMenuItem(\n                  contextualMenuItem,\n                  itemsIndex,\n                  itemsIndex,\n                  sectionProps.items.length,\n                  hasCheckmarks,\n                  hasIcons,\n                ),\n              )}\n              {sectionProps.bottomDivider && this._renderSeparator(index, menuClassNames, false, true)}\n            </ul>\n          </div>\n        </li>\n      );\n    }\n  }\n\n  private _renderListItem(\n    content: React.ReactNode,\n    key: string | number,\n    classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n    title?: string,\n  ) {\n    return (\n      <li role=\"presentation\" title={title} key={key} className={classNames.item}>\n        {content}\n      </li>\n    );\n  }\n\n  private _renderSeparator(\n    index: number,\n    classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n    top?: boolean,\n    fromSection?: boolean,\n  ): React.ReactNode {\n    if (fromSection || index > 0) {\n      return (\n        <li\n          role=\"separator\"\n          key={'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom')}\n          className={classNames.divider}\n          aria-hidden=\"true\"\n        />\n      );\n    }\n    return null;\n  }\n\n  private _renderNormalItem(\n    item: IContextualMenuItem,\n    classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ): React.ReactNode {\n    if (item.onRender) {\n      return item.onRender(\n        { 'aria-posinset': focusableElementIndex + 1, 'aria-setsize': totalItemCount, ...item },\n        this.dismiss,\n      );\n    }\n    if (item.href) {\n      return this._renderAnchorMenuItem(\n        item,\n        classNames,\n        index,\n        focusableElementIndex,\n        totalItemCount,\n        hasCheckmarks,\n        hasIcons,\n      );\n    }\n\n    if (item.split && hasSubmenu(item)) {\n      return this._renderSplitButton(\n        item,\n        classNames,\n        index,\n        focusableElementIndex,\n        totalItemCount,\n        hasCheckmarks,\n        hasIcons,\n      );\n    }\n\n    return this._renderButtonItem(\n      item,\n      classNames,\n      index,\n      focusableElementIndex,\n      totalItemCount,\n      hasCheckmarks,\n      hasIcons,\n    );\n  }\n\n  private _renderHeaderMenuItem(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ): React.ReactNode {\n    const { contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem } = this.props;\n    const { itemProps, id } = item;\n    const divHtmlProperties =\n      itemProps && getNativeProps<React.HTMLAttributes<HTMLDivElement>>(itemProps, divProperties);\n    return (\n      // eslint-disable-next-line deprecation/deprecation\n      <div id={id} className={this._classNames.header} {...divHtmlProperties} style={item.style}>\n        <ChildrenRenderer\n          item={item}\n          classNames={classNames}\n          index={index}\n          onCheckmarkClick={hasCheckmarks ? this._onItemClick : undefined}\n          hasIcons={hasIcons}\n          {...itemProps}\n        />\n      </div>\n    );\n  }\n\n  private _renderAnchorMenuItem(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ): React.ReactNode {\n    const { contextualMenuItemAs } = this.props;\n    const { expandedMenuItemKey } = this.state;\n    return (\n      <ContextualMenuAnchor\n        item={item}\n        classNames={classNames}\n        index={index}\n        focusableElementIndex={focusableElementIndex}\n        totalItemCount={totalItemCount}\n        hasCheckmarks={hasCheckmarks}\n        hasIcons={hasIcons}\n        contextualMenuItemAs={contextualMenuItemAs}\n        onItemMouseEnter={this._onItemMouseEnterBase}\n        onItemMouseLeave={this._onMouseItemLeave}\n        onItemMouseMove={this._onItemMouseMoveBase}\n        onItemMouseDown={this._onItemMouseDown}\n        executeItemClick={this._executeItemClick}\n        onItemClick={this._onAnchorClick}\n        onItemKeyDown={this._onItemKeyDown}\n        getSubMenuId={this._getSubMenuId}\n        expandedMenuItemKey={expandedMenuItemKey}\n        openSubMenu={this._onItemSubMenuExpand}\n        dismissSubMenu={this._onSubMenuDismiss}\n        dismissMenu={this.dismiss}\n      />\n    );\n  }\n\n  private _renderButtonItem(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks?: boolean,\n    hasIcons?: boolean,\n  ) {\n    const { contextualMenuItemAs } = this.props;\n    const { expandedMenuItemKey } = this.state;\n\n    return (\n      <ContextualMenuButton\n        item={item}\n        classNames={classNames}\n        index={index}\n        focusableElementIndex={focusableElementIndex}\n        totalItemCount={totalItemCount}\n        hasCheckmarks={hasCheckmarks}\n        hasIcons={hasIcons}\n        contextualMenuItemAs={contextualMenuItemAs}\n        onItemMouseEnter={this._onItemMouseEnterBase}\n        onItemMouseLeave={this._onMouseItemLeave}\n        onItemMouseMove={this._onItemMouseMoveBase}\n        onItemMouseDown={this._onItemMouseDown}\n        executeItemClick={this._executeItemClick}\n        onItemClick={this._onItemClick}\n        onItemClickBase={this._onItemClickBase}\n        onItemKeyDown={this._onItemKeyDown}\n        getSubMenuId={this._getSubMenuId}\n        expandedMenuItemKey={expandedMenuItemKey}\n        openSubMenu={this._onItemSubMenuExpand}\n        dismissSubMenu={this._onSubMenuDismiss}\n        dismissMenu={this.dismiss}\n      />\n    );\n  }\n\n  private _renderSplitButton(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks?: boolean,\n    hasIcons?: boolean,\n  ): JSX.Element {\n    const { contextualMenuItemAs } = this.props;\n    const { expandedMenuItemKey } = this.state;\n\n    return (\n      <ContextualMenuSplitButton\n        item={item}\n        classNames={classNames}\n        index={index}\n        focusableElementIndex={focusableElementIndex}\n        totalItemCount={totalItemCount}\n        hasCheckmarks={hasCheckmarks}\n        hasIcons={hasIcons}\n        contextualMenuItemAs={contextualMenuItemAs}\n        onItemMouseEnter={this._onItemMouseEnterBase}\n        onItemMouseLeave={this._onMouseItemLeave}\n        onItemMouseMove={this._onItemMouseMoveBase}\n        onItemMouseDown={this._onItemMouseDown}\n        executeItemClick={this._executeItemClick}\n        onItemClick={this._onItemClick}\n        onItemClickBase={this._onItemClickBase}\n        onItemKeyDown={this._onItemKeyDown}\n        openSubMenu={this._onItemSubMenuExpand}\n        dismissSubMenu={this._onSubMenuDismiss}\n        dismissMenu={this.dismiss}\n        expandedMenuItemKey={expandedMenuItemKey}\n        onTap={this._onPointerAndTouchEvent}\n      />\n    );\n  }\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    // Take note if we are processing an alt (option) or meta (command) keydown.\n    // See comment in _shouldHandleKeyUp for reasoning.\n    this._lastKeyDownWasAltOrMeta = this._isAltOrMeta(ev);\n\n    // On Mac, pressing escape dismisses all levels of native context menus\n    const dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n\n    return this._keyHandler(ev, this._shouldHandleKeyDown, dismissAllMenus);\n  };\n\n  private _shouldHandleKeyDown = (ev: React.KeyboardEvent<HTMLElement>) => {\n    return (\n      ev.which === KeyCodes.escape ||\n      this._shouldCloseSubMenu(ev) ||\n      (ev.which === KeyCodes.up && (ev.altKey || ev.metaKey))\n    );\n  };\n\n  private _onMenuFocusCapture = (ev: React.FocusEvent<HTMLElement>) => {\n    if (this.props.delayUpdateFocusOnHover) {\n      this._shouldUpdateFocusOnMouseEvent = true;\n    }\n  };\n\n  private _onKeyUp = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    return this._keyHandler(ev, this._shouldHandleKeyUp, true /* dismissAllMenus */);\n  };\n\n  /**\n   * We close the menu on key up only if ALL of the following are true:\n   * - Most recent key down was alt or meta (command)\n   * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n   *   expand/collapse the menu)\n   * - We're not on a Mac (or iOS)\n   *\n   * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n   * closing any open context menus. There is not a similar behavior on Macs.\n   */\n  private _shouldHandleKeyUp = (ev: React.KeyboardEvent<HTMLElement>) => {\n    const keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && this._isAltOrMeta(ev);\n    this._lastKeyDownWasAltOrMeta = false;\n    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n  };\n\n  /**\n   * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n   */\n  private _isAltOrMeta(ev: React.KeyboardEvent<HTMLElement>): boolean {\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\n  }\n\n  /**\n   * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n   * if so, stops event propagation and dismisses menu(s).\n   * @param ev - The keyboard event.\n   * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n   * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n   * Only does anything if `shouldHandleKey` returns true.\n   * @returns Whether the event was handled.\n   */\n  private _keyHandler = (\n    ev: React.KeyboardEvent<HTMLElement>,\n    shouldHandleKey: (ev: React.KeyboardEvent<HTMLElement>) => boolean,\n    dismissAllMenus?: boolean,\n  ): boolean => {\n    let handled = false;\n\n    if (shouldHandleKey(ev)) {\n      this._focusingPreviousElement = true;\n      this.dismiss(ev, dismissAllMenus);\n      ev.preventDefault();\n      ev.stopPropagation();\n      handled = true;\n    }\n\n    return handled;\n  };\n\n  /**\n   * Checks if the submenu should be closed\n   */\n  private _shouldCloseSubMenu = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    const submenuCloseKey = getRTL(this.props.theme) ? KeyCodes.right : KeyCodes.left;\n\n    if (ev.which !== submenuCloseKey || !this.props.isSubMenu) {\n      return false;\n    }\n\n    return (\n      this._adjustedFocusZoneProps.direction === FocusZoneDirection.vertical ||\n      (!!this._adjustedFocusZoneProps.checkForNoWrap &&\n        !shouldWrapFocus(ev.target as HTMLElement, 'data-no-horizontal-wrap'))\n    );\n  };\n\n  private _onMenuKeyDown = (ev: React.KeyboardEvent<HTMLElement>) => {\n    // Mark as handled if onKeyDown returns true (for handling collapse cases)\n    // or if we are attempting to expand a submenu\n    const handled = this._onKeyDown(ev);\n\n    if (handled || !this._host) {\n      return;\n    }\n\n    // If we have a modifier key being pressed, we do not want to move focus.\n    // Otherwise, handle up and down keys.\n    const hasModifier = !!(ev.altKey || ev.metaKey);\n    const isUp = ev.which === KeyCodes.up;\n    const isDown = ev.which === KeyCodes.down;\n    if (!hasModifier && (isUp || isDown)) {\n      const elementToFocus = isUp\n        ? getLastFocusable(this._host, this._host.lastChild as HTMLElement, true)\n        : getFirstFocusable(this._host, this._host.firstChild as HTMLElement, true);\n\n      if (elementToFocus) {\n        elementToFocus.focus();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  /**\n   * Scroll handler for the callout to make sure the mouse events\n   * for updating focus are not interacting during scroll\n   */\n  private _onScroll = (): void => {\n    if (!this._isScrollIdle && this._scrollIdleTimeoutId !== undefined) {\n      this._async.clearTimeout(this._scrollIdleTimeoutId);\n      this._scrollIdleTimeoutId = undefined;\n    } else {\n      this._isScrollIdle = false;\n    }\n\n    this._scrollIdleTimeoutId = this._async.setTimeout(() => {\n      this._isScrollIdle = true;\n    }, NavigationIdleDelay);\n  };\n\n  private _onItemMouseEnterBase = (item: any, ev: React.MouseEvent<HTMLElement>, target?: HTMLElement): void => {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    this._updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  private _onItemMouseMoveBase = (item: any, ev: React.MouseEvent<HTMLElement>, target: HTMLElement): void => {\n    const targetElement = ev.currentTarget as HTMLElement;\n\n    // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n    if (this._shouldUpdateFocusOnMouseEvent) {\n      this._gotMouseMove = true;\n    } else {\n      return;\n    }\n\n    if (\n      !this._isScrollIdle ||\n      this._enterTimerId !== undefined ||\n      targetElement === (this._targetWindow.document.activeElement as HTMLElement)\n    ) {\n      return;\n    }\n\n    this._updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  private _shouldIgnoreMouseEvent(): boolean {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  }\n\n  private _onMouseItemLeave = (item: any, ev: React.MouseEvent<HTMLElement>): void => {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n      this._enterTimerId = undefined;\n    }\n\n    if (this.state.expandedMenuItemKey !== undefined) {\n      return;\n    }\n\n    /**\n     * IE11 focus() method forces parents to scroll to top of element.\n     * Edge and IE expose a setActive() function for focusable divs that\n     * sets the page focus but does not scroll the parent element.\n     */\n    if ((this._host as any).setActive) {\n      try {\n        (this._host as any).setActive();\n      } catch (e) {\n        /* no-op */\n      }\n    } else {\n      this._host.focus();\n    }\n  };\n\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n  private _updateFocusOnMouseEvent(item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>, target?: HTMLElement) {\n    const targetElement = target ? target : (ev.currentTarget as HTMLElement);\n    const { subMenuHoverDelay: timeoutDuration = NavigationIdleDelay } = this.props;\n\n    if (item.key === this.state.expandedMenuItemKey) {\n      return;\n    }\n\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n      this._enterTimerId = undefined;\n    }\n\n    // If the menu is not expanded we can update focus without any delay\n    if (this.state.expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    }\n\n    // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      this._enterTimerId = this._async.setTimeout(() => {\n        targetElement.focus();\n        this.setState({\n          expandedByMouseClick: true,\n        });\n        this._onItemSubMenuExpand(item, targetElement);\n        this._enterTimerId = undefined;\n      }, timeoutDuration);\n    } else {\n      this._enterTimerId = this._async.setTimeout(() => {\n        this._onSubMenuDismiss(ev);\n        targetElement.focus();\n        this._enterTimerId = undefined;\n      }, timeoutDuration);\n    }\n  }\n\n  private _onItemMouseDown = (item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>): void => {\n    if (item.onMouseDown) {\n      item.onMouseDown(item, ev);\n    }\n  };\n\n  private _onItemClick = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    this._onItemClickBase(item, ev, ev.currentTarget as HTMLElement);\n  };\n\n  private _onItemClickBase = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    target: HTMLElement,\n  ): void => {\n    const items = getSubmenuItems(item);\n\n    // Cancel a async menu item hover timeout action from being taken and instead\n    // just trigger the click event instead.\n    this._cancelSubMenuTimer();\n\n    if (!hasSubmenu(item) && (!items || !items.length)) {\n      // This is an item without a menu. Click it.\n      this._executeItemClick(item, ev);\n    } else {\n      if (item.key !== this.state.expandedMenuItemKey) {\n        // This has a collapsed sub menu. Expand it.\n        this.setState({\n          // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n          // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n          // between a real click event and a keypress event (detail should be the number of mouse clicks).\n          // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n          // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n          // and \"\" for pressing \"Enter\" with Narrator on.\n          expandedByMouseClick: ev.nativeEvent.detail !== 0 || (ev.nativeEvent as PointerEvent).pointerType === 'mouse',\n        });\n        this._onItemSubMenuExpand(item, target);\n      }\n    }\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  private _onAnchorClick = (item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>) => {\n    this._executeItemClick(item, ev);\n    ev.stopPropagation();\n  };\n\n  private _executeItemClick = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    if (item.disabled || item.isDisabled) {\n      return;\n    }\n\n    let dismiss = false;\n    if (item.onClick) {\n      dismiss = !!item.onClick(ev, item);\n    } else if (this.props.onItemClick) {\n      dismiss = !!this.props.onItemClick(ev, item);\n    }\n\n    if (dismiss || !ev.defaultPrevented) {\n      this.dismiss(ev, true);\n\n      // This should be removed whenever possible.\n      // This ensures that the hidden dismissal action maintains the same behavior.\n      // If the menu is being dismissed then the previously focused element should\n      // get focused since the dismiss was triggered by a user click on an item\n      // Rather than focus being lost.\n      this._focusingPreviousElement = true;\n    }\n  };\n\n  private _onItemKeyDown = (item: any, ev: React.KeyboardEvent<HTMLElement>): void => {\n    const openKey = getRTL(this.props.theme) ? KeyCodes.left : KeyCodes.right;\n\n    if (\n      !item.disabled &&\n      (ev.which === openKey || ev.which === KeyCodes.enter || (ev.which === KeyCodes.down && (ev.altKey || ev.metaKey)))\n    ) {\n      this.setState({\n        expandedByMouseClick: false,\n      });\n      this._onItemSubMenuExpand(item, ev.currentTarget as HTMLElement);\n      ev.preventDefault();\n    }\n  };\n\n  // Cancel a async menu item hover timeout action from being taken and instead\n  // do new upcoming behavior\n  private _cancelSubMenuTimer = () => {\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n      this._enterTimerId = undefined;\n    }\n  };\n\n  private _onItemSubMenuExpand = (item: IContextualMenuItem, target: HTMLElement): void => {\n    if (this.state.expandedMenuItemKey !== item.key) {\n      if (this.state.expandedMenuItemKey) {\n        this._onSubMenuDismiss();\n      }\n\n      // Focus the target to ensure when we close it, we're focusing on the correct element.\n      target.focus();\n      this.setState({\n        expandedMenuItemKey: item.key,\n        submenuTarget: target,\n      });\n    }\n  };\n\n  private _getSubmenuProps() {\n    const { submenuTarget, expandedMenuItemKey } = this.state;\n    const item = this._findItemByKey(expandedMenuItemKey!);\n    let submenuProps: IContextualMenuProps | null = null;\n\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item)!,\n        target: submenuTarget,\n        onDismiss: this._onSubMenuDismiss,\n        isSubMenu: true,\n        id: this.state.subMenuId,\n        shouldFocusOnMount: true,\n        shouldFocusOnContainer: this.state.expandedByMouseClick,\n        directionalHint: getRTL(this.props.theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className: this.props.className,\n        gapSpace: 0,\n        isBeakVisible: false,\n      };\n\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n    }\n    return submenuProps;\n  }\n\n  private _findItemByKey(key: string): IContextualMenuItem | undefined {\n    const { items } = this.props;\n    return this._findItemByKeyFromItems(key, items);\n  }\n\n  /**\n   * Returns the item that mathes a given key if any.\n   * @param key - The key of the item to match\n   * @param items - The items to look for the key\n   */\n  private _findItemByKeyFromItems(key: string, items: IContextualMenuItem[]): IContextualMenuItem | undefined {\n    for (const item of items) {\n      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n        const match = this._findItemByKeyFromItems(key, item.sectionProps.items);\n        if (match) {\n          return match;\n        }\n      } else if (item.key && item.key === key) {\n        return item;\n      }\n    }\n  }\n\n  /**\n   * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n   * after the component is unmounted. The _mounted property is added to prevent\n   * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n   * code.\n   */\n  private _onSubMenuDismiss = (ev?: any, dismissAll?: boolean): void => {\n    if (dismissAll) {\n      this.dismiss(ev, dismissAll);\n    } else if (this._mounted) {\n      this.setState({\n        dismissedMenuItemKey: this.state.expandedMenuItemKey,\n        expandedMenuItemKey: undefined,\n        submenuTarget: undefined,\n      });\n    }\n  };\n\n  private _setTargetWindowAndElement(target: Target): void {\n    const currentElement = this._host;\n\n    if (target) {\n      if (typeof target === 'string') {\n        const currentDoc: Document = getDocument(currentElement)!;\n        this._target = currentDoc ? (currentDoc.querySelector(target) as Element) : null;\n        this._targetWindow = getWindow(currentElement)!;\n        // Cast to any prevents error about stopPropagation always existing\n      } else if ((target as any).stopPropagation) {\n        this._targetWindow = getWindow((target as MouseEvent).target as HTMLElement)!;\n        this._target = target as MouseEvent;\n      } else if (\n        // eslint-disable-next-line deprecation/deprecation\n        ((target as Point).left !== undefined || (target as Point).x !== undefined) &&\n        // eslint-disable-next-line deprecation/deprecation\n        ((target as Point).top !== undefined || (target as Point).y !== undefined)\n      ) {\n        this._targetWindow = getWindow(currentElement)!;\n        this._target = target as Point;\n      } else if ((target as React.RefObject<Element>).current !== undefined) {\n        this._target = (target as React.RefObject<Element>).current;\n        this._targetWindow = getWindow(this._target)!;\n      } else {\n        const targetElement: Element = target as Element;\n        this._targetWindow = getWindow(targetElement)!;\n        this._target = target as Element;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement)!;\n    }\n  }\n\n  private _getSubMenuId = (item: IContextualMenuItem): string | undefined => {\n    let { subMenuId } = this.state;\n\n    if (item.subMenuProps && item.subMenuProps.id) {\n      subMenuId = item.subMenuProps.id;\n    }\n\n    return subMenuId;\n  };\n\n  private _onPointerAndTouchEvent = (ev: React.TouchEvent<HTMLElement> | PointerEvent) => {\n    this._cancelSubMenuTimer();\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}